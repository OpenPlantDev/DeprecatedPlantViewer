{"version":3,"file":"geometry-core.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\Constant.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\Geometry.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BSpline1dNd.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BSplineCurve.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BSplineCurve3dH.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BSplineSurface.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\Bezier1dNd.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BezierCurve3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BezierCurve3dH.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\BezierCurveBase.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\bspline\\KnotVector.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\clipping\\ClipPlane.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\clipping\\ClipPrimitive.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\clipping\\ClipUtils.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\clipping\\ClipVector.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\clipping\\ConvexClipPlaneSet.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\clipping\\UnionOfConvexClipPlaneSets.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\Arc3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\ConstructCurveBetweenCurves.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CoordinateXYZ.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CurveChainWithDistanceIndex.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CurveCollection.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CurveCurveIntersectXY.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CurveLocationDetail.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CurvePrimitive.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\CurveProcessor.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\GeometryQuery.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\LineSegment3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\LineString3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\Loop.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\ParityRegion.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\Path.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\PointString3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\Query\\CylindricalRange.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\Query\\StrokeCountChain.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\Query\\StrokeCountMap.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\StrokeOptions.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\TransitionSpiral.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\curve\\UnionRegion.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry-core.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Angle.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\AngleSweep.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\BilinearPatch.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\FrameBuilder.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\FrustumAnimation.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\GeometryHandler.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\GrowableBlockedArray.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\GrowableFloat64Array.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\GrowableXYArray.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\GrowableXYZArray.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\IndexedXYCollection.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\IndexedXYZCollection.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Matrix3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\OrderedRotationAngles.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Plane3dByOriginAndUnitNormal.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Plane3dByOriginAndVectors.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Point2dArrayCarrier.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Point2dVector2d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Point3dVector3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\PointHelpers.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\PolygonOps.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Range.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Ray3d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Segment1d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\Transform.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry3d\\YawPitchRollAngles.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry4d\\Map4d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry4d\\Matrix4d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry4d\\MomentData.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry4d\\PlaneByOriginAndVectors4d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\geometry4d\\Point4d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\BezierPolynomials.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\ClusterableArray.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\Complex.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\ConvexPolygon2d.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\Newton.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\PascalCoefficients.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\Polynomials.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\Quadrature.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\Range1dArray.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\numerics\\TriDiagonalSystem.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\AuxData.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\BoxTopology.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\FacetFaceData.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\IndexedEdgeMatcher.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\Polyface.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\PolyfaceBuilder.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\PolyfaceClip.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\PolyfaceData.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\polyface\\PolyfaceQuery.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\serialization\\DeepCompare.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\serialization\\GeometrySamples.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\serialization\\IModelJsonSchema.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\Box.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\Cone.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\LinearSweep.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\RotationalSweep.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\RuledSweep.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\SolidPrimitive.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\Sphere.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\SweepContour.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\solid\\TorusPipe.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\topology\\Graph.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\topology\\Triangulation.ts","file:///D:\\vsts_a\\1\\s\\core\\geometry\\src\\topology\\XYParitySearchContext.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"geometry_core\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"geometry_core\"] = factory();\n\telse\n\t\troot[\"geometry_core\"] = factory();\n})(this, function() {\nreturn ","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module CartesianGeometry */\n\n/** Commonly used constant values.\n * @alpha\n */\nexport class Constant {\n  /** symbolic name for 1 millimeter:  0.001 meter */\n  public static readonly oneMillimeter: number = 0.001;\n  /** symbolic name for 1 centimeter:  0.01 meter */\n  public static readonly oneCentimeter: number = 0.01;\n  /** symbolic name for 1 meter:  1.0 meter */\n  public static readonly oneMeter: number = 1.0;\n  /** symbolic name for 1 kilometer: 1000 meter */\n  public static readonly oneKilometer: number = 1000.0;\n  /** Diameter of the earth in kilometers. */\n  public static readonly diameterOfEarth: number = 12742.0 * Constant.oneKilometer;\n  /** circumference of the earth in meters. */\n  public static readonly circumferenceOfEarth: number = 40075.0 * Constant.oneKilometer;\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\nimport { Point2d, Vector2d, XY } from \"./geometry3d/Point2dVector2d\";\r\nimport { XAndY } from \"./geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d, XYZ } from \"./geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"./geometry4d/Point4d\";\r\nimport { AngleSweep } from \"./geometry3d/AngleSweep\";\r\n\r\n/** Enumeration of the 6 possible orderings of XYZ axis order\r\n * @public\r\n */\r\nexport enum AxisOrder {\r\n  /** Right handed system, X then Y then Z */\r\n  XYZ = 0,\r\n  /** Right handed system, Y then Z then X */\r\n  YZX = 1,\r\n  /** Right handed system, Z then X then Y */\r\n  ZXY = 2,\r\n  /** Left handed system, X then Z then Y */\r\n  XZY = 4,\r\n  /** Left handed system, Y then X then Z */\r\n  YXZ = 5,\r\n  /** Left handed system, Z then Y then X */\r\n  ZYX = 6,\r\n}\r\n/** Enumeration of numeric indices of 3 axes AxisIndex.X, AxisIndex.Y, AxisIndex.Z\r\n * @public\r\n */\r\nexport enum AxisIndex {\r\n  /** x axis is index 0 */\r\n  X = 0,\r\n  /** y axis is index 1 */\r\n  Y = 1,\r\n  /** 2 axis is index 2 */\r\n  Z = 2,\r\n}\r\n\r\n/** Standard views.   Used in `Matrix3d.createStandardViewAxes (index: StandardViewIndex, worldToView :boolean)`\r\n * @public\r\n */\r\nexport enum StandardViewIndex {\r\n  /** X to right, Y up */\r\n  Top = 1,\r\n  /** X to right, negative Y up */\r\n  Bottom = 2,\r\n  /** negative Y to right, Z up */\r\n  Left = 3,\r\n  /**  Y to right, Z up */\r\n  Right = 4,\r\n  /** X to right, Z up */\r\n  Front = 5,\r\n  /** negative X to right, Z up */\r\n  Back = 6,\r\n  /** View towards origin from (-1,-1,1) */\r\n  Iso = 7,\r\n  /** View towards origin from (1,-1,1) */\r\n  RightIso = 8,\r\n}\r\n\r\n/** Enumeration among choice for how a coordinate transformation should incorporate scaling.\r\n * @public\r\n */\r\nexport enum AxisScaleSelect {\r\n  /** All axes of unit length. */\r\n  Unit = 0,\r\n  /** On each axis, the vector length matches the longest side of the range of the data. */\r\n  LongestRangeDirection = 1,\r\n  /** On each axis, the vector length matches he length of the corresponding edge of the range. */\r\n  NonUniformRangeContainment = 2,\r\n}\r\n/** object with a radians value and its associated cosine and sine values.\r\n * @public\r\n */\r\nexport interface TrigValues {\r\n  /** the cosine value */\r\n  c: number;\r\n  /** the sine value */\r\n  s: number;\r\n  /** the radians value */\r\n  radians: number;\r\n}\r\n/**\r\n * Interface so various plane representations can be used by algorithms that just want altitude evaluations.\r\n *\r\n * Specific implementors are\r\n * * Plane3dByOriginAndUnitNormal\r\n * * Point4d (used for homogeneous plane coefficients)\r\n * @public\r\n */\r\nexport interface PlaneAltitudeEvaluator {\r\n  /**\r\n   * Return the altitude of the point from the plane.\r\n   * @param point point for evaluation\r\n   */\r\n  altitude(point: Point3d): number;\r\n  /**\r\n   * Return the derivative of altitude wrt motion along a vector.\r\n   * @param point point for evaluation\r\n   */\r\n  velocity(vector: Vector3d): number;\r\n\r\n  /**\r\n   * Return the derivative of altitude wrt motion along a vector given by components\r\n   * @param point point for evaluation\r\n   */\r\n  velocityXYZ(x: number, y: number, z: number): number;\r\n  /**\r\n   * Return the weighted altitude\r\n   * @param point xyzw data.\r\n   */\r\n  weightedAltitude(point: Point4d): number;\r\n}\r\n/**\r\n * Interface for `toJSON` and `setFromJSON` methods\r\n * @public\r\n */\r\nexport interface BeJSONFunctions {\r\n  /**\r\n   * Set content from a JSON object.\r\n   * If the json object is undefined or unrecognized, always set a default value.\r\n   */\r\n  setFromJSON(json: any): void;\r\n  /** Return a json object with this object's contents. */\r\n  toJSON(): any;\r\n}\r\n\r\n/** The Properties for a JSON representation of an Angle.\r\n * If value is a number, it is in *degrees*.\r\n * If value is an object, it can have either degrees or radians.\r\n * @public\r\n */\r\nexport type AngleProps = { degrees: number } | { radians: number } | { _radians: number } | { _degrees: number } | number;\r\n\r\n/** The Properties for a JSON representation of an AngleSweep.\r\n * * The json data is always start and end angles as a pair in an array.\r\n * If AngleProps data is an array of two numbers, it is an angle in degrees.\r\n * If the AngleProps is an object with key degrees, the degrees value must be an array with the two degrees angles as numbers\r\n * If the AngleProps is an object with key radians, the radians value must be an array with the two radians angles as numbers\r\n * @public\r\n */\r\nexport type AngleSweepProps =\r\n  AngleSweep |\r\n  { degrees: [number, number] } |\r\n  { radians: [number, number] } |\r\n  [number, number];\r\n\r\n/**\r\n * Class containing static methods for typical numeric operations.\r\n * * Experimentally, methods like Geometry.hypotenuse are observed to be faster than the system intrinsics.\r\n * * This is probably due to\r\n *    * Fixed length arg lists\r\n *    * strongly typed parameters\r\n * @public\r\n */\r\nexport class Geometry {\r\n  /** Tolerance for small distances in metric coordinates */\r\n  public static readonly smallMetricDistance = 1.0e-6;\r\n  /** Square of `smallMetricTolerance` */\r\n  public static readonly smallMetricDistanceSquared = 1.0e-12;\r\n  /** tolerance for small angle measured in radians. */\r\n  public static readonly smallAngleRadians = 1.0e-12;\r\n  /** square of `smallAngleRadians` */\r\n  public static readonly smallAngleRadiansSquared = 1.0e-24;\r\n  /** numeric value that may considered huge for numbers expected to be 0..1 fractions. */\r\n  public static readonly largeFractionResult = 1.0e10;\r\n  /** numeric value that may considered infinite for metric coordinates.\r\n   * * This coordinate should be used only as a placeholder indicating \"at infinity\" -- computing actual points at this coordinate invites numerical problems.\r\n   */\r\n  public static readonly hugeCoordinate = 1.0e12;\r\n  /** Test if absolute value of x is huge.\r\n   * * See `Geometry.hugeCoordinate`\r\n   */\r\n  public static isHugeCoordinate(x: number): boolean {\r\n    return x > this.hugeCoordinate || x < - this.hugeCoordinate;\r\n  }\r\n\r\n  /** Radians value for full circle 2PI radians minus `smallAngleRadians` */\r\n  public static readonly fullCircleRadiansMinusSmallAngle = 2.0 * Math.PI - 1.0e-12;    // smallAngleRadians less than 360degrees\r\n  /** Correct `distance` to zero if smaller than metric tolerance.   Otherwise return it unchanged. */\r\n  public static correctSmallMetricDistance(distance: number, replacement: number = 0.0): number {\r\n    if (Math.abs(distance) < Geometry.smallMetricDistance) {\r\n      return replacement;\r\n    }\r\n    return distance;\r\n  }\r\n  /**\r\n * If `a` is large enough for safe division, return `1/a`, using Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.\r\n * @param a denominator of division\r\n */\r\n  public static inverseMetricDistance(a: number): number | undefined { return (Math.abs(a) <= Geometry.smallMetricDistance) ? undefined : 1.0 / a; }\r\n  /**\r\n   * If `a` is large enough, return `1/a`, using the square of Geometry.smallMetricDistance as the tolerance for declaring it as divide by zero.  Otherwise return `undefined`.\r\n   * @param a denominator of division\r\n   */\r\n  public static inverseMetricDistanceSquared(a: number): number | undefined {\r\n    return (Math.abs(a) <= Geometry.smallMetricDistanceSquared) ? undefined : 1.0 / a;\r\n  }\r\n  /** Boolean test for metric coordinate near-equality */\r\n  public static isSameCoordinate(x: number, y: number, tol?: number): boolean {\r\n    if (tol)\r\n      return Math.abs(x - y) < Math.abs(tol);\r\n    return Math.abs(x - y) < Geometry.smallMetricDistance;\r\n  }\r\n  /** Boolean test for squared metric coordinate near-equality */\r\n  public static isSameCoordinateSquared(x: number, y: number): boolean {\r\n    return Math.abs(Math.sqrt(x) - Math.sqrt(y)) < Geometry.smallMetricDistance;\r\n  }\r\n  /** boolean test for small `dataA.distance (dataB)`  within `smallMetricDistance` */\r\n  public static isSamePoint3d(dataA: Point3d, dataB: Point3d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for distance between `XYZ` objects within `smallMetricDistance`\r\n   *  * Note that Point3d and Vector3d are both derived from XYZ, so this method tolerates mixed types.\r\n   */\r\n  public static isSameXYZ(dataA: XYZ, dataB: XYZ): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSamePoint3dXY(dataA: Point3d, dataB: Point3d): boolean { return dataA.distanceXY(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSameVector3d(dataA: Vector3d, dataB: Vector3d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSamePoint2d(dataA: Point2d, dataB: Point2d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n  /** boolean test for small `dataA.distanceXY (dataB)`  within `smallMetricDistance` */\r\n  public static isSameVector2d(dataA: Vector2d, dataB: Vector2d): boolean { return dataA.distance(dataB) < Geometry.smallMetricDistance; }\r\n\r\n  /**\r\n   * Lexical comparison of (a.x,a.y) (b.x,b.y) with x as first test, y second.\r\n   * * This is appropriate for a horizontal sweep in the plane.\r\n   */\r\n  public static lexicalXYLessThan(a: XY | XYZ, b: XY | XYZ) {\r\n    if (a.x < b.x)\r\n      return -1;\r\n    else if (a.x > b.x)\r\n      return 1;\r\n    if (a.y < b.y)\r\n      return -1;\r\n    else if (a.y > b.y)\r\n      return 1;\r\n    return 0;\r\n  }\r\n  /**\r\n   * Lexical comparison of (a.x,a.y) (b.x,b.y) with y as first test, x second.\r\n   * * This is appropriate for a vertical sweep in the plane.\r\n   */\r\n  public static lexicalYXLessThan(a: XY | XYZ, b: XY | XYZ) {\r\n    if (a.y < b.y)\r\n      return -1;\r\n    else if (a.y > b.y)\r\n      return 1;\r\n    if (a.x < b.x)\r\n      return -1;\r\n    else if (a.x > b.x)\r\n      return 1;\r\n    return 0;\r\n  }\r\n  /**\r\n   * Lexical test, based on x first, y second, z third.\r\n   */\r\n  public static lexicalXYZLessThan(a: XYZ, b: XYZ) {\r\n    if (a.x < b.x)\r\n      return -1;\r\n    else if (a.x > b.x)\r\n      return 1;\r\n    if (a.y < b.y)\r\n      return -1;\r\n    else if (a.y > b.y)\r\n      return 1;\r\n    if (a.z < b.z)\r\n      return -1;\r\n    else if (a.z > b.z)\r\n      return 1;\r\n    return 0;\r\n  }\r\n  /** Test if `value` is small compared to `smallAngleRadians`.\r\n   * * This is appropriate if `value` is know to be a typical 0..1 fraction.\r\n   */\r\n  public static isSmallRelative(value: number): boolean { return Math.abs(value) < Geometry.smallAngleRadians; }\r\n  /** Test if `value` is small compared to `smallAngleRadians` */\r\n  public static isSmallAngleRadians(value: number): boolean { return Math.abs(value) < Geometry.smallAngleRadians; }\r\n  /** Toleranced equality test, using tolerance `smallAngleRadians * ( 1 + abs(a) + (abs(b)))`\r\n   * * Effectively an absolute tolerance of `smallAngleRadians`, with tolerance increasing for larger values of a and b.\r\n  */\r\n  public static isAlmostEqualNumber(a: number, b: number) {\r\n    const sumAbs = 1.0 + Math.abs(a) + Math.abs(b);\r\n    return Math.abs(a - b) <= Geometry.smallAngleRadians * sumAbs;\r\n  }\r\n  /** Toleranced equality test, using caller-supplied tolerance. */\r\n  public static isDistanceWithinTol(distance: number, tol: number) {\r\n    return Math.abs(distance) <= Math.abs(tol);\r\n  }\r\n  /** Toleranced equality test, using `smallMetricDistance` tolerance. */\r\n  public static isSmallMetricDistance(distance: number): boolean {\r\n    return Math.abs(distance) <= Geometry.smallMetricDistance;\r\n  }\r\n  /** Toleranced equality, using `smallMetricDistanceSquared` tolerance. */\r\n  public static isSmallMetricDistanceSquared(distanceSquared: number): boolean {\r\n    return Math.abs(distanceSquared) <= Geometry.smallMetricDistanceSquared;\r\n  }\r\n  /** Return `axis modulo 3` with proper handling of negative indices (-1 is z), -2 is y, -3 is x etc) */\r\n  public static cyclic3dAxis(axis: number): number {\r\n    /* Direct test for the most common cases, avoid modulo */\r\n    if (axis >= 0) {\r\n      if (axis < 3)\r\n        return axis;\r\n      if (axis < 6)\r\n        return axis - 3;\r\n      return axis % 3;\r\n    }\r\n    const j = axis + 3;\r\n    if (j >= 0)\r\n      return j;\r\n    return 2 - ((-axis - 1) % 3);\r\n  }\r\n  /** Return the AxisOrder for which axisIndex is the first named axis.\r\n   * * `axisIndex===0`returns AxisOrder.XYZ\r\n   * * `axisIndex===1`returns AxisOrder.YZX\r\n   * * `axisIndex===2`returns AxisOrder.ZXY\r\n   */\r\n  public static axisIndexToRightHandedAxisOrder(axisIndex: AxisIndex): AxisOrder {\r\n    if (axisIndex === 0) return AxisOrder.XYZ;\r\n    if (axisIndex === 1) return AxisOrder.YZX;\r\n    if (axisIndex === 2) return AxisOrder.ZXY;\r\n    return Geometry.axisIndexToRightHandedAxisOrder(Geometry.cyclic3dAxis(axisIndex));\r\n  }\r\n  /** Return the largest absolute distance from a to either of b0 or b1 */\r\n  public static maxAbsDiff(a: number, b0: number, b1: number): number { return Math.max(Math.abs(a - b0), Math.abs(a - b1)); }\r\n  /** Return the largest absolute absolute value among x,y,z */\r\n  public static maxAbsXYZ(x: number, y: number, z: number): number {\r\n    return Geometry.maxXYZ(Math.abs(x), Math.abs(y), Math.abs(z));\r\n  }\r\n  /** Return the largest absolute absolute value among x,y */\r\n  public static maxAbsXY(x: number, y: number): number {\r\n    return Geometry.maxXY(Math.abs(x), Math.abs(y));\r\n  }\r\n\r\n  /** Return the largest signed value among a, b, c */\r\n  public static maxXYZ(a: number, b: number, c: number): number {\r\n    let q = a;\r\n    if (b > q) q = b;\r\n    if (c > q) q = c;\r\n    return q;\r\n  }\r\n  /** Return the largest signed value among a, b */\r\n  public static maxXY(a: number, b: number): number {\r\n    let q = a;\r\n    if (b > q) q = b;\r\n    return q;\r\n  }\r\n\r\n  /** Return the hypotenuse `sqrt(x*x + y*y)`. This is much faster than `Math.hypot(x,y)`. */\r\n  public static hypotenuseXY(x: number, y: number) { return Math.sqrt(x * x + y * y); }\r\n  /** Return the squared `hypotenuse (x*x + y*y)`. */\r\n  public static hypotenuseSquaredXY(x: number, y: number) { return x * x + y * y; }\r\n  /** Return the square of x */\r\n  public static square(x: number) { return x * x; }\r\n\r\n  /** Return the hypotenuse `sqrt(x*x + y*y + z*z)`. This is much faster than `Math.hypot(x,y,z)`. */\r\n  public static hypotenuseXYZ(x: number, y: number, z: number) { return Math.sqrt(x * x + y * y + z * z); }\r\n  /** Return the squared hypotenuse `(x*x + y*y + z*z)`. This is much faster than `Math.hypot(x,y,z)`. */\r\n  public static hypotenuseSquaredXYZ(x: number, y: number, z: number) { return x * x + y * y + z * z; }\r\n  /** Return the (full 4d) hypotenuse `sqrt(x*x + y*y + z*z + w*w)`. This is much faster than `Math.hypot(x,y,z,w)`. */\r\n  public static hypotenuseXYZW(x: number, y: number, z: number, w: number) { return Math.sqrt(x * x + y * y + z * z + w * w); }\r\n  /** Return the squared hypotenuse `(x*x + y*y + z*z+w*w)`. This is much faster than `Math.hypot(x,y,z)`. */\r\n  public static hypotenuseSquaredXYZW(x: number, y: number, z: number, w: number) { return x * x + y * y + z * z + w * w; }\r\n  /**\r\n   * Return the distance between xy points given as numbers.\r\n   * @param x0 x coordinate of point 0\r\n   * @param y0 y coordinate of point 0\r\n   * @param x1 x coordinate of point 1\r\n   * @param y1 y coordinate of point 1\r\n   */\r\n  public static distanceXYXY(x0: number, y0: number, x1: number, y1: number): number {\r\n    return Geometry.hypotenuseXY(x1 - x0, y1 - y0);\r\n  }\r\n  /**\r\n   * Return the distance between xyz points given as numbers.\r\n   * @param x0 x coordinate of point 0\r\n   * @param y0 y coordinate of point 0\r\n   * @param z0 z coordinate of point 0\r\n   * @param x1 x coordinate of point 1\r\n   * @param y1 y coordinate of point 1\r\n   * @param z1 z coordinate of point 1\r\n   */\r\n  public static distanceXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number): number {\r\n    return Geometry.hypotenuseXYZ(x1 - x0, y1 - y0, z1 - z0);\r\n  }\r\n  /** Returns Returns the triple product of 3 vectors provided as x,y,z number sequences.\r\n   *\r\n   * * The triple product is the determinant of the 3x3 matrix with the 9 numbers placed in either row or column order.\r\n   * * The triple product is positive if the 3 vectors form a right handed coordinate system.\r\n   * * The triple product is negative if the 3 vectors form a left handed coordinate system.\r\n   * * Treating the 9 numbers as 3 vectors U, V, W, any of these formulas gives the same result:\r\n   *\r\n   * ** U dot (V cross W)\r\n   * ** V dot (W cross U)\r\n   * ** W dot (U cross V)\r\n   * **  (-U dot (W cross V))  -- (note the negative -- reversing cross product order changes the sign)\r\n   * ** (-V dot (U cross W)) -- (note the negative -- reversing cross product order changes the sign)\r\n   * ** (-W dot (V cross U)) -- (note the negative -- reversing cross product order changes the sign)\r\n   * * the triple product is 6 times the (signed) volume of the tetrahedron with the three vectors as edges from a common vertex.\r\n   */\r\n  public static tripleProduct(\r\n    ux: number, uy: number, uz: number,\r\n    vx: number, vy: number, vz: number,\r\n    wx: number, wy: number, wz: number): number {\r\n    return ux * (vy * wz - vz * wy)\r\n      + uy * (vz * wx - vx * wz)\r\n      + uz * (vx * wy - vy * wx);\r\n  }\r\n\r\n  /**\r\n * Returns curvature magnitude from a first and second derivative vector.\r\n * @param ux  first derivative x component\r\n * @param uy first derivative y component\r\n * @param uz first derivative z component\r\n * @param vx second derivative x component\r\n * @param vy second derivative y component\r\n * @param vz second derivative z component\r\n */\r\n  public static curvatureMagnitude(\r\n    ux: number, uy: number, uz: number,\r\n    vx: number, vy: number, vz: number): number {\r\n    let q = uy * vz - uz * vy;\r\n    let sum = q * q;\r\n    q = uz * vx - ux * vz;\r\n    sum += q * q;\r\n    q = ux * vy - uy * vx;\r\n    sum += q * q;\r\n    const a = Math.sqrt(ux * ux + uy * uy + uz * uz);\r\n    const b = Math.sqrt(sum);\r\n    // (sum and a are both nonnegative)\r\n    const aaa = a * a * a;\r\n    // radius of curvature = aaa / b;\r\n    // curvature = b/aaa\r\n    const tol = Geometry.smallAngleRadians;\r\n    if (aaa > tol * b)\r\n      return b / aaa;\r\n    return 0; // hm.. maybe should be infinite?\r\n  }\r\n\r\n  /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.\r\n   *\r\n   */\r\n  public static tripleProductXYW(\r\n    columnA: XAndY, weightA: number,\r\n    columnB: XAndY, weightB: number,\r\n    columnC: XAndY, weightC: number) {\r\n    return Geometry.tripleProduct(\r\n      columnA.x, columnB.x, columnC.x,\r\n      columnA.y, columnB.y, columnC.y,\r\n      weightA, weightB, weightC);\r\n  }\r\n\r\n  /** Returns the determinant of 3x3 matrix with x and y rows taken from 3 points, third row from corresponding numbers.\r\n   *\r\n   */\r\n  public static tripleProductPoint4dXYW(\r\n    columnA: Point4d,\r\n    columnB: Point4d,\r\n    columnC: Point4d) {\r\n    return Geometry.tripleProduct(\r\n      columnA.x, columnB.x, columnC.x,\r\n      columnA.y, columnB.y, columnC.y,\r\n      columnA.w, columnB.w, columnC.w);\r\n  }\r\n  /** 2D cross product of vectors layed out as scalars. */\r\n  public static crossProductXYXY(ux: number, uy: number, vx: number, vy: number): number {\r\n    return ux * vy - uy * vx;\r\n  }\r\n\r\n  /** 3D cross product of vectors layed out as scalars. */\r\n  public static crossProductXYZXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(\r\n      uy * vz - uz * vy,\r\n      uz * vx - ux * vz,\r\n      ux * vy - uy * vx, result);\r\n  }\r\n\r\n  /** magnitude of 3D cross product of vectors, with the vectors presented as */\r\n  public static crossProductMagnitude(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number {\r\n    return Geometry.hypotenuseXYZ(\r\n      uy * vz - uz * vy,\r\n      uz * vx - ux * vz,\r\n      ux * vy - uy * vx);\r\n  }\r\n  /** 3D dot product of vectors layed out as scalars. */\r\n  public static dotProductXYZXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number {\r\n    return ux * vx + uy * vy + uz * vz;\r\n  }\r\n  /**\r\n   * Clamp to (min(a,b), max(a,b))\r\n   * @param x\r\n   * @param a\r\n   * @param b\r\n   */\r\n  public static clampToStartEnd(x: number, a: number, b: number): number {\r\n    if (a > b)\r\n      return Geometry.clampToStartEnd(x, b, a);\r\n    if (x < a)\r\n      return a;\r\n    if (b < x)\r\n      return b;\r\n    return x;\r\n  }\r\n  /**\r\n   * Clamp value to (min,max) with no test for order of (min,max)\r\n   * @param value C\r\n   * @param min\r\n   * @param max\r\n   */\r\n  public static clamp(value: number, min: number, max: number): number { return Math.max(min, Math.min(max, value)); }\r\n  /** If given a number, return it.   If given undefined, return `defaultValue`. */\r\n  public static resolveNumber(value: number | undefined, defaultValue: number = 0): number {\r\n    return value !== undefined ? value : defaultValue;\r\n  }\r\n  /** simple interpolation between values, but choosing (based on fraction) a or b as starting point for maximum accuracy. */\r\n  public static interpolate(a: number, f: number, b: number): number {\r\n    return f <= 0.5 ? a + f * (b - a) : b - (1.0 - f) * (b - a);\r\n  }\r\n\r\n  /** given an axisOrder (e.g. XYZ, YZX, ZXY, XZYLeftHanded etc) and an (integer) offset, resolve to an axis index. */\r\n  public static axisOrderToAxis(order: AxisOrder, index: number): number {\r\n    const axis = order <= AxisOrder.ZXY ? order + index : (order - AxisOrder.XZY) - index;\r\n    return Geometry.cyclic3dAxis(axis);\r\n  }\r\n  /** Return (a modulo period), e.g. for use as a cyclid index.  Both a and period may be negative. */\r\n  public static modulo(a: number, period: number): number {\r\n    if (period <= 0) {\r\n      if (period === 0)\r\n        return a;\r\n      return -Geometry.modulo(-a, -period);\r\n    }\r\n\r\n    if (a >= 0) {\r\n      if (a < period)\r\n        return a;\r\n      if (a < 2 * period)\r\n        return a - period;\r\n    } else {\r\n      a += period;  // hopefully move into primary period without division and floor\r\n      if (a > 0)\r\n        return a;\r\n    }\r\n    const m = Math.floor(a / period);\r\n    return a - m * period;\r\n  }\r\n  /** return 0 if the value is undefined, 1 if defined. */\r\n  public static defined01(value: any): number { return value === undefined ? 0 : 1; }\r\n  /** normally, return numerator/denominator.\r\n   * but if the ratio would exceed Geometry.largeFractionResult, return undefined.\r\n   */\r\n  public static conditionalDivideFraction(numerator: number, denominator: number): number | undefined {\r\n    if (Math.abs(denominator) * Geometry.largeFractionResult > Math.abs(numerator))\r\n      return numerator / denominator;\r\n    return undefined;\r\n  }\r\n\r\n  /** return the 0, 1, or 2 pairs of (c,s) values that solve\r\n   * {constCoff + cosCoff * c + sinCoff * s = }\r\n   * with the constraint {c*c+s*s = 1}\r\n   */\r\n  public static solveTrigForm(constCoff: number, cosCoff: number, sinCoff: number): Vector2d[] | undefined {\r\n    {\r\n      const delta2 = cosCoff * cosCoff + sinCoff * sinCoff;\r\n      const constCoff2 = constCoff * constCoff;\r\n      // let nSolution = 0;\r\n      let result;\r\n      if (delta2 > 0.0) {\r\n        const lambda = - constCoff / delta2;\r\n        const a2 = constCoff2 / delta2;\r\n        const D2 = 1.0 - a2;\r\n        if (D2 >= 0.0) {\r\n          const mu = Math.sqrt(D2 / delta2);\r\n          /* c0,s0 = closest approach of line to origin */\r\n          const c0 = lambda * cosCoff;\r\n          const s0 = lambda * sinCoff;\r\n          // nSolution = 2;\r\n          result = [Vector2d.create(c0 - mu * sinCoff, s0 + mu * cosCoff), Vector2d.create(c0 + mu * sinCoff, s0 - mu * cosCoff)];\r\n        }\r\n      }\r\n      return result;\r\n    }\r\n  }\r\n\r\n  /** normally,  return the number result of conditionalDivideFraction.\r\n   * but if conditionalDivideFraction fails return specified default number.\r\n   */\r\n  public static safeDivideFraction(numerator: number, denominator: number, defaultResult: number): number {\r\n    const a = Geometry.conditionalDivideFraction(numerator, denominator);\r\n    if (a !== undefined)\r\n      return a;\r\n    return defaultResult;\r\n  }\r\n  /** For a line f(x) whose function values at x0 and x1 are f0 and f1, return the x value at which f(x)=fTarget;\r\n   */\r\n  public static inverseInterpolate(x0: number, f0: number, x1: number, f1: number,\r\n    targetF: number = 0,\r\n    defaultResult?: number): number | undefined {\r\n    const g = Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);\r\n    if (g)\r\n      return Geometry.interpolate(x0, g, x1);\r\n    return defaultResult;\r\n  }\r\n  /** For a line f(x) whose function values at x=0 and x=1 are f0 and f1, return the x value at which f(x)=fTarget;\r\n   */\r\n  public static inverseInterpolate01(f0: number, f1: number, targetF: number = 0): number | undefined {\r\n    return Geometry.conditionalDivideFraction(targetF - f0, f1 - f0);\r\n  }\r\n  /** Return true if json is an array with at least minEntries, and all entries are numbers (including those beyond minEntries) */\r\n  public static isNumberArray(json: any, minEntries: number = 0): boolean {\r\n    if (Array.isArray(json) && json.length >= minEntries) {\r\n      let entry;\r\n      for (entry of json) {\r\n        //        if (!(entry as number) && entry !== 0.0)\r\n        if (!Number.isFinite(entry))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return true if json is an array of at least numNumberArrays, with at least minEntries in each number array.\r\n   */\r\n  public static isArrayOfNumberArray(json: any, numNumberArray: number, minEntries: number = 0): boolean {\r\n    if (Array.isArray(json) && json.length >= numNumberArray) {\r\n      let entry;\r\n      for (entry of json)\r\n        if (!Geometry.isNumberArray(entry, minEntries)) return false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** return the number of steps to take so that numSteps * stepSize >= total.\r\n   * minCount is returned for both (a) setSize 0 or less and (b) stepSize > total.\r\n   * A small tolerance is applied for almost\r\n  */\r\n  public static stepCount(stepSize: number, total: number, minCount = 1, maxCount = 101): number {\r\n    if (stepSize <= 0)\r\n      return minCount;\r\n    if (stepSize >= total)\r\n      return minCount;\r\n    const stepCount = Math.floor((total + 0.999999 * stepSize) / stepSize);\r\n    if (stepCount < minCount)\r\n      return minCount;\r\n    if (stepCount > maxCount)\r\n      return maxCount;\r\n    return stepCount;\r\n  }\r\n  /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)\r\n   * @param x value to test.\r\n   * @param apply01 if false, accept all x.\r\n   */\r\n  public static isIn01(x: number, apply01: boolean = true): boolean { return apply01 ? x >= 0.0 && x <= 1.0 : true; }\r\n  /** Test if x is in simple 0..1 interval.  But optionally skip the test.  (this odd behavior is very convenient for code that sometimes does not do the filtering.)\r\n   * @param x value to test.\r\n   * @param apply01 if false, accept all x.\r\n   */\r\n  public static isIn01WithTolerance(x: number, tolerance: number): boolean { return x + tolerance >= 0.0 && x - tolerance <= 1.0; }\r\n  /**\r\n   * restrict x so it is in the interval `[a,b]`, allowing a,b to be in either order.\r\n   * @param x\r\n   * @param a (usually the lower) interval limit\r\n   * @param b (usually the upper) interval limit\r\n   */\r\n  public static restrictToInterval(x: number, a: number, b: number): number {\r\n    if (a <= b) {\r\n      if (x < a) return a;\r\n      if (x > b) return b;\r\n      return x;\r\n    }\r\n    // reversed interval ....\r\n    if (x < b) return b;\r\n    if (x > a) return a;\r\n    return x;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { KnotVector, BSplineWrapMode } from \"./KnotVector\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/** Bspline knots and poles for 1d-to-Nd.\r\n * * The \"pole\" (aka control point) of this class is a block of `poleLength` numbers.\r\n * * Derived classes (not this class) assign meaning such as x,y,z,w.\r\n * * for instance, an instance of this class with `poleLength===3` does not know if its poles are x,y,z or weighed 2D x,y,w\r\n * @public\r\n */\r\nexport class BSpline1dNd {\r\n  /** knots of the bspline */\r\n  public knots: KnotVector;\r\n  /** poles, packed in blocks of `poleLength` doubles. */\r\n  public packedData: Float64Array;\r\n  /** (property accessor) Return the number of numeric values per pole. */\r\n  public poleLength: number;\r\n  /** (property accessor) Return the degree of the polynomials. */\r\n  public get degree(): number { return this.knots.degree; }\r\n  /** (property accessor) Return the number of order (one more than degree) of the polynomials */\r\n  public get order(): number { return this.knots.degree + 1; }\r\n  /** (property accessor) Return the number of bezier spans (including null spans at multiple knots)*/\r\n  public get numSpan(): number { return this.numPoles - this.knots.degree; }\r\n  /** (property accessor)  Return the number of poles*/\r\n  public get numPoles(): number { return this.packedData.length / this.poleLength; }\r\n  /** copy 3 values of pole `i` into a point.\r\n   * * The calling clas sis responsible for knowing if this is an appropriate access to the blocked data.\r\n   */\r\n  public getPoint3dPole(i: number, result?: Point3d): Point3d | undefined { return Point3d.createFromPacked(this.packedData, i, result); }\r\n  /** preallocated array (length === `order`) used as temporary in evaluations */\r\n  public basisBuffer: Float64Array; // one set of basis function values.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `poleLength`) used as temporary in evaluations */\r\n  public poleBuffer: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `order`) used as temporary in evaluations */\r\n  public basisBuffer1: Float64Array; // one set of basis function values.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `order`) used as temporary in evaluations */\r\n  public basisBuffer2: Float64Array; // one set of basis function values.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `poleLength`) used as temporary in evaluations */\r\n  public poleBuffer1: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** preallocated array (length === `poleLength`) used as temporary in evaluations */\r\n  public poleBuffer2: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n\r\n  /**\r\n   * initialize arrays for given spline dimensions.\r\n   * @param numPoles number of poles\r\n   * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)\r\n   * @param order number of poles in support for a section of the bspline\r\n   * @param knots KnotVector.  This is captured, not cloned.\r\n   */\r\n  protected constructor(numPoles: number, poleLength: number, order: number, knots: KnotVector) {\r\n    this.knots = knots;\r\n    this.packedData = new Float64Array(numPoles * poleLength);\r\n    this.poleLength = poleLength;\r\n    this.basisBuffer = new Float64Array(order);\r\n    this.poleBuffer = new Float64Array(poleLength);\r\n    this.basisBuffer1 = new Float64Array(order);\r\n    this.basisBuffer2 = new Float64Array(order);\r\n    this.poleBuffer1 = new Float64Array(poleLength);\r\n    this.poleBuffer2 = new Float64Array(poleLength);\r\n  }\r\n\r\n  /**\r\n   * create a 1Bspline1dNd`\r\n   * @param numPoles number of poles\r\n   * @param poleLength number of coordinates per pole (e.g.. 3 for 3D unweighted, 4 for 3d weighted, 2 for 2d unweighted, 3 for 2d weighted)\r\n   * @param order number of poles in support for a section of the bspline\r\n   * @param knots KnotVector.  This is captured, not cloned.\r\n   */\r\n  public static create(numPoles: number, poleLength: number, order: number, knots: KnotVector): BSpline1dNd | undefined {\r\n    return new BSpline1dNd(numPoles, poleLength, order, knots);\r\n  }\r\n  /** Map a span index and local fraction to knot value. */\r\n  public spanFractionToKnot(span: number, localFraction: number): number {\r\n    return this.knots.spanFractionToKnot(span, localFraction);\r\n  }\r\n\r\n  /** Evaluate the `order` basis functions (and optionally one or two derivatives) at a given fractional position within indexed span. */\r\n  public evaluateBasisFunctionsInSpan(spanIndex: number, spanFraction: number, f: Float64Array, df?: Float64Array, ddf?: Float64Array) {\r\n    if (spanIndex < 0) spanIndex = 0;\r\n    if (spanIndex >= this.numSpan) spanIndex = this.numSpan - 1;\r\n    const knotIndex0 = spanIndex + this.degree - 1;\r\n    const globalKnot = this.knots.baseKnotFractionToKnot(knotIndex0, spanFraction);\r\n    return df ?\r\n      this.knots.evaluateBasisFunctions1(knotIndex0, globalKnot, f, df, ddf) :\r\n      this.knots.evaluateBasisFunctions(knotIndex0, globalKnot, f);\r\n  }\r\n  /**\r\n   * * Evaluate the basis functions at spanIndex and fraction.\r\n   *   * Evaluations are stored in the preallocated `this.basisBuffer`\r\n   * * Immediately do the summations of the basis values times the respective control points\r\n   *   * Summations are stored in the preallocated `this.poleBuffer`\r\n   * */\r\n  public evaluateBuffersInSpan(spanIndex: number, spanFraction: number) {\r\n    this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer);\r\n    this.sumPoleBufferForSpan(spanIndex);\r\n  }\r\n  /**\r\n   * * Evaluate the basis functions and one derivative at spanIndex and fraction.\r\n   *   * Evaluations are stored in the preallocated `this.basisBuffer`\r\n   * * Immediately do the summations of the basis values times the respective control points\r\n   *   * Summations are stored in the preallocated `this.poleBuffer` and `this.poleBuffer`\r\n   * */\r\n  public evaluateBuffersInSpan1(spanIndex: number, spanFraction: number) {\r\n    this.evaluateBasisFunctionsInSpan(spanIndex, spanFraction, this.basisBuffer, this.basisBuffer1);\r\n    this.sumPoleBufferForSpan(spanIndex);\r\n    this.sumPoleBuffer1ForSpan(spanIndex);\r\n  }\r\n  /** sum poles at span `spanIndex` by the weights in the `poleBuffer` */\r\n  public sumPoleBufferForSpan(spanIndex: number) {\r\n    this.poleBuffer.fill(0);\r\n    let k = spanIndex * this.poleLength;\r\n    for (const f of this.basisBuffer) {\r\n      for (let j = 0; j < this.poleLength; j++) { this.poleBuffer[j] += f * this.packedData[k++]; }\r\n    }\r\n  }\r\n  /** sum poles at span `spanIndex` by the weights in the `poleBuffer1`, i.e. form first derivatives */\r\n  public sumPoleBuffer1ForSpan(spanIndex: number) {\r\n    this.poleBuffer1.fill(0);\r\n    let k = spanIndex * this.poleLength;\r\n    for (const f of this.basisBuffer1) {\r\n      for (let j = 0; j < this.poleLength; j++) {\r\n        this.poleBuffer1[j] += f * this.packedData[k++];\r\n      }\r\n    }\r\n  }\r\n  /** sum poles at span `spanIndex` by the weights in the `poleBuffer2`, i.e. form second derivatives */\r\n  public sumPoleBuffer2ForSpan(spanIndex: number) {\r\n    this.poleBuffer2.fill(0);\r\n    let k = spanIndex * this.poleLength;\r\n    for (const f of this.basisBuffer2) {\r\n      for (let j = 0; j < this.poleLength; j++) {\r\n        this.poleBuffer2[j] += f * this.packedData[k++];\r\n      }\r\n    }\r\n  }\r\n  /** Evaluate the function values and 1 or 2 derivatives into `this.poleBuffer`, `this.poleBuffer1` and `this.poleBuffer2` */\r\n  public evaluateBuffersAtKnot(u: number, numDerivative: number = 0) {\r\n    const knotIndex0 = this.knots.knotToLeftKnotIndex(u);\r\n    if (numDerivative < 1) {\r\n      this.knots.evaluateBasisFunctions(knotIndex0, u, this.basisBuffer);\r\n      this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\r\n    } else if (numDerivative === 1) {\r\n      this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1);\r\n      this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\r\n      this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);\r\n    } else {\r\n      this.knots.evaluateBasisFunctions1(knotIndex0, u, this.basisBuffer, this.basisBuffer1, this.basisBuffer2);\r\n      this.sumPoleBufferForSpan(knotIndex0 - this.degree + 1);\r\n      this.sumPoleBuffer1ForSpan(knotIndex0 - this.degree + 1);\r\n      this.sumPoleBuffer2ForSpan(knotIndex0 - this.degree + 1);\r\n    }\r\n  }\r\n  /**\r\n   * Reverse the (blocked) poles (in `this.packedData` in place.\r\n   */\r\n  public reverseInPlace(): void {\r\n    // reverse poles in blocks ...\r\n    const b = this.poleLength;\r\n    const data = this.packedData;\r\n    for (let i0 = 0, j0 = b * (this.numPoles - 1);\r\n      i0 < j0;\r\n      i0 += b, j0 -= b) {\r\n      let t = 0;\r\n      for (let i = 0; i < b; i++) {\r\n        t = data[i0 + i];\r\n        data[i0 + i] = data[j0 + i];\r\n        data[j0 + i] = t;\r\n      }\r\n    }\r\n    this.knots.reflectKnots();\r\n  }\r\n  /**\r\n   * Test if the leading and trailing polygon coordinates are replicated in the manner of a \"closed\" bspline polygon which has been expanded\r\n   * to act as a normal bspline.\r\n   * @returns true if `degree` leading and trailing polygon blocks match\r\n   */\r\n  public testCloseablePolygon(mode?: BSplineWrapMode): boolean {\r\n    if (mode === undefined)\r\n      mode = this.knots.wrappable;\r\n    const degree = this.degree;\r\n    const blockSize = this.poleLength;\r\n    const indexDelta = (this.numPoles - this.degree) * blockSize;\r\n    const data = this.packedData;\r\n    if (mode === BSplineWrapMode.OpenByAddingControlPoints) {\r\n      // expect {degree} matched points.\r\n      const numValuesToTest = degree * blockSize;\r\n      for (let i0 = 0; i0 < numValuesToTest; i0++) {\r\n        if (!Geometry.isSameCoordinate(data[i0], data[i0 + indexDelta]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    if (mode === BSplineWrapMode.OpenByRemovingKnots) {\r\n      // no pole conditions are applied.\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d, Range1d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\n\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\r\n\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Geometry, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { KnotVector, BSplineWrapMode } from \"./KnotVector\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { BezierCurve3dH } from \"./BezierCurve3dH\";\r\nimport { BezierCurve3d } from \"./BezierCurve3d\";\r\nimport { BSpline1dNd } from \"./BSpline1dNd\";\r\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { Bezier1dNd } from \"./Bezier1dNd\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * Base class for BSplineCurve3d and BSplineCurve3dH.\r\n * * A bspline curve consists of a set of knots and a set of poles.\r\n * * The bspline curve is a function of the independent \"knot axis\" variable\r\n * * The curve \"follows\" the poles loosely.\r\n * * The is a set of polynomial spans.\r\n * * The polynomial spans all have same `degree`.\r\n * * Within each span, the polynomial of that `degree` is controlled by `order = degree + 1` contiguous points called poles.\r\n * * The is a strict relationship between knot and poles counts:  `numPoles + order = numKnots + 2'\r\n * * The number of spans is `numSpan = numPoles - degree`\r\n * * For a given `spanIndex`:\r\n *   * The `order` poles begin at index `spanIndex`.\r\n *   * The `2*order` knots begin as span index\r\n *   * The knot interval for this span is from `knot[degree+span-1] to knot[degree+span]`\r\n * * The active part of the knot axis is `knot[degree-1] < knot < knot[degree-1 + numSpan]` i.e. `knot[degree-1] < knot < knot[numPoles]\r\n *\r\n * Nearly all bsplines are \"clamped \".\r\n * * Clamping make the curve pass through its first and last poles, with tangents directed along the first and last edges of the control polygon.\r\n * * The knots for a clamped bspline have `degree` copies of the lowest knot value and `degree` copies of the highest knot value.\r\n * * For instance, the knot vector `[0,0,0,1,2,3,3,3]\r\n *   * can be evaluated from `0<=knot<=3`\r\n *   * has 3 spans: 0 to 1, 1 to 2, 2 to 3\r\n *   * has 6 poles\r\n *   * passes through its first and last poles.\r\n * * `create` methods may allow classic convention that has an extra knot at the beginning and end of the knot vector.\r\n *   * The extra knots (first and last) were never referenced by the bspline recurrence relations.\r\n *   * When the `create` methods recognize the classic setup (`numPoles + order = numKnots`), the extra knot is not saved with the BSplineCurve3dBase knots.\r\n *\r\n * * The weighted variant has the problem that CurvePrimitive 3d typing does not allow undefined result where Point4d has zero weight.\r\n * * The convention for these is to return 000 in such places.\r\n *\r\n * * Note the class relationships:\r\n *   * BSpline1dNd knows the bspline recurrence relations for control points (poles) with no physical meaning.\r\n *   * BsplineCurve3dBase owns a protected BSpline1dNd\r\n *   * BsplineCurve3dBase is derived from CurvePrimitive, which creates obligation to act as a 3D curve, such as\r\n *     * evaluate fraction to point and derivatives wrt fraction\r\n *     * compute intersection with plane\r\n *   * BSplineCurve3d and BSplineCurve3dH have variant logic driven by whether or not there are \"weights\" on the poles.\r\n *     * For `BSplineCurve3d`, the xyz value of pole calculations are \"final\" values for 3d evaluation\r\n *     * For `BSplineCurve3dH`, various `BSpline1dNd` results with xyzw have to be normalized back to xyz.\r\n *\r\n * * These classes do not support \"periodic\" variants.\r\n *   * Periodic curves need to have certain leading knots and poles replicated at the end\r\n * @public\r\n */\r\nexport abstract class BSplineCurve3dBase extends CurvePrimitive {\r\n  /** The underlying blocked-pole spline, with simple x,y,z poles */\r\n  protected _bcurve: BSpline1dNd;\r\n  protected constructor(poleDimension: number, numPoles: number, order: number, knots: KnotVector) {\r\n    super();\r\n    this._bcurve = BSpline1dNd.create(numPoles, poleDimension, order, knots) as BSpline1dNd;\r\n  }\r\n  /** Return the degree (one less than the order) of the curve */\r\n  public get degree(): number { return this._bcurve.degree; }\r\n  /** Return the order (one more than degree) of the curve */\r\n  public get order(): number { return this._bcurve.order; }\r\n  /** Return the number of bezier spans in the curve.  Note that this number includes the number of null spans at repeated knows */\r\n  public get numSpan(): number { return this._bcurve.numSpan; }\r\n  /** Return the number of poles */\r\n  public get numPoles(): number { return this._bcurve.numPoles; }\r\n  /**\r\n * return a simple array form of the knots.  optionally replicate the first and last\r\n * in classic over-clamped manner\r\n */\r\n  public copyKnots(includeExtraEndKnot: boolean): number[] { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }\r\n\r\n  /**\r\n * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\r\n */\r\n  public setWrappable(value: BSplineWrapMode) {\r\n    this._bcurve.knots.wrappable = value;\r\n  }\r\n\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public abstract evaluatePointInSpan(spanIndex: number, spanFraction: number, result?: Point3d): Point3d;\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public abstract evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number, result?: Ray3d): Ray3d;\r\n  /** Evaluate xyz at a position given by knot. */\r\n  public abstract knotToPoint(knot: number, result?: Point3d): Point3d;\r\n  /** Evaluate xyz and derivative at position given by a knot value.  */\r\n  public abstract knotToPointAndDerivative(knot: number, result?: Ray3d): Ray3d;\r\n  /** Evaluate xyz and 2 derivatives at position given by a knot value.  */\r\n  public abstract knotToPointAnd2Derivatives(knot: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;\r\n  /** Evaluate the curve point at `fraction` */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);\r\n  }\r\n  /** Construct a ray with\r\n   * * origin at the fractional position along the arc\r\n   * * direction is the first derivative, i.e. tangent along the curve\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAndDerivative(knot, result);\r\n    result.direction.scaleInPlace(this._bcurve.knots.knotLength01);\r\n    return result;\r\n  }\r\n\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the curve\r\n   * * y axis is the second derivative\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAnd2Derivatives(knot, result);\r\n    const a = this._bcurve.knots.knotLength01;\r\n    result.vectorU.scaleInPlace(a);\r\n    result.vectorV.scaleInPlace(a * a);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the start point of the curve.\r\n   */\r\n  public startPoint(): Point3d { return this.evaluatePointInSpan(0, 0.0); }\r\n  /**\r\n   * Return the end point of the curve\r\n   */\r\n  public endPoint(): Point3d { return this.evaluatePointInSpan(this.numSpan - 1, 1.0); }\r\n  /** Reverse the curve in place.\r\n   * * Poles are reversed\r\n   * * knot values are mirrored around the middle of the\r\n   */\r\n  public reverseInPlace(): void { this._bcurve.reverseInPlace(); }\r\n  /**\r\n   * Return an array with this curve's bezier fragments.\r\n   */\r\n  public collectBezierSpans(prefer3dH: boolean): BezierCurveBase[] {\r\n    const result: BezierCurveBase[] = [];\r\n    const numSpans = this.numSpan;\r\n    for (let i = 0; i < numSpans; i++) {\r\n      if (this._bcurve.knots.isIndexOfRealSpan(i)) {\r\n        const span = this.getSaturatedBezierSpan3dOr3dH(i, prefer3dH);\r\n        if (span)\r\n          result.push(span);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n    * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCurve3d or BezierCurve3dH according to the instance type and the prefer3dH parameter.\r\n    * @param spanIndex\r\n    * @param prefer3dH true to force promotion to homogeneous.\r\n    * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n    */\r\n  public abstract getSaturatedBezierSpan3dOr3dH(spanIndex: number, prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined;\r\n  /** Return a specified pole as a Point4d.\r\n   * * BSplineCurve3d appends weight 1 to its xyz\r\n   * * BSplineCurve3dH with pole whose \"normalized\" point is (x,y,z) but has weight w returns its weighted (wx,wy,wz,w)\r\n   */\r\n  public abstract getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined;\r\n  /** Return a specified pole as a Point3d\r\n   * * BSplineCurve3d returns its simple xyz\r\n   * * BSplineCurve3dH attempts to normalize its (wx,wy,wz,w) back to (x,y,z), and returns undefined if weight is zero.\r\n   * @param poleIndex\r\n   * @param result optional result\r\n   */\r\n  public abstract getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined;\r\n\r\n  /** Given a pole index, return the starting index for the contiguous array. */\r\n  public poleIndexToDataIndex(poleIndex: number): number | undefined {\r\n    if (poleIndex >= 0 && poleIndex < this.numPoles)\r\n      return poleIndex * this._bcurve.poleLength;\r\n    return undefined;\r\n  }\r\n\r\n  /** Search for the curve point that is closest to the spacePoint.\r\n   *\r\n   * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.\r\n   * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed\r\n   * @param spacePoint point in space\r\n   * @param extend true to extend the curve (if possible)\r\n   * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, _extend: boolean): CurveLocationDetail | undefined {\r\n    const point = this.fractionToPoint(0);\r\n    const result = CurveLocationDetail.createCurveFractionPointDistance(this, 0.0, point, point.distance(spacePoint));\r\n    this.fractionToPoint(1.0, point);\r\n    result.updateIfCloserCurveFractionPointDistance(this, 1.0, spacePoint, spacePoint.distance(point));\r\n\r\n    let span: BezierCurve3dH | undefined;\r\n    const numSpans = this.numSpan;\r\n    for (let i = 0; i < numSpans; i++) {\r\n      if (this._bcurve.knots.isIndexOfRealSpan(i)) {\r\n        span = this.getSaturatedBezierSpan3dOr3dH(i, true, span) as BezierCurve3dH;\r\n        if (span) {\r\n          if (span.updateClosestPointByTruePerpendicular(spacePoint, result)) {\r\n            // the detail records the span bezier -- promote it to the parent curve . ..\r\n            result.curve = this;\r\n            result.fraction = span.fractionToParentFraction(result.fraction);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Implement `CurvePrimitive.appendPlaneIntersections`\r\n   * @param plane A plane (e.g. specific type Plane3dByOriginAndUnitNormal or Point4d)\r\n   * @param result growing array of plane intersections\r\n   * @return number of intersections appended to the array.\r\n  */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const numPole = this.numPoles;\r\n    const order = this.order;\r\n    const allCoffs = new Float64Array(numPole);\r\n    const numSpan = this.numSpan;\r\n    const point4d = Point4d.create();\r\n    // compute all pole altitudes from the plane\r\n    const minMax = Range1d.createNull();\r\n    // Put the altitudes of all the bspline poles in one array.\r\n    for (let i = 0; i < numPole; i++) {\r\n      allCoffs[i] = plane.weightedAltitude(this.getPolePoint4d(i, point4d)!);\r\n      minMax.extendX(allCoffs[i]);\r\n    }\r\n    // A univariate bspline through the altitude poles gives altitude as function of the bspline knot.\r\n    // The (bspline) altitude function for each span is `order` consecutive altitudes.\r\n    // If those altitudes bracket zero, the span may potentially have a crossing.\r\n    // When that occurs,\r\n    let univariateBezier: UnivariateBezier | undefined;\r\n    let numFound = 0;\r\n    let previousFraction = -1000.0;\r\n    if (minMax.containsX(0.0)) {\r\n      for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n        if (this._bcurve.knots.isIndexOfRealSpan(spanIndex)) {  // ignore trivial knot intervals.\r\n          // outer range test ...\r\n          minMax.setNull();\r\n          minMax.extendArraySubset(allCoffs, spanIndex, order);\r\n          if (minMax.containsX(0.0)) {\r\n            // pack the bspline support into a univariate bezier ...\r\n            univariateBezier = UnivariateBezier.createArraySubset(allCoffs, spanIndex, order, univariateBezier)!;\r\n            // saturate and solve the bezier\r\n            Bezier1dNd.saturate1dInPlace(univariateBezier.coffs, this._bcurve.knots, spanIndex);\r\n            const roots = univariateBezier.roots(0.0, true);\r\n            if (roots) {\r\n              for (const spanFraction of roots) {\r\n                // promote each local bezier fraction to global fraction.\r\n                // savet the curve evaluation at that fraction.\r\n                numFound++;\r\n                const fraction = this._bcurve.knots.spanFractionToFraction(spanIndex, spanFraction);\r\n                if (!Geometry.isAlmostEqualNumber(fraction, previousFraction)) {\r\n                  const detail = CurveLocationDetail.createCurveEvaluatedFraction(this, fraction);\r\n                  result.push(detail);\r\n                  previousFraction = fraction;\r\n                }\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return numFound;\r\n  }\r\n\r\n}\r\n/**\r\n * A BSplineCurve3d is a bspline curve whose poles are Point3d.\r\n * See BSplineCurve3dBase for description of knots, order, degree.\r\n * @public\r\n */\r\nexport class BSplineCurve3d extends BSplineCurve3dBase {\r\n\r\n  private _workBezier?: BezierCurve3dH;\r\n  private initializeWorkBezier(): BezierCurve3dH {\r\n    if (this._workBezier === undefined)\r\n      this._workBezier = BezierCurve3dH.createOrder(this.order);\r\n    return this._workBezier;\r\n  }\r\n  /** test of `other` is an instance of BSplineCurve3d */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineCurve3d; }\r\n  /** Apply `transform` to the poles. */\r\n  public tryTransformInPlace(transform: Transform): boolean { Point3dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }\r\n  /** Get a pole as simple Point3d. */\r\n  public getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      return Point3d.create(data[k], data[k + 1], data[k + 2], result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Get a pole as Point4d with weight 1 */\r\n  public getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      return Point4d.create(data[k], data[k + 1], data[k + 2], 1.0, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Convert  `spanIndex` and `localFraction` to a knot. */\r\n  public spanFractionToKnot(span: number, localFraction: number): number {\r\n    return this._bcurve.spanFractionToKnot(span, localFraction);\r\n  }\r\n  private constructor(numPoles: number, order: number, knots: KnotVector) {\r\n    super(3, numPoles, order, knots);\r\n  }\r\n  /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */\r\n  public copyPoints(): any[] { return Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 3); }\r\n  /** Return a simple array of the control points coordinates */\r\n  public copyPointsFloat64Array(): Float64Array { return this._bcurve.packedData.slice(); }\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(includeExtraEndKnot: boolean): number[] { return this._bcurve.knots.copyKnots(includeExtraEndKnot); }\r\n\r\n  /** Create a bspline with uniform knots. */\r\n  public static createUniformKnots(poles: Point3d[] | Float64Array | GrowableXYZArray, order: number): BSplineCurve3d | undefined {\r\n    const numPoles = poles instanceof Float64Array ? poles.length / 3 : poles.length;\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.createUniformClamped(numPoles, order - 1, 0.0, 1.0);\r\n    const curve = new BSplineCurve3d(numPoles, order, knots);\r\n    if (poles instanceof Float64Array) {\r\n      for (let i = 0; i < 3 * numPoles; i++)\r\n        curve._bcurve.packedData[i] = poles[i];\r\n    } else if (poles instanceof GrowableXYZArray) {\r\n      curve._bcurve.packedData = poles.float64Data().slice(0, 3 * numPoles);\r\n    } else {\r\n      let i = 0;\r\n      for (const p of poles) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; }\r\n    }\r\n    return curve;\r\n  }\r\n  /** Create a bspline with given knots.\r\n   *\r\n   * *  Two count conditions are recognized:\r\n   *\r\n   * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\r\n   *\r\n   */\r\n  public static create(poleArray: Float64Array | Point3d[], knotArray: Float64Array | number[], order: number): BSplineCurve3d | undefined {\r\n    let numPoles = poleArray.length;\r\n    if (poleArray instanceof Float64Array) {\r\n      numPoles /= 3;  // blocked as xyz\r\n    }\r\n    const numKnots = knotArray.length;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const skipFirstAndLast = (numPoles + order === numKnots);\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.create(knotArray, order - 1, skipFirstAndLast);\r\n    const curve = new BSplineCurve3d(numPoles, order, knots);\r\n    if (poleArray instanceof Float64Array) {\r\n      let i = 0;\r\n      for (const coordinate of poleArray) { curve._bcurve.packedData[i++] = coordinate; }\r\n    } else {\r\n      let i = 0;\r\n      for (const p of poleArray) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; }\r\n    }\r\n    return curve;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): BSplineCurve3d {\r\n    const knotVector1 = this._bcurve.knots.clone();\r\n    const curve1 = new BSplineCurve3d(this.numPoles, this.order, knotVector1);\r\n    curve1._bcurve.packedData = this._bcurve.packedData.slice();\r\n    return curve1;\r\n  }\r\n  /** Return a transformed deep clone. */\r\n  public cloneTransformed(transform: Transform): BSplineCurve3d {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public evaluatePointInSpan(spanIndex: number, spanFraction: number): Point3d {\r\n    this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);\r\n    return Point3d.createFrom(this._bcurve.poleBuffer);\r\n  }\r\n  /** Evaluate point and derivative vector at a position given by fractional position within a span.\r\n   * * The derivative is with respect to the span fraction (NOT scaled to either global fraction or knot)\r\n   */\r\n  public evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number): Ray3d {\r\n    this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);\r\n    return Ray3d.createCapture(\r\n      Point3d.createFrom(this._bcurve.poleBuffer),\r\n      Vector3d.createFrom(this._bcurve.poleBuffer1));\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPoint(u: number, result?: Point3d): Point3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u);\r\n    return Point3d.createFrom(this._bcurve.poleBuffer, result);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivative(u: number, result?: Ray3d): Ray3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 1);\r\n    if (!result) return Ray3d.createCapture(\r\n      Point3d.createFrom(this._bcurve.poleBuffer),\r\n      Vector3d.createFrom(this._bcurve.poleBuffer1));\r\n    result.origin.setFrom(this._bcurve.poleBuffer);\r\n    result.direction.setFrom(this._bcurve.poleBuffer1);\r\n    return result;\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */\r\n  public knotToPointAnd2Derivatives(u: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 2);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(\r\n      this._bcurve.poleBuffer[0], this._bcurve.poleBuffer[1], this._bcurve.poleBuffer[2],\r\n      this._bcurve.poleBuffer1[0], this._bcurve.poleBuffer1[1], this._bcurve.poleBuffer1[2],\r\n      this._bcurve.poleBuffer2[0], this._bcurve.poleBuffer2[1], this._bcurve.poleBuffer2[2], result);\r\n  }\r\n  /** Evaluate the curve point at a fractional of the entire knot range. */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    return this.knotToPoint(this._bcurve.knots.fractionToKnot(fraction), result);\r\n  }\r\n\r\n  /** Evaluate the curve point at a fractional of the entire knot range. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAndDerivative(knot, result);\r\n    result.direction.scaleInPlace(this._bcurve.knots.knotLength01);\r\n    return result;\r\n  }\r\n\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knot = this._bcurve.knots.fractionToKnot(fraction);\r\n    result = this.knotToPointAnd2Derivatives(knot, result);\r\n    const a = this._bcurve.knots.knotLength01;\r\n    result.vectorU.scaleInPlace(a);\r\n    result.vectorV.scaleInPlace(a * a);\r\n    return result;\r\n  }\r\n  /** test if almost the same curve as `other` */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineCurve3d) {\r\n      return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)\r\n        && Point3dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);\r\n    }\r\n    return false;\r\n  }\r\n  /** test if this curve is entirely within plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point3dArray.isCloseToPlane(this._bcurve.packedData, plane);\r\n  }\r\n  /** Return the control polygon length as approximation (always overestimate) of the curve length. */\r\n  public quickLength(): number { return Point3dArray.sumEdgeLengths(this._bcurve.packedData); }\r\n  /** Emit beziers or strokes (selected by the stroke options) to the handler. */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const needBeziers = handler.announceBezierCurve !== undefined;\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStrokes;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);\r\n      if (bezier) {\r\n        numStrokes = bezier.computeStrokeCountForOptions(options);\r\n        if (needBeziers) {\r\n          handler.announceBezierCurve!(bezier, numStrokes, this,\r\n            spanIndex,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n\r\n        } else {\r\n          handler.announceIntervalForUniformStepStrokes(this, numStrokes,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStroke = 0;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        numStroke += bezier.computeStrokeCountForOptions(options);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   * @alpha\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\r\n\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier) {\r\n        const segmentLength = workBezier.curveLength();\r\n        const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);\r\n        myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\r\n      }\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\r\n  }\r\n  /** Append strokes to a linestring. */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        bezier.emitStrokes(dest, options);\r\n    }\r\n  }\r\n  /**\r\n   * Test knots, control points, and wrappable flag to see if all agree for a possible wrapping.\r\n   * @returns the manner of closing.   Se BSplineWrapMode for particulars of each mode.\r\n   *\r\n   */\r\n  public get isClosable(): BSplineWrapMode {\r\n    const mode = this._bcurve.knots.wrappable;\r\n    if (mode === BSplineWrapMode.None)\r\n      return BSplineWrapMode.None;\r\n    if (!this._bcurve.knots.testClosable(mode))\r\n      return BSplineWrapMode.None;\r\n    if (!this._bcurve.testCloseablePolygon(mode))\r\n      return BSplineWrapMode.None;\r\n    return mode;\r\n  }\r\n  /**\r\n   * Return a BezierCurveBase for this curve.  The concrete return type may be BezierCurve3d or BezierCurve3dH according to this type.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dOr3dH(spanIndex: number, prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    if (prefer3dH)\r\n      return this.getSaturatedBezierSpan3dH(spanIndex, result);\r\n    return this.getSaturatedBezierSpan3d(spanIndex, result);\r\n  }\r\n\r\n  /**\r\n   * Return a CurvePrimitive (which is a BezierCurve3d) for a specified span of this curve.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3d(spanIndex: number, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    if (spanIndex < 0 || spanIndex >= this.numSpan)\r\n      return undefined;\r\n\r\n    const order = this.order;\r\n    if (result === undefined || !(result instanceof BezierCurve3d) || result.order !== order)\r\n      result = BezierCurve3d.createOrder(order);\r\n    const bezier = result as BezierCurve3d;\r\n    bezier.loadSpanPoles(this._bcurve.packedData, spanIndex);\r\n    if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\r\n      return result;\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dH(spanIndex: number, result?: BezierCurveBase): BezierCurve3dH | undefined {\r\n    if (spanIndex < 0 || spanIndex >= this.numSpan)\r\n      return undefined;\r\n\r\n    const order = this.order;\r\n    if (result === undefined || !(result instanceof BezierCurve3dH) || result.order !== order)\r\n      result = BezierCurve3dH.createOrder(order);\r\n    const bezier = result as BezierCurve3dH;\r\n    bezier.loadSpan3dPolesWithWeight(this._bcurve.packedData, spanIndex, 1.0);\r\n    if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\r\n      return bezier;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\r\n   */\r\n  public setWrappable(value: BSplineWrapMode) {\r\n    this._bcurve.knots.wrappable = value;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineCurve3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineCurve3d(this);\r\n  }\r\n  /**\r\n   * Extend a range so in includes the range of this curve\r\n   * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.\r\n   * @param rangeToExtend\r\n   * @param transform transform to apply to points as they are entered into the range.\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const buffer = this._bcurve.packedData;\r\n    const n = buffer.length - 2;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += 3)\r\n        rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += 3)\r\n        rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    }\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\n\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { KnotVector } from \"./KnotVector\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Point3dArray, Point4dArray } from \"../geometry3d/PointHelpers\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { BezierCurve3dH } from \"./BezierCurve3dH\";\r\nimport { BSplineCurve3dBase } from \"./BSplineCurve\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\n\r\n/**\r\n * Weighted (Homogeneous) BSplineCurve in 3d\r\n * @public\r\n */\r\nexport class BSplineCurve3dH extends BSplineCurve3dBase {\r\n  private _workBezier?: BezierCurve3dH;\r\n  private initializeWorkBezier(): BezierCurve3dH {\r\n    if (this._workBezier === undefined)\r\n      this._workBezier = BezierCurve3dH.createOrder(this.order);\r\n    return this._workBezier;\r\n  }\r\n  /** Test if `other` is an instance of `BSplineCurve3dH` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineCurve3dH; }\r\n  /** Apply `transform` to the curve */\r\n  public tryTransformInPlace(transform: Transform): boolean { Point4dArray.multiplyInPlace(transform, this._bcurve.packedData); return true; }\r\n  /** Get a pole, normalized to Point3d. */\r\n  public getPolePoint3d(poleIndex: number, result?: Point3d): Point3d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      const divw = Geometry.conditionalDivideFraction(1.0, data[k + 3]);\r\n      if (divw !== undefined)\r\n        return Point3d.create(data[k] * divw, data[k + 1] * divw, data[k + 2] * divw, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Get a pole as Point4d */\r\n  public getPolePoint4d(poleIndex: number, result?: Point4d): Point4d | undefined {\r\n    const k = this.poleIndexToDataIndex(poleIndex);\r\n    if (k !== undefined) {\r\n      const data = this._bcurve.packedData;\r\n      return Point4d.create(data[k], data[k + 1], data[k + 2], data[k + 3], result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** map a spanIndex and fraction to a knot value. */\r\n  public spanFractionToKnot(span: number, localFraction: number): number {\r\n    return this._bcurve.spanFractionToKnot(span, localFraction);\r\n  }\r\n  private constructor(numPoles: number, order: number, knots: KnotVector) {\r\n    super(4, numPoles, order, knots);\r\n  }\r\n  /** Return a simple array of arrays with the control points as `[[x,y,z,w],[x,y,z,w],..]` */\r\n  public copyPoints(): any[] { return Point3dArray.unpackNumbersToNestedArrays(this._bcurve.packedData, 4); }\r\n  /** Return a simple array of the control points coordinates */\r\n  public copyPointsFloat64Array(): Float64Array { return this._bcurve.packedData.slice(); }\r\n\r\n  /** Create a bspline with uniform knots.\r\n   * * Control points may be supplied as:\r\n   *   * array of Point4d, with weight already multiplied into the `[wx,wy,wz,w]`\r\n   *   * array of Point3d, with implied weight 1.\r\n   *   * Float64Array, blocked as xyzw, i.e. 4 doubles per control point.\r\n   * @param controlPoints pole data in array form as noted above.\r\n   * @param order  curve order (1 more than degree)\r\n   */\r\n  public static createUniformKnots(controlPoints: Point3d[] | Point4d[] | Float64Array, order: number): BSplineCurve3dH | undefined {\r\n    const numPoles = (controlPoints instanceof Float64Array) ? controlPoints.length / 4 : controlPoints.length;\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.createUniformClamped(controlPoints.length, order - 1, 0.0, 1.0);\r\n    const curve = new BSplineCurve3dH(numPoles, order, knots);\r\n    let i = 0;\r\n    if (controlPoints[0] instanceof Point3d) {\r\n      for (const p of (controlPoints as Point3d[])) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = 1.0; }\r\n    } else if (controlPoints[0] instanceof Point4d) {\r\n      for (const p of (controlPoints as Point4d[])) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = p.w; }\r\n    } else if (controlPoints instanceof Float64Array) {\r\n      const qPoles = controlPoints as Float64Array;\r\n      const numQ = qPoles.length;\r\n      for (let k = 0; k < numQ; k++) {\r\n        curve._bcurve.packedData[k] = qPoles[k];\r\n      }\r\n    } else {\r\n      return undefined;\r\n    }\r\n    return curve;\r\n  }\r\n  /** Create a bspline with given knots.\r\n   *\r\n   * *  Two count conditions are recognized:\r\n   *\r\n   * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\r\n   *\r\n   */\r\n  public static create(controlPoints: Float64Array | Point4d[] | Point3d[], knotArray: Float64Array | number[], order: number): BSplineCurve3dH | undefined {\r\n    let numPoles = controlPoints.length;\r\n    if (controlPoints instanceof Float64Array) {\r\n      numPoles /= 4;  // blocked as xyz\r\n    }\r\n    const numKnots = knotArray.length;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const skipFirstAndLast = (numPoles + order === numKnots);\r\n    if (order < 1 || numPoles < order)\r\n      return undefined;\r\n    const knots = KnotVector.create(knotArray, order - 1, skipFirstAndLast);\r\n    const curve = new BSplineCurve3dH(numPoles, order, knots);\r\n    if (controlPoints instanceof Float64Array) {\r\n      let i = 0;\r\n      for (const coordinate of controlPoints) { curve._bcurve.packedData[i++] = coordinate; }\r\n    } else if (controlPoints[0] instanceof Point4d) {\r\n      let i = 0;\r\n      for (const p of (controlPoints as Point4d[])) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = p.w; }\r\n    } else if (controlPoints[0] instanceof Point3d) {\r\n      let i = 0;\r\n      for (const p of controlPoints) { curve._bcurve.packedData[i++] = p.x; curve._bcurve.packedData[i++] = p.y; curve._bcurve.packedData[i++] = p.z; curve._bcurve.packedData[i++] = 1.0; }\r\n    }\r\n    return curve;\r\n  }\r\n  /** Return a deep clone of this curve. */\r\n  public clone(): BSplineCurve3dH {\r\n    const knotVector1 = this._bcurve.knots.clone();\r\n    const curve1 = new BSplineCurve3dH(this.numPoles, this.order, knotVector1);\r\n    curve1._bcurve.packedData = this._bcurve.packedData.slice();\r\n    return curve1;\r\n  }\r\n  /** Clone the curve and apply a transform to the clone. */\r\n  public cloneTransformed(transform: Transform): BSplineCurve3dH {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public evaluatePointInSpan(spanIndex: number, spanFraction: number, result?: Point3d): Point3d {\r\n    this._bcurve.evaluateBuffersInSpan(spanIndex, spanFraction);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    return Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);\r\n  }\r\n\r\n  /** Evaluate at a position given by fractional position within a span. */\r\n  public evaluatePointAndDerivativeInSpan(spanIndex: number, spanFraction: number, result?: Ray3d): Ray3d {\r\n    this._bcurve.evaluateBuffersInSpan1(spanIndex, spanFraction);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    const dxyzw = this._bcurve.poleBuffer1;\r\n    return Point4d.createRealDerivativeRay3dDefault000(\r\n      xyzw[0], xyzw[1], xyzw[2], xyzw[3],\r\n      dxyzw[0], dxyzw[1], dxyzw[2], dxyzw[3], result);\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value. */\r\n  public knotToPoint(u: number, result?: Point3d): Point3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    return Point4d.createRealPoint3dDefault000(xyzw[0], xyzw[1], xyzw[2], xyzw[3], result);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivative(u: number, result?: Ray3d): Ray3d {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 1);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    const dxyzw = this._bcurve.poleBuffer1;\r\n    return Point4d.createRealDerivativeRay3dDefault000(\r\n      xyzw[0], xyzw[1], xyzw[2], xyzw[3],\r\n      dxyzw[0], dxyzw[1], dxyzw[2], dxyzw[3], result);\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  Return point with 2 derivatives. */\r\n  public knotToPointAnd2Derivatives(u: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this._bcurve.evaluateBuffersAtKnot(u, 2);\r\n    const xyzw = this._bcurve.poleBuffer;\r\n    const dxyzw = this._bcurve.poleBuffer1;\r\n    const ddxyzw = this._bcurve.poleBuffer2;\r\n    return Point4d.createRealDerivativePlane3dByOriginAndVectorsDefault000(\r\n      xyzw[0], xyzw[1], xyzw[2], xyzw[3],\r\n      dxyzw[0], dxyzw[1], dxyzw[2], dxyzw[3],\r\n      ddxyzw[0], ddxyzw[1], ddxyzw[2], ddxyzw[3],\r\n      result);\r\n  }\r\n  /** test if the curve is almost equal to `other` */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineCurve3dH) {\r\n      return this._bcurve.knots.isAlmostEqual(other._bcurve.knots)\r\n        && Point4dArray.isAlmostEqual(this._bcurve.packedData, other._bcurve.packedData);\r\n    }\r\n    return false;\r\n  }\r\n  /** Test if the curve is entirely within a plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point4dArray.isCloseToPlane(this._bcurve.packedData, plane);\r\n  }\r\n  /** Rreturn the control polygon length as quick approximation to the curve length. */\r\n  public quickLength(): number { return Point3dArray.sumEdgeLengths(this._bcurve.packedData); }\r\n  /** call a handler with interval data for stroking. */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const needBeziers = (handler as any).announceBezierCurve;\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStrokes;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dOr3dH(spanIndex, false, workBezier);\r\n      if (bezier) {\r\n        numStrokes = bezier.computeStrokeCountForOptions(options);\r\n        if (needBeziers) {\r\n          (handler as any).announceBezierCurve(bezier, numStrokes, this,\r\n            spanIndex,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n\r\n        } else {\r\n          handler.announceIntervalForUniformStepStrokes(this, numStrokes,\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 0.0),\r\n            this._bcurve.knots.spanFractionToFraction(spanIndex, 1.0));\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**  Append stroked approximation of this curve to the linestring. */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        bezier.emitStrokes(dest, options);\r\n    }\r\n  }\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    let numStroke = 0;\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier)\r\n        numStroke += bezier.computeStrokeCountForOptions(options);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const workBezier = this.initializeWorkBezier();\r\n    const numSpan = this.numSpan;\r\n    const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\r\n\r\n    for (let spanIndex = 0; spanIndex < numSpan; spanIndex++) {\r\n      const bezier = this.getSaturatedBezierSpan3dH(spanIndex, workBezier);\r\n      if (bezier) {\r\n        const segmentLength = workBezier.curveLength();\r\n        const numStrokeOnSegment = workBezier.computeStrokeCountForOptions(options);\r\n        myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\r\n      }\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\r\n  }\r\n  /**\r\n   * return true if the spline is (a) unclamped with (degree-1) matching knot intervals,\r\n   * (b) (degree-1) wrapped points,\r\n   * (c) marked wrappable from construction time.\r\n   */\r\n  public get isClosable(): boolean {\r\n    if (!this._bcurve.knots.wrappable)\r\n      return false;\r\n    const degree = this.degree;\r\n    const leftKnotIndex = this._bcurve.knots.leftKnotIndex;\r\n    const rightKnotIndex = this._bcurve.knots.rightKnotIndex;\r\n    const period = this._bcurve.knots.rightKnot - this._bcurve.knots.leftKnot;\r\n    const indexDelta = rightKnotIndex - leftKnotIndex;\r\n    for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {\r\n      const k1 = k0 + indexDelta;\r\n      if (!Geometry.isSameCoordinate(this._bcurve.knots.knots[k0] + period, this._bcurve.knots.knots[k1]))\r\n        return false;\r\n    }\r\n    const poleIndexDelta = this.numPoles - this.degree;\r\n    for (let p0 = 0; p0 < degree; p0++) {\r\n      const p1 = p0 + poleIndexDelta;\r\n      if (!Geometry.isSamePoint3d(this.getPolePoint3d(p0) as Point3d, this.getPolePoint3d(p1) as Point3d))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Return a CurvePrimitive (which is a BezierCurve3dH) for a specified span of this curve.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3d with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dH(spanIndex: number, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    if (spanIndex < 0 || spanIndex >= this.numSpan)\r\n      return undefined;\r\n\r\n    const order = this.order;\r\n    if (result === undefined || !(result instanceof BezierCurve3dH) || result.order !== order)\r\n      result = BezierCurve3dH.createOrder(order);\r\n    const bezier = result as BezierCurve3dH;\r\n    bezier.loadSpan4dPoles(this._bcurve.packedData, spanIndex);\r\n    if (bezier.saturateInPlace(this._bcurve.knots, spanIndex))\r\n      return result;\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return a BezierCurveBase for this curve.  Because BSplineCurve3dH is homogeneous, the returned BezierCurveBase is always homogeneous.\r\n   * @param spanIndex\r\n   * @param result optional reusable curve.  This will only be reused if it is a BezierCurve3dH with matching order.\r\n   */\r\n  public getSaturatedBezierSpan3dOr3dH(spanIndex: number, _prefer3dH: boolean, result?: BezierCurveBase): BezierCurveBase | undefined {\r\n    return this.getSaturatedBezierSpan3dH(spanIndex, result);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineCurve3dH(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineCurve3dH(this);\r\n  }\r\n  /**\r\n   * Extend a range so in includes the range of this curve\r\n   * * REMARK: this is based on the poles, not the exact curve.  This is generally larger than the true curve range.\r\n   * @param rangeToExtend\r\n   * @param transform transform to apply to points as they are entered into the range.\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const buffer = this._bcurve.packedData;\r\n    const n = buffer.length - 3;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += 4)\r\n        rangeToExtend.extendTransformedXYZW(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += 4)\r\n        rangeToExtend.extendXYZW(buffer[i0], buffer[i0 + 1], buffer[i0 + 2], buffer[i0 + 3]);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { AxisOrder, Geometry } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Point3dArray, Point4dArray } from \"../geometry3d/PointHelpers\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { KnotVector, BSplineWrapMode } from \"./KnotVector\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n/**\r\n * UVSelect is an integer indicating uDirection (0) or vDirection (1) in a bspline surface parameterization.\r\n * @public\r\n */\r\nexport enum UVSelect {\r\n  /** index of u direction */\r\n  uDirection = 0,\r\n  /** index of v direction */\r\n  VDirection = 1,\r\n\r\n}\r\n/**\r\n * Enumeration of how weights are carried\r\n * * UnWeighted (0) -- there are no weights\r\n * * WeightsAlreadyAppliedToCoordinates (1) -- for real point (x,y,z) the homogeneous point has weight applied throughout as (wx,wy,wz,w)\r\n * * WeightsSeparateFromCoordinates (2) -- for real point (x,y,z) the homogeneous point is (x,y,z,w)\r\n *   * Note that \"internal\" computations never use WeightsSeparateFromCoordinates.\r\n *   * WeightsSeparateFromCoordinates is only useful as input or output state in serializers.\r\n * @public\r\n */\r\nexport enum WeightStyle {\r\n  /** There are no weights. */\r\n  UnWeighted = 0,\r\n  /**\r\n   * * Data is weighted\r\n   * * point with normalized coordinate `[x,y,z]` and weight `w` has weights already multiplied in as `[x*w,y*w,z*w,w]`\r\n   * */\r\n  WeightsAlreadyAppliedToCoordinates = 1,\r\n  /**\r\n   * * Data is weighted\r\n   * * point with normalized coordinate `[x,y,z]` and weight `w` has is `[x,y,z,w]`\r\n   * */\r\n  WeightsSeparateFromCoordinates = 2,\r\n}\r\n/**\r\n * interface for points returned from getPointGrid, with annotation of physical and weighting dimensions.\r\n * @public\r\n */\r\nexport interface PackedPointGrid {\r\n  /**\r\n   * Array of coordinate data.\r\n   * * points[row] is all the data for a grid row.\r\n   * * points[row][j] is the j'th point across the row\r\n   * * points[row][j][k] is numeric value k.\r\n   */\r\n  points: number[][][];\r\n  /**\r\n   * Description of how weights are present in the coordinate data.\r\n  */\r\n  weightStyle?: WeightStyle;\r\n  /**\r\n   * number of cartesian dimensions, e.g. 2 or 3.\r\n   */\r\n  numCartesianDimensions: number;\r\n}\r\n/** Interface for methods supported by both regular (xyz) and weighted (xyzw) bspline surfaces.\r\n * @public\r\n */\r\nexport interface BSplineSurface3dQuery {\r\n  /** Evaluate xyz coordinates at fractional parameter u,v */\r\n  fractionToPoint(uFraction: number, vFraction: number): Point3d;\r\n  /** Evaluate a rigid frame at fractional parameter u,v\r\n   * * origin is at the surface point\r\n   * * x column is a unit vector in the direction of the u derivative\r\n   * * y column is a unit vector in the direction of the v derivative\r\n   * * z direction is the surface normal\r\n   */\r\n  fractionToRigidFrame(uFraction: number, vFraction: number): Transform | undefined;\r\n  /** Evaluate xyz coordinates at knot values (uKnot, vKnot) */\r\n  knotToPoint(uKnot: number, vKnot: number): Point3d;\r\n  /**  appply a transform to the surface */\r\n  tryTransformInPlace(transform: Transform): boolean;\r\n  /** clone the surface */\r\n  clone(): BSplineSurface3dQuery;\r\n  /** clone and transform */\r\n  cloneTransformed(transform: Transform): BSplineSurface3dQuery;\r\n  /** Reverse one of the parameterization directions. */\r\n  reverseInPlace(select: UVSelect): void;\r\n  /** Test if `this` and `other` are the same geometry class. */\r\n  isSameGeometryClass(other: any): boolean;\r\n  /** Extend `rangeToExtend` so this surface is included. */\r\n  extendRange(rangeToExtend: Range3d, transform?: Transform): void;\r\n  /** test for nearly equality with `other` */\r\n  isAlmostEqual(other: any): boolean;\r\n  /** ask if the u or v direction could be converted to periodic form */\r\n  isClosable(select: UVSelect): boolean;\r\n  /** Ask if the entire surface is within a plane. */\r\n  isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;\r\n  /** return the total number of poles (product of u,v counts) */\r\n  numPolesTotal(): number;\r\n  /**\r\n   * turn a numeric variable into a UVSelect (strict 0 or 1).\r\n   */\r\n  numberToUVSelect(value: number): UVSelect;\r\n  /**\r\n   * Return the degree in in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  degreeUV(select: UVSelect): number;\r\n  /**\r\n   * Return the order in in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  orderUV(select: UVSelect): number;\r\n  /**\r\n   * Return the number of bezier spans in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  numSpanUV(select: UVSelect): number;\r\n\r\n  /**\r\n   * Return the number of poles in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  numPolesUV(select: UVSelect): number;\r\n\r\n  /**\r\n   * Return the step between adjacent poles in selected direction (0 for u, 1 for v)\r\n   * @param select 0 for u, 1 for v\r\n   */\r\n  poleStepUV(select: UVSelect): number;\r\n\r\n  /*\r\n     * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.\r\n     * @param fractionU u parameter\r\n     * @param fractionV v parameter\r\n     * @param result undefined if surface derivatives are parallel (or either alone is zero)\r\n     */\r\n  // fractionToRigidFrame(fractionU: number, fractionV: number, result?: Transform): Transform | undefined;\r\n  /**\r\n  * Return control points json arrays.\r\n  * * Each row of points is an an array.\r\n  * * Within the array for each row, each point is an array [x,y,z] or [x,y,z,w].\r\n  * * The PackedPointGrid indicates if weights are present.\r\n  */\r\n  getPointGridJSON(): PackedPointGrid;\r\n}\r\n/** Bspline knots and poles for 2d-to-Nd.\r\n * * This abstract class in not independently instantiable -- GeometryQuery methods must be implemented by derived classes.\r\n * @public\r\n */\r\nexport abstract class BSpline2dNd extends GeometryQuery {\r\n  /** Array of (exactly 2) knot vectors for the u, v directions */\r\n  public knots: KnotVector[];\r\n  /** flat array of coordinate daa, blocked by poleDimension and row */\r\n  public coffs: Float64Array;\r\n  /** Number of componets per pole.\r\n   * * 3 for conventional xyz surface\r\n   * * 4 for weighted (wx, wy, wz, w) surface.\r\n   */\r\n  public poleDimension: number;\r\n  private _numPoles: number[];\r\n  /** Return the degree (one less than order) for the `select` direction (0 or 1) */\r\n  public degreeUV(select: UVSelect): number { return this.knots[select].degree; }\r\n  /** Return the order (one more than degree) for the `select` direction (0 or 1) */\r\n  public orderUV(select: UVSelect): number { return this.knots[select].degree + 1; }\r\n  /** Return the number of spans (INCLUDING NULL SPANS) for the `select` direction (0 or 1) */\r\n  public numSpanUV(select: UVSelect): number { return this._numPoles[select] - this.knots[select].degree; }\r\n  /** Return the total number of poles (product of x and y pole counts) */\r\n  public numPolesTotal(): number { return this.coffs.length / this.poleDimension; }\r\n  /** Return the number of poles for the `select` direction (0 or 1) */\r\n  public numPolesUV(select: UVSelect): number { return this._numPoles[select]; }\r\n  /** Return the step between adjacent poles for the `select` direction (0 or 1) */\r\n  public poleStepUV(select: UVSelect): number { return select === 0 ? 1 : this._numPoles[0]; }\r\n  /** Confirm that order and pole counts agree for both u and v directions */\r\n  public static validOrderAndPoleCounts(orderU: number, numPolesU: number, orderV: number, numPolesV: number, numUV: number): boolean {\r\n    if (orderU < 2 || numPolesU < orderU)\r\n      return false;\r\n    if (orderV < 2 || numPolesV < orderV)\r\n      return false;\r\n    if (numPolesU * numPolesV !== numUV)\r\n      return false;\r\n    return true;\r\n  }\r\n  /** Get the Point3d by row and column.\r\n   * * (IMPORTANT) This assumes this is an xyz surface.  Data will be incorrect if this is an xyzw surface.\r\n   */\r\n  public getPoint3dPole(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return Point3d.createFromPacked(this.coffs, i + j * this._numPoles[0], result);\r\n  }\r\n  /** Get the Point3d by row and column, projecting the weight away to get to xyz\r\n   * * (IMPORTANT) This assumes this is an xyzw surface.  Data will be incorrect if this is an xyz surface.\r\n   */\r\n  public getPoint3dPoleXYZW(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return Point3d.createFromPackedXYZW(this.coffs, i + j * this._numPoles[0], result);\r\n  }\r\n  /**\r\n   * Return 0 for 0 input, 1 for any nonzero input.\r\n   * @param value numeric value to convert to strict 0 or 1.\r\n   */\r\n  public numberToUVSelect(value: number): UVSelect { return value === 0 ? 0 : 1; }\r\n  /** extend a range, treating each block as simple XYZ */\r\n  public extendRangeXYZ(rangeToExtend: Range3d, transform?: Transform) {\r\n    const buffer = this.coffs;\r\n    const pd = this.poleDimension;\r\n    const n = buffer.length + 1 - pd;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += pd)\r\n        rangeToExtend.extendTransformedXYZ(transform, buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += pd)\r\n        rangeToExtend.extendXYZ(buffer[i0], buffer[i0 + 1], buffer[i0 + 2]);\r\n    }\r\n  }\r\n\r\n  /** extend a range, treating each block as homogeneous xyzw, with weight at offset 3 */\r\n  public extendRangeXYZH(rangeToExtend: Range3d, transform?: Transform) {\r\n    const buffer = this.coffs;\r\n    const pd = this.poleDimension;\r\n    const n = buffer.length + 1 - pd;\r\n    let w = 0;\r\n    let divW = 0;\r\n    if (transform) {\r\n      for (let i0 = 0; i0 < n; i0 += pd) {\r\n        w = buffer[i0 + 3];\r\n        if (w !== 0.0) {\r\n          divW = 1.0 / w;\r\n          rangeToExtend.extendTransformedXYZ(transform,\r\n            buffer[i0] * divW,\r\n            buffer[i0 + 1] * divW,\r\n            buffer[i0 + 2] * divW);\r\n        }\r\n      }\r\n    } else {\r\n      for (let i0 = 0; i0 < n; i0 += pd) {\r\n        w = buffer[i0 + 3];\r\n        if (w !== 0.0) {\r\n          divW = 1.0 / w;\r\n          rangeToExtend.extendXYZ(\r\n            buffer[i0] * divW,\r\n            buffer[i0 + 1] * divW,\r\n            buffer[i0 + 2] * divW);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * abstract declaration for evaluation of (unweighted) 3d point and derivatives.\r\n   * Derived classes must implement to get fractionToRigidFrame support.\r\n   * @param _fractionU u parameter\r\n   * @param _fractionV v parameter\r\n   * @param _result optional result.\r\n   */\r\n  public abstract fractionToPointAndDerivatives(_fractionU: number, _fractionV: number, _result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;\r\n  /**\r\n   * evaluate the surface at u and v fractions. Return a (squared, right handed) coordinate frame at that point on the surface.\r\n   * @param fractionU u parameter\r\n   * @param fractionV v parameter\r\n   * @param result undefined if surface derivatives are parallel (or either alone is zero)\r\n   */\r\n  public fractionToRigidFrame(fractionU: number, fractionV: number, result?: Transform): Transform | undefined {\r\n    const skewVectors = this.fractionToPointAndDerivatives(fractionU, fractionV);\r\n    if (!skewVectors)\r\n      return undefined;\r\n    const axes = Matrix3d.createColumnsInAxisOrder(AxisOrder.XYZ,\r\n      skewVectors.vectorU, skewVectors.vectorV, undefined);\r\n    const axes1 = Matrix3d.createRigidFromMatrix3d(axes, AxisOrder.XYZ, axes);\r\n    if (axes1)\r\n      result = Transform.createOriginAndMatrix(skewVectors.origin, axes1, result);\r\n    return result;\r\n  }\r\n  /** a scratch array sized for `order` numbers */\r\n  protected _basisBufferUV: Float64Array[]; //  basis function buffers for u, v directions.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** a scratch array sized for `order` numbers */\r\n  protected _basisBuffer1UV: Float64Array[]; // basis function buffers for u, v directions.   ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n\r\n  /** a scratch array sized for one pole */\r\n  protected _poleBuffer: Float64Array; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n  /** array of 2 scratch array, each sized for one pole\r\n   * * used in derivative evaluations, with respective u and v derivatives in the respective arrays.\r\n  */\r\n  protected _poleBuffer1UV: Float64Array[]; // one set of target values.  ALLOCATED BY CTOR FOR FREQUENT REUSE\r\n\r\n  /**\r\n   * initialize arrays for given spline dimensions.\r\n   */\r\n  protected constructor(numPolesU: number, numPolesV: number, poleLength: number, knotsU: KnotVector, knotsV: KnotVector) {\r\n    super();\r\n    const orderU = knotsU.degree + 1;\r\n    const orderV = knotsV.degree + 1;\r\n    this.knots = [knotsU, knotsV];\r\n    this.coffs = new Float64Array(numPolesU * numPolesV * poleLength);\r\n    this.poleDimension = poleLength;\r\n    this._basisBufferUV = [new Float64Array(orderU), new Float64Array(orderV)];\r\n    this._basisBuffer1UV = [new Float64Array(orderU), new Float64Array(orderV)];\r\n    this._numPoles = [numPolesU, numPolesV];\r\n    this._poleBuffer = new Float64Array(poleLength);\r\n    this._poleBuffer1UV = [new Float64Array(poleLength), new Float64Array(poleLength)];\r\n\r\n  }\r\n  /**\r\n   * Map a position, specified as (uv direction, bezier span, fraction within the bezier), to an overall knot value.\r\n   * @param select selector indicating U or V direction.\r\n   * @param span index of bezier span\r\n   * @param localFraction fractional coordinate within the bezier span\r\n   */\r\n  public spanFractionToKnot(select: UVSelect, span: number, localFraction: number): number {\r\n    return this.knots[select].spanFractionToKnot(span, localFraction);\r\n  }\r\n\r\n  /** Evaluate basis functions given\r\n   * * choice of u or v\r\n   * * span index\r\n   * * local fraction within the span.\r\n   */\r\n  public spanFractionsToBasisFunctions(select: UVSelect, spanIndex: number, spanFraction: number, f: Float64Array, df?: Float64Array) {\r\n    spanIndex = Geometry.clampToStartEnd(spanIndex, 0, this.numSpanUV(select));\r\n    const knotIndex0 = spanIndex + this.degreeUV(select) - 1;\r\n    const globalKnot = this.knots[select].baseKnotFractionToKnot(knotIndex0, spanFraction);\r\n    return df ?\r\n      this.knots[select].evaluateBasisFunctions1(knotIndex0, globalKnot, f, df) :\r\n      this.knots[select].evaluateBasisFunctions(knotIndex0, globalKnot, f);\r\n  }\r\n  /** sum poles by the weights in the basisBuffer, using poles for given span */\r\n  public sumPoleBufferForSpan(spanIndexU: number, spanIndexV: number) {\r\n    const poleBuffer = this._poleBuffer;\r\n    const coffs = this.coffs;\r\n    poleBuffer.fill(0);\r\n    const m = this.poleDimension;\r\n    const stepV = this.poleDimension * this._numPoles[0];\r\n    let kU = m * spanIndexU + spanIndexV * stepV;\r\n    let g = 0;\r\n    for (const fV of this._basisBufferUV[1]) {\r\n      let k = kU;\r\n      for (const fU of this._basisBufferUV[0]) {\r\n        g = fU * fV;\r\n        for (let j = 0; j < m; j++) {\r\n          poleBuffer[j] += g * coffs[k++];\r\n        }\r\n      }\r\n      kU += stepV;\r\n    }\r\n  }\r\n  /** sum derivatives by the weights in the basisBuffer, using poles for given span */\r\n  public sumpoleBufferDerivativesForSpan(spanIndexU: number, spanIndexV: number) {\r\n    const poleBuffer1U = this._poleBuffer1UV[0];\r\n    const poleBuffer1V = this._poleBuffer1UV[1];\r\n    poleBuffer1U.fill(0);\r\n    poleBuffer1V.fill(0);\r\n    const m = this.poleDimension;\r\n    const stepV = this.poleDimension * this._numPoles[0];\r\n    let kU = m * spanIndexU + spanIndexV * stepV;\r\n    // U partial derivatives ...\r\n    let g = 0;\r\n    for (const fV of this._basisBufferUV[1]) {\r\n      let k = kU;\r\n      for (const fU of this._basisBuffer1UV[0]) {\r\n        g = fU * fV;\r\n        for (let j = 0; j < m; j++) {\r\n          poleBuffer1U[j] += g * this.coffs[k++];\r\n        }\r\n      }\r\n      kU += stepV;\r\n    }\r\n\r\n    // V partial derivatives ...\r\n    kU = m * spanIndexU + spanIndexV * stepV;\r\n    for (const fV of this._basisBuffer1UV[1]) {\r\n      let k = kU;\r\n      for (const fU of this._basisBufferUV[0]) {\r\n        g = fU * fV;\r\n        for (let j = 0; j < m; j++) {\r\n          poleBuffer1V[j] += g * this.coffs[k++];\r\n        }\r\n      }\r\n      kU += stepV;\r\n    }\r\n  }\r\n  /**\r\n   * Evaluate the _basisBuffer, _poleBuffer and (optionally) _basisBuffer1 and _poleBuffer1 arrays at given knot.\r\n   *\r\n   * @param u u knot value\r\n   * @param v v not value\r\n   * @param numDerivative number of derivatives needed\r\n   */\r\n  public evaluateBuffersAtKnot(u: number, v: number, numDerivative: number = 0) {\r\n    const knotIndex0U = this.knots[0].knotToLeftKnotIndex(u);\r\n    const knotIndex0V = this.knots[1].knotToLeftKnotIndex(v);\r\n    const poleIndex0U = knotIndex0U - this.degreeUV(0) + 1;\r\n    const poleIndex0V = knotIndex0V - this.degreeUV(1) + 1;\r\n\r\n    if (numDerivative < 1) {\r\n      this.knots[0].evaluateBasisFunctions(knotIndex0U, u, this._basisBufferUV[0]);\r\n      this.knots[1].evaluateBasisFunctions(knotIndex0V, v, this._basisBufferUV[1]);\r\n      this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);\r\n    } else {\r\n      this.knots[0].evaluateBasisFunctions1(knotIndex0U, u, this._basisBufferUV[0], this._basisBuffer1UV[0]);\r\n      this.knots[1].evaluateBasisFunctions1(knotIndex0V, v, this._basisBufferUV[1], this._basisBuffer1UV[1]);\r\n      this.sumPoleBufferForSpan(poleIndex0U, poleIndex0V);\r\n      this.sumpoleBufferDerivativesForSpan(poleIndex0U, poleIndex0V);\r\n    }\r\n  }\r\n  // Swap numSwap entries in coffs, starting at i0 and i1 (absolute indices -- not blocks)\r\n  private swapBlocks(i0: number, i1: number, numSwap: number) {\r\n    let a: number;\r\n    for (let i = 0; i < numSwap; i++) {\r\n      a = this.coffs[i0 + i];\r\n      this.coffs[i0 + i] = this.coffs[i1 + i];\r\n      this.coffs[i1 + i] = a;\r\n    }\r\n  }\r\n  /**\r\n   * Reverse the parameter direction for either u or v.\r\n   * @param select direction to reverse -- 0 for u, 1 for v.\r\n   */\r\n  public reverseInPlace(select: UVSelect): void {\r\n    const m = this.poleDimension;\r\n    const numU = this.numPolesUV(0);\r\n    const numV = this.numPolesUV(1);\r\n    if (select === 0) {\r\n      // reverse within rows.\r\n      for (let j = 0; j < numV; j++) {\r\n        const rowStart = j * numU * m;\r\n        for (let i0 = 0, i1 = numU - 1; i0 < i1; i0++ , i1--) {\r\n          this.swapBlocks(rowStart + i0 * m, rowStart + i1 * m, m);\r\n        }\r\n      }\r\n    } else {\r\n      // swap full rows ..\r\n      const numPerRow = m * numU;\r\n      for (let i0 = 0, i1 = (numV - 1) * numPerRow;\r\n        i0 < i1;\r\n        i0 += numPerRow, i1 -= numPerRow) {\r\n        this.swapBlocks(i0, i1, numPerRow);\r\n      }\r\n    }\r\n    this.knots[select].reflectKnots();\r\n  }\r\n  /**\r\n   * Set the flag indicating the bspline might be suitable for having wrapped \"closed\" interpretation.\r\n   */\r\n  public setWrappable(select: UVSelect, value: BSplineWrapMode) {\r\n    this.knots[select].wrappable = value;\r\n  }\r\n  /**\r\n   * Test if `degree` leading and trailing (one of U or V) blocks match, as if the data is an unwrapped closed spline in the selected direction.\r\n   * @param select select U or V direction\r\n   * @returns true if coordinates matched.\r\n   */\r\n  public isClosable(select: UVSelect): boolean {\r\n    if (this.knots[select].wrappable === BSplineWrapMode.None)\r\n      return false;\r\n    if (!this.knots[select].testClosable())\r\n      return false;\r\n\r\n    const numU = this.numPolesUV(0);\r\n    const numV = this.numPolesUV(1);\r\n    const blockSize = this.poleDimension;\r\n    const rowToRowStep = numU * blockSize;\r\n    const degreeU = this.degreeUV(0);\r\n    const degreeV = this.degreeUV(1);\r\n    const data = this.coffs;\r\n    if (select === 0) {\r\n      const numTest = blockSize * degreeU;  // degreeU contiguous poles.\r\n      for (let row = 0; row < numV; row++) {\r\n        const i0 = row * rowToRowStep;\r\n        const i1 = i0 + rowToRowStep - numTest;\r\n        for (let i = 0; i < numTest; i++) {\r\n          if (!Geometry.isSameCoordinate(data[i0 + i], data[i1 + i]))\r\n            return false;\r\n        }\r\n      }\r\n    } else {\r\n      // Test the entire multi-row contiguous block in one loop . ..\r\n      const numTest = degreeV * rowToRowStep;\r\n      const i1 = blockSize * numU * numV - numTest;\r\n      for (let i = 0; i < numTest; i++) {\r\n        if (!Geometry.isSameCoordinate(data[i], data[i1 + i]))\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/**  BSplineSurface3d is a parametric surface in xyz space.\r\n * * This (BSplineSurface3d) is an unweighted surface.   Use the separate class BSplineSurface3dH for a weighted surface.\r\n *\r\n * The various static \"create\" methods have subtle differences in how grid sizes are conveyed:\r\n * | Method | control point array | counts |\r\n * | create | flat array of [x,y,z] | arguments numPolesU, numPolesV |\r\n * | createGrid | array of array of [x,y,z ] | There are no `numPolesU` or `numPolesV` args. The counts are conveyed by the deep arrays |\r\n * @public\r\n */\r\nexport class BSplineSurface3d extends BSpline2dNd implements BSplineSurface3dQuery {\r\n  /** Test if `other` is an instance of `BSplineSurface3d */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineSurface3d; }\r\n  /** Apply the transform to the poles */\r\n  public tryTransformInPlace(transform: Transform): boolean { Point3dArray.multiplyInPlace(transform, this.coffs); return true; }\r\n  /** Return a pole by u and v indices */\r\n  public getPole(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return this.getPoint3dPole(i, j, result);\r\n  }\r\n\r\n  private constructor(numPolesU: number, numPolesV: number, knotsU: KnotVector, knotsV: KnotVector) {\r\n    super(numPolesU, numPolesV, 3, knotsU, knotsV);\r\n  }\r\n  /**\r\n   * Return control points json arrays.\r\n   * * if `flatArray===true`, each point appears as an array [x,y,z] in row-major order of a containing array.\r\n   * * if `flatArray===false` each row of points is an an array of [x,y,z] in an array.  Each of these row arrays is in the result array.\r\n   */\r\n  public getPointArray(flatArray: boolean = true): any[] {\r\n    if (flatArray)\r\n      return Point3dArray.unpackNumbersToNestedArrays(this.coffs, 3);\r\n    return Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0));\r\n  }\r\n  /**\r\n   * Return control points json arrays.\r\n   * * Each row of points is an an array.\r\n   * * Within the array for each row, each point is an array [x,y,z]\r\n   */\r\n  public getPointGridJSON(): PackedPointGrid {\r\n    const result = {\r\n      points: Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 3, this.numPolesUV(0)),\r\n      weighStyle: WeightStyle.UnWeighted,\r\n      numCartesianDimensions: 3,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /** Return a simple array of the control points coordinates */\r\n  public copyPointsFloat64Array(): Float64Array { return this.coffs.slice(); }\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(select: UVSelect, includeExtraEndKnot: boolean): number[] { return this.knots[select].copyKnots(includeExtraEndKnot); }\r\n\r\n  /** Create a bspline surface.\r\n   * * This `create` variant takes control points in a \"flattened\" array, with\r\n   *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in\r\n   *  a row-by-row grid structure\r\n   * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\r\n   * *  When knots are given, two knot count conditions are recognized:\r\n   * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\r\n   *      the classic unused first and last knot.\r\n   * @param controlPointArray Array of points, ordered along the U direction.\r\n   * @param numPoleU number of poles in each row in the U direction.\r\n   * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayU knots for the V direction.  See note above about knot counts.\r\n   * @param numPoleV number of poles in each row in the U direction.\r\n   * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayV knots for the V direction.  See note above about knot counts.\r\n   */\r\n  public static create(controlPointArray: Point3d[] | Float64Array,\r\n    numPolesU: number,\r\n    orderU: number,\r\n    knotArrayU: number[] | Float64Array | undefined,\r\n    numPolesV: number,\r\n    orderV: number,\r\n    knotArrayV: number[] | Float64Array | undefined): BSplineSurface3d | undefined {\r\n    let numPoles = controlPointArray.length;\r\n    if (controlPointArray instanceof Float64Array)\r\n      numPoles /= 3;\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n    // shift knots-of-interest limits for overclampled case ...\r\n    const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\r\n    const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n\r\n    const knotsU = knotArrayU ?\r\n      KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n    const knotsV = knotArrayV ?\r\n      KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\r\n      KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);\r\n\r\n    const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);\r\n    if (controlPointArray instanceof Float64Array) {\r\n      let i = 0;\r\n      for (const coordinate of controlPointArray) { surface.coffs[i++] = coordinate; }\r\n    } else {\r\n      let i = 0;\r\n      for (const p of controlPointArray) { surface.coffs[i++] = p.x; surface.coffs[i++] = p.y; surface.coffs[i++] = p.z; }\r\n    }\r\n    return surface;\r\n  }\r\n\r\n  /** Create a bspline surface.\r\n   * * This `create` variant takes control points in a \"grid\" array, with the points from\r\n   * each grid row `[rowIndex]` being an independent array `points[rowIndex][indexAlongRow][x,y,z]`\r\n   * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omited (undefined).\r\n   * *  When knots are given, two knot count conditions are recognized:\r\n   * * + If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * * + If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\r\n   *      the classic unused first and last knot.\r\n   * @param controlPointArray Array of points, ordered along the U direction.\r\n   * @param numPoleU number of poles in each row in the U direction.\r\n   * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayU knots for the V direction.  See note above about knot counts.\r\n   * @param numPoleV number of poles in each row in the U direction.\r\n   * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayV knots for the V direction.  See note above about knot counts.\r\n   */\r\n  public static createGrid(points: number[][][],\r\n    orderU: number,\r\n    knotArrayU: number[] | Float64Array | undefined,\r\n    orderV: number,\r\n    knotArrayV: number[] | Float64Array | undefined): BSplineSurface3d | undefined {\r\n    const numPolesV = points.length;\r\n    const numPolesU = points[0].length;\r\n    const numPoles = numPolesU * numPolesV;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\r\n    const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n\r\n    const knotsU = knotArrayU ?\r\n      KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n    const knotsV = knotArrayV ?\r\n      KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n\r\n    const surface = new BSplineSurface3d(numPolesU, numPolesV, knotsU, knotsV);\r\n    let i = 0;\r\n    for (const row of points) {\r\n      for (const xyz of row) {\r\n        surface.coffs[i++] = xyz[0];\r\n        surface.coffs[i++] = xyz[1];\r\n        surface.coffs[i++] = xyz[2];\r\n      }\r\n    }\r\n    return surface;\r\n  }\r\n  /**\r\n   * Return a complete copy of the bspline surface.\r\n   */\r\n  public clone(): BSplineSurface3d {\r\n    const knotVector1U = this.knots[0].clone();\r\n    const knotVector1V = this.knots[1].clone();\r\n    const surface1 = new BSplineSurface3d(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);\r\n    surface1.coffs = this.coffs.slice();\r\n    return surface1;\r\n  }\r\n  /**\r\n   * Return a complete copy of the bspline surface, with a transform applied to the control points.\r\n   * @param transform transform to apply to the control points\r\n   */\r\n  public cloneTransformed(transform: Transform): BSplineSurface3d {\r\n    const surface1 = this.clone();\r\n    surface1.tryTransformInPlace(transform);\r\n    return surface1;\r\n  }\r\n\r\n  /** Evaluate at a position given by u and v coordinates in knot space.\r\n   * @param u u value, in knot range.\r\n   * @param v v value in knot range.\r\n * @returns Return the xyz coordinates on the surface.\r\n   */\r\n  public knotToPoint(u: number, v: number): Point3d {\r\n    this.evaluateBuffersAtKnot(u, v);\r\n    return Point3d.createFrom(this._poleBuffer);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivatives(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this.evaluateBuffersAtKnot(u, v, 1);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsArrays(\r\n      this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);\r\n  }\r\n  /** Evaluate at a position given by fractional coordinate in each direction.\r\n     * @param fractionU u coordinate, as a fraction of the knot range.\r\n     * @param fractionV v coordinate, as a fraction of the knot range.\r\n   * @returns Return the xyz coordinates on the surface.\r\n   */\r\n  public fractionToPoint(fractionU: number, fractionV: number): Point3d {\r\n    return this.knotToPoint(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\r\n  }\r\n\r\n  /**\r\n   * evaluate the surface at u and v fractions.\r\n   * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.\r\n   * @param fractionU u coordinate, as a fraction of the knot range.\r\n   * @param fractionV v coordinate, as a fraction of the knot range.\r\n   * @param result optional pre-allocated object for return values.\r\n   * @returns Returns point and derivative directions.\r\n   */\r\n  public fractionToPointAndDerivatives(fractionU: number, fractionV: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knotU = this.knots[0].fractionToKnot(fractionU);\r\n    const knotV = this.knots[1].fractionToKnot(fractionV);\r\n    return this.knotToPointAndDerivatives(knotU, knotV, result);\r\n  }\r\n  /** test for identical counts and near-equal coordinates */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineSurface3d) {\r\n      return this.knots[0].isAlmostEqual(other.knots[0])\r\n        && this.knots[1].isAlmostEqual(other.knots[1])\r\n        && Point3dArray.isAlmostEqual(this.coffs, other.coffs);\r\n    }\r\n    return false;\r\n  }\r\n  /** Test if all poles are in a plane */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point3dArray.isCloseToPlane(this.coffs, plane);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineSurface3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineSurface3d(this);\r\n  }\r\n  /** Extend the range to include all poles\r\n   * * This is not a tight range.\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this.extendRangeXYZ(rangeToExtend, transform);\r\n  }\r\n\r\n}\r\n\r\n/**  BsplinceCurve in xyzw homogeneous space\r\n * @public\r\n */\r\nexport class BSplineSurface3dH extends BSpline2dNd implements BSplineSurface3dQuery {\r\n  /** Test if `other` is an instance of `BSplineSurface3dH */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BSplineSurface3dH; }\r\n  /** Apply the transform to the poles */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    Point4dArray.multiplyInPlace(transform, this.coffs); return true;\r\n  }\r\n  /** Return a pole by u and v indices */\r\n  public getPole(i: number, j: number, result?: Point3d): Point3d | undefined {\r\n    return this.getPoint3dPoleXYZW(i, j, result);\r\n  }\r\n\r\n  private constructor(numPolesU: number, numPolesV: number, knotsU: KnotVector, knotsV: KnotVector) {\r\n    super(numPolesU, numPolesV, 4, knotsU, knotsV);\r\n  }\r\n  /** Return a simple array of the control points. */\r\n  public copyPoints4d(): Point4d[] { return Point4dArray.unpackToPoint4dArray(this.coffs); }\r\n\r\n  /** Return a simple array of the control points. */\r\n  public copyPointsAndWeights(points: Point3d[], weights: number[],\r\n    formatter: (x: number, y: number, z: number) => any = Point3d.create) {\r\n    Point4dArray.unpackFloat64ArrayToPointsAndWeights(this.coffs, points, weights,\r\n      formatter);\r\n  }\r\n\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(select: UVSelect, includeExtraEndKnot: boolean): number[] { return this.knots[select].copyKnots(includeExtraEndKnot); }\r\n\r\n  /** Create a weighted bspline surface, with control points and weights each organized as flattened array of points continuing from one U row to the next.\r\n   * * This `create` variant takes control points in a \"flattened\" array, with\r\n   *  points from succeeding U rows packed together in one array.  Use `createGrid` if the points are in\r\n   *  a deeper grid array structure.\r\n   * * knotArrayU and knotArrayV are optional -- uniform knots are implied if they are omitted (undefined).\r\n   * *  When knots are given, two knot count conditions are recognized:\r\n   * * * If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * * * If poleArray.length + order == knotArray.length + 2, the knots are in modern form that does not have\r\n   *      the classic unused first and last knot.\r\n   * @param controlPointArray Array of points, ordered along the U direction.\r\n   * @param weightArray array of weights, ordered along the U direction.\r\n   * @param numPoleU number of poles in each row in the U direction.\r\n   * @param orderU order for the U direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayU optional knots for the V direction.  See note above about knot counts.\r\n   * @param numPoleV number of poles in each row in the U direction.\r\n   * @param orderV order for the V direction polynomial (`order` is one more than the `degree`.  \"cubic\" polynomial is order 4.)\r\n   * @param KnotArrayV optional knots for the V direction.  See note above about knot counts.\r\n   */\r\n  public static create(\r\n    controlPointArray: Point3d[],\r\n    weightArray: number[],\r\n    numPolesU: number,\r\n    orderU: number,\r\n    knotArrayU: number[] | undefined,\r\n    numPolesV: number,\r\n    orderV: number,\r\n    knotArrayV: number[] | undefined): BSplineSurface3dH | undefined {\r\n    const numPoles = controlPointArray.length;\r\n    if (numPolesU * numPolesV !== numPoles) return undefined;\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n\r\n    const numKnotsU = knotArrayU ? knotArrayU.length : numPolesU + orderU - 2;\r\n    const numKnotsV = knotArrayV ? knotArrayV.length : numPolesV + orderV - 2;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n\r\n    const knotsU = knotArrayU ?\r\n      KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU) :\r\n      KnotVector.createUniformClamped(numPolesU, orderU - 1, 0.0, 1.0);\r\n    const knotsV = knotArrayV ?\r\n      KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV) :\r\n      KnotVector.createUniformClamped(numPolesV, orderV - 1, 0.0, 1.0);\r\n\r\n    const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);\r\n    Point4dArray.packPointsAndWeightsToFloat64Array(controlPointArray, weightArray, surface.coffs);\r\n    return surface;\r\n  }\r\n\r\n  /** Create a bspline with given knots.\r\n   *\r\n   *   Two count conditions are recognized in each direction:\r\n   *\r\n   * ** If poleArray.length + order == knotArray.length, the first and last are assumed to be the\r\n   *      extraneous knots of classic clamping.\r\n   * ** If poleArray.length + order == knotArray.length + 2, the knots are in modern form.\r\n   *\r\n   */\r\n  public static createGrid(\r\n    xyzwGrid: number[][][],\r\n    weightStyle: WeightStyle,\r\n    orderU: number,\r\n    knotArrayU: number[],\r\n    orderV: number,\r\n    knotArrayV: number[]): BSplineSurface3dH | undefined {\r\n    const numPolesV = xyzwGrid.length;\r\n    const numPolesU = xyzwGrid[0].length;\r\n    const numPoles = numPolesU * numPolesV;\r\n    if (!this.validOrderAndPoleCounts(orderU, numPolesU, orderV, numPolesV, numPoles))\r\n      return undefined;\r\n\r\n    // const numPoles = numPolesU * numPolesV;\r\n    // shift knots-of-interest limits for overclamped case ...\r\n    const numKnotsU = knotArrayU.length;\r\n    const numKnotsV = knotArrayV.length;\r\n    const skipFirstAndLastU = (numPolesU + orderU === numKnotsU);\r\n    const skipFirstAndLastV = (numPolesV + orderV === numKnotsV);\r\n\r\n    const knotsU = KnotVector.create(knotArrayU, orderU - 1, skipFirstAndLastU);\r\n    const knotsV = KnotVector.create(knotArrayV, orderV - 1, skipFirstAndLastV);\r\n\r\n    const surface = new BSplineSurface3dH(numPolesU, numPolesV, knotsU, knotsV);\r\n\r\n    if (weightStyle === WeightStyle.WeightsSeparateFromCoordinates) {\r\n      let i = 0;\r\n      for (const row of xyzwGrid) {\r\n        for (const point of row) {\r\n          const w = point[3];\r\n          surface.coffs[i++] = point[0] * w;\r\n          surface.coffs[i++] = point[1] * w;\r\n          surface.coffs[i++] = point[2] * w;\r\n          surface.coffs[i++] = point[3];\r\n        }\r\n      }\r\n    } else {\r\n      // implicit WeightStyle.WeightsAlreadyAppliedToCoordinates\r\n      let i = 0;\r\n      for (const row of xyzwGrid) {\r\n        for (const point of row) {\r\n          surface.coffs[i++] = point[0];\r\n          surface.coffs[i++] = point[1];\r\n          surface.coffs[i++] = point[2];\r\n          surface.coffs[i++] = point[3];\r\n        }\r\n      }\r\n    }\r\n    return surface;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): BSplineSurface3dH {\r\n    const knotVector1U = this.knots[0].clone();\r\n    const knotVector1V = this.knots[1].clone();\r\n    const surface1 = new BSplineSurface3dH(this.numPolesUV(0), this.numPolesUV(1), knotVector1U, knotVector1V);\r\n    surface1.coffs = this.coffs.slice();\r\n    return surface1;\r\n  }\r\n  /** Return a transformed clone */\r\n  public cloneTransformed(transform: Transform): BSplineSurface3dH {\r\n    const surface1 = this.clone();\r\n    surface1.tryTransformInPlace(transform);\r\n    return surface1;\r\n  }\r\n  /**\r\n    * Return control points json arrays.\r\n    * * Each row of points is an an array.\r\n    * * Within the array for each row, each point is an array [wx,wy,wz,w].\r\n    */\r\n  public getPointGridJSON(): PackedPointGrid {\r\n    const result = {\r\n      points: Point3dArray.unpackNumbersToNestedArraysIJK(this.coffs, 4, this.numPolesUV(0)),\r\n      numCartesianDimensions: 3,\r\n      weightStyle: WeightStyle.WeightsAlreadyAppliedToCoordinates,\r\n    };\r\n    return result;\r\n  }\r\n\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPoint4d(u: number, v: number): Point4d {\r\n    this.evaluateBuffersAtKnot(u, v);\r\n    return Point4d.createFromPackedXYZW(this._poleBuffer, 0);\r\n  }\r\n  /** Evaluate at a position given by a knot value.  */\r\n  public knotToPointAndDerivatives(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    this.evaluateBuffersAtKnot(u, v, 1);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsWeightedArrays(this._poleBuffer, this._poleBuffer1UV[0], this._poleBuffer1UV[1], result);\r\n  }\r\n\r\n  /** Evaluate the Point4d (leaving weights in the point) at given fractional coordinates. */\r\n  public fractionToPoint4d(fractionU: number, fractionV: number): Point4d {\r\n    return this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\r\n  }\r\n  /**\r\n   * * evaluate the surface and return the cartesian (weight = 1) point.\r\n   * * if the surface XYZW point has weight0, returns point3d at 000.\r\n   * @param fractionU u direction fraction\r\n   * @param fractionV v direction fraction\r\n   * @param result optional result\r\n   */\r\n  public fractionToPoint(fractionU: number, fractionV: number, result?: Point3d): Point3d {\r\n    const point4d = this.knotToPoint4d(this.knots[0].fractionToKnot(fractionU), this.knots[1].fractionToKnot(fractionV));\r\n    return point4d.realPointDefault000(result);\r\n  }\r\n  /**\r\n * * evaluate the surface and return the cartesian (weight = 1) point.\r\n * * if the surface XYZW point has weight0, returns point3d at 000.\r\n * @param knotU u direction knot\r\n * @param knotV v direction knot\r\n * @param result optional result\r\n */\r\n  public knotToPoint(knotU: number, knotV: number, result?: Point3d): Point3d {\r\n    const point4d = this.knotToPoint4d(knotU, knotV);\r\n    return point4d.realPointDefault000(result);\r\n  }\r\n  /**\r\n   * evaluate the surface at u and v fractions.\r\n   * @returns plane with origin at the surface point, direction vectors are derivatives in the u and v directions.\r\n   * @param fractionU u coordinate, as a fraction of the knot range.\r\n   * @param fractionV v coordinate, as a fraction of the knot range.\r\n   * @param result optional pre-allocated object for return values.\r\n   * @returns Returns point and derivative directions.\r\n   */\r\n  public fractionToPointAndDerivatives(fractionU: number, fractionV: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const knotU = this.knots[0].fractionToKnot(fractionU);\r\n    const knotV = this.knots[1].fractionToKnot(fractionV);\r\n    return this.knotToPointAndDerivatives(knotU, knotV, result);\r\n  }\r\n  /** test for identical counts and near-equal coordinates */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BSplineSurface3dH) {\r\n      return this.knots[0].isAlmostEqual(other.knots[0])\r\n        && this.knots[1].isAlmostEqual(other.knots[1])\r\n        && Point4dArray.isAlmostEqual(this.coffs, other.coffs);\r\n    }\r\n    return false;\r\n  }\r\n  /** Test if all poles are in a plane */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point4dArray.isCloseToPlane(this.coffs, plane);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBSplineSurface3dH(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBSplineSurface3dH(this);\r\n  }\r\n  /**\r\n   * extend a range to include the (optionally transformed) points of this surface\r\n   * @param rangeToExtend range that is updated to include this surface range\r\n   * @param transform transform to apply to the surface points\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this.extendRangeXYZH(rangeToExtend, transform);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\r\nimport { BezierCoffs, UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { KnotVector } from \"./KnotVector\";\r\n/**\r\n * Shared implementation details for derived bezier curve classes\r\n * * BezierCurve3d implements with blockSize 3.\r\n * * BezierCurve3dH implements with blockSize 4.\r\n * @public\r\n */\r\nexport class Bezier1dNd {\r\n  private _packedData: Float64Array;\r\n  private _order: number; // bezier order.   probably low\r\n  private _blockSize: number; // loosely expected to be 1 to 4.\r\n  private _basis: BezierCoffs; // server for basis queries.  It carries coefficients that we don't use.\r\n  // constructor CAPTURES the control points array.\r\n  public constructor(blockSize: number, polygon: Float64Array) {\r\n    this._blockSize = blockSize;\r\n    this._order = Math.floor(polygon.length / blockSize); // This should be an integer!!!\r\n    this._packedData = polygon;\r\n    this._basis = new UnivariateBezier(this._order);\r\n  }\r\n  /** return a clone of the data array */\r\n  public clonePolygon(result?: Float64Array): Float64Array {\r\n    const n = this._packedData.length;\r\n    if (!result || result.length !== n)\r\n      return this._packedData.slice();\r\n    /** move data into the supplied result */\r\n    for (let i = 0; i < n; i++)\r\n      result[i] = this._packedData[i];\r\n    return result;\r\n  }\r\n  /** Return the bezier order */\r\n  public get order() { return this._order; }\r\n  /** return the packed data array.  This is a REFERENCE to the array. */\r\n  public get packedData() { return this._packedData; }\r\n  /** Create a Bezier1dNd, using the structure of `data[0]` to determine the bezier order. */\r\n  public static create(data: Point2d[] | Point3d[] | Point4d[]): Bezier1dNd | undefined {\r\n    if (data.length < 1)\r\n      return undefined;\r\n    if (data[0] instanceof Point3d) {\r\n      const polygon = new Float64Array(data.length * 3);\r\n      let i = 0;\r\n      for (const p of (data as Point3d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n      }\r\n      return new Bezier1dNd(3, polygon);\r\n    } else if (data[0] instanceof Point4d) {\r\n      const polygon = new Float64Array(data.length * 4);\r\n      let i = 0;\r\n      for (const p of (data as Point4d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n        polygon[i++] = p.w;\r\n      }\r\n      return new Bezier1dNd(4, polygon);\r\n    } else if (data[0] instanceof Point2d) {\r\n      const polygon = new Float64Array(data.length * 2);\r\n      let i = 0;\r\n      for (const p of (data as Point2d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n      }\r\n      return new Bezier1dNd(2, polygon);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the curve value at bezier fraction `s`\r\n   * @return buffer of length `blockSize`.\r\n   */\r\n  public evaluate(s: number, buffer?: Float64Array): Float64Array {\r\n    return this._basis.sumBasisFunctions(s, this._packedData, this._blockSize, buffer);\r\n  }\r\n  /** Return the curve derivative value at bezier fraction `s`\r\n   * @return buffer of length `blockSize`.\r\n   */\r\n  public evaluateDerivative(s: number, buffer?: Float64Array): Float64Array {\r\n    return this._basis.sumBasisFunctionDerivatives(s, this._packedData, this._blockSize, buffer);\r\n  }\r\n  /** get a single point of the polygon as a simple array.  */\r\n  public getPolygonPoint(i: number, buffer?: Float64Array): Float64Array | undefined {\r\n    if (!buffer)\r\n      buffer = new Float64Array(this._blockSize);\r\n    if (i >= 0 && i < this._order) {\r\n      const k0 = this._blockSize * i;\r\n      for (let k = 0; k < this._blockSize; k++)\r\n        buffer[k] = this._packedData[k0 + k];\r\n      return buffer;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** set a single point of the polygon as a simple array.  */\r\n  public setPolygonPoint(i: number, buffer: Float64Array) {\r\n    if (i >= 0 && i < this._order) {\r\n      const k0 = this._blockSize * i;\r\n      for (let k = 0; k < this._blockSize; k++)\r\n        this._packedData[k0 + k] = buffer[k];\r\n    }\r\n  }\r\n  /** Load order * dimension doubles from data[dimension * spanIndex] as poles\r\n   * @param data packed source array.  block size in `data` assumed to match dimension for this.\r\n   * @param spanIndex block index in data.\r\n   */\r\n  public loadSpanPoles(data: Float64Array, spanIndex: number) {\r\n    let k = spanIndex * this._blockSize;\r\n    for (let i = 0; i < this._packedData.length; i++)\r\n      this._packedData[i] = data[k++];\r\n  }\r\n  /** Load order * (dataDimension + 1)  doubles from data[dataDimension * spanIndex] as poles with weight inserted\r\n   * @param data packed array of data.\r\n   * @param dataDimension dimension of data. Must have `dataDimension+1=this.order`\r\n   * @param spanIndex index of first data block to access.\r\n   * @param weight weight to append to each block\r\n   */\r\n  public loadSpanPolesWithWeight(data: Float64Array, dataDimension: number, spanIndex: number, weight: number) {\r\n    let destIndex = 0;\r\n    const order = this._order;\r\n    let dataIndex = spanIndex * dataDimension;\r\n    for (let i = 0; i < order; i++) {\r\n      for (let j = 0; j < dataDimension; j++)\r\n        this._packedData[destIndex++] = data[dataIndex++];\r\n      this._packedData[destIndex++] = weight;\r\n    }\r\n  }\r\n  /**  return a json array of arrays with each control point as a lower level array of numbers */\r\n  public unpackToJsonArrays(): any[] {\r\n    return Point3dArray.unpackNumbersToNestedArrays(this._packedData, this._blockSize);\r\n  }\r\n  /** equality test with usual metric tolerances */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof Bezier1dNd) {\r\n      if (this._blockSize !== other._blockSize)\r\n        return false;\r\n      if (this._order !== other._order)\r\n        return false;\r\n      if (this._packedData.length !== other._packedData.length)\r\n        return false;\r\n      for (let i = 0; i < this._packedData.length; i++) {\r\n        if (!Geometry.isSameCoordinate(this._packedData[i], other._packedData[i]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** block-by-block reversal */\r\n  public reverseInPlace() {\r\n    const m = this._blockSize;\r\n    const n = this._order;\r\n    let i, j;\r\n    let a;\r\n    for (i = 0, j = (n - 1) * m; i < j; i += m, j -= m) {\r\n      for (let k = 0; k < m; k++) {\r\n        a = this._packedData[i + k];\r\n        this._packedData[i + k] = this._packedData[j + k];\r\n        this._packedData[j + k] = a;\r\n      }\r\n    }\r\n  }\r\n  //\r\n  /**\r\n   * interpolate at `fraction` between poleA and poleB.\r\n   * * Data is left \"in place\" in poleIndexA\r\n   * @param poleIndexA first pole index\r\n   * @param fraction fractional position\r\n   * @param poleIndexB second pole index\r\n   */\r\n  public interpolatePoleInPlace(poleIndexA: number, fraction: number, poleIndexB: number) {\r\n    let i0 = poleIndexA * this._blockSize;\r\n    let i1 = poleIndexB * this._blockSize;\r\n    const data = this._packedData;\r\n    for (let i = 0; i < this._blockSize; i++ , i0++ , i1++) {\r\n      data[i0] += fraction * (data[i1] - data[i0]);\r\n    }\r\n  }\r\n  private static _knotTolerance = 1.0e-8;\r\n  /**\r\n   * Compute new control points to \"clamp\" bspline unsaturated support to saturated form.\r\n   * * At input time, the control points are associated with the input knots (unsaturated)\r\n   * * At output, they control points are modified by repeated knot insertion to be fully clamped.\r\n   * @param knots knot values for the current (unsaturated) pole set\r\n   * @param spanIndex index of span whose (unsaturated) poles are in the bezier.\r\n   * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.\r\n   */\r\n  public saturateInPlace(knots: KnotVector, spanIndex: number): boolean {\r\n    const degree = knots.degree;\r\n    const kA = spanIndex + degree - 1; // left knot index of the active span\r\n    const kB = kA + 1;\r\n    if (spanIndex < 0 || spanIndex >= knots.numSpans)\r\n      return false;\r\n    const knotArray = knots.knots;\r\n    const knotA = knotArray[kA];\r\n    const knotB = knotArray[kB];\r\n    this.setInterval(knotA, knotB);\r\n    if (knotB <= knotA + Bezier1dNd._knotTolerance)\r\n      return false;\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      //  left numInsert poles are pulled forward\r\n      let k0 = kA - numInsert;\r\n      if (knotArray[k0] < knotA) {\r\n        let k1 = kB;\r\n        for (let i = 0; i < numInsert; i++ , k0++ , k1++) {\r\n          const knot0 = knotArray[k0];\r\n          const knot1 = knotArray[k1];\r\n          const fraction = (knotA - knot0) / (knot1 - knot0);\r\n          this.interpolatePoleInPlace(i, fraction, i + 1);\r\n        }\r\n      }\r\n    }\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      let k2 = kB + numInsert;\r\n      if (knotArray[k2] > knotB) {\r\n        for (let i = 0; i < numInsert; i++ , k2--) {\r\n          const knot2 = knotArray[k2]; // right side of moving window\r\n          // left side of window ia always the (previously saturated) knotA\r\n          const fraction = (knotB - knot2) / (knotA - knot2);\r\n          this.interpolatePoleInPlace(degree - i, fraction, degree - i - 1);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Saturate a univariate bspline coefficient array in place\r\n   * * On input, the array is the coefficients one span of a bspline, packed in an array of `(knots.order)` values.\r\n   * * These are modified in place, and on return are a bezier for the same knot interval.\r\n   * @param coffs input as bspline coefficients, returned as bezier coefficients\r\n   * @param knots knot vector\r\n   * @param spanIndex index of span whose (unsaturated) poles are in the coefficients.\r\n   * @param optional function for `setInterval (knotA, knotB)` call to announce knot limits.\r\n   */\r\n  public static saturate1dInPlace(coffs: Float64Array, knots: KnotVector, spanIndex: number): boolean {\r\n    const degree = knots.degree;\r\n    const kA = spanIndex + degree - 1; // left knot index of the active span\r\n    const kB = kA + 1;\r\n    if (spanIndex < 0 || spanIndex >= knots.numSpans)\r\n      return false;\r\n    const knotArray = knots.knots;\r\n    const knotA = knotArray[kA];\r\n    const knotB = knotArray[kB];\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      //  left numInsert poles are pulled forward\r\n      let k0 = kA - numInsert;\r\n      if (knotArray[k0] < knotA) {\r\n        let k1 = kB;\r\n        for (let i = 0; i < numInsert; i++ , k0++ , k1++) {\r\n          const knot0 = knotArray[k0];\r\n          const knot1 = knotArray[k1];\r\n          const fraction = (knotA - knot0) / (knot1 - knot0);\r\n          coffs[i] = coffs[i] + fraction * (coffs[i + 1] - coffs[i]);\r\n        }\r\n      }\r\n    }\r\n    for (let numInsert = degree - 1; numInsert > 0; numInsert--) {\r\n      let k2 = kB + numInsert;\r\n      let k;\r\n      if (knotArray[k2] > knotB) {\r\n        for (let i = 0; i < numInsert; i++ , k2--) {\r\n          const knot2 = knotArray[k2]; // right side of moving window\r\n          // left side of window ia always the (previously saturated) knotA\r\n          const fraction = (knotB - knot2) / (knotA - knot2);\r\n          k = degree - i;\r\n          coffs[k] += fraction * (coffs[k - 1] - coffs[k]);\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original\r\n   * @param fraction \"end\" fraction for split.\r\n   * @returns false if fraction is 0 -- no changes applied.\r\n   */\r\n  public subdivideInPlaceKeepLeft(fraction: number): boolean {\r\n    if (Geometry.isAlmostEqualNumber(fraction, 1.0))\r\n      return true;\r\n    if (Geometry.isAlmostEqualNumber(fraction, 0.0))\r\n      return false;\r\n    const g = 1.0 - fraction;   // interpolations will pull towards right indices\r\n    const order = this.order;\r\n    for (let level = 1; level < order; level++) {\r\n      for (let i1 = order - 1; i1 >= level; i1--) {\r\n        this.interpolatePoleInPlace(i1, g, i1 - 1); // leave updates to right\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Apply deCasteljou interpolations to isolate a smaller bezier polygon, representing interval 0..fraction of the original\r\n   * @param fraction \"end\" fraction for split.\r\n   * @returns false if fraction is 0 -- no changes applied.\r\n   */\r\n  public subdivideInPlaceKeepRight(fraction: number): boolean {\r\n    if (Geometry.isAlmostEqualNumber(fraction, 0.0))\r\n      return true;\r\n    if (Geometry.isAlmostEqualNumber(fraction, 1.0))\r\n      return false;\r\n    const order = this.order;\r\n    for (let level = 1; level < order; level++) {\r\n      for (let i0 = 0; i0 + level < order; i0++)\r\n        this.interpolatePoleInPlace(i0, fraction, i0 + 1);   // leave updates to left.\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Saturate a univariate bspline coefficient array in place\r\n   * @param fraction0 fraction for first split.   This is the start of the output polygon\r\n   * @param fraction1 fraction for first split.   This is the start of the output polygon\r\n   * @return false if fractions are (almost) identical.\r\n   */\r\n  public subdivideToIntervalInPlace(fraction0: number, fraction1: number): boolean {\r\n    if (Geometry.isAlmostEqualNumber(fraction0, fraction1))\r\n      return false;\r\n    if (fraction1 < fraction0) {\r\n      this.subdivideToIntervalInPlace(fraction0, fraction1);\r\n      this.reverseInPlace();\r\n      return true;\r\n    }\r\n    this.subdivideInPlaceKeepLeft(fraction1);\r\n    this.subdivideInPlaceKeepRight(fraction0 / fraction1);\r\n    return true;\r\n  }\r\n\r\n  /** optional interval for mapping to a parent object */\r\n  public interval?: Segment1d;\r\n  /** create or update the mapping to parent curve. */\r\n  public setInterval(a: number, b: number) {\r\n    this.interval = Segment1d.create(a, b, this.interval);\r\n  }\r\n  /** map a fraction to the parent space. */\r\n  public fractionToParentFraction(fraction: number): number { return this.interval ? this.interval.fractionToPoint(fraction) : fraction; }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { BezierPolynomialAlgebra } from \"../numerics/BezierPolynomials\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\n// ================================================================================================================\r\n// ================================================================================================================\r\n// ================================================================================================================\r\n// ================================================================================================================\r\n/** 3d Bezier curve class.\r\n * * Use BezierCurve3dH if the curve has weights.\r\n * * The control points (xyz) are managed as the _packedData buffer in the _polygon member of BezierCurveBase.\r\n * @public\r\n */\r\nexport class BezierCurve3d extends BezierCurveBase {\r\n  /** test if `other` is also a BezierCurve3d. */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BezierCurve3d; }\r\n  /** apply the transform to the control points. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    const data = this._workData0;\r\n    for (let i = 0; i < this._polygon.order; i++) {\r\n      this._polygon.getPolygonPoint(i, data);\r\n      transform.multiplyXYZToFloat64Array(data[0], data[1], data[2], data);\r\n      this._polygon.setPolygonPoint(i, data);\r\n    }\r\n    return true;\r\n  }\r\n  private _workRay0: Ray3d;\r\n  private _workRay1: Ray3d;\r\n  /** Return a specific pole as a full `[x,y,z] Point3d` */\r\n  public getPolePoint3d(i: number, result?: Point3d): Point3d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point3d.create(data[0], data[1], data[2], result);\r\n    return undefined;\r\n  }\r\n  /** Return a specific pole as a full `[w*x,w*y,w*z, w] Point4d` */\r\n  public getPolePoint4d(i: number, result?: Point4d): Point4d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point4d.create(data[0], data[1], data[2], 1.0, result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Capture a polygon as the data for a new `BezierCurve3d`\r\n   * @param polygon complete packed data and order.\r\n   */\r\n  private constructor(polygon: Float64Array) {\r\n    super(3, polygon);\r\n    this._workRay0 = Ray3d.createXAxis();\r\n    this._workRay1 = Ray3d.createXAxis();\r\n  }\r\n  /** Return poles as a linestring */\r\n  public copyPointsAsLineString(): LineString3d {\r\n    const result = LineString3d.create();\r\n    for (let i = 0; i < this._polygon.order; i++)\r\n      result.addPoint(this.getPolePoint3d(i)!);\r\n    return result;\r\n  }\r\n  /** Create a curve with given points.\r\n   * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`\r\n   * * If input is `Point3d[]`, the points are promoted with w=1`\r\n   *\r\n   */\r\n  public static create(data: Point3d[] | Point2d[]): BezierCurve3d | undefined {\r\n    if (data.length < 1)\r\n      return undefined;\r\n    const polygon = new Float64Array(data.length * 3);\r\n    if (data[0] instanceof Point3d) {\r\n      let i = 0;\r\n      for (const p of (data as Point3d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n      }\r\n      return new BezierCurve3d(polygon);\r\n    } else if (data[0] instanceof Point2d) {\r\n      let i = 0;\r\n      for (const p of (data as Point2d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = 0.0;\r\n      }\r\n      return new BezierCurve3d(polygon);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** create a bezier curve of specified order, filled with zeros */\r\n  public static createOrder(order: number): BezierCurve3d {\r\n    const polygonArray = new Float64Array(order * 3); // This is initialized to zeros!!\r\n    return new BezierCurve3d(polygonArray);\r\n  }\r\n  /** Load order * 3 doubles from data[3 * spanIndex] as poles */\r\n  public loadSpanPoles(data: Float64Array, spanIndex: number) {\r\n    this._polygon.loadSpanPoles(data, spanIndex);\r\n  }\r\n  /** Clone as a bezier 3d. */\r\n  public clone(): BezierCurve3d {\r\n    return new BezierCurve3d(this._polygon.clonePolygon());\r\n  }\r\n  /** Clone the interval from f0 to f1. */\r\n  public clonePartialCurve(f0: number, f1: number): BezierCurve3d | undefined {\r\n    const partialCurve = new BezierCurve3d(this._polygon.clonePolygon());\r\n    partialCurve._polygon.subdivideToIntervalInPlace(f0, f1);\r\n    return partialCurve;\r\n  }\r\n\r\n  /**\r\n   * Return a curve after transform.\r\n   */\r\n  public cloneTransformed(transform: Transform): BezierCurve3d {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    return Point3d.create(this._workData0[0], this._workData0[1], this._workData0[2], result);\r\n  }\r\n  /** Return the cartesian point and derivative vector. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    this._polygon.evaluateDerivative(fraction, this._workData1);\r\n    return Ray3d.createXYZUVW(this._workData0[0], this._workData0[1], this._workData0[2], this._workData1[0], this._workData1[1], this._workData1[2], result);\r\n  }\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const epsilon = 1.0e-8;\r\n    const a = 1.0 / (2.0 * epsilon);\r\n    if (!result)\r\n      result = Plane3dByOriginAndVectors.createXYPlane();\r\n    const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);\r\n    result.origin.setFrom(ray.origin);\r\n    result.vectorU.setFrom(ray.direction);\r\n    const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);\r\n    const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);\r\n    Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);\r\n    return result;\r\n  }\r\n  /** Near-equality test on poles. */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BezierCurve3d) {\r\n      return this._polygon.isAlmostEqual(other._polygon);\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const data = this._polygon.packedData;\r\n    let dx0 = data[3] - data[0];\r\n    let dy0 = data[4] - data[1];\r\n    let dz0 = data[5] - data[2];\r\n    let dx1, dy1, dz1; // first differences of leading edge\r\n    // let ex, ey, ez; // second differences.\r\n    let sweepRadians = 0.0;\r\n    let sumLength = Geometry.hypotenuseXYZ(dx0, dy0, dz0);\r\n    const n = data.length;\r\n    for (let i = 6; i + 2 < n; i += 3) {\r\n      dx1 = data[i] - data[i - 3];\r\n      dy1 = data[i + 1] - data[i - 2];\r\n      dz1 = data[i + 2] - data[i - 1];\r\n      //        ex = dx1 - dx0; ey = dy1 - dy0; ez = dz1 - dz0;\r\n      sweepRadians += Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);\r\n      sumLength += Geometry.hypotenuseXYZ(dx1, dy1, dz1);\r\n      dx0 = dx1;\r\n      dy0 = dy1;\r\n      dz0 = dz1;\r\n    }\r\n    const numPerSpan = StrokeOptions.applyAngleTol(options, StrokeOptions.applyMaxEdgeLength(options, 1, sumLength), sweepRadians, 0.2);\r\n    return numPerSpan;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBezierCurve3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBezierCurve3d(this);\r\n  }\r\n  /** Extend `rangeToExtend`, using candidate extrema at\r\n   * * both end points\r\n   * * any internal extrema in x,y,z\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const order = this.order;\r\n    if (!transform) {\r\n      this.allocateAndZeroBezierWorkData(order - 1, 0, 0);\r\n      const bezier = this._workBezier!;\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        BezierPolynomialAlgebra.componentDifference(bezier.coffs, this._polygon.packedData, 3, order, axisIndex);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extend(this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      this.allocateAndZeroBezierWorkData(order - 1, order, 0);\r\n      const bezier = this._workBezier!;\r\n      const componentCoffs = this._workCoffsA!;   // to hold transformed copy of x,y,z in turn.\r\n\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n      const data = this._polygon.packedData;\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        // apply one row of the transform to get the transformed coff by itself\r\n        for (let i = 0, k = 0; i < order; i++ , k += 3)\r\n          componentCoffs[i] = transform.multiplyComponentXYZ(axisIndex, data[k], data[k + 1], data[k + 2]);\r\n        BezierPolynomialAlgebra.univariateDifference(componentCoffs, bezier.coffs);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots && roots.length > 0) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { CurveLocationDetail } from \"../curve/CurveLocationDetail\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { BezierPolynomialAlgebra } from \"../numerics/BezierPolynomials\";\r\nimport { BezierCurveBase } from \"./BezierCurveBase\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\n\r\n/** 3d curve with homogeneous weights.\r\n * * A control point with weight w and cartesian (projected) coordinates x,y,z has the weight multiplied into the coordinates,\r\n *    hence the control point as stored is (xw, yw, zw, w).\r\n * @public\r\n */\r\nexport class BezierCurve3dH extends BezierCurveBase {\r\n  /** test if `other` is also a BezierCurve3dH. */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof BezierCurve3dH; }\r\n  /**\r\n   * Apply (multiply by) an affine transform\r\n   * @param transform\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    const data = this._workData0;\r\n    for (let i = 0; i < this._polygon.order; i++) {\r\n      this._polygon.getPolygonPoint(i, data);\r\n      transform.multiplyXYZWToFloat64Array(data[0], data[1], data[2], data[3], data);\r\n      this._polygon.setPolygonPoint(i, data);\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Apply (multiply by) a perspective transform\r\n   * @param matrix\r\n   */\r\n  public tryMultiplyMatrix4dInPlace(matrix: Matrix4d) {\r\n    matrix.multiplyBlockedFloat64ArrayInPlace(this._polygon.packedData);\r\n  }\r\n  private _workRay0: Ray3d;\r\n  private _workRay1: Ray3d;\r\n  /** Return a specific pole as a full `[x,y,z,x] Point4d` */\r\n  public getPolePoint4d(i: number, result?: Point4d): Point4d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point4d.create(data[0], data[1], data[2], data[3], result);\r\n    return undefined;\r\n  }\r\n  /** Return a specific pole normalized to weight 1\r\n   */\r\n  public getPolePoint3d(i: number, result?: Point3d): Point3d | undefined {\r\n    const data = this._polygon.getPolygonPoint(i, this._workData0);\r\n    if (data)\r\n      return Point3d.createFromPackedXYZW(data, 0, result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Returns true if all weights are within tolerance of 1.0\r\n   */\r\n  public isUnitWeight(tolerance?: number): boolean {\r\n    if (tolerance === undefined)\r\n      tolerance = Geometry.smallAngleRadians;\r\n    const aLow = 1.0 - tolerance;\r\n    const aHigh = 1.0 + tolerance;\r\n    const data = this._polygon.packedData;\r\n    const n = data.length;\r\n    let a;\r\n    for (let i = 3; i < n; i += 4) {\r\n      a = data[i];\r\n      if (a < aLow || a > aHigh)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Capture a polygon as the data for a new `BezierCurve3dH`\r\n   * @param polygon complete packed data and order.\r\n   */\r\n  private constructor(polygon: Float64Array) {\r\n    super(4, polygon);\r\n    this._workRay0 = Ray3d.createXAxis();\r\n    this._workRay1 = Ray3d.createXAxis();\r\n  }\r\n  /** Create a curve with given points.\r\n   * * If input is `Point2d[]`, the points are promoted with `z=0` and `w=1`\r\n   * * If input is `Point3d[]`, the points are promoted with w=1`\r\n   *\r\n   */\r\n  public static create(data: Point3d[] | Point4d[] | Point2d[]): BezierCurve3dH | undefined {\r\n    if (data.length < 1)\r\n      return undefined;\r\n    const polygon = new Float64Array(data.length * 4);\r\n    if (data[0] instanceof Point3d) {\r\n      let i = 0;\r\n      for (const p of (data as Point3d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n        polygon[i++] = 1.0;\r\n      }\r\n      return new BezierCurve3dH(polygon);\r\n    } else if (data[0] instanceof Point4d) {\r\n      let i = 0;\r\n      for (const p of (data as Point4d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = p.z;\r\n        polygon[i++] = p.w;\r\n      }\r\n      return new BezierCurve3dH(polygon);\r\n    } else if (data[0] instanceof Point2d) {\r\n      let i = 0;\r\n      for (const p of (data as Point2d[])) {\r\n        polygon[i++] = p.x;\r\n        polygon[i++] = p.y;\r\n        polygon[i++] = 0.0;\r\n        polygon[i++] = 1.0;\r\n      }\r\n      return new BezierCurve3dH(polygon);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** create a bezier curve of specified order, filled with zeros */\r\n  public static createOrder(order: number): BezierCurve3dH {\r\n    const polygonArray = new Float64Array(order * 4); // and we trust that this is all zeros !!!\r\n    return new BezierCurve3dH(polygonArray);\r\n  }\r\n  /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */\r\n  public loadSpan3dPolesWithWeight(data: Float64Array, spanIndex: number, weight: number) {\r\n    this._polygon.loadSpanPolesWithWeight(data, 3, spanIndex, weight);\r\n  }\r\n  /** Load order * 4 doubles from data[3 * spanIndex] as poles (with added weight) */\r\n  public loadSpan4dPoles(data: Float64Array, spanIndex: number) {\r\n    this._polygon.loadSpanPoles(data, spanIndex);\r\n  }\r\n  /** Clone the entire curve. */\r\n  public clone(): BezierCurve3dH {\r\n    return new BezierCurve3dH(this._polygon.clonePolygon());\r\n  }\r\n  /**\r\n   * Return a curve after transform.\r\n   */\r\n  public cloneTransformed(transform: Transform): BezierCurve3dH {\r\n    const curve1 = this.clone();\r\n    curve1.tryTransformInPlace(transform);\r\n    return curve1;\r\n  }\r\n  /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    result = Point3d.createFromPackedXYZW(this._workData0, 0, result);\r\n    return result ? result : Point3d.createZero();\r\n  }\r\n  /** Return a (deweighted) point on the curve. If deweight fails, returns 000 */\r\n  public fractionToPoint4d(fraction: number, result?: Point4d): Point4d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    return Point4d.createFromPackedXYZW(this._workData0, 0, result);\r\n  }\r\n  /** Return the cartesian point and derivative vector. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    this._polygon.evaluate(fraction, this._workData0);\r\n    this._polygon.evaluateDerivative(fraction, this._workData1);\r\n    result = Ray3d.createWeightedDerivative(this._workData0, this._workData1, result);\r\n    if (result)\r\n      return result;\r\n    // Bad. Very Bad.  Return origin and x axis.   Should be undefined, but usual cartesian types do not allow that\r\n    return Ray3d.createXAxis();\r\n  }\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const epsilon = 1.0e-8;\r\n    const a = 1.0 / (2.0 * epsilon);\r\n    if (!result)\r\n      result = Plane3dByOriginAndVectors.createXYPlane();\r\n    const ray = this.fractionToPointAndDerivative(fraction, this._workRay0);\r\n    result.origin.setFrom(ray.origin);\r\n    result.vectorU.setFrom(ray.direction);\r\n    const ray0 = this.fractionToPointAndDerivative(fraction - epsilon, this._workRay0);\r\n    const ray1 = this.fractionToPointAndDerivative(fraction + epsilon, this._workRay1);\r\n    Vector3d.createAdd2Scaled(ray0.direction, -a, ray1.direction, a, result.vectorV);\r\n    return result;\r\n  }\r\n  /** test for nearly equal control points */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof BezierCurve3dH) {\r\n      return this._polygon.isAlmostEqual(other._polygon);\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Assess length and turn to determine a stroke count.\r\n   * @param options stroke options structure.\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    // ugh.   for pure 3d case, local dx,dy,dz vars worked efficiently.\r\n    // managing the weights is tricky, so just do the easy code with temporary point vars.\r\n    this.getPolePoint3d(0, this._workPoint0);\r\n    this.getPolePoint3d(1, this._workPoint1);\r\n    let numStrokes = 1;\r\n    if (this._workPoint0 && this._workPoint1) {\r\n      let dx0 = this._workPoint1.x - this._workPoint0.x;\r\n      let dy0 = this._workPoint1.y - this._workPoint0.y;\r\n      let dz0 = this._workPoint1.z - this._workPoint0.z;\r\n      let dx1, dy1, dz1; // first differences of leading edge\r\n      let sumRadians = 0.0;\r\n      let thisLength = Geometry.hypotenuseXYZ(dx0, dy0, dz0);\r\n      this._workPoint1.setFromPoint3d(this._workPoint0);\r\n      let sumLength = thisLength;\r\n      let maxLength = thisLength;\r\n      let maxRadians = 0.0;\r\n      let thisRadians;\r\n      for (let i = 2; this.getPolePoint3d(i, this._workPoint1); i++) {\r\n        dx1 = this._workPoint1.x - this._workPoint0.x;\r\n        dy1 = this._workPoint1.y - this._workPoint0.y;\r\n        dz1 = this._workPoint1.z - this._workPoint0.z;\r\n        thisRadians = Angle.radiansBetweenVectorsXYZ(dx0, dy0, dz0, dx1, dy1, dz1);\r\n        sumRadians += thisRadians;\r\n        maxRadians = Geometry.maxAbsXY(thisRadians, maxRadians);\r\n        thisLength = Geometry.hypotenuseXYZ(dx1, dy1, dz1);\r\n        sumLength += thisLength;\r\n        maxLength = Geometry.maxXY(maxLength, thisLength);\r\n        dx0 = dx1;\r\n        dy0 = dy1;\r\n        dz0 = dz1;\r\n        this._workPoint0.setFrom(this._workPoint1);\r\n      }\r\n      const length1 = maxLength * this.degree;    // This may be larger than sumLength\r\n      const length2 = Math.sqrt(length1 * sumLength);  // This is in between\r\n      let radians1 = maxRadians * (this.degree - 1);  // As if worst case keeps happening.\r\n      if (this.degree < 3)\r\n        radians1 *= 3;  // so quadratics aren't understroked\r\n      const radians2 = Math.sqrt(radians1 * sumRadians);\r\n      numStrokes = StrokeOptions.applyAngleTol(options,\r\n        StrokeOptions.applyMaxEdgeLength(options, this.degree, length2), radians2, 0.1);\r\n    }\r\n    return numStrokes;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBezierCurve3dH(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBezierCurve3dH(this);\r\n  }\r\n  /**\r\n   * Form dot products of each pole with given coefficients. Return as entries in products array.\r\n   * @param products array of (scalar) dot products\r\n   * @param ax x coefficient\r\n   * @param ay y coefficient\r\n   * @param az z coefficient\r\n   * @param aw w coefficient\r\n   */\r\n  public poleProductsXYZW(products: Float64Array, ax: number, ay: number, az: number, aw: number) {\r\n    const n = this.numPoles;\r\n    const data = this._polygon.packedData;\r\n    for (let i = 0, k = 0; i < n; i++ , k += 4)\r\n      products[i] = ax * data[k] + ay * data[k + 1] + az * data[k + 2] + aw * data[k + 3];\r\n  }\r\n  /** Find the closest point within the bezier span, using true perpendicular test (but no endpoint test)\r\n   * * If closer than previously recorded, update the CurveLocationDetail\r\n   * * This assumes this bezier is saturated.\r\n   * @param spacePoint point being projected\r\n   * @param detail pre-allocated detail to record (evolving) closest point.\r\n   * @returns true if an updated occurred, false if either (a) no perpendicular projections or (b) perpendiculars were not closer.\r\n   */\r\n  public updateClosestPointByTruePerpendicular(spacePoint: Point3d, detail: CurveLocationDetail): boolean {\r\n    let numUpdates = 0;\r\n    let roots: number[] | undefined;\r\n    if (this.isUnitWeight()) {\r\n      // unweighted !!!\r\n      const productOrder = 2 * this.order - 2;\r\n      this.allocateAndZeroBezierWorkData(productOrder, 0, 0);\r\n      const bezier = this._workBezier!;\r\n      // closestPoint condition is:\r\n      //   (spacePoint - curvePoint) DOT curveTangent = 0;\r\n      // Each product (x,y,z) of the DOT is the product of two bezier polynomials\r\n      BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 0, -spacePoint.x, 0);\r\n      BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 1, -spacePoint.y, 1);\r\n      BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(bezier.coffs, this._polygon.packedData, 4, this.order, 1.0, 2, -spacePoint.z, 2);\r\n      roots = bezier.roots(0.0, true);\r\n    } else {\r\n      // This bezier has weights.\r\n      // The pure cartesian closest point condition is\r\n      //   (spacePoint - X/w) DOT (X' w - w' X)/ w^2 = 0\r\n      // ignoring denominator and using bezier coefficient differences for the derivative, making the numerator 0 is\r\n      //   (w * spacePoint - X) DOT ( DELTA X * w - DELTA w * X) = 0\r\n      const orderA = this.order;\r\n      const orderB = 2 * this.order - 2; // products of component and component difference.\r\n      const productOrder = orderA + orderB - 1;\r\n      this.allocateAndZeroBezierWorkData(productOrder, orderA, orderB);\r\n      const bezier = this._workBezier!;\r\n      const workA = this._workCoffsA!;\r\n      const workB = this._workCoffsB!;\r\n      const packedData = this._polygon.packedData;\r\n      for (let i = 0; i < 3; i++) {\r\n        // x representing loop pass:   (w * spacePoint.x - curve.x(s), 1.0) * (curveDelta.x(s) * curve.w(s) - curve.x(s) * curveDelta.w(s))\r\n        // (and p.w is always 1)\r\n        BezierPolynomialAlgebra.scaledComponentSum(workA, packedData, 4, orderA, 3, spacePoint.at(i), // w * spacePoint.x\r\n          i, -1.0); // curve.x(s) * 1.0\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, 1.0, 3, 1.0, i);\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(workB, packedData, 4, orderA, -1.0, i, 1.0, 3);\r\n        BezierPolynomialAlgebra.accumulateProduct(bezier.coffs, workA, workB);\r\n      }\r\n      roots = bezier.roots(0.0, true);\r\n    }\r\n    if (roots) {\r\n      for (const fraction of roots) {\r\n        const xyz = this.fractionToPoint(fraction);\r\n        const a = xyz.distance(spacePoint);\r\n        numUpdates += detail.updateIfCloserCurveFractionPointDistance(this, fraction, xyz, a) ? 1 : 0;\r\n      }\r\n    }\r\n    return numUpdates > 0;\r\n  }\r\n  /** Extend `rangeToExtend`, using candidate extrema at\r\n   * * both end points\r\n   * * any internal extrema in x,y,z\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const order = this.order;\r\n    if (!transform) {\r\n      this.allocateAndZeroBezierWorkData(order * 2 - 2, 0, 0);\r\n      const bezier = this._workBezier!;\r\n      const data = this._polygon.packedData;\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extend(this._workPoint0);\r\n      // Example:\r\n      // For x component ...\r\n      //     coefficients of (weighted x) are at axisIndex=0\r\n      //     deweighted polynomial is (x(s)/w(s))\r\n      //    its derivative (to be zeroed) is\r\n      //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)\r\n      // The coefficients of the derivatives are (degree times) differences of successive coffs.\r\n      // Make the numerator zero to get extrema\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        bezier.zero();\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(\r\n          bezier.coffs,\r\n          data, 4, order,\r\n          1.0,\r\n          axisIndex, 0.0,\r\n          3);\r\n        BezierPolynomialAlgebra.accumulateScaledShiftedComponentTimesComponentDelta(\r\n          bezier.coffs,\r\n          data, 4, order,\r\n          -1.0,\r\n          3, 0.0,\r\n          axisIndex);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extend(this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n    } else {\r\n      this.allocateAndZeroBezierWorkData(order * 2 - 2, order, order);\r\n      const componentCoffs = this._workCoffsA!;   // to hold transformed copy of x,y,z in turn.\r\n      const weightCoffs = this._workCoffsB!;    // to hold weights\r\n      const bezier = this._workBezier!;\r\n\r\n      this.getPolePoint3d(0, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n      this.getPolePoint3d(order - 1, this._workPoint0);\r\n      rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n\r\n      const data = this._polygon.packedData;      // Example:\r\n      // For x component ...\r\n      //     coefficients of (weighted x) are at axisIndex=0\r\n      //     deweighted polynomial is (x(s)/w(s))\r\n      //    its derivative (to be zeroed) is\r\n      //              (x'(s)*w(s) -x(s) * w'(s)) / w^2(s)\r\n      // The coefficients of the derivatives are (degree times) differences of successive coffs.\r\n      // Make the numerator zero to get extrema\r\n      // apply one row of the transform to get the transformed coff by itself\r\n      let weight;\r\n      for (let axisIndex = 0; axisIndex < 3; axisIndex++) {\r\n        bezier.zero();\r\n        for (let i = 0, k = 0; i < order; i++ , k += 4) {\r\n          weight = data[k + 3];\r\n          componentCoffs[i] = transform.multiplyComponentXYZW(axisIndex, data[k], data[k + 1], data[k + 2], weight);\r\n          weightCoffs[i] = weight;\r\n        }\r\n        BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, componentCoffs, weightCoffs, 1.0);\r\n        BezierPolynomialAlgebra.accumulateProductWithDifferences(bezier.coffs, weightCoffs, componentCoffs, -1.0);\r\n        const roots = bezier.roots(0.0, true);\r\n        if (roots && roots.length > 0) {\r\n          for (const r of roots) {\r\n            this.fractionToPoint(r, this._workPoint0);\r\n            rangeToExtend.extendTransformedPoint(transform, this._workPoint0);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { KnotVector } from \"./KnotVector\";\r\nimport { Bezier1dNd } from \"./Bezier1dNd\";\r\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\n/**\r\n * Base class for CurvePrimitive (necessarily 3D) with _polygon.\r\n * * This has a Bezier1dNd polygon as a member, and implements dimension-independent methods\r\n * * This exists to support\r\n *    * BezierCurve3d -- 3 coordinates x,y,z per block in the Bezier1dNd poles\r\n *    * BezierCurve3dH -- 4 coordinates x,y,z,w per block in the Bezier1dNd poles\r\n * * The implementations of \"pure 3d\" queries is based on calling `getPolePoint3d`.\r\n * * This has the subtle failure difference that `getPolePoint3d` call with a valid index on on a 3d curve always succeeds, but on 3dH curve fails when weight is zero.\r\n * @public\r\n */\r\nexport abstract class BezierCurveBase extends CurvePrimitive {\r\n  /** Control points */\r\n  protected _polygon: Bezier1dNd;\r\n  /** scratch data blocks accessible by concrete class.   Initialized to correct blockSize in constructor. */\r\n  protected _workData0: Float64Array;\r\n  /** scratch data blocks accessible by concrete class.   Initialized to correct blockSize in constructor. */\r\n  protected _workData1: Float64Array;\r\n  /** Scratch xyz point accessible by derived classes. */\r\n  protected _workPoint0: Point3d;\r\n  /** Scratch xyz point accessible by derived classes. */\r\n  protected _workPoint1: Point3d;\r\n\r\n  protected constructor(blockSize: number, data: Float64Array) {\r\n    super();\r\n    this._polygon = new Bezier1dNd(blockSize, data);\r\n    this._workPoint0 = Point3d.create();\r\n    this._workPoint1 = Point3d.create();\r\n    this._workData0 = new Float64Array(blockSize);\r\n    this._workData1 = new Float64Array(blockSize);\r\n\r\n  }\r\n  /** reverse the poles in place */\r\n  public reverseInPlace(): void { this._polygon.reverseInPlace(); }\r\n  /** saturate the pole in place, using knot intervals from `spanIndex` of the `knotVector` */\r\n  public saturateInPlace(knotVector: KnotVector, spanIndex: number): boolean {\r\n    const boolstat = this._polygon.saturateInPlace(knotVector, spanIndex);\r\n    if (boolstat) {\r\n      this.setInterval(\r\n        knotVector.spanFractionToFraction(spanIndex, 0.0),\r\n        knotVector.spanFractionToFraction(spanIndex, 1.0));\r\n    }\r\n    return boolstat;\r\n  }\r\n  /** (property accessor) Return the polynomial degree (one less than order) */\r\n  public get degree(): number {\r\n    return this._polygon.order - 1;\r\n  }\r\n  /** (property accessor) Return the polynomial order */\r\n  public get order(): number { return this._polygon.order; }\r\n  /** (property accessor) Return the number of poles (aka control points) */\r\n  public get numPoles(): number { return this._polygon.order; }\r\n  /** Get pole `i` as a Point3d.\r\n   * * For 3d curve, this is simple a pole access, and only fails (return `undefined`) for invalid index\r\n   * * For 4d curve, this deweights the homogeneous pole and can fail due to 0 weight.\r\n   */\r\n  public abstract getPolePoint3d(i: number, point?: Point3d): Point3d | undefined;\r\n\r\n  /** Get pole `i` as a Point4d.\r\n   * * For 3d curve, this accesses the simple pole and returns with weight 1.\r\n   * * For 4d curve, this accesses the (weighted) pole.\r\n   */\r\n  public abstract getPolePoint4d(i: number, point?: Point4d): Point4d | undefined;\r\n  /** Set mapping to parent curve (e.g. if this bezier is a span extracted from a bspline, this is the knot interval of the span) */\r\n  public setInterval(a: number, b: number) { this._polygon.setInterval(a, b); }\r\n  /** map `fraction` from this Bezier curves inherent 0..1 range to the (a,b) range of parent\r\n   * * ( The parent range should have been previously defined with `setInterval`)\r\n   */\r\n  public fractionToParentFraction(fraction: number): number { return this._polygon.fractionToParentFraction(fraction); }\r\n  /** Return a stroke count appropriate for given stroke options. */\r\n  public abstract computeStrokeCountForOptions(options?: StrokeOptions): number;\r\n\r\n  /** append stroke points to a linestring, based on `strokeCount` and `fractionToPoint` from derived class*/\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const numPerSpan = this.computeStrokeCountForOptions(options);\r\n    const fractionStep = 1.0 / numPerSpan;\r\n    for (let i = 0; i <= numPerSpan; i++) {\r\n      const fraction = i * fractionStep;\r\n      this.fractionToPoint(fraction, this._workPoint0);\r\n      dest.appendStrokePoint(this._workPoint0);\r\n    }\r\n  }\r\n  /** announce intervals with stroke counts */\r\n  public emitStrokableParts(handler: IStrokeHandler, _options?: StrokeOptions): void {\r\n    const numPerSpan = this.computeStrokeCountForOptions(_options);\r\n    handler.announceIntervalForUniformStepStrokes(this, numPerSpan, 0.0, 1.0);\r\n  }\r\n  /** Return a simple array of arrays with the control points as `[[x,y,z],[x,y,z],..]` */\r\n  public copyPolesAsJsonArray(): any[] { return this._polygon.unpackToJsonArrays(); }\r\n\r\n  /** return true if all poles are on a plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    let point: Point3d | undefined = this._workPoint0;\r\n    for (let i = 0; ; i++) {\r\n      point = this.getPolePoint3d(i, point);\r\n      if (!point)\r\n        return true;\r\n      if (!plane.isPointInPlane(point))\r\n        break;    // which gets to return false, which is otherwise unreachable . . .\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the length of the control polygon. */\r\n  public polygonLength(): number {\r\n    if (!this.getPolePoint3d(0, this._workPoint0))\r\n      return 0.0;\r\n    let i = 0;\r\n    let sum = 0.0;\r\n    while (this.getPolePoint3d(++i, this._workPoint1)) {\r\n      sum += this._workPoint0.distance(this._workPoint1);\r\n      this._workPoint0.setFrom(this._workPoint1);\r\n    }\r\n    return sum;\r\n  }\r\n  /** Return the start point.  (first control point) */\r\n  public startPoint(): Point3d {\r\n    const result = this.getPolePoint3d(0)!;   // ASSUME non-trivial pole set -- if null comes back, it bubbles out\r\n    return result;\r\n  }\r\n  /** Return the end point.  (last control point) */\r\n  public endPoint(): Point3d {\r\n    const result = this.getPolePoint3d(this.order - 1)!;    // ASSUME non-trivial pole set\r\n    return result;\r\n  }\r\n  /** Return the control polygon length as a quick length estimate. */\r\n  public quickLength(): number { return this.polygonLength(); }\r\n  /** Concrete classes must implement extendRange . . .  */\r\n  public abstract extendRange(rangeToExtend: Range3d, transform?: Transform): void;\r\n  /**\r\n   * 1D bezier coefficients for use in range computations.\r\n   * @internal\r\n   */\r\n  protected _workBezier?: UnivariateBezier; // available for bezier logic within a method\r\n  /** scratch array for use by derived classes, using allocateAndZeroBezierWorkData for sizing. */\r\n  protected _workCoffsA?: Float64Array;\r\n  /** scratch array for use by derived classes, using allocateAndZeroBezierWorkData for sizing. */\r\n  protected _workCoffsB?: Float64Array;\r\n\r\n  /**\r\n   * set up the _workBezier members with specific order.\r\n   * * Try to reuse existing members if their sizes match.\r\n   * * Ignore members corresponding to args that are 0 or negative.\r\n   * @param primaryBezierOrder order of expected bezier\r\n   * @param orderA length of _workCoffsA (simple array)\r\n   * @param orderB length of _workdCoffsB (simple array)\r\n   */\r\n  protected allocateAndZeroBezierWorkData(primaryBezierOrder: number, orderA: number, orderB: number) {\r\n    if (primaryBezierOrder > 0) {\r\n      if (this._workBezier !== undefined && this._workBezier.order === primaryBezierOrder) {\r\n        this._workBezier.zero();\r\n      } else\r\n        this._workBezier = new UnivariateBezier(primaryBezierOrder);\r\n    }\r\n    if (orderA > 0) {\r\n      if (this._workCoffsA !== undefined && this._workCoffsA.length === orderA)\r\n        this._workCoffsA.fill(0);\r\n      else\r\n        this._workCoffsA = new Float64Array(orderA);\r\n    }\r\n    if (orderB > 0) {\r\n      if (this._workCoffsB !== undefined && this._workCoffsB.length === orderB)\r\n        this._workCoffsB.fill(0);\r\n      else\r\n        this._workCoffsB = new Float64Array(orderB);\r\n    }\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Bspline */\r\n\r\n// import { Point2d } from \"../Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\nimport { Geometry } from \"../Geometry\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\n/**\r\n * Enumeration of the possible ways of converting a \"periodic\" knot vector to an open knot vector.\r\n * None (0) ==> no wrap possible\r\n * OpenByAddintControlPoints (1)  ==> wrapped by adding poles\r\n * OpenByRemovingKnots (2)  ==> wrapped by deleting extreme knots.\r\n * @public\r\n */\r\nexport enum BSplineWrapMode {\r\n  /** No conversion to periodic */\r\n  None = 0,\r\n  /** Convert to periodic by removing control points.  This is typical for closed bcurve constructed by control points with maximum continuity.\r\n   * * Knots stay the same in open and periodic form.\r\n   * * Periodic form omits {degree} control points.\r\n   */\r\n  OpenByAddingControlPoints = 1,\r\n  /** Convert to periodic by adding special knots.  This is typical of closed bcurve constructed as exact circular or elliptic arc\r\n   * * 2 knots on each end are omitted in open form\r\n   * * poles stay the same.\r\n   */\r\n  OpenByRemovingKnots = 2,\r\n}\r\n/**\r\n * Array of non-decreasing numbers acting as a knot array for bsplines.\r\n *\r\n * * Essential identity: numKnots = numPoles + order = numPoles + degree - 1\r\n * * Various bspline libraries have confusion over how many \"end knots\" are needed. \"Many\" libraries (including MicroStation)\r\n *     incorrectly demand \"order\" knots at each end for clamping.   But only \"order - 1\" are really needed.\r\n * * This class uses the \"order-1\" convention.\r\n * * This class provides queries to convert among spanIndex and knotIndex\r\n * * A span is a single interval of the knots.\r\n * * The left knot of span {k} is knot {k+degree-1}\r\n * * This class provides queries to convert among spanFraction, fraction of knot range, and knot\r\n * * core computations (evaluateBasisFunctions) have leftKnotIndex and global knot value as inputs.  Caller's need to\r\n * know their primary values (global knot, spanFraction).\r\n * @public\r\n */\r\nexport class KnotVector {\r\n  /** The simple array of knot values. */\r\n  public knots: Float64Array;\r\n  /** Return the degree of basis functions defined in these knots. */\r\n  public degree: number;\r\n  private _knot0: number;\r\n  private _knot1: number;\r\n\r\n  private _wrapMode?: BSplineWrapMode;\r\n  /** tolerance for considering two knots to be the same. */\r\n  public static readonly knotTolerance = 1.0e-9;\r\n  /** Return the leftmost knot value (of the active interval, ignoring unclamped leading knots)*/\r\n  public get leftKnot() { return this._knot0; }\r\n  /** Return the rightmost knot value (of the active interval, ignoring unclamped leading knots)*/\r\n  public get rightKnot() { return this._knot1; }\r\n  /** Return the index of the leftmost knot of the active interval */\r\n  public get leftKnotIndex() { return this.degree - 1; }\r\n  /** Return the index of the rightmost knot of the active interval */\r\n  public get rightKnotIndex() { return this.knots.length - this.degree; }\r\n  /**\r\n   * Return true if the bspline was created by adding poles in to \"closed\" structure\r\n   */\r\n  public get wrappable() { return this._wrapMode === undefined ? BSplineWrapMode.None : this._wrapMode; }\r\n  /** Set the wrappable flag.  This is used by serialize/deserialize to mark knotVector's that were converted from periodic style. */\r\n  public set wrappable(value: BSplineWrapMode) { this._wrapMode = value; }\r\n  /** Return the number of bezier spans.  Not that this includes zero-length spans if there are repeated knots. */\r\n  public get numSpans() { return this.rightKnotIndex - this.leftKnotIndex; }\r\n  /**\r\n   *\r\n   * * If knots is a number array or Float64Array, the those values become the local knot array.\r\n   * * If knots is a simple number, the local knot array is allocated to that size but left as zeros.\r\n   * @param knots\r\n   * @param degree\r\n   */\r\n  private constructor(knots: number[] | Float64Array | number, degree: number) {\r\n    this.degree = degree;\r\n    // default values to satisfy compiler -- real values hapn setupFixedValues or final else defers to user\r\n    this._knot0 = 0.0;\r\n    this._knot1 = 1.0;\r\n    // satisfy the initialize checker ..\r\n    if (Array.isArray(knots)) { // remark:  This ctor is private.  The callers (as of April 2019) do not use this path.\r\n      this.knots = new Float64Array(knots.length);\r\n      this.setKnots(knots);\r\n      this.setupFixedValues();\r\n    } else if (knots instanceof Float64Array) {\r\n      this.knots = knots.slice();\r\n      this.setupFixedValues();\r\n    } else { // caller is responsible for filling array separately ...\r\n      this.knots = new Float64Array(knots);\r\n    }\r\n  }\r\n  /** copy degree and knots to a new KnotVector. */\r\n  public clone(): KnotVector { return new KnotVector(this.knots, this.degree); }\r\n  private setupFixedValues() {\r\n    // These should be read-only . ..\r\n    this._knot0 = this.knots[this.degree - 1];\r\n    this._knot1 = this.knots[this.knots.length - this.degree];\r\n  }\r\n  /** Return the total knot distance from beginning to end. */\r\n  public get knotLength01(): number { return this._knot1 - this._knot0; }\r\n  /**\r\n   * Returns true if all numeric values have wraparound conditions for \"closed\" knotVector with specified wrap mode\r\n   * @param mode optional test mode.  If undefined, use the this.wrappable.\r\n   */\r\n  public testClosable(mode?: BSplineWrapMode): boolean {\r\n    if (mode === undefined)\r\n      mode = this.wrappable;\r\n    const leftKnotIndex = this.leftKnotIndex;\r\n    const rightKnotIndex = this.rightKnotIndex;\r\n    const period = this.rightKnot - this.leftKnot;\r\n    const degree = this.degree;\r\n    const indexDelta = rightKnotIndex - leftKnotIndex;\r\n    // maximum continuity mode .  . .\r\n    if (mode === BSplineWrapMode.OpenByAddingControlPoints) {\r\n      for (let k0 = leftKnotIndex - degree + 1; k0 < leftKnotIndex + degree - 1; k0++) {\r\n        const k1 = k0 + indexDelta;\r\n        if (!Geometry.isSameCoordinate(this.knots[k0] + period, this.knots[k1]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    // arc mode ...\r\n    if (mode === BSplineWrapMode.OpenByRemovingKnots) {\r\n      // we expect {degree} replicated knots at each end . . .\r\n      const numRepeated = degree - 1;\r\n      const leftKnot = this.knots[leftKnotIndex];\r\n      const rightKnot = this.knots[rightKnotIndex];\r\n      for (let i = 0; i < numRepeated; i++) {\r\n        if (!Geometry.isSameCoordinate(leftKnot, this.knots[leftKnotIndex - i - 1]))\r\n          return false;\r\n        if (!Geometry.isSameCoordinate(rightKnot, this.knots[rightKnotIndex + i + 1]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n\r\n    return false;\r\n  }\r\n  /** Test matching degree and knot values */\r\n  public isAlmostEqual(other: KnotVector): boolean {\r\n    if (this.degree !== other.degree) return false;\r\n    return NumberArray.isAlmostEqual(this.knots, other.knots, KnotVector.knotTolerance);\r\n  }\r\n  /** install knot values from an array, optionally ignoring first and last.\r\n   */\r\n  public setKnots(knots: number[] | Float64Array, skipFirstAndLast?: boolean) {\r\n    const numAllocate = skipFirstAndLast ? knots.length - 2 : knots.length;\r\n    if (numAllocate !== this.knots.length)\r\n      this.knots = new Float64Array(numAllocate);\r\n    if (skipFirstAndLast) {\r\n      for (let i = 1; i + 1 < knots.length; i++)\r\n        this.knots[i - 1] = knots[i];\r\n\r\n    } else {\r\n      for (let i = 0; i < knots.length; i++)\r\n        this.knots[i] = knots[i];\r\n    }\r\n    this.setupFixedValues();\r\n  }\r\n  /**\r\n   * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.\r\n   * @param numPoles Number of poles\r\n   * @param degree degree of polynomial\r\n   * @param a0 left knot value for active interval\r\n   * @param a1 right knot value for active interval\r\n   */\r\n  public static createUniformClamped(numPoles: number, degree: number, a0: number, a1: number): KnotVector {\r\n    const knots = new KnotVector(numPoles + degree - 1, degree);\r\n    let k = 0;\r\n    for (let m = 0; m < degree; m++)knots.knots[k++] = a0;\r\n    const du = 1.0 / (numPoles - degree);\r\n    for (let i = 1; i + degree < numPoles; i++)\r\n      knots.knots[k++] = a0 + i * du * (a1 - a0);\r\n    for (let m = 0; m < degree; m++)knots.knots[k++] = a1;\r\n    knots.setupFixedValues();\r\n    return knots;\r\n  }\r\n  /**\r\n   * Create knot vector with {degree-1} replicated knots at start and end, and uniform knots between.\r\n   * @param  numInterval number of intervals in knot space.  (NOT POLE COUNT)\r\n   * @param degree degree of polynomial\r\n   * @param a0 left knot value for active interval\r\n   * @param a1 right knot value for active interval\r\n   */\r\n  public static createUniformWrapped(numInterval: number, degree: number, a0: number, a1: number): KnotVector {\r\n    const knots = new KnotVector(numInterval + 2 * degree - 1, degree);\r\n    const du = 1.0 / numInterval;\r\n    for (let i = 1 - degree, k = 0; i < numInterval + degree; i++ , k++) {\r\n      knots.knots[k] = Geometry.interpolate(a0, i * du, a1);\r\n    }\r\n    knots.setupFixedValues();\r\n    return knots;\r\n  }\r\n\r\n  /**\r\n   * Create knot vector with given knot values and degree.\r\n   * @param knotArray knot values\r\n   * @param degree degree of polynomial\r\n   * @param skipFirstAndLast true to skip class overclamped end knots.\r\n   */\r\n  public static create(knotArray: number[] | Float64Array, degree: number, skipFirstAndLast?: boolean): KnotVector {\r\n    const numAllocate = skipFirstAndLast ? knotArray.length - 2 : knotArray.length;\r\n    const knots = new KnotVector(numAllocate, degree);\r\n    knots.setKnots(knotArray, skipFirstAndLast);\r\n    return knots;\r\n  }\r\n\r\n  /**\r\n   * Return the average of degree consecutive knots beginning at spanIndex.\r\n   */\r\n  public grevilleKnot(spanIndex: number): number {\r\n    if (spanIndex < 0) return this.leftKnot;\r\n    if (spanIndex > this.rightKnotIndex) return this.rightKnot;\r\n    let sum = 0.0;\r\n    for (let i = spanIndex; i < spanIndex + this.degree; i++)\r\n      sum += this.knots[i];\r\n    return sum / this.degree;\r\n  }\r\n  /** Return an array sized for a set of the basis function values. */\r\n  public createBasisArray(): Float64Array { return new Float64Array(this.degree + 1); }\r\n  /** Convert localFraction within the interval following an indexed knot to a knot value. */\r\n  public baseKnotFractionToKnot(knotIndex0: number, localFraction: number): number {\r\n    const knot0 = this.knots[knotIndex0];\r\n    return knot0 + localFraction * (this.knots[knotIndex0 + 1] - knot0);\r\n  }\r\n  /** Convert localFraction within an indexed bezier span to a knot value. */\r\n  public spanFractionToKnot(spanIndex: number, localFraction: number): number {\r\n    const k = this.spanIndexToLeftKnotIndex(spanIndex);\r\n    return this.knots[k] + localFraction * (this.knots[k + 1] - this.knots[k]);\r\n  }\r\n  /** Convert localFraction within an indexed bezier span to fraction of active knot range. */\r\n  public spanFractionToFraction(spanIndex: number, localFraction: number): number {\r\n    const knot = this.spanFractionToKnot(spanIndex, localFraction);\r\n    return (knot - this.leftKnot) / (this.rightKnot - this.leftKnot);\r\n  }\r\n  /** Return fraction of active knot range to knot value. */\r\n  public fractionToKnot(fraction: number): number {\r\n    return Geometry.interpolate(this.knots[this.degree - 1], fraction, this.knots[this.knots.length - this.degree]);\r\n  }\r\n  /**\r\n   * Evaluate basis functions f[] at knot value u.\r\n   *\r\n   * @param u knot value for evaluation\r\n   * @param f array of basis values.  ASSUMED PROPER LENGTH\r\n   */\r\n  public evaluateBasisFunctions(knotIndex0: number, u: number, f: Float64Array) {\r\n    f[0] = 1.0;\r\n    if (this.degree < 1) return;\r\n    // direct compute for linear part ...\r\n    const u0 = this.knots[knotIndex0];\r\n    const u1 = this.knots[knotIndex0 + 1];\r\n    f[1] = (u - u0) / (u1 - u0);\r\n    f[0] = 1.0 - f[1];\r\n    if (this.degree < 2) return;\r\n\r\n    for (let depth = 1; depth < this.degree; depth++) {\r\n      let kLeft = knotIndex0 - depth;\r\n      let kRight = kLeft + depth + 1;\r\n      let gCarry = 0.0;\r\n      for (let step = 0; step <= depth; step++) {\r\n        const tLeft = this.knots[kLeft++];\r\n        const tRight = this.knots[kRight++];\r\n        const fraction = (u - tLeft) / (tRight - tLeft);\r\n        const g1 = f[step] * fraction;\r\n        const g0 = f[step] * (1.0 - fraction);\r\n        f[step] = gCarry + g0;\r\n        gCarry = g1;\r\n      }\r\n      f[depth + 1] = gCarry;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Evaluate basis fucntions f[] at knot value u.\r\n   *\r\n   * @param u knot value for evaluation\r\n   * @param f array of basis values.  ASSUMED PROPER LENGTH\r\n   */\r\n  public evaluateBasisFunctions1(knotIndex0: number, u: number, f: Float64Array, df: Float64Array, ddf?: Float64Array) {\r\n    f[0] = 1.0; df[0] = 0.0;\r\n    if (this.degree < 1) return;\r\n    // direct compute for linear part ...\r\n    const u0 = this.knots[knotIndex0];\r\n    const u1 = this.knots[knotIndex0 + 1];\r\n    // ah = 1/(u1-u0)      is the derivative of fraction0\r\n    // (-ah) is the derivative of fraction1.\r\n    let ah = 1.0 / (u1 - u0);\r\n    f[1] = (u - u0) * ah;\r\n    f[0] = 1.0 - f[1];\r\n    df[0] = -ah; df[1] = ah;\r\n    if (ddf) {  // first derivative started constant, second derivative started zero.\r\n      ddf[0] = 0.0; ddf[1] = 0.0;\r\n    }\r\n    if (this.degree < 2) return;\r\n    for (let depth = 1; depth < this.degree; depth++) {\r\n      let kLeft = knotIndex0 - depth;\r\n      let kRight = kLeft + depth + 1;\r\n      let gCarry = 0.0;\r\n      let dgCarry = 0.0;\r\n      let ddgCarry = 0.0;\r\n      // f, df, ddf, are each row vectors with product of `step` linear terms.\r\n      // f is multiplied on the right by matrix V.  Each row has 2 nonzero entries (which sum to 1)  (0,0,1-fraction, fraction,0,0,0)\r\n      //    Each row of the derivative dV is two entries (0,0, -1/h, 1/h,0,0,0)\r\n      // Hence fnew = f * V\r\n      //      dfnew = df * V + f * dV\r\n      //      ddfnew = ddf * V + df*dV + df * dV + f * ddV\r\n      // but ddV is zero so\r\n      //      ddfnew = ddf * V + 2 * df * dV\r\n      for (let step = 0; step <= depth; step++) {\r\n        const tLeft = this.knots[kLeft++];\r\n        const tRight = this.knots[kRight++];\r\n        ah = 1.0 / (tRight - tLeft);\r\n        const fraction = (u - tLeft) * ah;\r\n        const fraction1 = 1.0 - fraction;\r\n        const g1 = f[step] * fraction;\r\n        const g0 = f[step] * fraction1;\r\n        const dg1 = df[step] * fraction + f[step] * ah;\r\n        const dg0 = df[step] * fraction1 - f[step] * ah;\r\n        const dfSave = 2.0 * df[step] * ah;\r\n        f[step] = gCarry + g0;\r\n        df[step] = dgCarry + dg0;\r\n        gCarry = g1;\r\n        dgCarry = dg1;\r\n        if (ddf) {  // do the backward reference to df before rewriting df !!!\r\n          const ddg1 = ddf[step] * fraction + dfSave;\r\n          const ddg0 = ddf[step] * fraction1 - dfSave;\r\n          ddf[step] = ddgCarry + ddg0;\r\n          ddgCarry = ddg1;\r\n        }\r\n      }\r\n      f[depth + 1] = gCarry;\r\n      df[depth + 1] = dgCarry;\r\n      if (ddf)\r\n        ddf[depth + 1] = ddgCarry;\r\n    }\r\n  }\r\n  /** Return the (highest) index of the knot less than or equal to u */\r\n  public knotToLeftKnotIndex(u: number): number {\r\n    // Anything to left is in the first span . .\r\n    const firstLeftKnot = this.degree - 1;\r\n    if (u < this.knots[firstLeftKnot + 1]) return firstLeftKnot;\r\n    // Anything to right is in the last span ...\r\n    const lastLeftKnot = this.knots.length - this.degree - 1;\r\n    if (u >= this.knots.length - this.degree) return this.knots[lastLeftKnot];\r\n    // ugh ... linear search ...\r\n    for (let i = firstLeftKnot + 1; i < lastLeftKnot; i++)\r\n      if (u < this.knots[i + 1]) return i;  // testing against right side skips over multiple knot cases???\r\n    return lastLeftKnot;\r\n  }\r\n  /**\r\n   * Given a span index, return the index of the knot at its left.\r\n   * @param spanIndex index of span\r\n   */\r\n  public spanIndexToLeftKnotIndex(spanIndex: number): number {\r\n    const d = this.degree;\r\n    if (spanIndex <= 0.0) return d - 1;\r\n    return Math.min(spanIndex + d - 1, this.knots.length - d);\r\n  }\r\n  /** Return the knot interval length of indexed bezier span. */\r\n  public spanIndexToSpanLength(spanIndex: number): number {\r\n    const k = this.spanIndexToLeftKnotIndex(spanIndex);\r\n    return this.knots[k + 1] - this.knots[k];\r\n  }\r\n  /**\r\n   * Given a span index, test if it is within range and has nonzero length.\r\n   * * note that a false return does not imply there are no more spans.  This may be a double knot (zero length span) followed by more real spans\r\n   * @param spanIndex index of span to test.\r\n   */\r\n  public isIndexOfRealSpan(spanIndex: number): boolean {\r\n    if (spanIndex >= 0 && spanIndex < this.knots.length - this.degree)\r\n      return !Geometry.isSmallMetricDistance(this.spanIndexToSpanLength(spanIndex));\r\n    return false;\r\n  }\r\n  /** Reflect all knots so `leftKnot` and `rightKnot` are maintained but interval lengths reverse. */\r\n  public reflectKnots() {\r\n    const a = this.leftKnot;\r\n    const b = this.rightKnot;\r\n    const numKnots = this.knots.length;\r\n    for (let i = 0; i < numKnots; i++)\r\n      this.knots[i] = a + (b - this.knots[i]);\r\n    this.knots.reverse();\r\n  }\r\n  /**\r\n   * return a simple array form of the knots.  optionally replicate the first and last\r\n   * in classic over-clamped manner\r\n   */\r\n  public copyKnots(includeExtraEndKnot: boolean): number[] {\r\n    const wrap = this.wrappable === BSplineWrapMode.OpenByAddingControlPoints && this.testClosable();\r\n    const leftIndex = this.leftKnotIndex;\r\n    const rightIndex = this.rightKnotIndex;\r\n    const a0 = this.leftKnot;\r\n    const a1 = this.rightKnot;\r\n    const delta = a1 - a0;\r\n    const degree = this.degree;\r\n    const values: number[] = [];\r\n    if (includeExtraEndKnot) {\r\n      if (wrap) {\r\n        values.push(this.knots[rightIndex - degree] - delta);\r\n      } else {\r\n        values.push(this.knots[0]);\r\n      }\r\n    }\r\n    for (const u of this.knots) values.push(u);\r\n    if (includeExtraEndKnot) {\r\n      if (wrap) {\r\n        values.push(this.knots[leftIndex + degree] + delta);\r\n      } else\r\n        values.push(values[values.length - 1]);\r\n    }\r\n    return values;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { AnalyticRoots } from \"../numerics/Polynomials\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { Clipper, ClipUtilities } from \"./ClipUtils\";\r\nimport { AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/** A ClipPlane is a single plane represented as\r\n * * An inward unit normal (u,v,w)\r\n * * A signedDistance\r\n *\r\n * Hence\r\n * * The halfspace function evaluation for \"point\" [x,y,z,] is: ([x,y,z] DOT (u,v,w)l - signedDistance)\r\n * * POSITIVE values of the halfspace function are \"inside\"\r\n * * ZERO value of the halfspace function is \"on\"\r\n * * NEGATIVE value of the halfspace function is \"outside\"\r\n * * A representative point on the plane is (signedDistance*u, signedDistance * v, signedDistance *w)\r\n * @public\r\n */\r\nexport class ClipPlane implements Clipper {\r\n  // Static variable from original native c++ function ConvexPolygonClipInPlace\r\n  private static _fractionTol = 1.0e-8;\r\n  private _inwardNormal: Vector3d;\r\n  /** Construct a parallel plane through the origin.\r\n   * * Move it to the actual position.\r\n   * * _distanceFromOrigin is the distance it moved, with the (inward) normal direction as positive\r\n   */\r\n  private _distanceFromOrigin: number;\r\n  private _invisible: boolean;\r\n  private _interior: boolean;\r\n\r\n  private constructor(normal: Vector3d, distance: number, invisible: boolean, interior: boolean) {\r\n    this._invisible = invisible;\r\n    this._interior = interior;\r\n    this._inwardNormal = normal;\r\n    this._distanceFromOrigin = distance;\r\n  }\r\n  private safeSetXYZDistance(nx: number, ny: number, nz: number, d: number) {\r\n    this._inwardNormal.set(nx, ny, nz);\r\n    this._distanceFromOrigin = d;\r\n  }\r\n  /**\r\n   * Return true if all members are almostEqual to corresponding members of other.\r\n   * @param other clip plane to compare\r\n   */\r\n  public isAlmostEqual(other: ClipPlane): boolean {\r\n    return Geometry.isSameCoordinate(this._distanceFromOrigin, other._distanceFromOrigin)\r\n      && this._inwardNormal.isAlmostEqual(other._inwardNormal)\r\n      && this._interior === other._interior\r\n      && this._invisible === other._invisible;\r\n  }\r\n  /** return a cloned plane */\r\n  public clone(): ClipPlane {\r\n    const result = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);\r\n    return result;\r\n  }\r\n  /** return Return a cloned plane with coordinate data negated. */\r\n  public cloneNegated(): ClipPlane {\r\n    const plane = new ClipPlane(this._inwardNormal.clone(), this._distanceFromOrigin, this._invisible, this._interior);\r\n    plane.negateInPlace();\r\n    return plane;\r\n  }\r\n  /** Create a ClipPlane from Plane3dByOriginAndUnitNormal. */\r\n  public static createPlane(plane: Plane3dByOriginAndUnitNormal, invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane {\r\n    const distance = plane.getNormalRef().dotProduct(plane.getOriginRef());\r\n    if (result) {\r\n      result._invisible = invisible;\r\n      result._interior = interior;\r\n      result._inwardNormal = plane.getNormalRef().clone();\r\n      result._distanceFromOrigin = distance;\r\n      return result;\r\n    }\r\n    return new ClipPlane(plane.getNormalRef().clone(), distance, invisible, interior);\r\n  }\r\n  /**\r\n   * * Create a ClipPlane with direct normal and signedDistance.\r\n   * * The vector is normalized for storage.\r\n   */\r\n  public static createNormalAndDistance(normal: Vector3d, distance: number, invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane | undefined {\r\n    const normalized = normal.normalize();\r\n    if (normalized) {\r\n      if (result) {\r\n        result._invisible = invisible;\r\n        result._interior = interior;\r\n        result._inwardNormal = normalized;\r\n        result._distanceFromOrigin = distance;\r\n      }\r\n      return new ClipPlane(normalized, distance, invisible, interior);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Create a ClipPlane\r\n   * * \"normal\" is the inward normal of the plane. (It is internally normalized)\r\n   * * \"point\" is any point of the plane.\r\n   * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)\r\n   */\r\n  public static createNormalAndPoint(normal: Vector3d, point: Point3d, invisible: boolean = false, interior: boolean = false, result?: ClipPlane): ClipPlane | undefined {\r\n    const normalized = normal.normalize();\r\n    if (normalized) {\r\n      const distance = normalized.dotProduct(point);\r\n      if (result) {\r\n        result._invisible = invisible;\r\n        result._interior = interior;\r\n        result._inwardNormal = normalized;\r\n        result._distanceFromOrigin = distance;\r\n      }\r\n      return new ClipPlane(normalized, distance, invisible, interior);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Create a ClipPlane\r\n   * * \"normal\" is the inward normal of the plane. (It is internally normalized)\r\n   * * \"point\" is any point of the plane.\r\n   * * The stored distance for the plane is the dot product of the point with the normal (i.e. treat the point's xyz as a vector from the origin.)\r\n   */\r\n  public static createNormalAndPointXYZXYZ(normalX: number, normalY: number, normalZ: number,\r\n    originX: number, originY: number, originZ: number,\r\n    invisible: boolean = false, interior: boolean = false): ClipPlane | undefined {\r\n    const normal = Vector3d.create(normalX, normalY, normalZ);\r\n\r\n    const normalized = normal.normalizeInPlace();\r\n    if (normalized) {\r\n      const distance = normal.dotProductXYZ(originX, originY, originZ);\r\n      return new ClipPlane(normal, distance, invisible, interior);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * return a json object of the form\r\n   * `{\"normal\":[u,v,w],\"dist\":signedDistanceValue,\"interior\":true,\"invisible\":true}`\r\n   */\r\n  public toJSON(): any {\r\n    const val: any = {};\r\n    val.normal = this.inwardNormalRef.toJSON();\r\n    val.dist = this.distance;\r\n    if (this.interior)\r\n      val.interior = true;\r\n    if (this.invisible)\r\n      val.invisible = true;\r\n    return val;\r\n  }\r\n  /** parse json object to ClipPlane instance */\r\n  public static fromJSON(json: any, result?: ClipPlane): ClipPlane | undefined {\r\n    if (json && json.normal && Number.isFinite(json.dist)) {\r\n      return ClipPlane.createNormalAndDistance(Vector3d.fromJSON(json.normal), json.dist, !!json.invisible, !!json.interior);\r\n    }\r\n    return ClipPlane.createNormalAndDistance(Vector3d.unitZ(), 0, false, false, result);\r\n  }\r\n  /** Set both the invisible and interior flags. */\r\n  public setFlags(invisible: boolean, interior: boolean) {\r\n    this._invisible = invisible;\r\n    this._interior = interior;\r\n  }\r\n\r\n  /**\r\n   * Return the stored distanceFromOrigin property.\r\n   */\r\n  public get distance() { return this._distanceFromOrigin; }\r\n  /**\r\n   * Return the stored inward normal property.\r\n   */\r\n  public get inwardNormalRef(): Vector3d { return this._inwardNormal; }\r\n  /**\r\n   * Return the \"interior\" property bit\r\n   */\r\n  public get interior() { return this._interior; }\r\n  /**\r\n   * Return the \"invisible\" property bit.\r\n   */\r\n  public get invisible() { return this._invisible; }\r\n\r\n  /**\r\n   * Create a plane defined by two points, an up vector, and a tilt angle relative to the up vector.\r\n   * @param point0 start point of the edge\r\n   * @param point1 end point of the edge\r\n   * @param upVector vector perpendicular to the plane\r\n   * @param tiltAngle angle to tilt the plane around the edge in the direction of the up vector.\r\n   * @param result optional preallocated plane\r\n   */\r\n  public static createEdgeAndUpVector(point0: Point3d, point1: Point3d, upVector: Vector3d, tiltAngle: Angle, result?: ClipPlane): ClipPlane | undefined {\r\n    const edgeVector = Vector3d.createFrom(point1.minus(point0));\r\n    let normal = (upVector.crossProduct(edgeVector)).normalize();\r\n\r\n    if (normal) {\r\n      if (!tiltAngle.isAlmostZero) {\r\n        const tiltNormal = Vector3d.createRotateVectorAroundVector(normal, edgeVector, tiltAngle);\r\n        if (tiltNormal) {\r\n          normal = tiltNormal.clone();\r\n        }\r\n      }\r\n      normal.negate(normal);\r\n      return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create a plane perpendicular to the edge between the xy parts of point0 and point1\r\n   */\r\n  public static createEdgeXY(point0: Point3d, point1: Point3d, result?: ClipPlane): ClipPlane | undefined {\r\n    const normal = Vector3d.create(point0.y - point1.y, point1.x - point0.x);\r\n    if (normal.normalizeInPlace())\r\n      return ClipPlane.createNormalAndPoint(normal, point0, false, false, result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return the Plane3d form of the plane.\r\n   * * The plane origin is the point `distance * inwardNormal`\r\n   * * The plane normal is the inward normal of the ClipPlane.\r\n   */\r\n  public getPlane3d(): Plane3dByOriginAndUnitNormal {\r\n    const d = this._distanceFromOrigin;\r\n    // Normal should be normalized, will not return undefined\r\n    return Plane3dByOriginAndUnitNormal.create(Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d), this._inwardNormal)!;\r\n  }\r\n\r\n  /**\r\n   * Return the Point4d d form of the plane.\r\n   * * The homogeneous xyz are the inward normal xyz.\r\n   * * The homogeneous weight is the negated ClipPlane distance.\r\n   */\r\n  public getPlane4d(): Point4d {\r\n    return Point4d.create(this._inwardNormal.x, this._inwardNormal.y, this._inwardNormal.z, - this._distanceFromOrigin);\r\n  }\r\n  /**\r\n   * Set the plane from DPoint4d style plane.\r\n   * * The saved plane has its direction normalized.\r\n   * * This preserves the plane itself as a zero set but make plane evaluations act as true distances (even if the plane coefficients are scaled otherwise)\r\n   * @param plane\r\n   */\r\n  public setPlane4d(plane: Point4d) {\r\n    const a = Math.sqrt(plane.x * plane.x + plane.y * plane.y + plane.z * plane.z);\r\n    const r = a === 0.0 ? 1.0 : 1.0 / a;\r\n    this._inwardNormal.x = r * plane.x;\r\n    this._inwardNormal.y = r * plane.y;\r\n    this._inwardNormal.z = r * plane.z;\r\n    this._distanceFromOrigin = -r * plane.w;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the distance from the plane to a point in space, i.e. (dot product with inward normal) minus distance\r\n   * @param point space point to test\r\n   */\r\n  public evaluatePoint(point: Point3d): number {\r\n    return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z - this._distanceFromOrigin;\r\n  }\r\n\r\n  /** Return the dot product of the plane normal with the vector (NOT using the plane's distanceFromOrigin).\r\n   */\r\n  public dotProductVector(vector: Vector3d): number {\r\n    return vector.x * this._inwardNormal.x + vector.y * this._inwardNormal.y + vector.z * this._inwardNormal.z;\r\n  }\r\n  /** Return the dot product of the plane normal with the point (treating the point xyz as a vector, and NOT using the plane's distanceFromOrigin).\r\n   */\r\n  public dotProductPlaneNormalPoint(point: Point3d): number {\r\n    return point.x * this._inwardNormal.x + point.y * this._inwardNormal.y + point.z * this._inwardNormal.z;\r\n  }\r\n  /**\r\n   * Return true if spacePoint is inside or on the plane, with tolerance applied to \"on\".\r\n   * @param spacePoint point to test.\r\n   * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\r\n   */\r\n  public isPointOnOrInside(spacePoint: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    let value = this.evaluatePoint(spacePoint);\r\n    if (tolerance) { value += tolerance; }\r\n    return value >= 0.0;\r\n  }\r\n\r\n  /**\r\n   * Return true if spacePoint is strictly inside the halfspace, with tolerance applied to \"on\".\r\n   * @param spacePoint point to test.\r\n   * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\r\n   */\r\n  public isPointInside(point: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    let value = this.evaluatePoint(point);\r\n    if (tolerance) { value -= tolerance; }\r\n    return value > 0.0;\r\n  }\r\n\r\n  /**\r\n   * Return true if spacePoint is strictly on the plane, within tolerance\r\n   * @param spacePoint point to test.\r\n   * @param tolerance tolerance for considering \"near plane\" to be \"on plane\"\r\n   */\r\n  public isPointOn(point: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    return Math.abs(this.evaluatePoint(point)) <= tolerance;\r\n  }\r\n  /**\r\n   * Compute intersections of an (UNBOUNDED) arc with the plane.  Append them (as radians) to a growing array.\r\n   * @param arc arc to test.  The angle limits of the arc are NOT considered.\r\n   * @param intersectionRadians array to receive results\r\n   */\r\n  public appendIntersectionRadians(arc: Arc3d, intersectionRadians: GrowableFloat64Array) {\r\n    const arcVectors = arc.toVectors();\r\n    const alpha = this.evaluatePoint(arc.center);\r\n    const beta = this.dotProductVector(arcVectors.vector0);\r\n    const gamma = this.dotProductVector(arcVectors.vector90);\r\n    AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, undefined, undefined, intersectionRadians);\r\n  }\r\n\r\n  private static _clipArcFractionArray = new GrowableFloat64Array();\r\n  /** Announce fractional intervals of arc clip.\r\n   * * Each call to `announce(fraction0, fraction1, arc)` announces one interval that is inside the clip plane.\r\n   */\r\n  public announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const breaks = ClipPlane._clipArcFractionArray;\r\n    breaks.clear();\r\n    this.appendIntersectionRadians(arc, breaks);\r\n    arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);\r\n    return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\r\n  }\r\n  /**\r\n   * * Compute intersection of (unbounded) segment with the plane.\r\n   * * If the ends are on the same side of the plane, return undefined.\r\n   * * If the intersection is an endpoint or interior to the segment return the fraction.\r\n   * * If both ends are on, return undefined.\r\n   */\r\n  public getBoundedSegmentSimpleIntersection(pointA: Point3d, pointB: Point3d): number | undefined {\r\n    const h0 = this.evaluatePoint(pointA);\r\n    const h1 = this.evaluatePoint(pointB);\r\n    if (h0 * h1 > 0.0)\r\n      return undefined;\r\n    if (h0 === 0.0 && h1 === 0.0) {\r\n      return undefined;\r\n    }\r\n    return - h0 / (h1 - h0);\r\n  }\r\n\r\n  /** Apply transform to the origin.  Apply inverse transpose of the matrix part to th normal vector. */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    const plane: Plane3dByOriginAndUnitNormal = this.getPlane3d();\r\n    const matrix: Matrix3d = transform.matrix;\r\n    const newPoint = transform.multiplyPoint3d(plane.getOriginRef());\r\n    // Normal transforms as the inverse transpose of the matrix part\r\n    // BTW: If the matrix is orthogonal, this is a long way to multiply by the matrix part (mumble grumble)\r\n    const newNormal = matrix.multiplyInverseTranspose(plane.getNormalRef());\r\n    if (!newNormal)\r\n      return false;\r\n\r\n    plane.set(newPoint, newNormal);\r\n    const normalized = (plane.getNormalRef()).normalize();\r\n    if (!normalized)\r\n      return false;\r\n    this._inwardNormal = normalized;\r\n    this._distanceFromOrigin = this._inwardNormal.dotProduct(plane.getOriginRef());\r\n    return true;\r\n  }\r\n  /** Set the invisible flag.   Interpretation of this is up to the use code algorithms. */\r\n  public setInvisible(invisible: boolean) {\r\n    this._invisible = invisible;\r\n  }\r\n\r\n  /**  reverse the sign of all coefficients, so outside and inside reverse */\r\n  public negateInPlace() {\r\n    this._inwardNormal = this._inwardNormal.negate();\r\n    this._distanceFromOrigin = - this._distanceFromOrigin;\r\n  }\r\n  /**\r\n   * Move the plane INWARD by given distance\r\n   * @param offset distance of shift inwards\r\n   */\r\n  public offsetDistance(offset: number) {\r\n    this._distanceFromOrigin += offset;\r\n  }\r\n  /**\r\n   * Clip a polygon, returning the clip result in the same object.\r\n   * @param xyz input/output polygon\r\n   * @param work scratch object\r\n   * @param tolerance tolerance for on-plane decision.\r\n   */\r\n  public convexPolygonClipInPlace(xyz: Point3d[], work: Point3d[], tolerance: number = Geometry.smallMetricDistance) {\r\n    work.length = 0;\r\n    let numNegative = 0;\r\n    ClipPlane._fractionTol = 1.0e-8;\r\n    const b = -tolerance;\r\n    if (xyz.length > 2) {\r\n      let xyz0 = xyz[xyz.length - 1];\r\n      let a0 = this.evaluatePoint(xyz0);\r\n      //    if (a0 >= 0.0)\r\n      //      work.push_back (xyz0);\r\n      for (const xyz1 of xyz) {\r\n        const a1 = this.evaluatePoint(xyz1);\r\n        if (a1 < 0)\r\n          numNegative++;\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing . . .\r\n          const f = - a0 / (a1 - a0);\r\n          if (f > 1.0 - ClipPlane._fractionTol && a1 >= 0.0) {\r\n            // the endpoint will be saved -- avoid the duplicate\r\n          } else {\r\n            work.push(xyz0.interpolate(f, xyz1));\r\n          }\r\n        }\r\n        if (a1 >= b)\r\n          work.push(xyz1);\r\n        xyz0 = Point3d.createFrom(xyz1);\r\n        a0 = a1;\r\n      }\r\n    }\r\n\r\n    if (work.length <= 2) {\r\n      xyz.length = 0;\r\n    } else if (numNegative > 0) {\r\n      xyz.length = 0;\r\n      for (const xyzi of work) {\r\n        xyz.push(xyzi);\r\n      }\r\n      work.length = 0;\r\n    }\r\n  }\r\n  /**\r\n   * Clip a polygon to the inside or outside of the plane.\r\n   * * Results with 2 or fewer points are ignored.\r\n   * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\r\n   * @param xyz input points.\r\n   * @param work work buffer\r\n   * @param tolerance tolerance for \"on plane\" decision.\r\n   */\r\n  public clipConvexPolygonInPlace(xyz: GrowableXYZArray, work: GrowableXYZArray, inside: boolean = true, tolerance: number = Geometry.smallMetricDistance) {\r\n    work.clear();\r\n    const n = xyz.length;\r\n    let numNegative = 0;\r\n    ClipPlane._fractionTol = 1.0e-8;\r\n    const b = -tolerance;\r\n    const s = inside ? 1.0 : -1.0;\r\n    const nx = s * this._inwardNormal.x;\r\n    const ny = s * this._inwardNormal.y;\r\n    const nz = s * this._inwardNormal.z;\r\n    const d = s * this._distanceFromOrigin;\r\n    if (xyz.length > 1) {\r\n      let a1;\r\n      let index0 = xyz.length - 1;\r\n      let a0 = xyz.evaluateUncheckedIndexDotProductXYZ(index0, nx, ny, nz) - d;\r\n      //    if (a0 >= 0.0)\r\n      //      work.push_back (xyz0);\r\n      for (let index1 = 0; index1 < n; a0 = a1, index0 = index1++) {\r\n        a1 = xyz.evaluateUncheckedIndexDotProductXYZ(index1, nx, ny, nz) - d;\r\n        if (a1 < 0)\r\n          numNegative++;\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing . . .\r\n          const f = - a0 / (a1 - a0);\r\n          if (f > 1.0 - ClipPlane._fractionTol && a1 >= 0.0) {\r\n            // the endpoint will be saved -- avoid the duplicate\r\n          } else {\r\n            work.pushInterpolatedFromGrowableXYZArray(xyz, index0, f, index1);\r\n          }\r\n        }\r\n        if (a1 >= b)\r\n          work.pushFromGrowableXYZArray(xyz, index1);\r\n        index0 = index1;\r\n        a0 = a1;\r\n      }\r\n    }\r\n\r\n    if (work.length <= 2) {\r\n      xyz.clear();\r\n    } else if (numNegative > 0) {\r\n      xyz.clear();\r\n      xyz.pushFromGrowableXYZArray(work);\r\n    }\r\n    work.clear();\r\n  }\r\n  /** Return an array containing\r\n   * * All points that are exactly on the plane.\r\n   * * Crossing points between adjacent points that are (strictly) on opposite sides.\r\n   */\r\n  public polygonCrossings(xyz: Point3d[], crossings: Point3d[]) {\r\n    crossings.length = 0;\r\n    if (xyz.length >= 2) {\r\n      let xyz0 = xyz[xyz.length - 1];\r\n      let a0 = this.evaluatePoint(xyz0);\r\n      for (const xyz1 of xyz) {\r\n        const a1 = this.evaluatePoint(xyz1);\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing. . .\r\n          const f = - a0 / (a1 - a0);\r\n          crossings.push(xyz0.interpolate(f, xyz1));\r\n        }\r\n        if (a1 === 0.0) {        // IMPORTANT -- every point is directly tested here\r\n          crossings.push(xyz1);\r\n        }\r\n        xyz0 = Point3d.createFrom(xyz1);\r\n        a0 = a1;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Split a (convex) polygon into 2 parts.\r\n   * @param xyz original polygon\r\n   * @param xyzIn array to receive inside part\r\n   * @param xyzOut array to receive outside part\r\n   * @param altitudeRange min and max altitudes encountered.\r\n   */\r\n  public convexPolygonSplitInsideOutside(xyz: Point3d[], xyzIn: Point3d[], xyzOut: Point3d[], altitudeRange: Range1d) {\r\n    xyzOut.length = 0;\r\n    xyzIn.length = 0;\r\n    // let numSplit = 0;\r\n    ClipPlane._fractionTol = 1.0e-8;\r\n    if (xyz.length > 2) {\r\n      let xyz0 = xyz[xyz.length - 1];\r\n      altitudeRange.setNull();\r\n      let a0 = this.evaluatePoint(xyz0);\r\n      altitudeRange.extendX(a0);\r\n      //    if (a0 >= 0.0)\r\n      //      work.push_back (xyz0);\r\n      for (const xyz1 of xyz) {\r\n        const a1 = this.evaluatePoint(xyz1);\r\n        altitudeRange.extendX(a1);\r\n        let nearZero = false;\r\n        if (a0 * a1 < 0.0) {\r\n          // simple crossing. . .\r\n          const f = - a0 / (a1 - a0);\r\n          if (f > 1.0 - ClipPlane._fractionTol && a1 >= 0.0) {\r\n            // the endpoint will be saved -- avoid the duplicate\r\n            nearZero = true;\r\n          } else {\r\n            const xyzA = xyz0.interpolate(f, xyz1);\r\n            xyzIn.push(xyzA);\r\n            xyzOut.push(xyzA);\r\n          }\r\n          // numSplit++;\r\n        }\r\n        if (a1 >= 0.0 || nearZero)\r\n          xyzIn.push(xyz1);\r\n        if (a1 <= 0.0 || nearZero)\r\n          xyzOut.push(xyz1);\r\n        xyz0 = Point3d.createFrom(xyz1);\r\n        a0 = a1;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Multiply the ClipPlane's DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   * @return false if unable to invert\r\n   */\r\n  public multiplyPlaneByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    const plane: Point4d = this.getPlane4d();\r\n    if (invert) {\r\n      const inverse = matrix.createInverse();\r\n      if (inverse)\r\n        return this.multiplyPlaneByMatrix4d(inverse, false, transpose);\r\n      return false;\r\n    }\r\n    if (transpose)\r\n      matrix.multiplyTransposePoint4d(plane, plane);\r\n    else\r\n      matrix.multiplyPoint4d(plane, plane);\r\n    this.setPlane4d(plane);\r\n    return true;\r\n  }\r\n\r\n  /** announce the interval (if any) where a line is within the clip plane half space. */\r\n  public announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    if (f1 < f0)\r\n      return false;\r\n    const h0 = - this.evaluatePoint(pointA);\r\n    const h1 = - this.evaluatePoint(pointB);\r\n    const delta = h1 - h0;\r\n    const f = Geometry.conditionalDivideFraction(-h0, delta);\r\n    if (f === undefined) { // The segment is parallel to the plane.\r\n      if (h0 <= 0.0) { if (announce) announce(f0, f1); return true; }\r\n      return false;\r\n    }\r\n    if (delta > 0) { // segment aims OUT\r\n      if (f < f1) f1 = f;\r\n    } else {\r\n      // segment aims IN\r\n      if (f > f0)\r\n        f0 = f;\r\n    }\r\n    if (f1 < f0)\r\n      return false;\r\n    if (announce) announce(f0, f1);\r\n    return true;\r\n  }\r\n  /**\r\n   * Return a coordinate frame with\r\n   * * origin at closest point to global origin\r\n   * * z axis points in\r\n   * x and y are \"in plane\"\r\n   */\r\n  public getFrame(): Transform {\r\n    const d = this._distanceFromOrigin;\r\n    const origin = Point3d.create(this._inwardNormal.x * d, this._inwardNormal.y * d, this._inwardNormal.z * d);\r\n    const matrix = Matrix3d.createRigidHeadsUp(this._inwardNormal, AxisOrder.ZXY);\r\n    return Transform.createOriginAndMatrix(origin, matrix);\r\n  }\r\n  /**\r\n   * Return the intersection of the plane with a range cube.\r\n   * @param range\r\n   * @param xyzOut intersection polygon.  This is convex.\r\n   */\r\n  public intersectRange(range: Range3d, addClosurePoint: boolean = false): GrowableXYZArray | undefined {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const corners = range.corners();\r\n    const frameOnPlane = this.getFrame();\r\n    frameOnPlane.multiplyInversePoint3dArrayInPlace(corners);\r\n    const localRange = Range3d.createArray(corners);\r\n    if (localRange.low.z * localRange.high.z > 0.0)\r\n      return undefined;\r\n    // oversized polygon on local z= 0\r\n    const xyzOut = new GrowableXYZArray();\r\n    xyzOut.pushXYZ(localRange.low.x, localRange.low.y, 0);\r\n    xyzOut.pushXYZ(localRange.high.x, localRange.low.y, 0);\r\n    xyzOut.pushXYZ(localRange.high.x, localRange.high.y, 0);\r\n    xyzOut.pushXYZ(localRange.low.x, localRange.high.y, 0);\r\n    xyzOut.multiplyTransformInPlace(frameOnPlane);\r\n    ClipPlane.intersectRangeConvexPolygonInPlace(range, xyzOut);\r\n    if (xyzOut.length === 0)\r\n      return undefined;\r\n    if (addClosurePoint)\r\n      xyzOut.pushWrap(1);\r\n    return xyzOut;\r\n  }\r\n  /**\r\n   * Return the intersection of the plane with a range cube.\r\n   * @param range\r\n   * @param xyzOut intersection polygon.  This is convex.\r\n   */\r\n  public static intersectRangeConvexPolygonInPlace(range: Range3d, xyz: GrowableXYZArray) {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const work = new GrowableXYZArray();\r\n    // clip the polygon to each plane of the cubic ...\r\n    const clipper = ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, range.high.y, range.high.z)!;\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, -1, 0, -range.high.y);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, 0, -1, -range.high.z);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(1, 0, 0, range.low.x);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, 1, 0, range.low.y);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n    clipper.safeSetXYZDistance(0, 0, 1, range.low.z);\r\n    clipper.clipConvexPolygonInPlace(xyz, work);\r\n    if (xyz.length === 0)\r\n      return undefined;\r\n\r\n    return xyz;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { ClipPlane } from \"./ClipPlane\";\r\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\r\nimport { ClipPlaneContainment } from \"./ClipUtils\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\r\nimport { Triangulator } from \"../topology/Triangulation\";\r\nimport { HalfEdgeGraph, HalfEdge, HalfEdgeMask } from \"../topology/Graph\";\r\n\r\n/**\r\n * Bit mask type for referencing subsets of 6 planes of range box.\r\n * @public\r\n */\r\nexport enum ClipMaskXYZRangePlanes {\r\n  /** no planes */\r\n  None = 0x00,\r\n  /** low x plane */\r\n  XLow = 0x01,\r\n  /** high x plane */\r\n  XHigh = 0x02,\r\n  /** low y plane */\r\n  YLow = 0x04,\r\n  /** high y plane */\r\n  YHigh = 0x08,\r\n  /** low z plane */\r\n  ZLow = 0x10,\r\n  /** high z plane */\r\n  ZHigh = 0x20,\r\n  /** all x and y planes, neither z plane */\r\n  XAndY = 0x0f,\r\n  /** all 6 planes */\r\n  All = 0x3f,\r\n}\r\n\r\n/**\r\n * * ClipPrimitive is a base class for clipping implementations that use\r\n *   * A ClipPlaneSet designated \"clipPlanes\"\r\n *   * an \"invisible\" flag\r\n * * When constructed directly, objects of type ClipPrimitive (directly, not through a derived class) will have just planes\r\n * * Derived classes (e.g. ClipShape) carry additional data of a swept shape.\r\n * * ClipPrimitive can be constructed with no planes.\r\n *     * Derived class is responsible for filling the plane sets.\r\n *     * At discretion of derived classes, plane construction can be done at construction time or \"on demand when\" queries call `ensurePlaneSets ()`\r\n * * ClipPrimitive can be constructed with planes (and no derived class).\r\n * @public\r\n */\r\nexport class ClipPrimitive {\r\n  /** The (union of) convex regions. */\r\n  protected _clipPlanes?: UnionOfConvexClipPlaneSets;\r\n  /** If true, pointInside inverts the sense of the pointInside for the _clipPlanes */\r\n  protected _invisible: boolean;\r\n  /** Get a reference to the `UnionOfConvexClipPlaneSets`.\r\n   *  * It triggers construction of the sets by `this.ensurePlaneSets()`.\r\n   *  * Derived class typically caches the set on the first such call.\r\n   */\r\n  public fetchClipPlanesRef(): UnionOfConvexClipPlaneSets | undefined { this.ensurePlaneSets(); return this._clipPlanes; }\r\n  /** Ask if this primitive is a hole. */\r\n  public get invisible(): boolean { return this._invisible; }\r\n\r\n  protected constructor(planeSet?: UnionOfConvexClipPlaneSets | undefined, isInvisible: boolean = false) {\r\n    this._clipPlanes = planeSet;\r\n    this._invisible = isInvisible;\r\n  }\r\n  /**\r\n   * Create a ClipPrimitive, capturing the supplied plane set as the clip planes.\r\n   * @param planes clipper\r\n   * @param isInvisible true to invert sense of the test\r\n   */\r\n  public static createCapture(planes: UnionOfConvexClipPlaneSets | ConvexClipPlaneSet | undefined, isInvisible: boolean = false): ClipPrimitive {\r\n    let planeData;\r\n    if (planes instanceof UnionOfConvexClipPlaneSets)\r\n      planeData = planes;\r\n    if (planes instanceof ConvexClipPlaneSet)\r\n      planeData = UnionOfConvexClipPlaneSets.createConvexSets([planes]);\r\n\r\n    return new ClipPrimitive(planeData, isInvisible);\r\n  }\r\n  /** Emit json form of the clip planes */\r\n  public toJSON(): any {\r\n    const data: any = {};\r\n    if (this._clipPlanes)\r\n      data.clips = this._clipPlanes.toJSON();\r\n    if (this._invisible)\r\n      data.invisible = true;\r\n    return { planes: data };\r\n  }\r\n\r\n  /**\r\n   * Returns true if the planes are present.\r\n   * * This can be false (for instance) if a ClipShape is holding a polygon but has not yet been asked to construct the planes.\r\n   */\r\n  public arePlanesDefined(): boolean {\r\n    return this._clipPlanes !== undefined;\r\n  }\r\n  /** Return a deep clone  */\r\n  public clone(): ClipPrimitive {\r\n    const newPlanes = this._clipPlanes ? this._clipPlanes.clone() : undefined;\r\n    const result = new ClipPrimitive(newPlanes, this._invisible);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * trigger (if needed)  computation of plane sets (if applicable) in the derived class.\r\n   * * Base class is no op.\r\n   * * In derived class, on first call create planes sets from defining data (e.g. swept shape).\r\n   * * In derived class, if planes are present leave them alone.\r\n   */\r\n  public ensurePlaneSets() { }\r\n  /** Return true if the point lies inside/on this polygon (or not inside/on if this polygon is a mask). Otherwise, return false.\r\n   * * Note that a derived class may choose to (a) implement its own test using its defining data, or (b) accept this implementation using planes that it inserted in the base class.\r\n   */\r\n  public pointInside(point: Point3d, onTolerance: number = Geometry.smallMetricDistanceSquared): boolean {\r\n    this.ensurePlaneSets();\r\n    let inside = true;\r\n    if (this._clipPlanes)\r\n      inside = this._clipPlanes.isPointOnOrInside(point, onTolerance);\r\n    if (this._invisible)\r\n      inside = !inside;\r\n    return inside;\r\n  }\r\n\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n\r\n    if (this._clipPlanes)\r\n      this._clipPlanes.multiplyPlanesByMatrix4d(matrix);\r\n    return true;\r\n  }\r\n\r\n  /** Apply a transform to the clipper (e.g. transform all planes) */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    if (this._clipPlanes)\r\n      this._clipPlanes.transformInPlace(transform);\r\n\r\n    return true;\r\n  }\r\n\r\n  /** Sets both the clip plane set and the mask set visibility */\r\n  public setInvisible(invisible: boolean) {\r\n    this._invisible = invisible;\r\n  }\r\n\r\n  /**\r\n   * Return true if any plane of the primary clipPlanes has (a) non-zero z component in its normal vector and (b) finite distance from origin.\r\n   */\r\n  public containsZClip(): boolean {\r\n    if (this.fetchClipPlanesRef() !== undefined)\r\n      for (const convexSet of this._clipPlanes!.convexSets)\r\n        for (const plane of convexSet.planes)\r\n          if (Math.abs(plane.inwardNormalRef.z) > 1.0e-6 && Math.abs(plane.distance) !== Number.MAX_VALUE)\r\n            return true;\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Quick test of whether the given points fall completely inside or outside.\r\n   * @param points points to test\r\n   * @param ignoreInvisibleSetting if true, do the test with the clip planes and return that, ignoring the invisible setting.\r\n   */\r\n  public classifyPointContainment(points: Point3d[], ignoreInvisibleSetting: boolean): ClipPlaneContainment {\r\n    this.ensurePlaneSets();\r\n    const planes = this._clipPlanes;\r\n    let inside = ClipPlaneContainment.StronglyInside;\r\n    if (planes)\r\n      inside = planes.classifyPointContainment(points, false);\r\n    if (this._invisible && !ignoreInvisibleSetting)\r\n      switch (inside) {\r\n        case ClipPlaneContainment.StronglyInside:\r\n          return ClipPlaneContainment.StronglyOutside;\r\n        case ClipPlaneContainment.StronglyOutside:\r\n          return ClipPlaneContainment.StronglyInside;\r\n        case ClipPlaneContainment.Ambiguous:\r\n          return ClipPlaneContainment.Ambiguous;\r\n      }\r\n    return inside;\r\n  }\r\n  /** Promote json object form to class instance\r\n   * * First try to convert to a ClipShape\r\n   * * then try as a standalone instance of the base class ClipPrimitive.\r\n   */\r\n  public static fromJSON(json: any): ClipPrimitive | undefined {\r\n    // try known derived classes first . . .\r\n    const shape = ClipShape.fromClipShapeJSON(json);\r\n    if (shape)\r\n      return shape;\r\n    const prim = ClipPrimitive.fromJSONClipPrimitive(json);\r\n    if (prim)\r\n      return prim;\r\n    return undefined;\r\n  }\r\n  /** Specific converter producing the base class ClipPrimitive. */\r\n  public static fromJSONClipPrimitive(json: any): ClipPrimitive | undefined {\r\n    if (json && json.planes) {\r\n      const planes = json.planes;\r\n      const clipPlanes = planes.hasOwnProperty(\"clips\") ? UnionOfConvexClipPlaneSets.fromJSON(planes.clips) : undefined;\r\n      const invisible = planes.hasOwnProperty(\"invisible\") ? planes.invisible : false;\r\n      return new ClipPrimitive(clipPlanes, invisible);\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/** Internal helper class holding XYZ components that serves as a representation of polygon edges defined by clip planes */\r\nclass PolyEdge {\r\n  public origin: Point3d;\r\n  public next: Point3d;\r\n  public normal: Vector2d;\r\n\r\n  public constructor(origin: Point3d, next: Point3d, normal: Vector2d, z: number) {\r\n    this.origin = Point3d.create(origin.x, origin.y, z);\r\n    this.next = Point3d.create(next.x, next.y, z);\r\n    this.normal = normal;\r\n  }\r\n}\r\n/**\r\n * A clipping volume defined by a shape (an array of 3d points using only x and y dimensions).\r\n * May be given either a ClipPlaneSet to store directly, or an array of polygon points as well as other parameters\r\n * for parsing clipplanes from the shape later.\r\n * @public\r\n */\r\nexport class ClipShape extends ClipPrimitive {\r\n  /** Points of the polygon, in the xy plane of the local coordinate system.  */\r\n  protected _polygon: Point3d[];\r\n  /** optional low z (in local coordinates) */\r\n  protected _zLow?: number;\r\n  /** optional high z (in local coordinates) */\r\n  protected _zHigh?: number;\r\n  /** true if this is considered a hole (keep geometry outside of the polygon.) */\r\n  protected _isMask: boolean;\r\n  /** transform from local to world */\r\n  protected _transformFromClip?: Transform;\r\n  /** Transform from world to local */\r\n  protected _transformToClip?: Transform;\r\n  protected constructor(polygon: Point3d[] = [], zLow?: number, zHigh?: number, transform?: Transform, isMask: boolean = false, invisible: boolean = false) {\r\n    super(undefined, invisible); // ClipPlaneSets will be set up later after storing points\r\n    this._isMask = false;\r\n    this._polygon = polygon;\r\n    this.initSecondaryProps(isMask, zLow, zHigh, transform);\r\n  }\r\n  /** Returns true if this ClipShape is marked as invisible. */\r\n  public get invisible(): boolean { return this._invisible; }\r\n  /** Return this transformFromClip, which may be undefined. */\r\n  public get transformFromClip(): Transform | undefined { return this._transformFromClip; }\r\n  /** Return this transformToClip, which may be undefined. */\r\n  public get transformToClip(): Transform | undefined { return this._transformToClip; }\r\n  /** Returns true if this ClipShape's transforms are currently set. */\r\n  public get transformValid(): boolean { return this.transformFromClip !== undefined; }\r\n  /** Returns true if this ClipShape's lower z boundary is set. */\r\n  public get zLowValid(): boolean { return this._zLow !== undefined; }\r\n  /** Returns true if this ClipShape's upper z boundary is set. */\r\n  public get zHighValid(): boolean { return this._zHigh !== undefined; }\r\n  /** Return true if this ClipShape has a local to world transform */\r\n  public get transformIsValid(): boolean { return this._transformFromClip !== undefined; }\r\n  /** Return this zLow, which may be undefined. */\r\n  public get zLow(): number | undefined { return this._zLow; }\r\n  /** Return this zHigh, which may be undefined. */\r\n  public get zHigh(): number | undefined { return this._zHigh; }\r\n  /** Returns a reference to this ClipShape's polygon array. */\r\n  public get polygon(): Point3d[] { return this._polygon; }\r\n  /** Returns true if this ClipShape is a masking set. */\r\n  public get isMask(): boolean { return this._isMask; }\r\n  /** Sets the polygon points array of this ClipShape to the array given (by reference). */\r\n  public setPolygon(polygon: Point3d[]) {\r\n    // Add closure point\r\n    if (!polygon[0].isAlmostEqual(polygon[polygon.length - 1]))\r\n      polygon.push(polygon[0].clone());\r\n    this._polygon = polygon;\r\n  }\r\n  /**\r\n   * * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is defined, do nothing.\r\n   * * If the ClipShape's associated `UnionOfConvexClipPlaneSets` is undefined, generate it from the `ClipShape` and transform.\r\n   */\r\n  public ensurePlaneSets() {\r\n    if (this._clipPlanes !== undefined)\r\n      return;\r\n    this._clipPlanes = UnionOfConvexClipPlaneSets.createEmpty();\r\n    this.parseClipPlanes(this._clipPlanes);\r\n    if (this._transformFromClip)\r\n      this._clipPlanes!.transformInPlace(this._transformFromClip!);\r\n  }\r\n  /**\r\n   * Initialize the members of the ClipShape class that may at times be undefined.\r\n   * zLow and zHigh default to Number.MAX_VALUE, and the transform defaults to an identity transform\r\n   */\r\n  public initSecondaryProps(isMask: boolean, zLow?: number, zHigh?: number, transform?: Transform) {\r\n    this._isMask = isMask;\r\n    this._zLow = zLow;\r\n    this._zHigh = zHigh;\r\n\r\n    if (transform !== undefined) {\r\n      this._transformFromClip = transform;\r\n      this._transformToClip = transform.inverse(); // could be undefined\r\n    } else {\r\n      this._transformFromClip = Transform.createIdentity();\r\n      this._transformToClip = Transform.createIdentity();\r\n    }\r\n  }\r\n  /** emit json object form */\r\n  public toJSON(): any {\r\n    const val: any = {};\r\n    val.shape = {};\r\n    val.shape.points = [];\r\n    for (const pt of this._polygon)\r\n      val.shape.points.push(pt.toJSON());\r\n    if (this.invisible)\r\n      val.shape.invisible = true;\r\n    if (this._transformFromClip && !this._transformFromClip.isIdentity)\r\n      val.shape.trans = this._transformFromClip.toJSON();\r\n    if (this.isMask)\r\n      val.shape.mask = true;\r\n    if (typeof (this.zLow) !== \"undefined\" && this.zLow !== -Number.MAX_VALUE)\r\n      val.shape.zlow = this.zLow;\r\n    if (typeof (this.zHigh) !== \"undefined\" && this.zHigh !== Number.MAX_VALUE)\r\n      val.shape.zhigh = this.zHigh;\r\n    return val;\r\n  }\r\n  /** parse `json` to a clip shape. */\r\n  public static fromClipShapeJSON(json: any, result?: ClipShape): ClipShape | undefined {\r\n    if (!json.shape)\r\n      return undefined;\r\n    const points: Point3d[] = [];\r\n    if (json.shape.points)\r\n      for (const pt of json.shape.points)\r\n        points.push(Point3d.fromJSON(pt));\r\n    let trans: Transform | undefined;\r\n    if (json.shape.trans)\r\n      trans = Transform.fromJSON(json.shape.trans);\r\n    let zLow: number | undefined;\r\n    if (undefined !== json.shape.zlow)\r\n      zLow = json.shape.zlow as number;\r\n    let zHigh: number | undefined;\r\n    if (undefined !== json.shape.zhigh)\r\n      zHigh = json.shape.zhigh as number;\r\n    let isMask = false;\r\n    if (json.shape.mask)\r\n      isMask = json.shape.mask as boolean;\r\n    let invisible = false;\r\n    if (json.shape.invisible)\r\n      invisible = true;\r\n    return ClipShape.createShape(points, zLow, zHigh, trans, isMask, invisible, result);\r\n  }\r\n  /** Returns a new ClipShape that is a deep copy of the ClipShape given */\r\n  public static createFrom(other: ClipShape, result?: ClipShape): ClipShape {\r\n    const retVal = ClipShape.createEmpty(false, false, undefined, result);\r\n    retVal._invisible = other._invisible;\r\n    for (const point of other._polygon) {\r\n      retVal._polygon.push(point.clone());\r\n    }\r\n    retVal._isMask = other._isMask;\r\n    retVal._zLow = other._zLow;\r\n    retVal._zHigh = other._zHigh;\r\n    retVal._transformToClip = other._transformToClip ? other._transformToClip.clone() : undefined;\r\n    retVal._transformFromClip = other._transformFromClip ? other._transformFromClip.clone() : undefined;\r\n    return retVal;\r\n  }\r\n  /** Create a new ClipShape from an array of points that make up a 2d shape (stores a deep copy of these points). */\r\n  public static createShape(polygon: Point3d[] = [], zLow?: number, zHigh?: number, transform?: Transform, isMask: boolean = false, invisible: boolean = false, result?: ClipShape): ClipShape | undefined {\r\n    if (polygon.length < 3)\r\n      return undefined;\r\n    const pPoints = polygon.slice(0);\r\n    // Add closure point\r\n    if (!pPoints[0].isExactEqual(pPoints[pPoints.length - 1]))\r\n      pPoints.push(pPoints[0]);\r\n    if (result) {\r\n      result._clipPlanes = undefined; // Start as undefined\r\n      result._invisible = invisible;\r\n      result._polygon = pPoints;\r\n      result.initSecondaryProps(isMask, zLow, zHigh, transform);\r\n      return result;\r\n    } else {\r\n      return new ClipShape(pPoints, zLow, zHigh, transform, isMask, invisible);\r\n    }\r\n  }\r\n  /**\r\n   * Create a ClipShape that exists as a 3 dimensional box of the range given. Optionally choose to\r\n   * also store this shape's zLow and zHigh members from the range through the use of a RangePlaneBitMask.\r\n   */\r\n  public static createBlock(extremities: Range3d, clipMask: ClipMaskXYZRangePlanes, isMask: boolean = false, invisible: boolean = false, transform?: Transform, result?: ClipShape): ClipShape {\r\n    const low = extremities.low;\r\n    const high = extremities.high;\r\n    const blockPoints: Point3d[] = [];\r\n    for (let i = 0; i < 5; i++)\r\n      blockPoints.push(Point3d.create());\r\n    blockPoints[0].x = blockPoints[3].x = blockPoints[4].x = low.x;\r\n    blockPoints[1].x = blockPoints[2].x = high.x;\r\n    blockPoints[0].y = blockPoints[1].y = blockPoints[4].y = low.y;\r\n    blockPoints[2].y = blockPoints[3].y = high.y;\r\n    return ClipShape.createShape(blockPoints, (ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZLow)) ? low.z : undefined, ClipMaskXYZRangePlanes.None !== (clipMask & ClipMaskXYZRangePlanes.ZHigh) ? high.z : undefined, transform, isMask, invisible, result)!;\r\n  }\r\n  /** Creates a new ClipShape with undefined members and a polygon points array of zero length. */\r\n  public static createEmpty(isMask = false, invisible: boolean = false, transform?: Transform, result?: ClipShape): ClipShape {\r\n    if (result) {\r\n      result._clipPlanes = undefined;\r\n      result._invisible = invisible;\r\n      result._polygon.length = 0;\r\n      result.initSecondaryProps(isMask, undefined, undefined, transform);\r\n      return result;\r\n    }\r\n    return new ClipShape([], undefined, undefined, transform, isMask, invisible);\r\n  }\r\n  /** Checks to ensure that the member polygon has an area, and that the polygon is closed. */\r\n  public get isValidPolygon(): boolean {\r\n    if (this._polygon.length < 3)\r\n      return false;\r\n    if (!this._polygon[0].isExactEqual(this._polygon[this._polygon.length - 1]))\r\n      return false;\r\n    return true;\r\n  }\r\n  /** Returns a deep copy of this instance of ClipShape, storing in an optional result */\r\n  public clone(result?: ClipShape): ClipShape {\r\n    return ClipShape.createFrom(this, result);\r\n  }\r\n  /** Given the current polygon data, parses clip planes that together form an object, storing the result in the set given, either clipplanes or maskplanes. */\r\n  private parseClipPlanes(set: UnionOfConvexClipPlaneSets) {\r\n    const points = this._polygon;\r\n    if (points.length === 3 && !this._isMask && points[0].isExactEqual(points[points.length - 1])) {\r\n      this.parseLinearPlanes(set, this._polygon[0], this._polygon[1]);\r\n      return true;\r\n    }\r\n    const direction = PolygonOps.testXYPolygonTurningDirections(points);\r\n    if (0 !== direction) {\r\n      this.parseConvexPolygonPlanes(set, this._polygon, direction);\r\n      return true;\r\n    } else {\r\n      this.parseConcavePolygonPlanes(set, this._polygon);\r\n      return false;\r\n    }\r\n  }\r\n  /** Given a start and end point, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region of linear planes. Returns true if successful. */\r\n  private parseLinearPlanes(set: UnionOfConvexClipPlaneSets, start: Point3d, end: Point3d, cameraFocalLength?: number): boolean {\r\n    // Handles the degenerate case of 2 distinct points (used by select by line).\r\n    const normal = start.vectorTo(end);\r\n    if (normal.magnitude() === 0.0)\r\n      return false;\r\n    normal.normalize(normal);\r\n    const convexSet = ConvexClipPlaneSet.createEmpty();\r\n    if (cameraFocalLength === undefined) {\r\n      const perpendicular = Vector2d.create(-normal.y, normal.x);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(normal.x, normal.y), Point3d.createFrom(start), this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(-normal.x, -normal.y), Point3d.createFrom(end), this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(perpendicular.x, perpendicular.y), Point3d.createFrom(start), this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(-perpendicular.x, -perpendicular.y), Point3d.createFrom(start), this._invisible)!);\r\n    } else {\r\n      const start3d = Point3d.create(start.x, start.y, -cameraFocalLength);\r\n      const end3d = Point3d.create(end.x, end.y, -cameraFocalLength);\r\n      const vecEnd3d = Vector3d.createFrom(end3d);\r\n      const perpendicular = vecEnd3d.crossProduct(Vector3d.createFrom(start3d)).normalize();\r\n      let endNormal = Vector3d.createFrom(start3d).crossProduct(perpendicular!).normalize();\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(perpendicular!, 0.0, this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(endNormal!, 0.0, this._invisible)!);\r\n      perpendicular!.negate();\r\n      endNormal = vecEnd3d.crossProduct(perpendicular!).normalize();\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(perpendicular!, 0.0, this._invisible)!);\r\n      convexSet.planes.push(ClipPlane.createNormalAndDistance(endNormal!, 0.0, this._invisible)!);\r\n    }\r\n    convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\r\n    set.addConvexSet(convexSet);\r\n    return true;\r\n  }\r\n  /** Given a convex polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with ConvexClipPlaneSets defining the bounded region. Returns true if successful. */\r\n  private parseConvexPolygonPlanes(set: UnionOfConvexClipPlaneSets, polygon: Point3d[], direction: number, cameraFocalLength?: number): boolean {\r\n    const samePointTolerance = 1.0e-8; // This could possibly be replaced with more widely used constants\r\n    const edges: PolyEdge[] = [];\r\n    const reverse = (direction < 0) !== this._isMask;\r\n    for (let i = 0; i < polygon.length - 1; i++) {\r\n      const z = (cameraFocalLength === undefined) ? 0.0 : -cameraFocalLength;\r\n      const dir = Vector2d.createFrom((polygon[i + 1].minus(polygon[i])));\r\n      const magnitude = dir.magnitude();\r\n      dir.normalize(dir);\r\n      if (magnitude > samePointTolerance) {\r\n        const normal = Vector2d.create(reverse ? dir.y : -dir.y, reverse ? -dir.x : dir.x);\r\n        edges.push(new PolyEdge(polygon[i], polygon[i + 1], normal, z));\r\n      }\r\n    }\r\n    if (edges.length < 3) {\r\n      return false;\r\n    }\r\n    if (this._isMask) {\r\n      const last = edges.length - 1;\r\n      for (let i = 0; i <= last; i++) {\r\n        const edge = edges[i];\r\n        const prevEdge = edges[i ? (i - 1) : last];\r\n        const nextEdge = edges[(i === last) ? 0 : (i + 1)];\r\n        const convexSet = ConvexClipPlaneSet.createEmpty();\r\n        const prevNormal = edge.normal.minus(prevEdge.normal);\r\n        const nextNormal = edge.normal.minus(nextEdge.normal);\r\n        prevNormal.normalize(prevNormal);\r\n        nextNormal.normalize(nextNormal);\r\n        // Create three-sided fans from each edge.   Note we could define the correct region\r\n        // with only two planes for edge, but cannot then designate the \"interior\" status of the edges accurately.\r\n        convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(prevNormal.x, prevNormal.y), edge.origin, this._invisible, true)!);\r\n        convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(edge.normal.x, edge.normal.y), edge.origin, this._invisible, false)!);\r\n        convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(nextNormal.x, nextNormal.y), nextEdge.origin, this._invisible, true)!);\r\n        convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\r\n        set.addConvexSet(convexSet);\r\n      }\r\n      set.addOutsideZClipSets(this._invisible, this._zLow, this._zHigh);\r\n    } else {\r\n      const convexSet = ConvexClipPlaneSet.createEmpty();\r\n      if (cameraFocalLength === undefined) {\r\n        for (const edge of edges)\r\n          convexSet.planes.push(ClipPlane.createNormalAndPoint(Vector3d.create(edge.normal.x, edge.normal.y), edge.origin)!);\r\n      } else {\r\n        if (reverse)\r\n          for (const edge of edges)\r\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(Vector3d.createFrom(edge.origin).crossProduct(Vector3d.createFrom(edge.next)).normalize()!, 0.0)!);\r\n        else\r\n          for (const edge of edges)\r\n            convexSet.planes.push(ClipPlane.createNormalAndDistance(Vector3d.createFrom(edge.next).crossProduct(Vector3d.createFrom(edge.origin)).normalize()!, 0.0)!);\r\n      }\r\n      convexSet.addZClipPlanes(this._invisible, this._zLow, this._zHigh);\r\n      set.addConvexSet(convexSet);\r\n    }\r\n    return true;\r\n  }\r\n  /** Given a concave polygon defined as an array of points, populate the given UnionOfConvexClipPlaneSets with multiple ConvexClipPlaneSets defining the bounded region. Returns true if successful. */\r\n  private parseConcavePolygonPlanes(set: UnionOfConvexClipPlaneSets, polygon: Point3d[], cameraFocalLength?: number): boolean {\r\n    const triangulatedPolygon = Triangulator.createTriangulatedGraphFromSingleLoop(polygon);\r\n    Triangulator.flipTriangles(triangulatedPolygon);\r\n    triangulatedPolygon.announceFaceLoops((_graph: HalfEdgeGraph, edge: HalfEdge): boolean => {\r\n      if (!edge.isMaskSet(HalfEdgeMask.EXTERIOR)) {\r\n        const convexFacetPoints = edge.collectAroundFace((node: HalfEdge): any => {\r\n          if (!node.isMaskSet(HalfEdgeMask.EXTERIOR))\r\n            return Point3d.create(node.x, node.y, 0);\r\n        });\r\n        // parseConvexPolygonPlanes expects a closed loop (pushing the reference doesn't matter)\r\n        convexFacetPoints.push(convexFacetPoints[0]);\r\n        const direction = PolygonOps.testXYPolygonTurningDirections(convexFacetPoints); // ###TODO: Can we expect a direction coming out of graph facet?\r\n        this.parseConvexPolygonPlanes(set, convexFacetPoints, direction, cameraFocalLength);\r\n      }\r\n      return true;\r\n    });\r\n    return true;\r\n  }\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    this.ensurePlaneSets();\r\n    return super.multiplyPlanesByMatrix4d(matrix, invert, transpose);\r\n  }\r\n  /** Apply `transform` to the local to world (`transformFromClip`) transform.\r\n   * * The world to local transform (`transformToClip` is recomputed from the (changed) `transformToClip`\r\n   * * the transform is passed to the base class to be applied to clip plane form of the clipper.\r\n   */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    if (transform.isIdentity)\r\n      return true;\r\n    super.transformInPlace(transform);\r\n    if (this._transformFromClip)\r\n      transform.multiplyTransformTransform(this._transformFromClip!, this._transformFromClip);\r\n    else\r\n      this._transformFromClip = transform.clone();\r\n    this._transformToClip = this._transformFromClip!.inverse(); // could be undefined\r\n    return true;\r\n  }\r\n  /** Return true if\r\n   * * at least one point is defined\r\n   * * The local to world transform (transformFromClip) either\r\n   *   * is undefined\r\n   *   * has no xy parts in its column Z (local frame Z is parallel to global Z)\r\n   */\r\n  public get isXYPolygon(): boolean {\r\n    if (this._polygon.length === 0) // Note: This is a lenient check, as points array could also contain less than 3 points (not a polygon)\r\n      return false;\r\n    if (this._transformFromClip === undefined)\r\n      return true;\r\n    const zVector = this._transformFromClip.matrix.columnZ();\r\n    return zVector.magnitudeXY() < 1.0e-8;\r\n  }\r\n  /** Transform the input point using this instance's transformToClip member */\r\n  public performTransformToClip(point: Point3d) {\r\n    if (this._transformToClip !== undefined)\r\n      this._transformToClip.multiplyPoint3d(point);\r\n  }\r\n  /** Transform the input point using this instance's transformFromClip member */\r\n  public performTransformFromClip(point: Point3d) {\r\n    if (this._transformFromClip !== undefined)\r\n      this._transformFromClip.multiplyPoint3d(point);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range1d, Range3d } from \"../geometry3d/Range\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { UnionOfConvexClipPlaneSets } from \"./UnionOfConvexClipPlaneSets\";\r\nimport { CurvePrimitive, AnnounceNumberNumber, AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { ClipPrimitive } from \"./ClipPrimitive\";\r\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { ClipVector } from \"./ClipVector\";\r\n\r\n/** Enumerated type for describing where geometry lies with respect to clipping planes.\r\n * @public\r\n */\r\nexport enum ClipPlaneContainment {\r\n  /** All points inside */\r\n  StronglyInside = 1,\r\n  /** Inside/outside state unknown. */\r\n  Ambiguous = 2,\r\n  /** All points outside */\r\n  StronglyOutside = 3,\r\n}\r\n\r\n/** Enumerated type for describing what must yet be done to clip a piece of geometry.\r\n * @public\r\n */\r\nexport enum ClipStatus {\r\n  /** some geometry may cross the clip boundaries */\r\n  ClipRequired,\r\n  /** geometry is clearly outside */\r\n  TrivialReject,\r\n  /** geometry is clearly inside */\r\n  TrivialAccept,\r\n}\r\n\r\n/** An object containing clipping planes that can be used to clip geometry.\r\n * @public\r\n */\r\nexport interface Clipper {\r\n  /** test if `point` is on or inside the Clipper's volume. */\r\n  isPointOnOrInside(point: Point3d, tolerance?: number): boolean;\r\n  /** Find the parts of the line segment  (if any) that is within the convex clip volume.\r\n   * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.\r\n   * * To clip to the usual bounded line segment, start with fractions (0,1).\r\n   * If the clip volume is unbounded, the line interval may also be unbounded.\r\n   * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.\r\n   * @param f0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)\r\n   * @param f1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)\r\n   * @param pointA segment start (fraction 0)\r\n   * @param pointB segment end (fraction 1)\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if a segment was announced, false if entirely outside.\r\n   */\r\n  announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: AnnounceNumberNumber): boolean;\r\n  /** Find the portion (or portions) of the arc (if any) that are within the convex clip volume.\r\n   * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if one or more arcs portions were announced, false if entirely outside.\r\n   */\r\n  announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean;\r\n}\r\n\r\n/** Static class whose various methods are functions for clipping geometry\r\n * @public\r\n */\r\nexport class ClipUtilities {\r\n  private static _selectIntervals01TestPoint = Point3d.create();\r\n  /**\r\n   * * Augment the unsortedFractionsArray with 0 and 1\r\n   * * sort\r\n   * * test the midpoint of each interval with `clipper.isPointOnOrInside`\r\n   * * pass accepted intervals to `announce(f0,f1,curve)`\r\n   */\r\n  public static selectIntervals01(curve: CurvePrimitive, unsortedFractions: GrowableFloat64Array, clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    unsortedFractions.push(0);\r\n    unsortedFractions.push(1);\r\n    unsortedFractions.sort();\r\n    let f0 = unsortedFractions.atUncheckedIndex(0);\r\n    let f1;\r\n    let fMid;\r\n    const testPoint = ClipUtilities._selectIntervals01TestPoint;\r\n    const n = unsortedFractions.length;\r\n    for (let i = 1; i < n; i++ , f0 = f1) {\r\n      f1 = unsortedFractions.atUncheckedIndex(i);\r\n      fMid = 0.5 * (f0 + f1);\r\n      if (f1 > f0 && (fMid >= 0.0 && fMid <= 1.0)) {\r\n        curve.fractionToPoint(fMid, testPoint);\r\n        if (clipper.isPointOnOrInside(testPoint)) {\r\n          if (announce)\r\n            announce(f0, f1, curve);\r\n          else\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Announce triples of (low, high, cp) for each entry in intervals\r\n   * @param intervals source array\r\n   * @param cp CurvePrimitive for announcement\r\n   * @param announce function to receive data\r\n   */\r\n  public static announceNNC(intervals: Range1d[], cp: CurvePrimitive, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    if (announce) {\r\n      for (const ab of intervals) {\r\n        announce(ab.low, ab.high, cp);\r\n      }\r\n    }\r\n    return intervals.length > 0;\r\n  }\r\n\r\n  /** Find portions of the curve that are within the clipper.\r\n   * Collect them into an array of curve primitives.\r\n   */\r\n  public static collectClippedCurves(curve: CurvePrimitive, clipper: Clipper): CurvePrimitive[] {\r\n    const result: CurvePrimitive[] = [];\r\n    curve.announceClipIntervals(clipper,\r\n      (fraction0: number, fraction1: number, curveA: CurvePrimitive) => {\r\n        if (fraction1 !== fraction0) {\r\n          const partialCurve = curveA.clonePartialCurve(fraction0, fraction1);\r\n          if (partialCurve)\r\n            result.push(partialCurve);\r\n        }\r\n      });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Clip a polygon down to regions defined by each shape of a ClipShape.\r\n   * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.\r\n   */\r\n  public static clipPolygonToClipShape(polygon: Point3d[], clipShape: ClipPrimitive): Point3d[][] {\r\n    const outputA = this.clipPolygonToClipShapeReturnGrowableXYZArrays(polygon, clipShape);\r\n    const output = [];\r\n    for (const g of outputA)\r\n      output.push(g.getPoint3dArray());\r\n    return output;\r\n  }\r\n\r\n  /**\r\n   * Clip a polygon down to regions defined by each shape of a ClipShape.\r\n   * @return An multidimensional array of points, where each array is the boundary of part of the remaining polygon.\r\n   */\r\n  public static clipPolygonToClipShapeReturnGrowableXYZArrays(polygon: Point3d[], clipShape: ClipPrimitive): GrowableXYZArray[] {\r\n    const output: GrowableXYZArray[] = [];\r\n    const clipper = clipShape.fetchClipPlanesRef();\r\n    // NEEDS WORK -- what if it is a mask !!!!\r\n    if (clipper) {\r\n      clipper.polygonClip(polygon, output);\r\n    }\r\n    return output;\r\n  }\r\n\r\n  /** Given an array of points, test for trivial containment conditions.\r\n   * * ClipStatus.TrivialAccept if all points are in any one of the convexSet's.\r\n   * * ClipStatus.ClipRequired if (in any single convexSet) there were points on both sides of any single plane.\r\n   * * ClipStatus.TrivialReject if neither of those occurred.\r\n   */\r\n  public static pointSetSingleClipStatus(points: GrowableXYZArray, planeSet: UnionOfConvexClipPlaneSets, tolerance: number): ClipStatus {\r\n    if (planeSet.convexSets.length === 0)\r\n      return ClipStatus.TrivialAccept;\r\n\r\n    for (const convexSet of planeSet.convexSets) {\r\n      let allOutsideSinglePlane = false, anyOutside = false;\r\n\r\n      for (const plane of convexSet.planes) {\r\n        let numInside = 0, numOutside = 0;\r\n        const planeDistance = plane.distance - tolerance;\r\n\r\n        const currPt = Point3d.create();\r\n        const currVec = Vector3d.create();\r\n        for (let i = 0; i < points.length; i++) {\r\n          points.getPoint3dAtUncheckedPointIndex(i, currPt);\r\n          currVec.setFrom(currPt);\r\n          currVec.dotProduct(plane.inwardNormalRef) > planeDistance ? numInside++ : numOutside++;\r\n        }\r\n\r\n        anyOutside = (numOutside !== 0) ? true : anyOutside;\r\n        if (numInside === 0) {\r\n          allOutsideSinglePlane = true;\r\n          break;\r\n        }\r\n      }\r\n\r\n      if (!anyOutside)  // totally inside this set - no clip required\r\n        return ClipStatus.TrivialAccept;\r\n      if (!allOutsideSinglePlane)\r\n        return ClipStatus.ClipRequired;\r\n    }\r\n    return ClipStatus.TrivialReject;\r\n  }\r\n\r\n  /**\r\n   * Emit point loops for intersection of a convex set with a range.\r\n   * * return zero length array for (a) null range or (b) no intersections\r\n   * @param range range to intersect\r\n   * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\r\n   * @param includeRangeFaces if false, do not compute facets originating as range faces\r\n   * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\r\n   */\r\n  public static announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet: ConvexClipPlaneSet, range: Range3d, loopFunction: (loopPoints: GrowableXYZArray) => void,\r\n    includeConvexSetFaces: boolean = true, includeRangeFaces: boolean = true, ignoreInvisiblePlanes = false) {\r\n    const work = new GrowableXYZArray();\r\n    if (includeConvexSetFaces) {\r\n      // Clip convexSet planes to the range and to the rest of the convexSet . .\r\n      for (const plane of convexSet.planes) {\r\n        if (ignoreInvisiblePlanes && plane.invisible)\r\n          continue;\r\n        const pointsClippedToRange = plane.intersectRange(range, true);\r\n        const finalPoints = new GrowableXYZArray();\r\n        if (pointsClippedToRange) {\r\n          convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);\r\n          if (finalPoints.length > 0)\r\n            loopFunction(finalPoints);\r\n        }\r\n      }\r\n    }\r\n\r\n    if (includeRangeFaces) {\r\n      // clip range faces to the convex set . . .\r\n      const corners = range.corners();\r\n      for (let i = 0; i < 6; i++) {\r\n        const indices = Range3d.faceCornerIndices(i);\r\n        const finalPoints = new GrowableXYZArray();\r\n        const lineString = LineString3d.createIndexedPoints(corners, indices);\r\n        convexSet.polygonClip(lineString.packedPoints, finalPoints, work);\r\n        if (finalPoints.length > 0)\r\n          loopFunction(finalPoints);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Return a (possibly empty) array of geometry (Loops !!) which are facets of the intersection of the convex set intersecting a range.\r\n   * * return zero length array for (a) null range or (b) no intersections\r\n   * @param range range to intersect\r\n   * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\r\n   * @param includeRangeFaces if false, do not compute facets originating as range faces\r\n   * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\r\n   */\r\n  public static loopsOfConvexClipPlaneIntersectionWithRange(convexSet: ConvexClipPlaneSet, range: Range3d,\r\n    includeConvexSetFaces: boolean = true, includeRangeFaces: boolean = true, ignoreInvisiblePlanes = false): GeometryQuery[] {\r\n    const result: GeometryQuery[] = [];\r\n    this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range,\r\n      (points: GrowableXYZArray) => {\r\n        if (points.length > 0) result.push(Loop.createPolygon(points));\r\n      },\r\n      includeConvexSetFaces, includeRangeFaces, ignoreInvisiblePlanes);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the (possibly null) range of the intersection of the convex set with a range.\r\n   * * The convex set is permitted to be unbounded (e.g. a single plane).  The range parameter provides bounds.\r\n   * @param convexSet convex set for intersection.\r\n   * @param range range to intersect\r\n   */\r\n  public static rangeOfConvexClipPlaneSetIntersectionWithRange(convexSet: ConvexClipPlaneSet, range: Range3d): Range3d {\r\n    const result = Range3d.createNull();\r\n    this.announceLoopsOfConvexClipPlaneSetIntersectRange(convexSet, range,\r\n      (points: GrowableXYZArray) => {\r\n        if (points.length > 0) result.extendArray(points);\r\n      },\r\n      true, true, false);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the range of various types of clippers\r\n   * * `ConvexClipPlaneSet` -- dispatch to `rangeOfConvexClipPlaneSetIntersectionWithRange`\r\n   * * `UnionOfConvexClipPlaneset` -- union of ranges of member `ConvexClipPlaneSet`\r\n   * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.\r\n   * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.\r\n   * * `undefined` -- entire input range.\r\n   * * If `observeInvisibleFlag` is false, the \"invisible\" properties are ignored, and this effectively returns the range of the edge work of the members\r\n   * * If `observeInvisibleFlag` is false, the \"invisible\" properties are observed, and \"invisible\" parts do not restrict the range.\r\n   * @param clipper\r\n   * @param range non-null range.\r\n   * @param observeInvisibleFlag indicates how \"invisible\" bit is applied for ClipPrimitive.\r\n   */\r\n  public static rangeOfClipperIntersectionWithRange(clipper: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPrimitive | ClipVector | undefined, range: Range3d, observeInvisibleFlag: boolean = true): Range3d {\r\n    if (clipper === undefined)\r\n      return range.clone();\r\n    if (clipper instanceof ConvexClipPlaneSet)\r\n      return this.rangeOfConvexClipPlaneSetIntersectionWithRange(clipper, range);\r\n    if (clipper instanceof UnionOfConvexClipPlaneSets) {\r\n      const rangeUnion = Range3d.createNull();\r\n      for (const c of clipper.convexSets) {\r\n        const rangeC = this.rangeOfConvexClipPlaneSetIntersectionWithRange(c, range);\r\n        rangeUnion.extendRange(rangeC);\r\n      }\r\n      return rangeUnion;\r\n    }\r\n    if (clipper instanceof ClipPrimitive) {\r\n      if (observeInvisibleFlag && clipper.invisible)\r\n        return range.clone();\r\n      return this.rangeOfClipperIntersectionWithRange(clipper.fetchClipPlanesRef(), range);\r\n    }\r\n    if (clipper instanceof ClipVector) {\r\n      const rangeIntersection = range.clone();\r\n      for (const c of clipper.clips) {\r\n        if (observeInvisibleFlag && c.invisible) {\r\n          // trivial range tests do not expose the effects.   Assume the hole allows everything.\r\n        } else {\r\n          const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);\r\n          rangeIntersection.intersect(rangeC, rangeIntersection);\r\n        }\r\n      }\r\n      return rangeIntersection;\r\n\r\n    }\r\n    return range.clone();\r\n  }\r\n  /**\r\n   * Test if various types of clippers have any intersection with a range.\r\n   * * This follows the same logic as `rangeOfClipperIntersectionWithRange` but attempts to exit at earliest point of confirmed intersection\r\n   * * `ConvexClipPlaneSet` -- dispatch to `doesConvexClipPlaneSetIntersectRange`\r\n   * * `UnionOfConvexClipPlaneset` -- union of ranges of member `ConvexClipPlaneSet`\r\n   * * `ClipPrimitive` -- access its `UnionOfConvexClipPlaneSet`.\r\n   * * `ClipVector` -- intersection of the ranges of its `ClipPrimitive`.\r\n   * * `undefined` -- entire input range.\r\n   * * If `observeInvisibleFlag` is false, the \"invisible\" properties are ignored, and holes do not affect the result.\r\n   * * If `observeInvisibleFlag` is true, the \"invisible\" properties are observed, and may affect the result.\r\n   * @param clipper\r\n   * @param range non-null range.\r\n   * @param observeInvisibleFlag indicates how \"invisible\" bit is applied for ClipPrimitive.\r\n   */\r\n  public static doesClipperIntersectRange(clipper: ConvexClipPlaneSet | UnionOfConvexClipPlaneSets | ClipPrimitive | ClipVector | undefined, range: Range3d, observeInvisibleFlag: boolean = true): boolean {\r\n    if (clipper === undefined)\r\n      return true;\r\n\r\n    if (clipper instanceof ConvexClipPlaneSet)\r\n      return this.doesConvexClipPlaneSetIntersectRange(clipper, range);\r\n\r\n    if (clipper instanceof UnionOfConvexClipPlaneSets) {\r\n      for (const c of clipper.convexSets) {\r\n        if (this.doesConvexClipPlaneSetIntersectRange(c, range))\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n\r\n    if (clipper instanceof ClipPrimitive) {\r\n      if (observeInvisibleFlag && clipper.invisible)    // um is there an easy way to detect range-completely-inside?\r\n        return true;\r\n      return this.doesClipperIntersectRange(clipper.fetchClipPlanesRef(), range);\r\n    }\r\n\r\n    if (clipper instanceof ClipVector) {\r\n      const rangeIntersection = range.clone();\r\n      for (const c of clipper.clips) {\r\n        if (observeInvisibleFlag && c.invisible) {\r\n          // trivial range tests do not expose the effects.   Assume the hole allows everything.\r\n        } else {\r\n          const rangeC = this.rangeOfClipperIntersectionWithRange(c, range, observeInvisibleFlag);\r\n          rangeIntersection.intersect(rangeC, rangeIntersection);\r\n        }\r\n      }\r\n      return !rangeIntersection.isNull;\r\n    }\r\n    /** If the case statement above is complete for the variant inputs, this is unreachable .. */\r\n    return false;\r\n  }\r\n  /**\r\n   * Emit point loops for intersection of a convex set with a range.\r\n   * * return zero length array for (a) null range or (b) no intersections\r\n   * @param range range to intersect\r\n   * @param includeConvexSetFaces if false, do not compute facets originating as convex set planes.\r\n   * @param includeRangeFaces if false, do not compute facets originating as range faces\r\n   * @param ignoreInvisiblePlanes if true, do NOT compute a facet for convex set faces marked invisible.\r\n   */\r\n  public static doesConvexClipPlaneSetIntersectRange(convexSet: ConvexClipPlaneSet, range: Range3d,\r\n    includeConvexSetFaces: boolean = true, includeRangeFaces: boolean = true, ignoreInvisiblePlanes = false): boolean {\r\n    const work = new GrowableXYZArray();\r\n    if (includeConvexSetFaces) {\r\n      // Clip convexSet planes to the range and to the rest of the convexSet . .\r\n      for (const plane of convexSet.planes) {\r\n        if (ignoreInvisiblePlanes && plane.invisible)\r\n          continue;\r\n        const pointsClippedToRange = plane.intersectRange(range, true);\r\n        if (pointsClippedToRange) {\r\n          const finalPoints = new GrowableXYZArray();\r\n          convexSet.polygonClip(pointsClippedToRange, finalPoints, work, plane);\r\n          if (finalPoints.length > 0)\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (includeRangeFaces) {\r\n      // clip range faces to the convex set . . .\r\n      const corners = range.corners();\r\n      for (let i = 0; i < 6; i++) {\r\n        const indices = Range3d.faceCornerIndices(i);\r\n        const finalPoints = new GrowableXYZArray();\r\n        const lineString = LineString3d.createIndexedPoints(corners, indices);\r\n        convexSet.polygonClip(lineString.packedPoints, finalPoints, work);\r\n        if (finalPoints.length > 0)\r\n          return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { ClipPrimitive, ClipMaskXYZRangePlanes, ClipShape } from \"./ClipPrimitive\";\r\nimport { ClipPlaneContainment } from \"./ClipUtils\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\n\r\n/** Class holding an array structure of shapes defined by `ClipPrimitive`\r\n * * The `ClipVector` defines an intersection of the member `ClipPrimitive` regions.\r\n * * In the most common usage, one of the `ClipPrimitive` will be an outer region, and all others are holes with marker flag indicating that they outside of each hole is live.\r\n * @public\r\n */\r\nexport class ClipVector {\r\n  private _clips: ClipPrimitive[];\r\n  /** range acting as first filter.\r\n   * * This is understood as overall range limit, not as precise planes.\r\n   * * applying any rotation to the whole ClipVector generally expands this range, rather than exactly transforming its planes.\r\n   */\r\n  public boundingRange: Range3d = Range3d.createNull();\r\n\r\n  /** Returns a reference to the array of ClipShapes. */\r\n  public get clips() { return this._clips; }\r\n\r\n  private constructor(clips?: ClipPrimitive[]) {\r\n    this._clips = clips ? clips : [];\r\n  }\r\n\r\n  /** Returns true if this ClipVector contains a ClipPrimitive. */\r\n  public get isValid(): boolean { return this._clips.length > 0; }\r\n\r\n  /** Create a ClipVector with an empty set of ClipShapes. */\r\n  public static createEmpty(result?: ClipVector): ClipVector {\r\n    if (result) {\r\n      result._clips.length = 0;\r\n      return result;\r\n    }\r\n    return new ClipVector();\r\n  }\r\n\r\n  /** Create a ClipVector from an array of ClipPrimitives (or derived classes) (capture the pointers) */\r\n  public static createCapture(clips: ClipPrimitive[], result?: ClipVector): ClipVector {\r\n    if (result) {\r\n      result._clips = clips;\r\n      return result;\r\n    }\r\n    return new ClipVector(clips);\r\n  }\r\n\r\n  /** Create a ClipVector from (clones of) an array of ClipPrimitives */\r\n  public static create(clips: ClipPrimitive[], result?: ClipVector): ClipVector {\r\n    const clipClones: ClipPrimitive[] = [];\r\n    for (const clip of clips)\r\n      clipClones.push(clip.clone());\r\n    return ClipVector.createCapture(clipClones, result);\r\n  }\r\n\r\n  /** Create a deep copy of another ClipVector */\r\n  public clone(result?: ClipVector): ClipVector {\r\n    const retVal = result ? result : new ClipVector();\r\n    retVal._clips.length = 0;\r\n    for (const clip of this._clips) {\r\n      retVal._clips.push(clip.clone());\r\n    }\r\n    retVal.boundingRange.setFrom(this.boundingRange);\r\n    return retVal;\r\n  }\r\n\r\n  /** Parse this ClipVector into a JSON object. */\r\n  public toJSON(): any {\r\n    if (!this.isValid)\r\n      return [];\r\n\r\n    const val: any = [];\r\n    for (const clipShape of this.clips)\r\n      val.push(clipShape.toJSON());\r\n\r\n    return val;\r\n  }\r\n\r\n  /** Parse a JSON object into a new ClipVector. */\r\n  public static fromJSON(json: any, result?: ClipVector): ClipVector {\r\n    result = result ? result : new ClipVector();\r\n    result.clear();\r\n\r\n    try {\r\n      for (const clip of json) {\r\n        const clipPrim = ClipPrimitive.fromJSON(clip);\r\n        if (clipPrim)\r\n          result._clips.push(clipPrim);\r\n      }\r\n    } catch (e) {\r\n      result.clear();\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /** Empties out the array of ClipShapes. */\r\n  public clear() {\r\n    this._clips.length = 0;\r\n  }\r\n\r\n  /** Append a deep copy of the given ClipPrimitive to this ClipVector. */\r\n  public appendClone(clip: ClipPrimitive) {\r\n    this._clips.push(clip.clone());\r\n  }\r\n\r\n  /** Append a reference of the given ClipPrimitive to this ClipVector. */\r\n  public appendReference(clip: ClipPrimitive) {\r\n    this._clips.push(clip);\r\n  }\r\n\r\n  /** Create and append a new ClipPrimitive to the array given a shape as an array of points. Returns true if successful. */\r\n  public appendShape(shape: Point3d[], zLow?: number, zHigh?: number,\r\n    transform?: Transform, isMask: boolean = false, invisible: boolean = false): boolean {\r\n    const clip = ClipShape.createShape(shape, zLow, zHigh, transform, isMask, invisible);\r\n    if (!clip)\r\n      return false;\r\n    this._clips.push(clip);\r\n    return true;\r\n  }\r\n\r\n  /** Returns true if the given point lies inside all of this ClipVector's ClipShapes (by rule of intersection). */\r\n  public pointInside(point: Point3d, onTolerance: number = Geometry.smallMetricDistanceSquared): boolean {\r\n    if (!this.boundingRange.isNull && !this.boundingRange.containsPoint(point))\r\n      return false;\r\n\r\n    for (const clip of this._clips) {\r\n      if (!clip.pointInside(point, onTolerance))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Transforms this ClipVector to a new coordinate-system.\r\n   * Note that if the transform has rotate and scale the boundingRange member expands.\r\n   * Returns true if successful.\r\n   */\r\n  public transformInPlace(transform: Transform): boolean {\r\n    for (const clip of this._clips)\r\n      if (clip.transformInPlace(transform) === false)\r\n        return false;\r\n\r\n    if (!this.boundingRange.isNull)\r\n      transform.multiplyRange(this.boundingRange, this.boundingRange);\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * A simple way of packaging this ClipVector's ClipShape points into a multidimensional array, while also\r\n   * taking into account each ClipPrimitive's individual transforms.\r\n   *\r\n   * ClipPrimitives OTHER THAN ClipShape are ignored.\r\n   *\r\n   * Information out:\r\n   *  - All of the loop points are stored in the multidimensional Point3d array given (will return unchanged upon failure)\r\n   *  - If given a transform, will be set from the transformFromClip of the first ClipPrimitive\r\n   *  - The ClipMask of the final ClipPrimitive is stored in the returned array at index 0\r\n   *  - The last valid zLow found is stored in the returned array at index 1\r\n   *  - The last valid zHigh found is stored in the returned array at index 2\r\n   */\r\n  public extractBoundaryLoops(loopPoints: Point3d[][], transform?: Transform): number[] {\r\n    let clipM = ClipMaskXYZRangePlanes.None;\r\n    let zBack = -Number.MAX_VALUE;\r\n    let zFront = Number.MAX_VALUE;\r\n    const retVal: number[] = [];\r\n    let nLoops = 0;\r\n\r\n    if (this._clips.length === 0)\r\n      return retVal;\r\n    let firstClipShape: ClipShape | undefined;\r\n    const deltaTrans = Transform.createIdentity();\r\n\r\n    for (const clip of this._clips) {\r\n      if (clip instanceof ClipShape) {\r\n        if (firstClipShape !== undefined && clip !== firstClipShape) {      // Is not the first iteration\r\n          let fwdTrans = Transform.createIdentity();\r\n          let invTrans = Transform.createIdentity();\r\n\r\n          if (firstClipShape.transformValid && clip.transformValid) {\r\n            fwdTrans = clip.transformFromClip!.clone();\r\n            invTrans = firstClipShape.transformToClip!.clone();\r\n          }\r\n          deltaTrans.setFrom(invTrans.multiplyTransformTransform(fwdTrans));\r\n        }\r\n        if (!firstClipShape)\r\n          firstClipShape = clip;\r\n        loopPoints[nLoops] = [];\r\n\r\n        if (clip.polygon !== undefined) {\r\n          clipM = ClipMaskXYZRangePlanes.XAndY;\r\n\r\n          if (clip.zHighValid) {\r\n            clipM = clipM | ClipMaskXYZRangePlanes.ZHigh;\r\n            zFront = clip.zHigh!;\r\n          }\r\n          if (clip.zLowValid) {\r\n            clipM = clipM | ClipMaskXYZRangePlanes.ZLow;\r\n            zBack = clip.zLow!;\r\n          }\r\n\r\n          for (const point of clip.polygon)\r\n            loopPoints[nLoops].push(point.clone());\r\n          deltaTrans.multiplyPoint3dArray(loopPoints[nLoops], loopPoints[nLoops]);\r\n          nLoops++;\r\n        }\r\n      }\r\n    }\r\n\r\n    retVal.push(clipM);\r\n    retVal.push(zBack);\r\n    retVal.push(zFront);\r\n\r\n    if (transform && firstClipShape)\r\n      transform.setFrom(firstClipShape.transformFromClip!);\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Sets this ClipVector and all of its members to the visibility specified. */\r\n  public setInvisible(invisible: boolean) {\r\n    for (const clip of this._clips)\r\n      clip.setInvisible(invisible);\r\n  }\r\n\r\n  /** For every clip, parse the member point array into the member clip plane object (only for clipPlanes member, not the mask) */\r\n  public parseClipPlanes() {\r\n    for (const clip of this._clips)\r\n      clip.fetchClipPlanesRef();\r\n  }\r\n\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   * @returns false if matrix inversion fails.\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n    // no inverse necessary -- lower level cannot fail.\r\n    for (const clip of this._clips)\r\n      clip.multiplyPlanesByMatrix4d(matrix, false, transpose);\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Determines whether the given points fall inside or outside this set of ClipShapes. If any set is defined by masking planes,\r\n   * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.\r\n   */\r\n  public classifyPointContainment(points: Point3d[], ignoreMasks: boolean = false): ClipPlaneContainment {\r\n    let currentContainment = ClipPlaneContainment.Ambiguous;\r\n\r\n    for (const primitive of this._clips) {\r\n      const thisContainment = primitive.classifyPointContainment(points, ignoreMasks);\r\n\r\n      if (ClipPlaneContainment.Ambiguous === thisContainment)\r\n        return ClipPlaneContainment.Ambiguous;\r\n\r\n      if (ClipPlaneContainment.Ambiguous === currentContainment)\r\n        currentContainment = thisContainment;\r\n      else if (currentContainment !== thisContainment)\r\n        return ClipPlaneContainment.Ambiguous;\r\n    }\r\n    return currentContainment;\r\n  }\r\n\r\n  /**\r\n   * Determines whether a 3D range lies inside or outside this set of ClipShapes. If any set is defined by masking planes,\r\n   * checks the mask planes only, provided that ignoreMasks is false. Otherwise, checks the _clipplanes member.\r\n   */\r\n  public classifyRangeContainment(range: Range3d, ignoreMasks: boolean): ClipPlaneContainment {\r\n    const corners: Point3d[] = range.corners();\r\n    return this.classifyPointContainment(corners, ignoreMasks);\r\n  }\r\n\r\n  /**\r\n   * For an array of points (making up a LineString), tests whether the segment between each point lies inside the ClipVector.\r\n   * If true, returns true immediately.\r\n   */\r\n  public isAnyLineStringPointInside(points: Point3d[]): boolean {\r\n    for (const clip of this._clips) {\r\n      const clipPlaneSet = clip.fetchClipPlanesRef();\r\n      if (clipPlaneSet !== undefined) {\r\n        for (let i = 0; i + 1 < points.length; i++) {\r\n          const segment = LineSegment3d.create(points[i], points[i + 1]);\r\n          if (clipPlaneSet.isAnyPointInOrOnFromSegment(segment))\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Note: Line segments are used to represent 1 dimensional intervals here, rather than segments. */\r\n  public sumSizes(intervals: Segment1d[], begin: number, end: number): number {\r\n    let s = 0.0;\r\n    for (let i = begin; i < end; i++)\r\n      s += (intervals[i].x1 - intervals[i].x0);\r\n    return s;\r\n  }\r\n\r\n  private static readonly _TARGET_FRACTION_SUM = 0.99999999;\r\n  /**\r\n   * For an array of points that make up a LineString, develops a line segment between each point pair,\r\n   * and returns true if all segments lie inside this ClipVector.\r\n   */\r\n  public isLineStringCompletelyContained(points: Point3d[]): boolean {\r\n    const clipIntervals: Segment1d[] = [];\r\n\r\n    for (let i = 0; i + 1 < points.length; i++) {\r\n      const segment = LineSegment3d.create(points[i], points[i + 1]);\r\n      let fractionSum = 0.0;\r\n      let index0 = 0;\r\n\r\n      for (const clip of this._clips) {\r\n        const clipPlaneSet = clip.fetchClipPlanesRef();\r\n        if (clipPlaneSet !== undefined) {\r\n          clipPlaneSet.appendIntervalsFromSegment(segment, clipIntervals);\r\n          const index1 = clipIntervals.length;\r\n          fractionSum += this.sumSizes(clipIntervals, index0, index1);\r\n          index0 = index1;\r\n          // ASSUME primitives are non-overlapping...\r\n          if (fractionSum >= ClipVector._TARGET_FRACTION_SUM)\r\n            break;\r\n        }\r\n      }\r\n      if (fractionSum < ClipVector._TARGET_FRACTION_SUM)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { ClipPlane } from \"./ClipPlane\";\r\nimport { ClipPlaneContainment, Clipper, ClipUtilities } from \"./ClipUtils\";\r\nimport { AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { Range3d, Range1d } from \"../geometry3d/Range\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * A ConvexClipPlaneSet is a collection of ClipPlanes, often used for bounding regions of space.\r\n * @public\r\n */\r\nexport class ConvexClipPlaneSet implements Clipper {\r\n  /** Value acting as \"at infinity\" for coordinates along a ray. */\r\n  public static readonly hugeVal = 1e37;\r\n  private _planes: ClipPlane[];\r\n  // private _parity: number;   <--- Not yet used\r\n  // public get parity() { return this._parity; }\r\n  // public set parity(value: number) { this._parity = value; }\r\n  private constructor(planes?: ClipPlane[]) {\r\n    // this._parity = 1;\r\n    this._planes = planes ? planes : [];\r\n  }\r\n  /** Return an array containing all the planes of the convex set.\r\n   * * Note that this has no leading keyword identifying it as a ConvexClipPlaneSet.\r\n   */\r\n  public toJSON(): any {\r\n    const val: any = [];\r\n    for (const plane of this._planes) {\r\n      val.push(plane.toJSON());\r\n    }\r\n    return val;\r\n  }\r\n  /** Extract clip planes from a json array `[  clipplane, clipplane ]`.\r\n   * * Non-clipplane members are ignored.\r\n   */\r\n  public static fromJSON(json: any, result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    if (!Array.isArray(json))\r\n      return result;\r\n    for (const thisJson of json) {\r\n      const plane = ClipPlane.fromJSON(thisJson);\r\n      if (plane)\r\n        result._planes.push(plane);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return true if all members are almostEqual to corresponding members of other.  This includes identical order in array.\r\n   * @param other clip plane to compare\r\n   */\r\n  public isAlmostEqual(other: ConvexClipPlaneSet): boolean {\r\n    if (this._planes.length !== other._planes.length)\r\n      return false;\r\n    for (let i = 0; i < this._planes.length; i++)\r\n      if (!this._planes[i].isAlmostEqual(other._planes[i]))\r\n        return false;\r\n    return true;\r\n  }\r\n  /** create from an array of planes.\r\n   * * Each plane reference in the `planes` array is taken into the result.\r\n   * * The input array itself is NOT taken into the result.\r\n   */\r\n  public static createPlanes(planes: ClipPlane[], result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    for (const plane of planes)\r\n      result._planes.push(plane);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create new convex set using selected planes of a Range3d.\r\n   * @param range range with coordinates\r\n   * @param lowX true to clip at the low x plane\r\n   * @param highX true to clip at the high x plane\r\n   * @param lowY true to clip at the low y plane\r\n   * @param highY true to clip at the high z plane\r\n   * @param lowZ true to clip at the low z plane\r\n   * @param highZ true to clip at the high z plane\r\n   */\r\n  public static createRange3dPlanes(range: Range3d,\r\n    lowX: boolean = true, highX: boolean = true,\r\n    lowY: boolean = true, highY: boolean = true,\r\n    lowZ: boolean = true, highZ: boolean = true): ConvexClipPlaneSet {\r\n    const result = ConvexClipPlaneSet.createEmpty();\r\n\r\n    if (lowX)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(1, 0, 0, range.low.x, 0, 0)!);\r\n    if (highX)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(-1, 0, 0, range.high.x, 0, 0)!);\r\n\r\n    if (lowY)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 1, 0, 0, range.low.y, 0)!);\r\n    if (highY)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, -1, 0, 0, range.high.y, 0)!);\r\n\r\n    if (lowZ)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, 1, 0, 0, range.low.z)!);\r\n    if (highZ)\r\n      result.planes.push(ClipPlane.createNormalAndPointXYZXYZ(0, 0, -1, 0, 0, range.high.z)!);\r\n\r\n    return result;\r\n  }\r\n  /** create an empty `ConvexClipPlaneSet` */\r\n  public static createEmpty(result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    if (result) {\r\n      result._planes.length = 0;\r\n      return result;\r\n    }\r\n    return new ConvexClipPlaneSet();\r\n  }\r\n  /** negate all planes of the set. */\r\n  public negateAllPlanes(): void {\r\n    for (const plane of this._planes)\r\n      plane.negateInPlace();\r\n  }\r\n  /** Create a convex clip plane set that clips to `x0 <= x <= x1` and `y0 <= y <= y1`.\r\n   * * Note that there is no test for the usual ordering `x0 <= x1` or `y0 <= y1`.\r\n   *    * if the usual ordering is violated, the convex set is an empty set.\r\n   */\r\n  public static createXYBox(x0: number, y0: number, x1: number, y1: number, result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    const clip0 = ClipPlane.createNormalAndDistance(Vector3d.create(-1, 0, 0), -x1, false, true);\r\n    const clip1 = ClipPlane.createNormalAndDistance(Vector3d.create(1, 0, 0), x0, false, true);\r\n    const clip2 = ClipPlane.createNormalAndDistance(Vector3d.create(0, -1, 0), -y1, false, true);\r\n    const clip3 = ClipPlane.createNormalAndDistance(Vector3d.create(0, 1, 0), y0, false, true);\r\n    if (clip0 && clip1 && clip2 && clip3) {\r\n      result._planes.push(clip0, clip1, clip2, clip3);\r\n    }\r\n    return result;\r\n  }\r\n  /** Create a convex set containing a half space for each edge between points of a polyline.\r\n   * * Caller is responsible for assuring the polyline is convex.\r\n   * @param points array of points.  Only xy parts are considered.\r\n   * @param interior array whose boolean value is used as both the `interior` and `invisible` bits of the plane for the succeeding segment.\r\n   * @param leftIsInside if true, the interior is \"to the left\" of the segments.  If false, interior is \"to the right\"\r\n   */\r\n  public static createXYPolyLine(points: Point3d[], interior: boolean[], leftIsInside: boolean, result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    for (let i0 = 0; (i0 + 1) < points.length; i0++) {\r\n      const edgeVector: Vector3d = Vector3d.createStartEnd(points[i0], points[i0 + 1]);\r\n      const perp: Vector3d = edgeVector.unitPerpendicularXY();\r\n      perp.z = 0.0;\r\n\r\n      if (!leftIsInside)\r\n        perp.negate();\r\n\r\n      const perpNormalized = perp.normalize();\r\n      if (perpNormalized) {\r\n        const clip = ClipPlane.createNormalAndPoint(perp, points[i0], interior[i0], interior[i0]);\r\n        if (clip) { result._planes.push(clip); }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a convexClipPlaneSet with planes whose \"inside\" normal is to the left of each segment.\r\n   * @param points array of points.\r\n   */\r\n  public static createXYPolyLineInsideLeft(points: Point3d[], result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    for (let i0 = 0; (i0 + 1) < points.length; i0++) {\r\n      const edgeVector: Vector3d = Vector3d.createStartEnd(points[i0], points[i0 + 1]);\r\n      const perp: Vector3d = edgeVector.unitPerpendicularXY();\r\n      perp.z = 0.0;\r\n\r\n      const perpNormalized = perp.normalize();\r\n      if (perpNormalized) {\r\n        const clip = ClipPlane.createNormalAndPoint(perp, points[i0], false, false);\r\n        if (clip) { result._planes.push(clip); }\r\n      }\r\n    }\r\n\r\n    return result;\r\n  }\r\n  /** Deep clone of all planes. */\r\n  public clone(result?: ConvexClipPlaneSet): ConvexClipPlaneSet {\r\n    result = result ? result : new ConvexClipPlaneSet();\r\n    result._planes.length = 0;\r\n    for (const plane of this._planes)\r\n      result._planes.push(plane.clone());\r\n    return result;\r\n  }\r\n  /** Return the (reference to the) array of `ClipPlane` */\r\n  public get planes(): ClipPlane[] {\r\n    return this._planes;\r\n  }\r\n\r\n  /** Test if there is any intersection with a ray defined by origin and direction.\r\n   * * Optionally record the range (null or otherwise) in caller-allocated result.\r\n   * * If the ray is unbounded inside the clip, result can contain positive or negative \"Geometry.hugeCoordinate\" values\r\n   * * If no result is provide, there are no object allocations.\r\n   * @param result optional Range1d to receive parameters along the ray.\r\n   */\r\n  public hasIntersectionWithRay(ray: Ray3d, result?: Range1d): boolean {\r\n    // form low and high values in locals that do not require allocation.\r\n    // transfer to caller-supplied result at end\r\n    let t0 = -Geometry.hugeCoordinate;\r\n    let t1 = Geometry.hugeCoordinate;\r\n    if (result)\r\n      result.setNull();\r\n    for (const plane of this._planes) {\r\n      const vD = plane.dotProductVector(ray.direction);\r\n      const vN = plane.evaluatePoint(ray.origin);\r\n\r\n      if (vD === 0.0) {\r\n        // Ray is parallel... No need to continue testing if outside halfspace.\r\n        if (vN < 0.0)\r\n          return false;   // and result is a null range.\r\n      } else {\r\n        const rayFraction = - vN / vD;\r\n        if (vD < 0.0) {\r\n          if (rayFraction < t1)\r\n            t1 = rayFraction;\r\n        } else {\r\n          if (rayFraction > t0)\r\n            t0 = rayFraction;\r\n        }\r\n      }\r\n    }\r\n    if (t1 < t0)\r\n      return false;   // and result is a null range.\r\n    if (result) {\r\n      result.extendX(t0);\r\n      result.extendX(t1);\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Multiply all the ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n    for (const plane of this._planes) {\r\n      plane.multiplyPlaneByMatrix4d(matrix, false, transpose);\r\n    }\r\n    return true;\r\n  }\r\n  /** Return true if `point` satisfies `point.isPointInside` for all planes */\r\n  public isPointInside(point: Point3d): boolean {\r\n    for (const plane of this._planes) {\r\n      if (!plane.isPointInside(point))  // Defaults to strict inside check. Other clipping classes may use \"on or inside\" check for the \"on\" case\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Return true if `point` satisfies `point.isPointOnOrInside` for all planes */\r\n  public isPointOnOrInside(point: Point3d, tolerance: number): boolean {\r\n    const interiorTolerance = Math.abs(tolerance);   // Interior tolerance should always be positive. (TFS# 246598).\r\n    for (const plane of this._planes) {\r\n      if (!plane.isPointOnOrInside(point, (plane.interior ? interiorTolerance : tolerance)))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Test if a sphere is completely inside the convex set.\r\n   * @param centerPoint center of sphere\r\n   * @param radius radius of sphere.\r\n   */\r\n  public isSphereInside(centerPoint: Point3d, radius: number): boolean {\r\n    const r1 = Math.abs(radius) + Geometry.smallMetricDistance;\r\n    for (const plane of this._planes) {\r\n      if (!plane.isPointOnOrInside(centerPoint, r1)) {\r\n        return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Find the parts of the line segment  (if any) that is within the convex clip volume.\r\n   * * The input fractional interval from fraction0 to fraction1 (increasing!!) is the active part to consider.\r\n   * * To clip to the usual bounded line segment, starts with fractions (0,1).\r\n   * If the clip volume is unbounded, the line interval may also be unbounded.\r\n   * * An unbounded line portion will have fraction coordinates positive or negative Number.MAX_VALUE.\r\n   * @param fraction0 fraction that is the initial lower fraction of the active interval. (e.g. 0.0 for bounded segment)\r\n   * @param fraction1 fraction that is the initial upper fraction of the active interval.  (e.g. 1.0 for bounded segment)\r\n   * @param pointA segment start (fraction 0)\r\n   * @param pointB segment end (fraction 1)\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if a segment was announced, false if entirely outside.\r\n   */\r\n  public announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    let fraction: number | undefined;\r\n    if (f1 < f0)\r\n      return false;\r\n    for (const plane of this._planes) {\r\n      const hA = - plane.evaluatePoint(pointA);\r\n      const hB = - plane.evaluatePoint(pointB);\r\n      fraction = Geometry.safeDivideFraction(-hA, (hB - hA), 0.0);\r\n      if (fraction === undefined) {\r\n        // LIne parallel to the plane.  If positive, it is all OUT\r\n        if (hA > 0.0)\r\n          return false;\r\n      } else if (hB > hA) {    // STRICTLY moving outward\r\n        if (fraction < f0)\r\n          return false;\r\n        if (fraction < f1)\r\n          f1 = fraction;\r\n      } else if (hA > hB) { // STRICTLY moving inward\r\n        if (fraction > f1)\r\n          return false;\r\n        if (fraction > f0)\r\n          f0 = fraction;\r\n      } else {\r\n        // Strictly equal evaluations\r\n        if (hA > 0.0)\r\n          return false;\r\n      }\r\n    }\r\n    if (f1 >= f0) {\r\n      if (announce)\r\n        announce(f0, f1);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private static _clipArcFractionArray = new GrowableFloat64Array();\r\n  /** Find fractional parts of the arc that are within this ClipPlaneSet, and announce each as\r\n   * * `announce(fraction, fraction, curve)`\r\n   */\r\n  public announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const breaks = ConvexClipPlaneSet._clipArcFractionArray;\r\n    breaks.clear();\r\n    for (const clipPlane of this.planes) {\r\n      clipPlane.appendIntersectionRadians(arc, breaks);\r\n    }\r\n    arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);\r\n    return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\r\n  }\r\n  /** Find the parts of the (unbounded) line segment  (if any) that is within the convex clip volume.\r\n   * @param pointA segment start (fraction 0)\r\n   * @param pointB segment end (fraction 1)\r\n   * @param announce function to be called to announce a fraction interval that is within the convex clip volume.\r\n   * @returns true if a segment was announced, false if entirely outside.\r\n   */\r\n  public clipUnboundedSegment(pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    return this.announceClippedSegmentIntervals(-Number.MAX_VALUE, Number.MAX_VALUE, pointA, pointB, announce);\r\n  }\r\n  /** transform each plane in place. */\r\n  public transformInPlace(transform: Transform) {\r\n    for (const plane of this._planes) {\r\n      plane.transformInPlace(transform);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Clip a polygon to the inside of the convex set.\r\n   * * Results with 2 or fewer points are ignored.\r\n   * * Other than ensuring capacity in the arrays, there are no object allocations during execution of this function.\r\n   * @param xyz input points.\r\n   * @param work work buffer\r\n   * @param tolerance tolerance for \"on plane\" decision.\r\n   */\r\n  public clipConvexPolygonInPlace(xyz: GrowableXYZArray, work: GrowableXYZArray, tolerance: number = Geometry.smallMetricDistance) {\r\n    for (const plane of this._planes) {\r\n      plane.clipConvexPolygonInPlace(xyz, work, true, tolerance);\r\n      if (xyz.length < 3)\r\n        return;\r\n    }\r\n  }\r\n\r\n  /** Returns 1, 2, or 3 based on whether point array is strongly inside, ambiguous, or strongly outside respectively.\r\n   * * This has a peculiar expected use case as a very fast pre-filter for more precise clipping.\r\n   * * The expected point set is for a polygon.\r\n   * * Hence any clipping will eventually have to consider the lines between the points.\r\n   * * This method looks for the special case of a single clip plane that has all the points outside.\r\n   * * In this case the whole polygon must be outside.\r\n   * * Note that this does not detect a polygon that is outside but \"crosses a corner\" -- it is mixed with respect to\r\n   *     multiple planes.\r\n   */\r\n  public classifyPointContainment(points: Point3d[], onIsOutside: boolean): ClipPlaneContainment {\r\n    let allInside = true;\r\n    const onTolerance = onIsOutside ? 1.0e-8 : -1.0e-8;\r\n    const interiorTolerance = 1.0e-8;   // Interior tolerance should always be positive\r\n\r\n    for (const plane of this._planes) {\r\n      let nOutside = 0;\r\n      for (const point of points) {\r\n        if (plane.evaluatePoint(point) < (plane.interior ? interiorTolerance : onTolerance)) {\r\n          nOutside++;\r\n          allInside = false;\r\n        }\r\n      }\r\n\r\n      if (nOutside === points.length)\r\n        return ClipPlaneContainment.StronglyOutside;\r\n    }\r\n\r\n    return allInside ? ClipPlaneContainment.StronglyInside : ClipPlaneContainment.Ambiguous;\r\n  }\r\n\r\n  /**\r\n   * * Create a convex clip set for a polygon swept with possible tilt angle.\r\n   * * planes are constructed by ClipPlane.createEdgeAndUpVector, using successive points from the array.\r\n   * * If the first and last points match, the polygon area is checked.  If the area is negative, points are used in reverse order.\r\n   * * If first and last points do not match, points are used in order given\r\n   * @param points polygon points. (Closure point optional)\r\n   * @param upVector primary sweep direction, as applied by ClipPlane.createEdgeAndUpVector\r\n   * @param tiltAngle angle to tilt sweep planes away from the sweep direction.\r\n   */\r\n  public static createSweptPolyline(points: Point3d[], upVector: Vector3d, tiltAngle: Angle): ConvexClipPlaneSet | undefined {\r\n    const result = ConvexClipPlaneSet.createEmpty();\r\n    let reverse = false;\r\n    if (points.length > 3 && points[0].isAlmostEqual(points[points.length - 1])) {\r\n      const polygonNormal: Vector3d = PolygonOps.areaNormal(points);\r\n      const normalDot = polygonNormal.dotProduct(upVector);\r\n      if (normalDot > 0.0)\r\n        reverse = true;\r\n    }\r\n    for (let i = 0; (i + 1) < points.length; i++) {\r\n      if (reverse) {\r\n        const toAdd = ClipPlane.createEdgeAndUpVector(points[i + 1], points[i], upVector, tiltAngle);\r\n        if (toAdd) {   // Clipplane creation could result in undefined\r\n          result.addPlaneToConvexSet(toAdd);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      } else {\r\n        const toAdd = ClipPlane.createEdgeAndUpVector(points[i], points[i + 1], upVector, tiltAngle);\r\n        if (toAdd) {   // Clipplane creation could result in undefined\r\n          result.addPlaneToConvexSet(toAdd);\r\n        } else {\r\n          return undefined;\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Add a plane to the convex set.\r\n   * @param plane plane to add\r\n   */\r\n  public addPlaneToConvexSet(plane: ClipPlane | undefined) {\r\n    if (plane)\r\n      this._planes.push(plane);\r\n  }\r\n  /**\r\n   * test many points.  Distribute them to arrays depending on in/out result.\r\n   * @param points points to test\r\n   * @param inOrOn points that are in or on the set\r\n   * @param out points that are out.\r\n   */\r\n  public clipPointsOnOrInside(points: Point3d[], inOrOn: Point3d[], out: Point3d[]) {\r\n    inOrOn.length = 0;\r\n    out.length = 0;\r\n    for (const xyz of points) {\r\n      if (this.isPointOnOrInside(xyz, 0.0)) {\r\n        inOrOn.push(xyz);\r\n      } else {\r\n        out.push(xyz);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Clip a polygon to the planes of the clip plane set.\r\n   * * For a convex input polygon, the output is another convex polygon.\r\n   * * For a non-convex input, the output may have double-back edges along plane intersections.  This is still a valid clip in a parity sense.\r\n   * * The containingPlane parameter allows callers within ConvexClipPlane set to bypass planes known to contain the polygon\r\n   * @param input input polygon, usually convex.\r\n   * @param output output polygon\r\n   * @param work work array.\r\n   * @param containingPlane if this plane is found in the convex set, it is NOT applied.\r\n   */\r\n  public polygonClip(input: GrowableXYZArray | Point3d[], output: GrowableXYZArray, work: GrowableXYZArray, planeToSkip?: ClipPlane) {\r\n    if (input instanceof GrowableXYZArray)\r\n      input.clone(output);\r\n    else\r\n      GrowableXYZArray.create(input, output);\r\n\r\n    for (const plane of this._planes) {\r\n      if (planeToSkip === plane)\r\n        continue;\r\n      if (output.length === 0)\r\n        break;\r\n      plane.clipConvexPolygonInPlace(output, work);\r\n    }\r\n  }\r\n  /**\r\n   * * Define new planes in this ConvexClipPlaneSet so it clips to the inside of a polygon.\r\n   * * always create planes for the swept edges of the polygon\r\n   * * optionally (with nonzero sideSelect) create a cap plane using the polygon normal.\r\n   * @param points Points of a bounding polygon\r\n   * @param sweepDirection direction to sweep.\r\n   * @param sideSelect 0 to have no cap polygon, 1 if the sweep vector side is in, -1 if sweep vector side is out.\r\n   */\r\n  public reloadSweptPolygon(points: Point3d[], sweepDirection: Vector3d, sideSelect: number): number {\r\n    this._planes.length = 0;\r\n    const n = points.length;\r\n    if (n <= 2)\r\n      return 0;\r\n\r\n    const planeNormal: Vector3d = PolygonOps.areaNormal(points);\r\n    const isCCW = sweepDirection.dotProduct(planeNormal) > 0.0;\r\n\r\n    const delta = isCCW ? 1 : n - 1;\r\n    for (let i = 0; i < n; i++) {\r\n      const i1 = (i + delta) % n;\r\n      const xyz0: Point3d = points[i];\r\n      const xyz1: Point3d = points[i1];\r\n      if (xyz0.isAlmostEqual(xyz1))\r\n        continue;\r\n      const edgeVector: Vector3d = Vector3d.createStartEnd(xyz0, xyz1);\r\n      const inwardNormal: Vector3d = Vector3d.createCrossProduct(sweepDirection.x, sweepDirection.y, sweepDirection.z,\r\n        edgeVector.x, edgeVector.y, edgeVector.z);\r\n      const inwardNormalNormalized = inwardNormal.normalize();\r\n      let distance;\r\n      if (inwardNormalNormalized) { // Should never fail... simply a check due to the format of the normalize function return\r\n        distance = inwardNormalNormalized.dotProduct(xyz0);\r\n        const clipToAdd = ClipPlane.createNormalAndDistance(inwardNormalNormalized, distance, false, false);\r\n        if (clipToAdd) { this._planes.push(clipToAdd); }  // Clipplane creation could result in undefined\r\n      }\r\n    }\r\n    if (sideSelect !== 0.0) {\r\n      let planeNormalNormalized = planeNormal.normalize();\r\n      if (planeNormalNormalized) { // Again.. should never fail\r\n        const a = sweepDirection.dotProduct(planeNormalNormalized) * sideSelect;\r\n        if (a < 0.0)\r\n          planeNormalNormalized = planeNormalNormalized.negate();\r\n        const xyz0: Point3d = points[0];\r\n        const distance = planeNormalNormalized.dotProduct(xyz0);\r\n        const clipToAdd = ClipPlane.createNormalAndDistance(planeNormalNormalized, distance, false, false);\r\n        if (clipToAdd) { this._planes.push(clipToAdd); }  // Clipplane creation could result in undefined\r\n      }\r\n    }\r\n    return isCCW ? 1 : -1;\r\n  }\r\n\r\n  /**\r\n   * Compute intersections among all combinations of 3 planes in the convex set.\r\n   * * optionally throw out points that are not in the set.\r\n   * * optionally push the points in the caller-supplied point array.\r\n   * * optionally extend a caller supplied range.\r\n   * * In the common case where the convex set is (a) a slab or (b) a view frustum, there will be 8 points and the range is the range of the convex set.\r\n   * * If the convex set is unbounded, the range only contains the range of the accepted (corner) points, and the range is not a representative of the \"range of all points in the set\" .\r\n   * @param transform (optional) transform to apply to the points.\r\n   * @param points (optional) array to which computed points are to be added.\r\n   * @param range (optional) range to be extended by the computed points\r\n   * @param transform (optional) transform to apply to the accepted points.\r\n   * @param testContainment if true, test each point to see if it is within the convex set.  (Send false if confident that the convex set is rectilinear set such as a slab.  Send true if chiseled corners are possible)\r\n   * @returns number of points.\r\n   */\r\n  public computePlanePlanePlaneIntersections(points: Point3d[] | undefined, rangeToExtend: Range3d | undefined, transform?: Transform, testContainment: boolean = true): number {\r\n\r\n    const normalRows = Matrix3d.createIdentity();\r\n    const allPlanes = this._planes;\r\n    const n = allPlanes.length;\r\n    let numPoints = 0;    // explicitly count points -- can't wait to end for points.length because it may be an optional output.\r\n    for (let i = 0; i < n; i++) {\r\n      for (let j = i + 1; j < n; j++)\r\n        for (let k = j + 1; k < n; k++) {\r\n          Matrix3d.createRowValues(\r\n            allPlanes[i].inwardNormalRef.x, allPlanes[i].inwardNormalRef.y, allPlanes[i].inwardNormalRef.z,\r\n            allPlanes[j].inwardNormalRef.x, allPlanes[j].inwardNormalRef.y, allPlanes[j].inwardNormalRef.z,\r\n            allPlanes[k].inwardNormalRef.x, allPlanes[k].inwardNormalRef.y, allPlanes[k].inwardNormalRef.z,\r\n            normalRows);\r\n          if (normalRows.computeCachedInverse(false)) {\r\n            const xyz = normalRows.multiplyInverseXYZAsPoint3d(allPlanes[i].distance, allPlanes[j].distance, allPlanes[k].distance)!;\r\n            if (!testContainment || this.isPointOnOrInside(xyz, Geometry.smallMetricDistance)) {\r\n              numPoints++;\r\n              if (transform)\r\n                transform.multiplyPoint3d(xyz, xyz);\r\n              if (points)\r\n                points.push(xyz);\r\n              if (rangeToExtend)\r\n                rangeToExtend.extendPoint(xyz);\r\n            }\r\n          }\r\n        }\r\n    }\r\n    return numPoints;\r\n  }\r\n  /**\r\n   * Set the `invisible` property on each plane of the convex set.\r\n   * @param invisible value to store\r\n   */\r\n  public setInvisible(invisible: boolean) {\r\n    for (const plane of this._planes) {\r\n      plane.setInvisible(invisible);\r\n    }\r\n  }\r\n  /**\r\n   * Add planes for z-direction clip between low and high z levels.\r\n   * @param invisible value to apply to the `invisible` bit for the new planes\r\n   * @param zLow low z value.  The plane clips out points with z below this.\r\n   * @param zHigh high z value.  The plane clips out points with z above this.\r\n   */\r\n  public addZClipPlanes(invisible: boolean, zLow?: number, zHigh?: number) {\r\n    if (zLow !== undefined)\r\n      this._planes.push(ClipPlane.createNormalAndDistance(Vector3d.create(0, 0, 1), zLow, invisible)!);\r\n    if (zHigh !== undefined)\r\n      this._planes.push(ClipPlane.createNormalAndDistance(Vector3d.create(0, 0, -1), -zHigh, invisible)!);\r\n  }\r\n  /*\r\n    #define CheckAreaXY_not\r\n    // EDL Dec 7 2016.\r\n    // superficially bad area split observed when a vertical facet (edge on from above) is split.\r\n    // a1=-2.9864408788819741e-008\r\n    // a2=0\r\n    // this is artificially near zero.\r\n    #ifdef CheckAreaXY\r\n    double Check(double a0, double a1)\r\n    {\r\n    double dx = fabs (a1 - a0);\r\n    bool sameArea = DoubleOps::AlmostEqual (a0, a1);\r\n    BeAssert (sameArea);\r\n    return dx;\r\n    }\r\n    #endif\r\n  */\r\n\r\n  // FUNCTIONS SKIPPED DUE TO BSPLINES, VU, OR NON-USAGE IN NATIVE CODE----------------------------------------------------------------\r\n\r\n  // Uses bsplines... skipping for now:\r\n  // public convexAppendIntervalsFromBspline();\r\n\r\n  // Uses pushing and clearing from/to a cache and added functionality for arrays. . . skipping for now\r\n  // public convexPolygonClipInsideOutside(input: Point3d[], inside: Point3d[], outside: Point3d[], work1: Point3d[], work2: Point3d[],\r\n  // clearOutside: boolean, distanceTolerance: number)\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module CartesianGeometry */\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Range3d, Range1d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { ClipPlaneContainment, Clipper, ClipUtilities } from \"./ClipUtils\";\r\nimport { AnnounceNumberNumberCurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { ConvexClipPlaneSet } from \"./ConvexClipPlaneSet\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * A collection of ConvexClipPlaneSets.\r\n * * A point is \"in\" the clip plane set if it is \"in\" one or more of  the ConvexClipPlaneSet\r\n * * Hence the boolean logic is that the ClipPlaneSet is a UNION of its constituents.\r\n * @public\r\n */\r\nexport class UnionOfConvexClipPlaneSets implements Clipper {\r\n  private _convexSets: ConvexClipPlaneSet[];\r\n  /** (property accessor)  Return the (reference to the) array of `ConvexClipPlaneSet` */\r\n  public get convexSets(): ConvexClipPlaneSet[] { return this._convexSets; }\r\n\r\n  private constructor() {\r\n    this._convexSets = [];\r\n  }\r\n  /** Return an array with the `toJSON` form of each  `ConvexClipPlaneSet` */\r\n  public toJSON(): any {\r\n    const val: any = [];\r\n    for (const convex of this._convexSets) {\r\n      val.push(convex.toJSON());\r\n    }\r\n    return val;\r\n  }\r\n  /** Convert json `UnionOfConvexClipPlaneSets`, using `setFromJSON`. */\r\n  public static fromJSON(json: any, result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    result = result ? result : new UnionOfConvexClipPlaneSets();\r\n    result._convexSets.length = 0;\r\n    if (!Array.isArray(json))\r\n      return result;\r\n    for (const thisJson of json) {\r\n      result._convexSets.push(ConvexClipPlaneSet.fromJSON(thisJson));\r\n    }\r\n    return result;\r\n  }\r\n  /** Create a `UnionOfConvexClipPlaneSets` with no members. */\r\n  public static createEmpty(result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    if (result) {\r\n      result._convexSets.length = 0;\r\n      return result;\r\n    }\r\n    return new UnionOfConvexClipPlaneSets();\r\n  }\r\n  /**\r\n   * Return true if all member convex sets are almostEqual to corresponding members of other.  This includes identical order in array.\r\n   * @param other clip plane to compare\r\n   */\r\n  public isAlmostEqual(other: UnionOfConvexClipPlaneSets): boolean {\r\n    if (this._convexSets.length !== other._convexSets.length)\r\n      return false;\r\n    for (let i = 0; i < this._convexSets.length; i++)\r\n      if (!this._convexSets[i].isAlmostEqual(other._convexSets[i]))\r\n        return false;\r\n    return true;\r\n  }\r\n  /** Create a `UnionOfConvexClipPlaneSets` with given `ConvexClipPlaneSet` members */\r\n  public static createConvexSets(convexSets: ConvexClipPlaneSet[], result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    result = result ? result : new UnionOfConvexClipPlaneSets();\r\n    for (const set of convexSets)\r\n      result._convexSets.push(set);\r\n    return result;\r\n  }\r\n  /** return a deep copy. */\r\n  public clone(result?: UnionOfConvexClipPlaneSets): UnionOfConvexClipPlaneSets {\r\n    result = result ? result : new UnionOfConvexClipPlaneSets();\r\n    result._convexSets.length = 0;\r\n    for (const convexSet of this._convexSets)\r\n      result._convexSets.push(convexSet.clone());\r\n    return result;\r\n  }\r\n  /** Append `toAdd` to the array of `ConvexClipPlaneSet` */\r\n  public addConvexSet(toAdd: ConvexClipPlaneSet) {\r\n    this._convexSets.push(toAdd);\r\n  }\r\n\r\n  /** Test if there is any intersection with a ray defined by origin and direction.\r\n   * * Optionally record the range (null or otherwise) in caller-allocated result.\r\n   * * If the ray is unbounded inside the clip, result can contain positive or negative \"Geometry.hugeCoordinate\" values\r\n   * * If no result is provide, there are no object allocations.\r\n   * @param maximalRange optional Range1d to receive parameters along the ray.\r\n   */\r\n  public hasIntersectionWithRay(ray: Ray3d, maximalRange?: Range1d): boolean {\r\n    if (maximalRange === undefined) {\r\n      // if complete result is not requested, return after any hit.\r\n      for (const planeSet of this._convexSets) {\r\n        if (planeSet.hasIntersectionWithRay(ray))\r\n          return true;\r\n      }\r\n      return false;\r\n    }\r\n    maximalRange.setNull();\r\n    const rangeA = Range1d.createNull();\r\n    for (const planeSet of this._convexSets) {\r\n      if (planeSet.hasIntersectionWithRay(ray, rangeA))\r\n        maximalRange.extendRange(rangeA);\r\n    }\r\n    return !maximalRange.isNull;\r\n  }\r\n\r\n  /** Return true if true is returned for any contained convex set returns true for `convexSet.isPointInside (point, tolerance)`  */\r\n  public isPointInside(point: Point3d): boolean {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.isPointInside(point)) {\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return true if true is returned for any contained convex set returns true for `convexSet.isPointOnOrInside (point, tolerance)`  */\r\n  public isPointOnOrInside(point: Point3d, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.isPointOnOrInside(point, tolerance))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Return true if true is returned for any contained convex set returns true for `convexSet.isSphereOnOrInside (point, tolerance)`  */\r\n  public isSphereInside(point: Point3d, radius: number) {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.isSphereInside(point, radius))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** test if any part of a line segment is within the volume */\r\n  public isAnyPointInOrOnFromSegment(segment: LineSegment3d): boolean {\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  // Intervals must be Segment1d array, as there may be multiple intervals along segment that pass through set regions,\r\n  // and so splitting the intervals into segments aids in better organization\r\n  /** Returns the fractions of the segment that pass through the set region, as 1 dimensional pieces */\r\n  public appendIntervalsFromSegment(segment: LineSegment3d, intervals: Segment1d[]) {\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.announceClippedSegmentIntervals(0.0, 1.0, segment.point0Ref, segment.point1Ref,\r\n        (fraction0: number, fraction1: number) =>\r\n          intervals.push(Segment1d.create(fraction0, fraction1)));\r\n    }\r\n  }\r\n  /** apply `transform` to all the ConvexClipPlaneSet's */\r\n  public transformInPlace(transform: Transform) {\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.transformInPlace(transform);\r\n    }\r\n  }\r\n\r\n  /** Returns 1, 2, or 3 based on whether point is strongly inside, ambiguous, or strongly outside respectively */\r\n  public classifyPointContainment(points: Point3d[], onIsOutside: boolean): number {\r\n    for (const convexSet of this._convexSets) {\r\n      const thisStatus = convexSet.classifyPointContainment(points, onIsOutside);\r\n      if (thisStatus !== ClipPlaneContainment.StronglyOutside)\r\n        return thisStatus;\r\n    }\r\n    return ClipPlaneContainment.StronglyOutside;\r\n  }\r\n\r\n  /** Clip a polygon using this ClipPlaneSet, returning new polygon boundaries. Note that each polygon may lie next to the previous, or be disconnected. */\r\n  public polygonClip(input: GrowableXYZArray | Point3d[], output: GrowableXYZArray[]) {\r\n    output.length = 0;\r\n    if (Array.isArray(input))\r\n      input = GrowableXYZArray.create(input);\r\n    const work = new GrowableXYZArray();\r\n    for (const convexSet of this._convexSets) {\r\n      const convexSetOutput = new GrowableXYZArray();\r\n      convexSet.polygonClip(input, convexSetOutput, work);\r\n      if (convexSetOutput.length !== 0)\r\n        output.push(convexSetOutput);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * announce clipSegment() for each convexSet in this ClipPlaneSet.\r\n   * * all clipPlaneSets are inspected\r\n   * * announced intervals are for each individual clipPlaneSet -- adjacent intervals are not consolidated.\r\n   * @param f0 active interval start.\r\n   * @param f1 active interval end\r\n   * @param pointA line segment start\r\n   * @param pointB line segment end\r\n   * @param announce function to announce interval.\r\n   * @returns Return true if any announcements are made.\r\n   */\r\n  public announceClippedSegmentIntervals(f0: number, f1: number, pointA: Point3d, pointB: Point3d, announce?: (fraction0: number, fraction1: number) => void): boolean {\r\n    let numAnnounce = 0;\r\n    for (const convexSet of this._convexSets) {\r\n      if (convexSet.announceClippedSegmentIntervals(f0, f1, pointA, pointB, announce))\r\n        numAnnounce++;\r\n    }\r\n    return numAnnounce > 0;\r\n  }\r\n\r\n  private static _clipArcFractionArray = new GrowableFloat64Array();\r\n  /** Find parts of an arc that are inside any member clipper.\r\n   * Announce each with `announce(startFraction, endFraction, this)`\r\n   */\r\n  public announceClippedArcIntervals(arc: Arc3d, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const breaks = UnionOfConvexClipPlaneSets._clipArcFractionArray;\r\n    breaks.clear();\r\n    for (const convexSet of this._convexSets) {\r\n      for (const clipPlane of convexSet.planes) {\r\n        clipPlane.appendIntersectionRadians(arc, breaks);\r\n      }\r\n    }\r\n    arc.sweep.radiansArraytoPositivePeriodicFractions(breaks);\r\n    return ClipUtilities.selectIntervals01(arc, breaks, this, announce);\r\n  }\r\n\r\n  /**\r\n   * Collect the output from computePlanePlanePlaneIntersections in all the contained convex sets.\r\n   *\r\n   * @param transform (optional) transform to apply to the points.\r\n   * @param points (optional) array to which computed points are to be added.\r\n   * @param range (optional) range to be extended by the computed points\r\n   * @param transform (optional) transform to apply to the accepted points.\r\n   * @param testContainment if true, test each point to see if it is within the convex set.  (Send false if confident that the convex set is rectilinear set such as a slab.  Send true if chiseled corners are possible)\r\n   * @returns number of points.\r\n   */\r\n  public computePlanePlanePlaneIntersectionsInAllConvexSets(points: Point3d[] | undefined, rangeToExtend: Range3d | undefined, transform?: Transform, testContainment: boolean = true): number {\r\n    let n = 0;\r\n    for (const convexSet of this._convexSets) {\r\n      n += convexSet.computePlanePlanePlaneIntersections(points, rangeToExtend, transform, testContainment);\r\n    }\r\n    return n;\r\n  }\r\n  /**\r\n   * Multiply all ClipPlanes DPoint4d by matrix.\r\n   * @param matrix matrix to apply.\r\n   * @param invert if true, use in verse of the matrix.\r\n   * @param transpose if true, use the transpose of the matrix (or inverse, per invert parameter)\r\n   * * Note that if matrixA is applied to all of space, the matrix to send to this method to get a corresponding effect on the plane is the inverse transpose of matrixA\r\n   * * Callers that will apply the same matrix to many planes should pre-invert the matrix for efficiency.\r\n   * * Both params default to true to get the full effect of transforming space.\r\n   * @param matrix matrix to apply\r\n   */\r\n  public multiplyPlanesByMatrix4d(matrix: Matrix4d, invert: boolean = true, transpose: boolean = true): boolean {\r\n    if (invert) {  // form inverse once here, reuse for all planes\r\n      const inverse = matrix.createInverse();\r\n      if (!inverse)\r\n        return false;\r\n      return this.multiplyPlanesByMatrix4d(inverse, false, transpose);\r\n    }\r\n    // (no inversion -- no failures possible)\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.multiplyPlanesByMatrix4d(matrix, false, transpose);\r\n    }\r\n    return true;\r\n  }\r\n  /** Recursively call `setInvisible` on all member convex sets. */\r\n  public setInvisible(invisible: boolean) {\r\n    for (const convexSet of this._convexSets) {\r\n      convexSet.setInvisible(invisible);\r\n    }\r\n  }\r\n  /** add convex sets that accept points below `zLow` and above `zHigh` */\r\n  public addOutsideZClipSets(invisible: boolean, zLow?: number, zHigh?: number) {\r\n    if (zLow) {\r\n      const convexSet = ConvexClipPlaneSet.createEmpty();\r\n      convexSet.addZClipPlanes(invisible, zLow);\r\n      this._convexSets.push(convexSet);\r\n    }\r\n    if (zHigh) {\r\n      const convexSet = ConvexClipPlaneSet.createEmpty();\r\n      convexSet.addZClipPlanes(invisible, undefined, zHigh);\r\n      this._convexSets.push(convexSet);\r\n    }\r\n  }\r\n\r\n  /* FUNCTIONS SKIPPED DUE TO BSPLINES, VU, OR NON-USAGE IN NATIVE CODE----------------------------------------------------------------\r\n\r\n  Involves vu: skipping for now...\r\n    public fromSweptPolygon(points: Point3d[], directions: Vector3d[]): ClipPlaneSet;\r\n    public parseConcavePolygonPlanes(...)\r\n\r\n  Uses bsplines... skipping for now:\r\n    public appendIntervalsClipPlaneSetFromCurve();\r\n\r\n  Uses bsplines... skipping for now:\r\n    public isAnyPointInOrOnFrom();\r\n\r\n  Skipped fromSweptPolygon(...), which is overloaded function from first, due to presence of vu\r\n    public fromSweptPolygon(points: Point3d[], directions: Vector3d[], shapes: Point3d[])\r\n  */\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, AxisOrder, BeJSONFunctions, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { TrigPolynomial, SmallSystem } from \"../numerics/Polynomials\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { CurvePrimitive, AnnounceNumberNumberCurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveLocationDetail, CurveSearchStatus } from \"./CurveLocationDetail\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n\r\n/* tslint:disable:variable-name no-empty*/\r\n/**\r\n * Circular or elliptic arc.\r\n *\r\n * * The angle to point equation is:\r\n *\r\n * **  `X = center + cos(theta) * vector0 + sin(theta) * vector90`\r\n * * When the two vectors are perpendicular and have equal length, it is a true circle.\r\n * * Non-perpendicular vectors are always elliptic.\r\n * *  vectors of unequal length are always elliptic.\r\n * * To create an ellipse in the common \"major and minor axis\" form of an ellipse:\r\n * ** vector0 is the vector from the center to the major axis extreme.\r\n * ** vector90 is the vector from the center to the minor axis extreme.\r\n * ** note the constructing the vectors to the extreme points makes them perpendicular.\r\n * *  The method toScaledMatrix3d () can be called to convert the unrestricted vector0,vector90 to perpendicular form.\r\n * * The unrestricted form is much easier to work with for common calculations -- stroking, projection to 2d, intersection with plane.\r\n * @public\r\n */\r\nexport class Arc3d extends CurvePrimitive implements BeJSONFunctions {\r\n  /**\r\n   * Test if this and other are both instances of Arc3d.\r\n   */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof Arc3d; }\r\n  private _center: Point3d;\r\n  private _matrix: Matrix3d; // columns are [vector0, vector90, unitNormal]\r\n  private _sweep: AngleSweep; // sweep limits.\r\n  private static _workPointA = Point3d.create();\r\n  private static _workPointB = Point3d.create();\r\n  /**\r\n   * read property for (clone of) center\r\n   */\r\n  public get center(): Point3d { return this._center.clone(); }\r\n  /**\r\n   * read property for (clone of) vector0\r\n   */\r\n  public get vector0(): Vector3d { return this._matrix.columnX(); }\r\n  /**\r\n   * read property for (clone of) vector90\r\n   */\r\n  public get vector90(): Vector3d { return this._matrix.columnY(); }\r\n  /**\r\n   * read property for (clone of!) matrix of vector0, vector90, unit normal\r\n   */\r\n  public get matrix(): Matrix3d { return this._matrix.clone(); }\r\n  /** property getter for the angle sweep */\r\n  public get sweep(): AngleSweep { return this._sweep; }\r\n  /** property setter for angle sweep */\r\n  public set sweep(value: AngleSweep) { this._sweep.setFrom(value); }\r\n  /**\r\n   * An Arc3d extends along its complete elliptic arc\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return true; }\r\n\r\n  // constructor copies the pointers !!!\r\n  private constructor(center: Point3d, matrix: Matrix3d, sweep: AngleSweep) {\r\n    super();\r\n    this._center = center;\r\n    this._matrix = matrix;\r\n    this._sweep = sweep;\r\n  }\r\n  /**\r\n   *  Return a clone of the arc, with transform applied\r\n   * @param transform\r\n   */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n\r\n  /**\r\n   * Redefine the arc with (captured references to) given data.\r\n   * @param center arc center\r\n   * @param matrix matrix with columns vector0, vector 90, and their unit cross product\r\n   * @param sweep angle sweep\r\n   */\r\n  public setRefs(center: Point3d, matrix: Matrix3d, sweep: AngleSweep) {\r\n    this._center = center;\r\n    this._matrix = matrix;\r\n    this._sweep = sweep;\r\n  }\r\n  /**\r\n   * Redefine the arc with (clones of) given data.\r\n   * @param center arc center\r\n   * @param matrix matrix with columns vector0, vector 90, and their unit cross product\r\n   * @param sweep angle sweep\r\n   */\r\n  public set(center: Point3d, matrix: Matrix3d, sweep: AngleSweep | undefined) {\r\n    this.setRefs(center.clone(), matrix.clone(), sweep ? sweep.clone() : AngleSweep.create360());\r\n  }\r\n  /**\r\n   * Copy center, matrix, and sweep from other Arc3d.\r\n   */\r\n  public setFrom(other: Arc3d) {\r\n    this._center.setFrom(other._center);\r\n    this._matrix.setFrom(other._matrix);\r\n    this._sweep.setFrom(other._sweep);\r\n  }\r\n  /** Return a clone of this arc. */\r\n  public clone(): Arc3d {\r\n    return new Arc3d(this._center.clone(), this._matrix.clone(), this._sweep.clone());\r\n  }\r\n  /**\r\n   * Create an arc, capturing references to center, matrix and sweep.\r\n   * @param center center point\r\n   * @param matrix matrix with columns vector0, vector90, and unit cross product\r\n   * @param sweep sweep limits\r\n   * @param result optional preallocated result.\r\n   */\r\n  public static createRefs(center: Point3d, matrix: Matrix3d, sweep: AngleSweep, result?: Arc3d): Arc3d {\r\n    if (result) {\r\n      result.setRefs(center, matrix, sweep);\r\n      return result;\r\n    }\r\n    return new Arc3d(center, matrix, sweep);\r\n  }\r\n  /**\r\n   * Create an arc from center, x column to be scaled, and y column to be scaled.\r\n   * @param center center of ellipse\r\n   * @param matrix matrix whose x and y columns are unit vectors to be scaled by radius0 and radius90\r\n   * @param radius0 radius in x direction.\r\n   * @param radius90 radius in y direction.\r\n   * @param sweep sweep limits\r\n   * @param result optional preallocated result.\r\n   */\r\n  public static createScaledXYColumns(center: Point3d, matrix: Matrix3d, radius0: number, radius90: number, sweep?: AngleSweep, result?: Arc3d): Arc3d {\r\n    const vector0 = matrix.columnX();\r\n    const vector90 = matrix.columnY();\r\n    return Arc3d.create(center, vector0.scale(radius0, vector0), vector90.scale(radius90, vector90), sweep, result);\r\n  }\r\n  /**\r\n   * Create a (full circular) arc from center, normal and radius\r\n   * @param center center of ellipse\r\n   * @param normal normal vector\r\n   * @param radius radius in x direction.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public static createCenterNormalRadius(center: Point3d, normal: Vector3d, radius: number, result?: Arc3d): Arc3d {\r\n    const frame = Matrix3d.createRigidHeadsUp(normal, AxisOrder.ZYX);\r\n    return Arc3d.createScaledXYColumns(center, frame, radius, radius, undefined, result);\r\n  }\r\n\r\n  /**\r\n   * Creat an arc by center with vectors to points at 0 and 90 degrees in parameter space.\r\n   * @param center arc center\r\n   * @param vector0 vector to 0 degrees (commonly major axis)\r\n   * @param vector90 vector to 90 degree point (commonly minor axis)\r\n   * @param sweep sweep limits\r\n   * @param result optional preallocted result\r\n   */\r\n  public static create(center: Point3d, vector0: Vector3d, vector90: Vector3d, sweep?: AngleSweep, result?: Arc3d): Arc3d {\r\n    const normal = vector0.unitCrossProductWithDefault(vector90, 0, 0, 0); // normal will be 000 for degenerate case ! !!\r\n    const matrix = Matrix3d.createColumns(vector0, vector90, normal);\r\n    return Arc3d.createRefs(center.clone(), matrix, sweep ? sweep.clone() : AngleSweep.create360(), result);\r\n  }\r\n  /**\r\n   * Return a quick estimate of the eccentricity of the ellipse.\r\n   * * The estimator is the cross magnitude of the product of vectors U and V, divided by square of the larger magnitude\r\n   * * for typical Arc3d with perpendicular UV, this is exactly the small axis divided by large.\r\n   * * note that the eccentricity is AT MOST ONE.\r\n   */\r\n  public quickEccentricity(): number {\r\n    const magX = this._matrix.columnXMagnitude();\r\n    const magY = this._matrix.columnYMagnitude();\r\n    const jacobian = this._matrix.columnXYCrossProductMagnitude();\r\n    const largeAxis = Geometry.maxXY(magX, magY);\r\n    return jacobian / (largeAxis * largeAxis);\r\n  }\r\n  /** Create a circular arc defined by start point, any intermediate point, and end point.\r\n   * If the points are colinear, assemble them into a linestring.\r\n   */\r\n  public static createCircularStartMiddleEnd(\r\n    pointA: XYAndZ,\r\n    pointB: XYAndZ,\r\n    pointC: XYAndZ,\r\n    result?: Arc3d): Arc3d | LineString3d | undefined {\r\n    const vectorAB = Vector3d.createStartEnd(pointA, pointB);\r\n    const vectorAC = Vector3d.createStartEnd(pointA, pointC);\r\n    const ab = vectorAB.magnitude();\r\n    const bc = vectorAC.magnitude();\r\n    const normal = vectorAB.sizedCrossProduct(vectorAC, Math.sqrt(ab * bc));\r\n    if (normal) {\r\n      const vectorToCenter = SmallSystem.linearSystem3d(\r\n        normal.x, normal.y, normal.z,\r\n        vectorAB.x, vectorAB.y, vectorAB.z,\r\n        vectorAC.x, vectorAC.y, vectorAC.z,\r\n        0,              // vectorToCenter DOT normal = 0\r\n        0.5 * ab * ab,  // vectorToCenter DOT vectorBA = 0.5 * vectorBA DOT vectorBA  (Rayleigh quotient)\r\n        0.5 * bc * bc); // vectorToCenter DOT vectorBC = 0.5 * vectorBC DOT vectorBC  (Rayleigh quotient)\r\n      if (vectorToCenter) {\r\n        const center = Point3d.create(pointA.x, pointA.y, pointA.z).plus(vectorToCenter);\r\n        const vectorX = Vector3d.createStartEnd(center, pointA);\r\n        const vectorY = Vector3d.createRotateVectorAroundVector(vectorX, normal, Angle.createDegrees(90));\r\n        if (vectorY) {\r\n          const vectorCenterToC = Vector3d.createStartEnd(center, pointC);\r\n          const sweepAngle = vectorX.signedAngleTo(vectorCenterToC, normal);\r\n          return Arc3d.create(center, vectorX, vectorY,\r\n            AngleSweep.createStartEndRadians(0.0, sweepAngle.radians), result);\r\n        }\r\n      }\r\n    }\r\n    return LineString3d.create(pointA, pointB, pointC);\r\n  }\r\n  /** The arc has simple proportional arc length if and only if it is a circular arc. */\r\n  public getFractionToDistanceScale(): number | undefined {\r\n    const radius = this.circularRadius();\r\n    if (radius !== undefined)\r\n      return Math.abs(radius * this._sweep.sweepRadians);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Convert a fractional position to xyz coordinates\r\n   * @param fraction fractional position on arc\r\n   * @param result optional preallocated result\r\n   */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    const radians = this._sweep.fractionToRadians(fraction);\r\n    return this._matrix.originPlusMatrixTimesXY(this._center, Math.cos(radians), Math.sin(radians), result);\r\n  }\r\n  /**\r\n   * Convert a fractional position to xyz coordinates and derivative with respect to fraction.\r\n   * @param fraction fractional position on arc\r\n   * @param result optional preallocated result\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = this.radiansToPointAndDerivative(this._sweep.fractionToRadians(fraction), result);\r\n    result.direction.scaleInPlace(this._sweep.sweepRadians);\r\n    return result;\r\n  }\r\n\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the arc\r\n   * * x axis is the first derivative, i.e. tangent along the arc\r\n   * * y axis is the second derivative, i.e. in the plane and on the center side of the tangent.\r\n   * If the arc is circular, the second derivative is directly towards the center\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const radians = this._sweep.fractionToRadians(fraction);\r\n    if (!result) result = Plane3dByOriginAndVectors.createXYPlane();\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\r\n    const a = this._sweep.sweepRadians;\r\n    this._matrix.multiplyXY(-a * s, a * c, result.vectorU);\r\n    const aa = a * a;\r\n    this._matrix.multiplyXY(- aa * c, -aa * s, result.vectorV);\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the point and derivative with respect to the angle (in radians)\r\n   * @param radians angular position\r\n   * @param result optional preallocated ray.\r\n   */\r\n  public radiansToPointAndDerivative(radians: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\r\n    this._matrix.multiplyXY(-s, c, result.direction);\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the point and derivative with respect to the angle (in radians)\r\n   * @param theta angular position\r\n   * @param result optional preallocated ray.\r\n   */\r\n  public angleToPointAndDerivative(theta: Angle, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const c = theta.cos();\r\n    const s = theta.sin();\r\n    this._matrix.originPlusMatrixTimesXY(this._center, c, s, result.origin);\r\n    this._matrix.multiplyXY(-s, c, result.direction);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the start point tof the arc.\r\n   * @param result optional preallocated result\r\n   */\r\n  public startPoint(result?: Point3d): Point3d { return this.fractionToPoint(0.0, result); }\r\n\r\n  /**\r\n   * Return the end point tof the arc.\r\n   * @param result optional preallocated result\r\n   */\r\n  public endPoint(result?: Point3d): Point3d { return this.fractionToPoint(1.0, result); }\r\n  /** * If this is a circular arc, return the simple length derived from radius and sweep.\r\n   * * Otherwise (i.e. if this elliptical) fall through to CurvePrimitive base implementation which\r\n   *     Uses quadrature.\r\n   */\r\n  public curveLength(): number {\r\n    return this.curveLengthBetweenFractions(0, 1);\r\n  }\r\n  /** Gauss point quadrature count for evaluating curve length.   (The number of intervals is adjusted to the arc sweep) */\r\n  public static readonly quadratureGuassCount = 5;\r\n  /** In quadrature for arc length, use this interval (divided by quickEccentricity) */\r\n  public static readonly quadratureIntervalAngleDegrees = 10.0;\r\n  /** * If this is a circular arc, return the simple length derived from radius and sweep.\r\n   * * Otherwise (i.e. if this elliptical) fall through CurvePrimitive integrator.\r\n   */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    const simpleLength = this.getFractionToDistanceScale();\r\n    if (simpleLength !== undefined)\r\n      return simpleLength * Math.abs(fraction1 - fraction0);\r\n    // fall through for true ellipse . .. stroke and accumulate quadrature with typical count .  ..\r\n    let f0 = fraction0;\r\n    let f1 = fraction1;\r\n    if (fraction0 > fraction1) {\r\n      f0 = fraction1;\r\n      f1 = fraction0;\r\n    }\r\n    const sweepDegrees = (f1 - f0) * this._sweep.sweepDegrees;\r\n    let eccentricity = this.quickEccentricity();\r\n    if (eccentricity < 0.00001)\r\n      eccentricity = 0.00001;\r\n    let numInterval = Math.ceil(sweepDegrees / (eccentricity * Arc3d.quadratureIntervalAngleDegrees));\r\n    if (numInterval > 400)\r\n      numInterval = 400;\r\n    if (numInterval < 1)\r\n      numInterval = 1;\r\n    return super.curveLengthWithFixedIntervalCountQuadrature(f0, f1, numInterval, Arc3d.quadratureGuassCount);\r\n  }\r\n\r\n  /**\r\n   * Return an approximate (but easy to compute) arc length.\r\n   * The estimate is:\r\n   * * Form 8 chords on full circle, proportionally fewer for partials.  (But 2 extras if less than half circle.)\r\n   * * sum the chord lengths\r\n   * * For a circle, we know this crude approximation has to be increased by a factor (theta/(2 sin (theta/2)))\r\n   * * Apply that factor.\r\n   * * Experiments confirm that this is within 3 percent for a variety of eccentricities and arc sweeps.\r\n   */\r\n  public quickLength(): number {\r\n    const totalSweep = Math.abs(this._sweep.sweepRadians);\r\n    let numInterval = Math.ceil(4 * totalSweep / Math.PI);\r\n    if (numInterval < 1)\r\n      numInterval = 1;\r\n    if (numInterval < 4)\r\n      numInterval += 3;\r\n    else if (numInterval < 6)\r\n      numInterval += 2;   // force extras for short arcs\r\n    const pointA = Arc3d._workPointA;\r\n    const pointB = Arc3d._workPointB;\r\n    let chordSum = 0.0;\r\n    this.fractionToPoint(0.0, pointA);\r\n    for (let i = 1; i <= numInterval; i++) {\r\n      this.fractionToPoint(i / numInterval, pointB);\r\n      chordSum += pointA.distance(pointB);\r\n      pointA.setFromPoint3d(pointB);\r\n    }\r\n    // The chord sum is always shorter.\r\n    // if it is a true circular arc, the ratio of correct over sum is easy ...\r\n    const dTheta = totalSweep / numInterval;\r\n    const factor = dTheta / (2.0 * Math.sin(0.5 * dTheta));\r\n    return chordSum * factor;\r\n  }\r\n  /**\r\n   * * See extended comments on `CurvePrimitive.moveSignedDistanceFromFraction`\r\n   * * A zero length line generates `CurveSearchStatus.error`\r\n   * * Nonzero length line generates `CurveSearchStatus.success` or `CurveSearchStatus.stoppedAtBoundary`\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: false, result?: CurveLocationDetail): CurveLocationDetail {\r\n    if (!this.isCircular) // suppress extension !!!\r\n      return super.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);\r\n    const totalLength = this.curveLength();\r\n    const signedFractionMove = Geometry.conditionalDivideFraction(signedDistance, totalLength);\r\n    if (signedFractionMove === undefined) {\r\n      return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(\r\n        this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveSearchStatus.error);\r\n    }\r\n    return CurveLocationDetail.createConditionalMoveSignedDistance(\r\n      allowExtension,\r\n      this,\r\n      startFraction,\r\n      startFraction + signedFractionMove,\r\n      signedDistance,\r\n      result);\r\n  }\r\n  /**\r\n   * Return all angles (in radians) where the ellipse tangent is perpendicular to the vector to a spacePoint.\r\n   * @param spacePoint point of origin of vectors to the ellipse\r\n   * @param _extend (NOT SUPPORTED -- ALWAYS ACTS AS \"true\")\r\n   * @param _endpoints (NOT SUPPORTED -- ALWAYS ACTS AS FALSE)\r\n   */\r\n  public allPerpendicularAngles(spacePoint: Point3d, _extend: boolean = true, _endpoints: boolean = false): number[] {\r\n    const radians: number[] = [];\r\n    const vectorQ = spacePoint.vectorTo(this.center);\r\n    const uu = this._matrix.columnXMagnitudeSquared();\r\n    const uv = this._matrix.columnXDotColumnY();\r\n    const vv = this._matrix.columnYMagnitudeSquared();\r\n    TrigPolynomial.solveUnitCircleImplicitQuadricIntersection(\r\n      uv,\r\n      vv - uu,\r\n      -uv,\r\n      this._matrix.dotColumnY(vectorQ),\r\n      -this._matrix.dotColumnX(vectorQ),\r\n      0.0, radians);\r\n    return radians;\r\n  }\r\n  /**\r\n   * Return details of the closest point on the arc, optionally extending to full ellipse.\r\n   * @param spacePoint search for point closest to this point.\r\n   * @param extend if true, consider projections to the complete ellipse.   If false, consider only endpoints and projections within the arc sweep.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = CurveLocationDetail.create(this, result);\r\n    const allRadians = this.allPerpendicularAngles(spacePoint);\r\n    if (!extend && !this._sweep.isFullCircle) {\r\n      allRadians.push(this._sweep.startRadians);\r\n      allRadians.push(this._sweep.endRadians);\r\n    }\r\n    // hm... logically there must at least two angles there ...  but if it happens return the start point ...\r\n    const workRay = Ray3d.createZero();\r\n    if (allRadians.length === 0) {\r\n      result.setFR(0.0, this.radiansToPointAndDerivative(this._sweep.startRadians, workRay));\r\n      result.a = spacePoint.distance(result.point);\r\n    } else {\r\n      let dMin = Number.MAX_VALUE;\r\n      let d = 0;\r\n      for (const radians of allRadians) {\r\n        if (extend || this._sweep.isRadiansInSweep(radians)) {\r\n          this.radiansToPointAndDerivative(radians, workRay);\r\n          d = spacePoint.distance(workRay.origin);\r\n          if (d < dMin) {\r\n            dMin = d;\r\n            result.setFR(this._sweep.radiansToSignedPeriodicFraction(radians), workRay);\r\n            result.a = d;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Reverse the sweep  of the arc. */\r\n  public reverseInPlace(): void { this._sweep.reverseInPlace(); }\r\n  /** apply a transform to the arc basis vectors.\r\n   * * nonuniform (i.e. skewing) transforms are allowed.\r\n   * * The transformed vector0 and vector90 are NOT squared up as major minor axes.  (This is a good feature!!)\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    this._center = transform.multiplyPoint3d(this._center, this._center);\r\n    this._matrix = transform.matrix.multiplyMatrixMatrix(this._matrix, this._matrix);\r\n    // force re-normalization of columnZ.\r\n    this.setVector0Vector90(this._matrix.columnX(), this._matrix.columnY());\r\n    return true;\r\n  }\r\n  /**\r\n   * Return true if the ellipse center and basis vectors are in the plane\r\n   * @param plane\r\n   */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    const normal = plane.getNormalRef();\r\n    // The ellipse vectors are full-length  -- true distance comparisons say things.\r\n    return Geometry.isSmallMetricDistance(plane.altitude(this._center))\r\n      && Geometry.isSmallMetricDistance(this._matrix.dotColumnX(normal))\r\n      && Geometry.isSmallMetricDistance(this._matrix.dotColumnY(normal));\r\n  }\r\n  /**\r\n   * Return true if the vector0 and vector90 are of equal length and perpendicular.\r\n   */\r\n  public get isCircular(): boolean {\r\n    const axx = this._matrix.columnXMagnitudeSquared();\r\n    const ayy = this._matrix.columnYMagnitudeSquared();\r\n    const axy = this._matrix.columnXDotColumnY();\r\n    return Angle.isPerpendicularDotSet(axx, ayy, axy) && Geometry.isSameCoordinateSquared(axx, ayy);\r\n  }\r\n  /** If the arc is circular, return its radius.  Otherwise return undefined */\r\n  public circularRadius(): number | undefined {\r\n    return this.isCircular ? this._matrix.columnXMagnitude() : undefined;\r\n  }\r\n\r\n  /** Return the larger of the two defining vectors. */\r\n  public maxVectorLength(): number { return Math.max(this._matrix.columnXMagnitude(), this._matrix.columnYMagnitude()); }\r\n  /**\r\n   * compute intersections with a plane.\r\n   * @param plane plane to intersect\r\n   * @param result array of locations on the curve.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const constCoff = plane.altitude(this._center);\r\n    const coffs = this._matrix.coffs;\r\n    const cosCoff = plane.velocityXYZ(coffs[0], coffs[3], coffs[6]);\r\n    const sinCoff = plane.velocityXYZ(coffs[1], coffs[4], coffs[7]);\r\n    const trigPoints = Geometry.solveTrigForm(constCoff, cosCoff, sinCoff);\r\n    let numIntersection = 0;\r\n    if (trigPoints !== undefined) {\r\n      numIntersection = trigPoints.length;\r\n      let xy;\r\n      for (xy of trigPoints) {\r\n        const radians = Math.atan2(xy.y, xy.x);\r\n        const fraction = this._sweep.radiansToPositivePeriodicFraction(radians);\r\n        result.push(CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction)));\r\n      }\r\n    }\r\n    return numIntersection;\r\n  }\r\n  /**\r\n   * Extend a range to include the range of the arc.\r\n   * @param range range being extended.\r\n   * @param transform optional transform to apply to the arc.\r\n   */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    const df = 1.0 / 32;\r\n    // KLUDGE --- evaluate lots of points ...\r\n    let point = Point3d.create();\r\n    for (let fraction = 0; fraction <= 1.001; fraction += df) {\r\n      point = this.fractionToPoint(fraction, point);\r\n      if (transform)\r\n        range.extendTransformedPoint(transform, point);\r\n      else\r\n        range.extendPoint(point);\r\n    }\r\n  }\r\n  /**\r\n   * Create a new arc which is a unit circle centered at the origin.\r\n   */\r\n  public static createUnitCircle(): Arc3d {\r\n    return Arc3d.createRefs(Point3d.create(0, 0, 0), Matrix3d.createIdentity(), AngleSweep.create360());\r\n  }\r\n  /**\r\n   * Create a new arc which is parallel to the xy plane, with given center and radius and optional angle sweep.\r\n   * @param center center of arc\r\n   * @param radius radius of arc\r\n   * @param sweep sweep limits.  defaults to full circle.\r\n   */\r\n  public static createXY(\r\n    center: Point3d,\r\n    radius: number,\r\n    sweep: AngleSweep = AngleSweep.create360()): Arc3d {\r\n    return new Arc3d(center.clone(), Matrix3d.createScale(radius, radius, 1.0), sweep);\r\n  }\r\n  /**\r\n   * Create a new arc which is parallel to the xy plane, with given center and x,y radii, and optional angle sweep\r\n   * @param center center of ellipse\r\n   * @param radiusA x axis radius\r\n   * @param radiusB y axis radius\r\n   * @param sweep angle sweep\r\n   */\r\n  public static createXYEllipse(\r\n    center: Point3d,\r\n    radiusA: number,\r\n    radiusB: number,\r\n    sweep: AngleSweep = AngleSweep.create360()): Arc3d {\r\n    return new Arc3d(center.clone(), Matrix3d.createScale(radiusA, radiusB, 1.0), sweep);\r\n  }\r\n  /**\r\n   * Replace the arc's 0 and 90 degree vectors.\r\n   * @param vector0 vector from center to ellipse point at 0 degrees in parameter space\r\n   * @param vector90 vector from center to ellipse point at 90 degrees in parameter space\r\n   */\r\n  public setVector0Vector90(vector0: Vector3d, vector90: Vector3d) {\r\n    this._matrix.setColumns(vector0, vector90,\r\n      vector0.unitCrossProductWithDefault(vector90, 0, 0, 0), // normal will be 000 for degenerate case !!!;\r\n    );\r\n  }\r\n  /** Return the arc definition with rigid matrix form with axis radii.\r\n   */\r\n  public toScaledMatrix3d(): { center: Point3d, axes: Matrix3d, r0: number, r90: number, sweep: AngleSweep } {\r\n    const angleData = Angle.dotProductsToHalfAngleTrigValues(\r\n      this._matrix.columnXMagnitudeSquared(),\r\n      this._matrix.columnYMagnitudeSquared(),\r\n      this._matrix.columnXDotColumnY(), true);\r\n    const vector0A = this._matrix.multiplyXY(angleData.c, angleData.s);\r\n    const vector90A = this._matrix.multiplyXY(-angleData.s, angleData.c);\r\n\r\n    const axes = Matrix3d.createRigidFromColumns(vector0A, vector90A, AxisOrder.XYZ);\r\n    return {\r\n      axes: (axes ? axes : Matrix3d.createIdentity()),\r\n      center: this._center,\r\n      r0: vector0A.magnitude(),\r\n      r90: vector90A.magnitude(),\r\n      sweep: this.sweep.cloneMinusRadians(angleData.radians),\r\n    };\r\n  }\r\n  /** Return the arc definition with center, two vectors, and angle sweep;\r\n   */\r\n  public toVectors(): { center: Point3d, vector0: Vector3d, vector90: Vector3d, sweep: AngleSweep } {\r\n    return {\r\n      center: this.center,\r\n      vector0: this._matrix.columnX(),\r\n      vector90: this._matrix.columnY(),\r\n      sweep: this.sweep,\r\n    };\r\n  }\r\n\r\n  /** Return the arc definition with center, two vectors, and angle sweep, optionally transformed.\r\n   */\r\n  public toTransformedVectors(transform?: Transform): { center: Point3d, vector0: Vector3d, vector90: Vector3d, sweep: AngleSweep } {\r\n    return transform ? {\r\n      center: transform.multiplyPoint3d(this._center),\r\n      vector0: transform.multiplyVector(this._matrix.columnX()),\r\n      vector90: transform.multiplyVector(this._matrix.columnY()),\r\n      sweep: this.sweep,\r\n    }\r\n      : {\r\n        center: this._center.clone(),\r\n        vector0: this._matrix.columnX(),\r\n        vector90: this._matrix.columnY(),\r\n        sweep: this.sweep,\r\n      };\r\n  }\r\n\r\n  /** Return the arc definition with center, two vectors, and angle sweep, transformed to 4d points.\r\n   */\r\n  public toTransformedPoint4d(matrix: Matrix4d): { center: Point4d, vector0: Point4d, vector90: Point4d, sweep: AngleSweep } {\r\n    return {\r\n      center: matrix.multiplyPoint3d(this._center, 1.0),\r\n      vector0: matrix.multiplyPoint3d(this._matrix.columnX(), 0.0),\r\n      vector90: matrix.multiplyPoint3d(this._matrix.columnY(), 0.0),\r\n      sweep: this.sweep,\r\n    };\r\n  }\r\n  /**\r\n   * Set this arc from a json object with these values:\r\n   * * center center point\r\n   * * vector0 vector from center to 0 degree point in parameter space (commonly but not always the major axis vector)\r\n   * * vector90 vector from center to 90 degree point in parameter space (commonly but not always the minor axis vector)\r\n   * @param json\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    if (json && json.center && json.vector0 && json.vector90 && json.sweep) {\r\n      this._center.setFromJSON(json.center);\r\n      const vector0 = Vector3d.create();\r\n      const vector90 = Vector3d.create();\r\n      vector0.setFromJSON(json.vector0);\r\n      vector90.setFromJSON(json.vector90);\r\n      this.setVector0Vector90(vector0, vector90);\r\n      this._sweep.setFromJSON(json.sweep);\r\n    } else {\r\n      this._center.set(0, 0, 0);\r\n      this._matrix.setFrom(Matrix3d.identity);\r\n      this._sweep.setStartEndRadians();\r\n    }\r\n  }\r\n  /**\r\n   * Convert to a JSON object.\r\n   * @return {*} [center:  [], vector0:[], vector90:[], sweep []}\r\n   */\r\n  public toJSON(): any {\r\n    return {\r\n      center: this._center.toJSON(),\r\n      sweep: this._sweep.toJSON(),\r\n      vector0: this._matrix.columnX().toJSON(),\r\n      vector90: this._matrix.columnY().toJSON(),\r\n    };\r\n  }\r\n  /**\r\n   * Test if this arc is almost equal to another GeometryQuery object\r\n   */\r\n  public isAlmostEqual(otherGeometry: GeometryQuery): boolean {\r\n    if (otherGeometry instanceof Arc3d) {\r\n      const other = otherGeometry as Arc3d;\r\n      return this._center.isAlmostEqual(other._center)\r\n        && this._matrix.isAlmostEqual(other._matrix)\r\n        && this._sweep.isAlmostEqualAllowPeriodShift(other._sweep);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const numStrokes = this.computeStrokeCountForOptions(options);\r\n    dest.appendFractionalStrokePoints(this, numStrokes, 0.0, 1.0, true);\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied handler */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const numStrokes = this.computeStrokeCountForOptions(options);\r\n    handler.startCurvePrimitive(this);\r\n    handler.announceIntervalForUniformStepStrokes(this, numStrokes, 0.0, 1.0);\r\n    handler.endCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 1;\r\n    if (options) {\r\n      const rMax = this.maxVectorLength();\r\n      numStroke = options.applyTolerancesToArc(rMax, this._sweep.sweepRadians);\r\n    } else {\r\n      numStroke = StrokeOptions.applyAngleTol(undefined, 1, this._sweep.sweepRadians);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleArc3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleArc3d(this);\r\n  }\r\n  /** Return (if possible) an arc which is a portion of this curve.\r\n   * @param fractionA [in] start fraction\r\n   * @param fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined {\r\n    if (fractionB < fractionA) {\r\n      const arcA = this.clonePartialCurve(fractionB, fractionA);\r\n      if (arcA)\r\n        arcA.reverseInPlace();\r\n      return arcA;\r\n    }\r\n    const arcB = this.clone();\r\n\r\n    arcB.sweep.setStartEndRadians(\r\n      this.sweep.fractionToRadians(fractionA),\r\n      this.sweep.fractionToRadians(fractionB));\r\n    return arcB;\r\n  }\r\n  /**\r\n   * Find intervals of this curveprimitve that are interior to a clipper\r\n   * @param clipper clip structure (e.g.clip planes)\r\n   * @param announce(optional) function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   * @returns true if any \"in\" segments are announced.\r\n   */\r\n  public announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    return clipper.announceClippedArcIntervals(this, announce);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/**\r\n * Context for constructing a curve that is interpolated between two other curves.\r\n * * The only callable method is the static `InterpolateBetween`.\r\n * * Other methods are called only by `dispatchToGeometryHandler`\r\n * @public\r\n */\r\nexport class ConstructCurveBetweenCurves extends NullGeometryHandler {\r\n  // private geometry0: GeometryQuery;  <-- Never used\r\n  private _geometry1: GeometryQuery;\r\n  private _fraction: number;\r\n  private constructor(_geometry0: GeometryQuery, _fraction: number, _geometry1: GeometryQuery) {\r\n    super();\r\n    // this.geometry0 = _geometry0;   <-- Never used\r\n    this._geometry1 = _geometry1;\r\n    this._fraction = _fraction;\r\n  }\r\n\r\n  /**\r\n   * * To be directly called only by double dispatcher\r\n   * * Assumes this.geometry1 was set by calling context.\r\n   * * Construct the interpolated curve between this.geometry1 and the supplied segment0.\r\n   */\r\n  public handleLineSegment3d(segment0: LineSegment3d): any {\r\n    if (this._geometry1 instanceof LineSegment3d) {\r\n      const segment1 = this._geometry1 as LineSegment3d;\r\n      return LineSegment3d.create(\r\n        segment0.startPoint().interpolate(this._fraction, segment1.startPoint()),\r\n        segment0.endPoint().interpolate(this._fraction, segment1.endPoint()));\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * To be directly called only by double dispatcher\r\n   * * Assumes this.geometry1 was set by calling context.\r\n   * * Construct the interpolated curve between this.geometry1 and the supplied ls0.\r\n   */\r\n  public handleLineString3d(ls0: LineString3d): any {\r\n    if (this._geometry1 instanceof LineString3d) {\r\n      const ls1 = this._geometry1 as LineString3d;\r\n      if (ls0.numPoints() === ls1.numPoints()) {\r\n        const numPoints = ls0.numPoints();\r\n        const ls = LineString3d.create();\r\n        const workPoint = Point3d.create();\r\n        const workPoint0 = Point3d.create();\r\n        const workPoint1 = Point3d.create();\r\n        let workVector0;\r\n        let workVector1;\r\n        const fraction = this._fraction;\r\n        for (let i = 0; i < numPoints; i++) {\r\n          ls0.pointAt(i, workPoint0);\r\n          ls1.pointAt(i, workPoint1);\r\n          workPoint0.interpolate(fraction, workPoint1, workPoint);\r\n          ls.addPoint(workPoint);\r\n        }\r\n        if (ls0.fractions && ls1.fractions) {\r\n          for (let i = 0; i < numPoints; i++) {\r\n            ls.addFraction(Geometry.interpolate(ls0.fractions.atUncheckedIndex(i), fraction, ls1.fractions.atUncheckedIndex(i)));\r\n          }\r\n        }\r\n        if (ls0.strokeData && ls1.strokeData) {\r\n          // Policy: simple clone of stroke count map from ls0.\r\n          // The curveLength will not match.\r\n          // But we expect to be called at a time compatible count and a0,a1 are the important thing.\r\n          ls.strokeData = ls0.strokeData.clone();\r\n        }\r\n        if (ls0.packedDerivatives && ls1.packedDerivatives) {\r\n          if (!workVector0)\r\n            workVector0 = Vector3d.create();\r\n          if (!workVector1)\r\n            workVector1 = Vector3d.create();\r\n          for (let i = 0; i < numPoints; i++) {\r\n            ls0.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector0);\r\n            ls1.packedDerivatives.getVector3dAtCheckedVectorIndex(i, workVector1);\r\n            ls.addDerivative(workVector0.interpolate(fraction, workVector1));\r\n          }\r\n\r\n        }\r\n        return ls;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * To be directly called only by double dispatcher\r\n   * * Assumes this.geometry1 was set by calling context.\r\n   * * Construct the interpolated curve between this.geometry1 and the supplied arc0.\r\n   */\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    if (this._geometry1 instanceof Arc3d) {\r\n      const arc1 = this._geometry1 as Arc3d;\r\n      return Arc3d.create(\r\n        arc0.center.interpolate(this._fraction, arc1.center),\r\n        arc0.vector0.interpolate(this._fraction, arc1.vector0),\r\n        arc0.vector90.interpolate(this._fraction, arc1.vector90),\r\n        arc0.sweep.interpolate(this._fraction, arc1.sweep));\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Construct a geometry item which is fractionally interpolated between two others.\r\n   * * The construction is only supported between certain types:\r\n   * * * LineSegment3d+LineSegment3d -- endpoints are interpolated\r\n   * * * LineString3d+LineString3d with matching counts.  Each point is interpolated.\r\n   * * * Arc3d+Arc3d -- center, vector0, vector90, and limit angles of the sweep are interpolated.\r\n   * @param geometry0 geometry \"at fraction 0\"\r\n   * @param fraction  fractional position\r\n   * @param geometry1 geometry \"at fraction 1\"\r\n   */\r\n  public static interpolateBetween(geometry0: GeometryQuery, fraction: number, geometry1: GeometryQuery): GeometryQuery | undefined {\r\n    const handler = new ConstructCurveBetweenCurves(geometry0, fraction, geometry1);\r\n    return geometry0.dispatchToGeometryHandler(handler);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\n\r\n/** A Coordinate is a persistable Point3d\r\n * @public\r\n */\r\nexport class CoordinateXYZ extends GeometryQuery {\r\n  private _xyz: Point3d;\r\n  /** Return a (REFERENCE TO) the coordinate data. */\r\n  public get point() { return this._xyz; }\r\n  /**\r\n   * @param xyz point to be CAPTURED.\r\n   */\r\n  private constructor(xyz: Point3d) {\r\n    super();\r\n    this._xyz = xyz;\r\n  }\r\n  /** Create a new CoordinateXYZ */\r\n  public static create(point: Point3d): CoordinateXYZ {\r\n    return new CoordinateXYZ(point.clone());\r\n  }\r\n  /** return the range of the point */\r\n  public range(): Range3d { return Range3d.create(this._xyz); }\r\n\r\n  /** extend `rangeToExtend` to include this point (optionally transformed) */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    if (transform)\r\n      rangeToExtend.extendTransformedXYZ(transform, this._xyz.x, this._xyz.y, this._xyz.z);\r\n    else\r\n      rangeToExtend.extend(this._xyz);\r\n  }\r\n  /** Apply transform to the Coordinate's point. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyPoint3d(this._xyz, this._xyz);\r\n    return true;\r\n  }\r\n  /** return a transformed clone.\r\n   */\r\n  public cloneTransformed(transform: Transform): GeometryQuery | undefined {\r\n    const result = new CoordinateXYZ(this._xyz.clone());\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** return a clone */\r\n  public clone(): GeometryQuery | undefined {\r\n    return new CoordinateXYZ(this._xyz.clone());\r\n  }\r\n  /** return GeometryQuery children for recursive queries.\r\n   *\r\n   * * leaf classes do not need to implement.\r\n   */\r\n\r\n  /** test if (other instanceof Coordinate).  */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean {\r\n    return other instanceof CoordinateXYZ;\r\n  }\r\n  /** test for exact structure and nearly identical geometry.\r\n   *\r\n   * *  Leaf classes must implement !!!\r\n   * *  base class implementation recurses through children.\r\n   * *  base implementation is complete for classes with children and no properties.\r\n   * *  classes with both children and properties must implement for properties, call super for children.\r\n   */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    return (other instanceof CoordinateXYZ) && this._xyz.isAlmostEqual(other._xyz);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleCoordinateXYZ(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleCoordinateXYZ(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { IStrokeHandler, GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveChain } from \"./CurveCollection\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\r\n/**\r\n * * Annotation of an interval of a curve.\r\n * * The interval is marked with two pairs of numbers:\r\n * * * fraction0, fraction1 = fraction parameters along the child curve\r\n * * * distance0,distance1 = distances within containing CurveChainWithDistanceIndex\r\n * @public\r\n */\r\nexport class PathFragment {\r\n  /** distance along parent to this fragment start */\r\n  public chainDistance0: number;\r\n  /** distance along parent to this fragment end */\r\n  public chainDistance1: number;\r\n  /** Fractional position of this fragment start within its curve primitive. */\r\n  public childFraction0: number;\r\n  /** Fractional position of this fragment end within its curve primitive.. */\r\n  public childFraction1: number;\r\n  /** Curve primitive of this fragment */\r\n  public childCurve: CurvePrimitive;\r\n  /** Create a fragment with complete fraction, distance and child data. */\r\n  public constructor(childFraction0: number, childFraction1: number, distance0: number, distance1: number, childCurve: CurvePrimitive) {\r\n    this.childFraction0 = childFraction0;\r\n    this.childFraction1 = childFraction1;\r\n    this.chainDistance0 = distance0;\r\n    this.chainDistance1 = distance1;\r\n    this.childCurve = childCurve;\r\n  }\r\n  /**\r\n   * Return true if the distance is within the distance limits of this fragment.\r\n   * @param distance\r\n   */\r\n  public containsChainDistance(distance: number): boolean {\r\n    return distance >= this.chainDistance0 && distance <= this.chainDistance1;\r\n  }\r\n\r\n  /**\r\n   * Return true if this fragment addresses `curve` and brackets `fraction`\r\n   * @param distance\r\n   */\r\n  public containsChildCurveAndChildFraction(curve: CurvePrimitive, fraction: number): boolean {\r\n    return this.childCurve === curve && fraction >= this.childFraction0 && fraction <= this.childFraction1;\r\n  }\r\n\r\n  /** Convert distance to local fraction, and apply that to interpolate between the stored curve fractions.\r\n   * Note that proportional calculation does NOT account for nonuniform parameterization in the child curve.\r\n   */\r\n  public chainDistanceToInterpolatedChildFraction(distance: number): number {\r\n    return Geometry.inverseInterpolate(\r\n      this.childFraction0, this.chainDistance0,\r\n      this.childFraction1, this.chainDistance1,\r\n      distance, this.childFraction0)!;    // the interval \"must\" have nonzero length, division should be safe . ..\r\n  }\r\n  /** Convert chainDistance to true chidFraction, using detailed moveSignedDistanceFromFraction\r\n   */\r\n  public chainDistanceToAccurateChildFraction(chainDistance: number): number {\r\n    // The fragments are really expected to do good mappings in their distance range ...\r\n    const childDetail = this.childCurve.moveSignedDistanceFromFraction(\r\n      this.childFraction0, chainDistance - this.chainDistance0, false);\r\n    return childDetail.fraction;\r\n  }\r\n  /** Return the scale factor to map childCurve fraction derivatives to chain fraction derivatives\r\n   * @param globalDistance total length of the global curve.\r\n   */\r\n  public fractionScaleFactor(globalDistance: number): number {\r\n    return globalDistance * (this.childFraction1 - this.childFraction0) / (this.chainDistance1 - this.chainDistance0);\r\n  }\r\n  /** Reverse the fraction and distance data.\r\n   * * each child fraction `f` is replaced by `1-f`\r\n   * * each `chainDistance` is replaced by `totalDistance-chainDistance`\r\n   */\r\n  public reverseFractionsAndDistances(totalDistance: number) {\r\n    const f0 = this.childFraction0;\r\n    const f1 = this.childFraction1;\r\n    const d0 = this.chainDistance0;\r\n    const d1 = this.chainDistance1;\r\n    this.childFraction0 = 1.0 - f1;\r\n    this.childFraction1 = 1.0 - f0;\r\n    this.chainDistance0 = totalDistance - d1;\r\n    this.chainDistance1 = totalDistance - d0;\r\n  }\r\n  /**\r\n   * convert a fractional position on the childCurve to distance in the chain space.\r\n   * @param fraction fraction along the curve within this fragment\r\n   */\r\n  public childFractionTChainDistance(fraction: number): number {\r\n    return this.chainDistance0 + this.childCurve.curveLengthBetweenFractions(this.childFraction0, fraction);\r\n  }\r\n}\r\n/** Non-instantiable class to build a distance index for a path. */\r\nclass DistanceIndexConstructionContext implements IStrokeHandler {\r\n  private _fragments: PathFragment[];\r\n  private _accumulatedDistance: number;\r\n  private constructor() {\r\n    this._accumulatedDistance = 0;\r\n    this._fragments = [];\r\n  }\r\n  // ignore curve announcements -- they are repeated in stroke announcements\r\n  public startParentCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public startCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public endParentCurvePrimitive(_cp: CurvePrimitive) { }\r\n  public endCurvePrimitive(_cp: CurvePrimitive) { }\r\n  // um .. we need to see curves? how to reject?\r\n  public announcePointTangent(_xyz: Point3d, _fraction: number, _tangent: Vector3d) { }\r\n  /** Announce numPoints interpolated between point0 and point1, with associated fractions */\r\n  public announceSegmentInterval(\r\n    cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    let d0 = this._accumulatedDistance;\r\n    if (numStrokes <= 1) {\r\n      this._accumulatedDistance += point0.distance(point1);\r\n      this._fragments.push(new PathFragment(fraction0, fraction1, d0, this._accumulatedDistance, cp));\r\n    } else {\r\n      let f1;\r\n      for (let i = 1, f0 = 0.0; i <= numStrokes; i++ , f0 = f1) {\r\n        f1 = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\r\n        d0 = this._accumulatedDistance;\r\n        this._accumulatedDistance += (Math.abs(f1 - f0) * point0.distance(point1));\r\n        this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp));\r\n      }\r\n    }\r\n  }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    let f1, d, d0;\r\n    for (let i = 1, f0 = fraction0; i <= numStrokes; i++ , f0 = f1) {\r\n      f1 = Geometry.interpolate(fraction0, i / numStrokes, fraction1);\r\n      d = cp.curveLengthBetweenFractions(f0, f1);\r\n      d0 = this._accumulatedDistance;\r\n      this._accumulatedDistance += d;\r\n      this._fragments.push(new PathFragment(f0, f1, d0, this._accumulatedDistance, cp));\r\n    }\r\n  }\r\n  public static createPathFragmentIndex(path: CurveChain, options?: StrokeOptions): PathFragment[] {\r\n    const handler = new DistanceIndexConstructionContext();\r\n    for (const curve of path.children) {\r\n      curve.emitStrokableParts(handler, options);\r\n    }\r\n    const fragments = handler._fragments;\r\n    return fragments;\r\n  }\r\n}\r\n/**\r\n * `CurveChainWithDistanceIndex` is a CurvePrimitive whose fractional parameterization is proportional to true\r\n * distance along a CurveChain.\r\n * * The curve chain can be any type derived from CurveChain.\r\n * * * i.e. either a `Path` or a `Loop`\r\n * @public\r\n */\r\nexport class CurveChainWithDistanceIndex extends CurvePrimitive {\r\n  private _path: CurveChain;\r\n  private _fragments: PathFragment[];\r\n  private _totalLength: number; // matches final fragment distance1.\r\n  /** Test if other is a `CurveChainWithDistanceIndex` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof CurveChainWithDistanceIndex; }\r\n  // final assembly of CurveChainWithDistanceIndex -- caller must create valid fragment index.\r\n  private constructor(path: CurveChain, fragments: PathFragment[]) {\r\n    super();\r\n    this._path = path;\r\n    this._fragments = fragments;\r\n    this._totalLength = fragments[fragments.length - 1].chainDistance1;\r\n  }\r\n  /**\r\n   * Create a clone, transformed and with its own distance index.\r\n   * @param transform transform to apply in the clone.\r\n   */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive | undefined {\r\n    const c = this._path.clone();\r\n    if (c !== undefined && c instanceof CurveChain && c.tryTransformInPlace(transform))\r\n      return CurveChainWithDistanceIndex.createCapture(c as CurveChain);\r\n    return undefined;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): CurvePrimitive | undefined {\r\n    const c = this._path.clone();\r\n    if (c !== undefined && c instanceof CurveChain)\r\n      return CurveChainWithDistanceIndex.createCapture(c as CurveChain);\r\n    return undefined;\r\n  }\r\n  /** Ask if the curve is within tolerance of a plane.\r\n   * @returns Returns true if the curve is completely within tolerance of the plane.\r\n   */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    for (const c of this._path.children) {\r\n      if (!c.isInPlane(plane))\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */\r\n  public startPoint(result?: Point3d): Point3d {\r\n    const c = this._path.cyclicCurvePrimitive(0);\r\n    if (c)\r\n      return c.startPoint(result);\r\n    return Point3d.createZero(result);\r\n  }\r\n  /** Return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */\r\n  public endPoint(result?: Point3d): Point3d {\r\n    const c = this._path.cyclicCurvePrimitive(-1);\r\n    if (c)\r\n      return c.endPoint(result);\r\n    return Point3d.createZero(result);\r\n  }\r\n  /** Add strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    for (const c of this._path.children) {\r\n      c.emitStrokes(dest, options);\r\n    }\r\n  }\r\n  /** Ask the curve to announce points and simple subcurve fragments for stroking.\r\n   * See IStrokeHandler for description of the sequence of the method calls.\r\n   */\r\n  public emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void {\r\n    for (const c of this._path.children) {\r\n      c.emitStrokableParts(dest, options);\r\n    }\r\n  }\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 0;\r\n    for (const c of this._path.children) {\r\n      numStroke += c.computeStrokeCountForOptions(options);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * construct StrokeCountMap for each child, accumulating data to stroke count map for this primitive.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const myMap = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap);\r\n    for (const c of this._path.children) {\r\n      c.computeAndAttachRecursiveStrokeCounts(options, myMap);\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myMap, parentStrokeMap);\r\n  }\r\n  /** Second step of double dispatch:  call `this._path.dispatchToGeometryHandler (handler)`\r\n   * * Note that this exposes the children individually to the handler.\r\n   */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return this._path.dispatchToGeometryHandler(handler);\r\n  }\r\n  /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed)\r\n   */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this._path.extendRange(rangeToExtend, transform);\r\n  }\r\n  /**\r\n   *\r\n   * * Curve length is always positive.\r\n   * @returns Returns a (high accuracy) length of the curve between fractional positions\r\n   * @returns Returns the length of the curve.\r\n   */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    return Math.abs(fraction1 - fraction0) * this._totalLength;\r\n  }\r\n  /**\r\n   * Capture (not clone) a path into a new `CurveChainWithDistanceIndex`\r\n   * @param primitives primitive array to be CAPTURED (not cloned)\r\n   */\r\n  public static createCapture(path: CurveChain, options?: StrokeOptions): CurveChainWithDistanceIndex {\r\n    const fragments = DistanceIndexConstructionContext.createPathFragmentIndex(path, options);\r\n    const result = new CurveChainWithDistanceIndex(path, fragments);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Resolve a fraction of the CurveChain to a PathFragment\r\n   * @param distance\r\n   * @param allowExtrapolation\r\n   */\r\n  protected chainDistanceToFragment(distance: number, allowExtrapolation: boolean = false): PathFragment | undefined {\r\n    const numFragments = this._fragments.length;\r\n    const fragments = this._fragments!;\r\n    if (numFragments > 0) {\r\n      if (distance < 0.0)\r\n        return allowExtrapolation ? fragments[0] : undefined;\r\n      if (distance >= this._totalLength)\r\n        return allowExtrapolation ? fragments[numFragments - 1] : undefined;\r\n      // humbug, linear search\r\n      for (const fragment of fragments) {\r\n        if (fragment.containsChainDistance(distance)) return fragment;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Convert distance along the chain to fraction along the chain.\r\n   * @param distance distance along the chain\r\n   */\r\n  public chainDistanceToChainFraction(distance: number): number { return distance / this._totalLength; }\r\n  /**\r\n   * Resolve a fraction within a specific curve to a fragment.\r\n   * @param curve\r\n   * @param fraction\r\n   */\r\n  protected curveAndChildFractionToFragment(curve: CurvePrimitive, fraction: number): PathFragment | undefined {\r\n    const numFragments = this._fragments.length;\r\n    const fragments = this._fragments!;\r\n    if (numFragments > 0) {\r\n      // humbug, linear search\r\n      for (const fragment of fragments) {\r\n        if (fragment.containsChildCurveAndChildFraction(curve, fraction)) return fragment;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Returns the total length of curves.\r\n   */\r\n  public curveLength(): number {\r\n    return this._totalLength;\r\n  }\r\n  /**\r\n   * Returns the total length of the path.\r\n   * * This is exact (and simple property lookup) because the true lengths were summed at construction time.\r\n   */\r\n  public quickLength(): number {\r\n    return this._totalLength;\r\n  }\r\n\r\n  /**\r\n   * Return the point (x,y,z) on the curve at fractional position along the chain.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a point on the curve.\r\n   */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    const chainDistance = fraction * this._totalLength;\r\n    let fragment = this.chainDistanceToFragment(chainDistance, true);\r\n    if (fragment) {\r\n      const childFraction = fragment.chainDistanceToAccurateChildFraction(chainDistance);\r\n      return fragment.childCurve.fractionToPoint(childFraction, result);\r\n    }\r\n    fragment = this.chainDistanceToFragment(chainDistance, true);\r\n    return this._fragments[0].childCurve.fractionToPoint(0.0, result);\r\n  }\r\n\r\n  /** Return the point (x,y,z) and derivative on the curve at fractional position.\r\n   *\r\n   * * Note that this derivative is \"derivative of xyz with respect to fraction.\"\r\n   * * this derivative shows the speed of the \"fractional point\" moving along the curve.\r\n   * * this is not generally a unit vector.  use fractionToPointAndUnitTangent for a unit vector.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a ray whose origin is the curve point and direction is the derivative with respect to the fraction.\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    const distanceAlongPath = fraction * this._totalLength;\r\n    const fragment = this.chainDistanceToFragment(distanceAlongPath, true)!;\r\n    const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);\r\n    result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);\r\n    const a = this._totalLength / result.direction.magnitude();\r\n    result.direction.scaleInPlace(a);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns a ray whose origin is the curve point and direction is the unit tangent.\r\n   * @param fraction fractional position on the curve\r\n   * @param result optional receiver for the result.\r\n   * Returns a ray whose origin is the curve point and direction is the unit tangent.\r\n   */\r\n  public fractionToPointAndUnitTangent(fraction: number, result?: Ray3d): Ray3d {\r\n    const distanceAlongPath = fraction * this._totalLength;\r\n    const fragment = this.chainDistanceToFragment(distanceAlongPath, true)!;\r\n    const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);\r\n    result = fragment.childCurve.fractionToPointAndDerivative(curveFraction, result);\r\n    result.direction.normalizeInPlace();\r\n    return result;\r\n  }\r\n  /** Return a plane with\r\n   *\r\n   * * origin at fractional position along the curve\r\n   * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\r\n   * * vectorV is the second derivative, i.e.derivative of vectorU.\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined {\r\n    const totalLength = this._totalLength;\r\n    const distanceAlongPath = fraction * totalLength;\r\n    const fragment = this.chainDistanceToFragment(distanceAlongPath, true)!;\r\n    const curveFraction = fragment.chainDistanceToAccurateChildFraction(distanceAlongPath);\r\n    result = fragment.childCurve.fractionToPointAnd2Derivatives(curveFraction, result);\r\n    if (!result)\r\n      return undefined;\r\n    const dotUU = result.vectorU.magnitudeSquared();\r\n    const magU = Math.sqrt(dotUU);\r\n    const dotUV = result.vectorU.dotProduct(result.vectorV);\r\n    const duds = 1.0 / magU;\r\n    const a = duds * duds;\r\n    Vector3d.createAdd2Scaled(result.vectorV, a, result.vectorU, -a * dotUV / dotUU, result.vectorV);   // IN PLACE update to vectorV.\r\n    result.vectorU.scale(duds);\r\n    // scale for 0..1 parameterization ....\r\n    result.vectorU.scaleInPlace(totalLength);\r\n    result.vectorV.scaleInPlace(totalLength * totalLength);\r\n    return result;\r\n  }\r\n  /** Attempt to transform in place.\r\n   * * Warning: If any child fails, this object becomes invalid.  But that should never happen.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    let numFail = 0;\r\n    for (const c of this._path.children) {\r\n      if (!c.tryTransformInPlace(transform))\r\n        numFail++;\r\n    }\r\n    return numFail === 0;\r\n  }\r\n  /** Reverse the curve's data so that its fractional stroking moves in the opposite direction. */\r\n  public reverseInPlace(): void {\r\n    this._path.reverseChildrenInPlace();\r\n    const totalLength = this._totalLength;\r\n    for (const fragment of this._fragments)\r\n      fragment.reverseFractionsAndDistances(totalLength);\r\n    for (let i = 0, j = this._fragments.length - 1; i < j; i++ , j--) {\r\n      const fragment = this._fragments[i];\r\n      this._fragments[i] = this._fragments[j];\r\n      this._fragments[j] = fragment;\r\n    }\r\n  }\r\n  /**\r\n   * Test for equality conditions:\r\n   * * Mismatched totalLength is a quick exit condition\r\n   * * If totalLength matches, recurse to the path for matching primitives.\r\n   * @param other\r\n   */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof CurveChainWithDistanceIndex) {\r\n      return Geometry.isSameCoordinate(this._totalLength, other._totalLength)\r\n        && this._path.isAlmostEqual(other._path);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Implement moveSignedDistanceFromFraction.\r\n   * * See `CurvePrimitive` for parameter details.\r\n   * * The returned location directly identifies fractional position along the CurveChainWithDistanceIndex, and has pointer to an additional detail for the child curve.\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const distanceA = startFraction * this._totalLength;\r\n    const distanceB = distanceA + signedDistance;\r\n    const fragmentB = this.chainDistanceToFragment(distanceB, true)!;\r\n    const childDetail = fragmentB.childCurve.moveSignedDistanceFromFraction(fragmentB.childFraction0, distanceB - fragmentB.chainDistance0, allowExtension, result);\r\n    const endFraction = startFraction + (signedDistance / this._totalLength);\r\n    const chainDetail = CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, endFraction, signedDistance, result);\r\n    chainDetail.childDetail = childDetail;\r\n    return chainDetail;\r\n  }\r\n\r\n  /** Search for the curve point that is closest to the spacePoint.\r\n   * * The CurveChainWithDistanceIndex invokes the base class CurvePrimitive method, which\r\n   *     (via a handler) determines a CurveLocation detail among the children.\r\n   * * The returned detail directly identifies fractional position along the CurveChainWithDistanceIndex, and has pointer to an additional detail for the child curve.\r\n   * @param spacePoint point in space\r\n   * @param extend true to extend the curve (NOT USED)\r\n   * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, _extend: boolean): CurveLocationDetail | undefined {\r\n    // umm... to \"extend\", would require selective extension of first, last\r\n    const childDetail = super.closestPoint(spacePoint, false);\r\n    if (!childDetail)\r\n      return undefined;\r\n    const fragment = this.curveAndChildFractionToFragment(childDetail.curve!, childDetail.fraction);\r\n    if (fragment) {\r\n      const chainDistance = fragment.childFractionTChainDistance(childDetail.fraction);\r\n      const chainFraction = this.chainDistanceToChainFraction(chainDistance);\r\n      const chainDetail = CurveLocationDetail.createCurveFractionPoint(this, chainFraction, childDetail.point);\r\n      chainDetail.childDetail = childDetail;\r\n      return chainDetail;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { RecursiveCurveProcessor, RecursiveCurveProcessorWithStack } from \"./CurveProcessor\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n\r\n// import { SumLengthsContext, GapSearchContext, CountLinearPartsSearchContext, CloneCurvesContext, TransformInPlaceContext } from \"./CurveSearches\";\r\n\r\n/** Algorithmic class: Accumulate maximum gap between adjacent primitives of CurveChain.\r\n */\r\nclass GapSearchContext extends RecursiveCurveProcessorWithStack {\r\n  public maxGap: number;\r\n  constructor() { super(); this.maxGap = 0.0; }\r\n  public static maxGap(target: CurveCollection): number {\r\n    const context = new GapSearchContext();\r\n    target.announceToCurveProcessor(context);\r\n    return context.maxGap;\r\n  }\r\n  public announceCurvePrimitive(curve: CurvePrimitive, _indexInParent: number): void {\r\n    if (this._stack.length > 0) {\r\n      const parent = this._stack[this._stack.length - 1];\r\n      if (parent instanceof CurveChain) {\r\n        const chain = parent as CurveChain;\r\n        const nextCurve = chain.cyclicCurvePrimitive(_indexInParent + 1);\r\n        if (curve !== undefined && nextCurve !== undefined) {\r\n          this.maxGap = Math.max(this.maxGap, curve.endPoint().distance(nextCurve.startPoint()));\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** Algorithmic class: Count LineSegment3d and LineString3d primitives.\r\n */\r\nclass CountLinearPartsSearchContext extends RecursiveCurveProcessorWithStack {\r\n  public numLineSegment: number;\r\n  public numLineString: number;\r\n  public numOther: number;\r\n  constructor() {\r\n    super();\r\n    this.numLineSegment = 0;\r\n    this.numLineString = 0;\r\n    this.numOther = 0;\r\n  }\r\n  public static hasNonLinearPrimitives(target: CurveCollection): boolean {\r\n    const context = new CountLinearPartsSearchContext();\r\n    target.announceToCurveProcessor(context);\r\n    return context.numOther > 0;\r\n  }\r\n  public announceCurvePrimitive(curve: CurvePrimitive, _indexInParent: number): void {\r\n    if (curve instanceof LineSegment3d)\r\n      this.numLineSegment++;\r\n    else if (curve instanceof LineString3d)\r\n      this.numLineString++;\r\n    else\r\n      this.numOther++;\r\n  }\r\n}\r\n\r\n/** Algorithmic class: Transform curves in place.\r\n */\r\nclass TransformInPlaceContext extends RecursiveCurveProcessor {\r\n  public numFail: number;\r\n  public numOK: number;\r\n  public transform: Transform;\r\n  constructor(transform: Transform) { super(); this.numFail = 0; this.numOK = 0; this.transform = transform; }\r\n  public static tryTransformInPlace(target: CurveCollection, transform: Transform): boolean {\r\n    const context = new TransformInPlaceContext(transform);\r\n    target.announceToCurveProcessor(context);\r\n    return context.numFail === 0;\r\n  }\r\n  public announceCurvePrimitive(curvePrimitive: CurvePrimitive, _indexInParent: number): void {\r\n    if (!curvePrimitive.tryTransformInPlace(this.transform))\r\n      this.numFail++;\r\n    else\r\n      this.numOK++;\r\n  }\r\n}\r\n/** Algorithmic class: Sum lengths of curves */\r\nclass SumLengthsContext extends RecursiveCurveProcessor {\r\n  private _sum: number;\r\n  private constructor() { super(); this._sum = 0.0; }\r\n  public static sumLengths(target: CurveCollection): number {\r\n    const context = new SumLengthsContext();\r\n    target.announceToCurveProcessor(context);\r\n    return context._sum;\r\n  }\r\n  public announceCurvePrimitive(curvePrimitive: CurvePrimitive, _indexInParent: number): void {\r\n    this._sum += curvePrimitive.curveLength();\r\n  }\r\n}\r\n/**\r\n * Algorithmic class for cloning curve collections.\r\n * * recurse through collection nodes, building image nodes as needed and inserting clones of children.\r\n * * for individual primitive, invoke doClone (protected) for direct clone; insert into parent\r\n */\r\nclass CloneCurvesContext extends RecursiveCurveProcessorWithStack {\r\n  private _result: CurveCollection | undefined;\r\n  private _transform: Transform | undefined;\r\n  private constructor(transform?: Transform) {\r\n    super();\r\n    this._transform = transform;\r\n    this._result = undefined;\r\n  }\r\n  public static clone(target: CurveCollection, transform?: Transform): CurveCollection | undefined {\r\n    const context = new CloneCurvesContext(transform);\r\n    target.announceToCurveProcessor(context);\r\n    return context._result;\r\n  }\r\n  public enter(c: CurveCollection) {\r\n    if (c instanceof CurveCollection)\r\n      super.enter(c.cloneEmptyPeer());\r\n  }\r\n  public leave(): CurveCollection | undefined {\r\n    const result = super.leave();\r\n    if (result) {\r\n      if (this._stack.length === 0) // this should only happen once !!!\r\n        this._result = result as BagOfCurves;\r\n      else // push this result to top of stack.\r\n        this._stack[this._stack.length - 1].tryAddChild(result);\r\n    }\r\n    return result;\r\n  }\r\n  // specialized cloners override this (and allow announceCurvePrimitive to insert to parent)\r\n  protected doClone(primitive: CurvePrimitive): CurvePrimitive {\r\n    if (this._transform)\r\n      return primitive.cloneTransformed(this._transform) as CurvePrimitive;\r\n    return primitive.clone() as CurvePrimitive;\r\n  }\r\n\r\n  public announceCurvePrimitive(primitive: CurvePrimitive, _indexInParent: number): void {\r\n    const c = this.doClone(primitive);\r\n    if (c && this._stack.length > 0) {\r\n      const parent = this._stack[this._stack.length - 1];\r\n      if (parent instanceof CurveChain) {\r\n        parent.tryAddChild(c);\r\n      } else if (parent instanceof BagOfCurves) {\r\n        parent.tryAddChild(c);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * * A `CurveCollection` is an abstract (non-instantiable) class for various sets of curves with particular structures:\r\n *   * `CurveChain` is a (non-instantiable) intermediate class for a sequence of `CurvePrimitive ` joining head-to-tail.  The two instantiable forms of `CurveChain` are\r\n *     * `Path` - A chain not required to close, and not enclosing a planar area\r\n *     * `Loop` - A chain required to close from last to first so that a planar area is enclosed.\r\n *   * `ParityRegion` -- a collection of coplanar `Loop`s, with \"in/out\" classification by parity rules\r\n *   * `UnionRegion` -- a collection of coplanar `Loop`s, with \"in/out\" classification by union rules\r\n *   * `BagOfCurves` -- a collection of `AnyCurve` with no implied structure.\r\n * @public\r\n */\r\nexport abstract class CurveCollection extends GeometryQuery {\r\n  /* tslint:disable:variable-name no-empty*/\r\n  /**  Flag for inner loop status. Only used by `Loop`. */\r\n  public isInner: boolean = false;\r\n  /** Return the sum of the lengths of all contained curves. */\r\n  public sumLengths(): number { return SumLengthsContext.sumLengths(this); }\r\n  /** return the max gap between adjacent primitives in Path and Loop collections.\r\n   *\r\n   * * In a Path, gaps are computed between consecutive primitives.\r\n   * * In a Loop, gaps are computed between consecutive primitives and between last and first.\r\n   * * gaps are NOT computed between consecutive CurvePrimitives in \"unstructured\" collections.  The type is \"unstructured\" so gaps should not be semantically meaningful.\r\n   */\r\n  public maxGap(): number { return GapSearchContext.maxGap(this); }\r\n  /** return true if the curve collection has any primitives other than LineSegment3d and LineString3d  */\r\n  public checkForNonLinearPrimitives(): boolean { return CountLinearPartsSearchContext.hasNonLinearPrimitives(this); }\r\n  /** Apply transform recursively to children */\r\n  public tryTransformInPlace(transform: Transform): boolean { return TransformInPlaceContext.tryTransformInPlace(this, transform); }\r\n  /** Return a deep copy. */\r\n  public clone(): CurveCollection | undefined {\r\n    return CloneCurvesContext.clone(this);\r\n  }\r\n  /** Create a deep copy of transformed curves. */\r\n  public cloneTransformed(transform: Transform): CurveCollection | undefined {\r\n    return CloneCurvesContext.clone(this, transform);\r\n  }\r\n  /** Return true for planar region types:\r\n   * * `Loop`\r\n   * * `ParityRegion`\r\n   * * `UnionRegion`\r\n   */\r\n  public get isAnyRegionType(): boolean {\r\n    return this.dgnBoundaryType() === 2 || this.dgnBoundaryType() === 5 || this.dgnBoundaryType() === 4;\r\n  }\r\n  /** Return true for a `Path`, i.e. a chain of curves joined head-to-tail\r\n   */\r\n  public get isOpenPath(): boolean {\r\n    return this.dgnBoundaryType() === 1;\r\n  }\r\n  /** Return true for a single-loop planar region type, i.e. `Loop`.\r\n   * * This is _not- a test for physical closure of a `Path`\r\n   */\r\n  public get isClosedPath(): boolean {\r\n    return this.dgnBoundaryType() === 2;\r\n  }\r\n  /** Return a CurveCollection with the same structure but all curves replaced by strokes. */\r\n  public abstract cloneStroked(options?: StrokeOptions): AnyCurve;\r\n  /** Support method for ICurvePrimitive ... one line call to specific announce method . . */\r\n  public abstract announceToCurveProcessor(processor: RecursiveCurveProcessor): void;\r\n  /** clone an empty collection. */\r\n  public abstract cloneEmptyPeer(): CurveCollection;\r\n  /** Return the boundary type of a corresponding  MicroStation CurveVector.\r\n   * * Derived class must implement.\r\n   */\r\n  public abstract dgnBoundaryType(): number;\r\n  /**\r\n   * Try to add a child.\r\n   * @param child child to add.\r\n   * @return true if child is an acceptable type for this collection.\r\n   */\r\n  public abstract tryAddChild(child: AnyCurve): boolean;\r\n  /** Return a child identified by by index */\r\n  public abstract getChild(i: number): AnyCurve | undefined;\r\n  /** Extend (increase) `rangeToExtend` as needed to include these curves (optionally transformed) */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const children = this.children;\r\n    if (children) {\r\n      for (const c of children) {\r\n        c.extendRange(rangeToExtend, transform);\r\n      }\r\n    }\r\n  }\r\n}\r\n/** Shared base class for use by both open and closed paths.\r\n * * A `CurveChain` contains only curvePrimitives.  No other paths, loops, or regions allowed.\r\n * * A single entry in the chain can in fact contain multiple curve primitives if the entry itself is (for instance) `CurveChainWithDistanceIndex`\r\n *   which presents itself (through method interface) as a CurvePrimitive with well defined mappings from fraction to xyz, but in fact does all the\r\n *    calculations over multiple primitives.\r\n * * The specific derived classes are `Path` and `Loop`\r\n * * `CurveChain` is an intermediate class.   It is not instantiable on its own.\r\n * @public\r\n */\r\nexport abstract class CurveChain extends CurveCollection {\r\n  /** The curve primitives in the chain. */\r\n  protected _curves: CurvePrimitive[];\r\n  protected constructor() { super(); this._curves = []; }\r\n  /** Return the array of `CurvePrimitive` */\r\n  public get children(): CurvePrimitive[] {\r\n    if (this._curves === undefined)\r\n      this._curves = [];\r\n    return this._curves;\r\n  }\r\n  /**\r\n   * Return curve primitive by index, interpreted cyclically if the Chain is a Loop.\r\n   *\r\n   * *  For a path, return undefined for any out-of-bounds index\r\n   * *  For a loop, an out-of-bounds index is mapped cyclically into bounds.\r\n   * @param index index to array\r\n   */\r\n  public abstract cyclicCurvePrimitive(index: number): CurvePrimitive | undefined;\r\n  /** Stroke the chain into a simple xyz array.\r\n   * @param options tolerance parameters controlling the stroking.\r\n   */\r\n  public getPackedStrokes(options?: StrokeOptions): GrowableXYZArray | undefined {\r\n    const tree = this.cloneStroked(options);\r\n    if (tree instanceof CurveChain) {\r\n      const children = tree.children;\r\n      if (children.length === 1) {\r\n        const ls = children[0];\r\n        if (ls instanceof LineString3d)\r\n          return ls.packedPoints;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return a structural clone, with CurvePrimitive objects stroked. */\r\n  public cloneStroked(options?: StrokeOptions): AnyCurve {\r\n    const strokes = LineString3d.create();\r\n    for (const curve of this.children)\r\n      curve.emitStrokes(strokes, options);\r\n    return strokes;\r\n  }\r\n  /** add a child curve.\r\n   * * Returns false if the given child is not a CurvePrimitive.\r\n   */\r\n  public tryAddChild(child: AnyCurve): boolean {\r\n    if (child instanceof CurvePrimitive) {\r\n      this._curves.push(child);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a child by index */\r\n  public getChild(i: number): CurvePrimitive | undefined {\r\n    if (i < this._curves.length) return this._curves[i];\r\n    return undefined;\r\n  }\r\n  /** invoke `curve.extendRange(range, transform)` for each child  */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    for (const curve of this._curves)\r\n      curve.extendRange(range, transform);\r\n  }\r\n  /**\r\n   * Reverse each child curve (in place)\r\n   * Reverse the order of the children in the CurveChain array.\r\n   */\r\n  public reverseChildrenInPlace() {\r\n    for (const curve of this._curves)\r\n      curve.reverseInPlace();\r\n    this._curves.reverse();\r\n  }\r\n}\r\n\r\n/**\r\n * * A `BagOfCurves` object is a collection of `AnyCurve` objects.\r\n * * A `BagOfCurves` has no implied properties such as being planar.\r\n * @public\r\n */\r\nexport class BagOfCurves extends CurveCollection {\r\n  /** test if `other` is an instance of `BagOfCurves` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof BagOfCurves; }\r\n  /** Array of children.\r\n   * * No restrictions on type.\r\n   */\r\n  protected _children: AnyCurve[];\r\n  /** Construct an empty `BagOfCurves` */\r\n  public constructor() { super(); this._children = []; }\r\n  /** Return the (reference to) array of children */\r\n  public get children(): AnyCurve[] { return this._children; }\r\n  /** create with given curves. */\r\n  public static create(...data: AnyCurve[]): BagOfCurves {\r\n    const result = new BagOfCurves();\r\n    for (const child of data) {\r\n      result.tryAddChild(child);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the boundary type (0) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 0; }\r\n  /** invoke `processor.announceBagOfCurves(this, indexInParent);` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceBagOfCurves(this, indexInParent);\r\n  }\r\n  /** Clone all children in stroked form. */\r\n  public cloneStroked(options?: StrokeOptions): BagOfCurves {\r\n    const clone = new BagOfCurves();\r\n    let child;\r\n    for (child of this.children) {\r\n      if (child instanceof CurvePrimitive) {\r\n        const ls = LineString3d.create();\r\n        (child as CurvePrimitive).emitStrokes(ls, options);\r\n        if (ls)\r\n          clone.children.push(ls);\r\n      } else if (child instanceof CurveCollection) {\r\n        const childStrokes = (child as CurveCollection).cloneStroked(options);\r\n        if (childStrokes)\r\n          clone.children.push(childStrokes);\r\n      }\r\n    }\r\n    return clone;\r\n  }\r\n  /** Return an empty `BagOfCurves` */\r\n  public cloneEmptyPeer(): BagOfCurves { return new BagOfCurves(); }\r\n  /** Add a child  */\r\n  public tryAddChild(child: AnyCurve): boolean {\r\n    this._children.push(child);\r\n    return true;\r\n  }\r\n  /** Get a child by index */\r\n  public getChild(i: number): AnyCurve | undefined {\r\n    if (i < this._children.length)\r\n      return this._children[i];\r\n    return undefined;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBagOfCurves(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBagOfCurves(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { NullGeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { CurveLocationDetail, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\nimport { LineString3d } from \"./LineString3d\";\r\n// import { Arc3d } from \"./Arc3d\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n// import { LineString3d } from \"./LineString3d\";\r\nimport { SmallSystem, AnalyticRoots, TrigPolynomial } from \"../numerics/Polynomials\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Arc3d } from \"./Arc3d\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../bspline/BSplineCurve\";\r\nimport { BezierCurveBase } from \"../bspline/BezierCurveBase\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { UnivariateBezier } from \"../numerics/BezierPolynomials\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { NewtonEvaluatorRRtoRRD, Newton2dUnboundedWithDerivative } from \"../numerics/Newton\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\n\r\n/**\r\n * * Private class for refining bezier-bezier intersections.\r\n * * The inputs are assumed pre-transformed so that the target condition is to match x and y coordinates.\r\n * @public\r\n */\r\nclass BezierBezierIntersectionXYRRToRRD extends NewtonEvaluatorRRtoRRD {\r\n  private _curveA: BezierCurveBase;\r\n  private _curveB: BezierCurveBase;\r\n  constructor(curveA: BezierCurveBase, curveB: BezierCurveBase) {\r\n    super();\r\n    this._curveA = curveA;\r\n    this._curveB = curveB;\r\n    this._rayA = Ray3d.createZero();\r\n    this._rayB = Ray3d.createZero();\r\n\r\n  }\r\n  private _rayA: Ray3d;\r\n  private _rayB: Ray3d;\r\n  public evaluate(fractionA: number, fractionB: number): boolean {\r\n    this._curveA.fractionToPointAndDerivative(fractionA, this._rayA);\r\n    this._curveB.fractionToPointAndDerivative(fractionB, this._rayB);\r\n    this.currentF.setOriginAndVectorsXYZ(\r\n      this._rayB.origin.x - this._rayA.origin.x, this._rayB.origin.y - this._rayA.origin.y, 0.0,\r\n      -this._rayA.direction.x, -this._rayA.direction.y, 0.0,\r\n      this._rayB.direction.x, this._rayB.direction.y, 0.0);\r\n    return true;\r\n  }\r\n}\r\n/**\r\n * Data bundle for a pair of arrays of CurveLocationDetail structures such as produced by CurveCurve,IntersectXY and\r\n * CurveCurve.ClosestApproach\r\n * @public\r\n */\r\nexport class CurveLocationDetailArrayPair {\r\n  /** first array of details ... */\r\n  public dataA: CurveLocationDetail[];\r\n  /** second array of details ... */\r\n  public dataB: CurveLocationDetail[];\r\n  public constructor() {\r\n    this.dataA = [];\r\n    this.dataB = [];\r\n  }\r\n}\r\n/*\r\n * * Handler class for XY intersections.\r\n * * This is local to the file (not exported)\r\n * * Instances are initialized and called from CurveCurve.\r\n */\r\nclass CurveCurveIntersectXY extends NullGeometryHandler {\r\n  // private geometryA: GeometryQuery;  // nb never used -- passed through handlers.\r\n  private _extendA: boolean;\r\n  private _geometryB: GeometryQuery;\r\n  private _extendB: boolean;\r\n  private _results!: CurveLocationDetailArrayPair;\r\n  private _worldToLocalPerspective: Matrix4d | undefined;\r\n  private _worldToLocalAffine: Transform | undefined;\r\n  private reinitialize() {\r\n    this._results = new CurveLocationDetailArrayPair();\r\n  }\r\n\r\n  public constructor(worldToLocal: Matrix4d | undefined, _geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean) {\r\n    super();\r\n    // this.geometryA = _geometryA;\r\n    this._extendA = extendA;\r\n    this._geometryB = geometryB;\r\n    this._extendB = extendB;\r\n    this._worldToLocalPerspective = undefined;\r\n    this._worldToLocalAffine = undefined;\r\n    if (worldToLocal !== undefined && !worldToLocal.isIdentity()) {\r\n      this._worldToLocalAffine = worldToLocal.asTransform;\r\n      if (!this._worldToLocalAffine)\r\n        this._worldToLocalPerspective = worldToLocal.clone();\r\n    }\r\n    this.reinitialize();\r\n  }\r\n  /**\r\n   * @param reinitialize if true, a new results structure is created for use by later calls.\r\n   * @returns Return the results structure for the intersection calculation.\r\n   *\r\n   */\r\n  public grabResults(reinitialize: boolean = false): CurveLocationDetailArrayPair {\r\n    const result = this._results;\r\n    if (reinitialize)\r\n      this.reinitialize();\r\n    return result;\r\n  }\r\n\r\n  private static _workVector2dA = Vector2d.create();\r\n\r\n  private acceptFraction(extend0: boolean, fraction: number, extend1: boolean) {\r\n    if (!extend0 && fraction < 0.0)\r\n      return false;\r\n    if (!extend1 && fraction > 1.0)\r\n      return false;\r\n    return true;\r\n  }\r\n\r\n  /** compute intersection of two line segments.\r\n   * filter by extension rules.\r\n   * record with fraction mapping.\r\n   */\r\n  private recordPointWithLocalFractions(\r\n    localFractionA: number,\r\n    cpA: CurvePrimitive,\r\n    fractionA0: number,\r\n    fractionA1: number,\r\n    localFractionB: number,   // Computed intersection fraction\r\n    cpB: CurvePrimitive,\r\n    fractionB0: number,\r\n    fractionB1: number,\r\n    reversed: boolean,\r\n  ) {\r\n    const globalFractionA = Geometry.interpolate(fractionA0, localFractionA, fractionA1);\r\n    const globalFractionB = Geometry.interpolate(fractionB0, localFractionB, fractionB1);\r\n    // ignore duplicate of most recent point .  ..\r\n    const numPrevious = this._results.dataA.length;\r\n    if (numPrevious > 0) {\r\n      const topFractionA = this._results.dataA[numPrevious - 1].fraction;\r\n      const topFractionB = this._results.dataB[numPrevious - 1].fraction;\r\n      if (reversed) {\r\n        if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionB) && Geometry.isAlmostEqualNumber(topFractionB, globalFractionA))\r\n          return;\r\n      } else {\r\n        if (Geometry.isAlmostEqualNumber(topFractionA, globalFractionA) && Geometry.isAlmostEqualNumber(topFractionB, globalFractionB))\r\n          return;\r\n      }\r\n    }\r\n    const detailA = CurveLocationDetail.createCurveFractionPoint(cpA,\r\n      globalFractionA, cpA.fractionToPoint(globalFractionA));\r\n    detailA.setIntervalRole(CurveIntervalRole.isolated);\r\n    const detailB = CurveLocationDetail.createCurveFractionPoint(cpB,\r\n      globalFractionB, cpB.fractionToPoint(globalFractionB));\r\n    detailB.setIntervalRole(CurveIntervalRole.isolated);\r\n    if (reversed) {\r\n      this._results.dataA.push(detailB);\r\n      this._results.dataB.push(detailA);\r\n    } else {\r\n      this._results.dataA.push(detailA);\r\n      this._results.dataB.push(detailB);\r\n    }\r\n  }\r\n  /** compute intersection of two line segments.\r\n   * filter by extension rules.\r\n   * record with fraction mapping.\r\n   */\r\n  private computeSegmentSegment3D(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n\r\n    const uv = CurveCurveIntersectXY._workVector2dA;\r\n    if (SmallSystem.lineSegment3dXYTransverseIntersectionUnbounded(\r\n      pointA0, pointA1,\r\n      pointB0, pointB1, uv)\r\n      && this.acceptFraction(extendA0, uv.x, extendA1)\r\n      && this.acceptFraction(extendB0, uv.y, extendB1)\r\n    ) {\r\n      this.recordPointWithLocalFractions(uv.x, cpA, fractionA0, fractionA1, uv.y, cpB, fractionB0, fractionB1, reversed);\r\n    }\r\n  }\r\n  private static _workPointA0H = Point4d.create();\r\n  private static _workPointA1H = Point4d.create();\r\n  private static _workPointB0H = Point4d.create();\r\n  private static _workPointB1H = Point4d.create();\r\n  // intersection of PROJECTED homogeneous segments ...  assumes caller knows the _worldToLocal is present\r\n  private computeSegmentSegment3DH(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const hA0 = CurveCurveIntersectXY._workPointA0H;\r\n    const hA1 = CurveCurveIntersectXY._workPointA1H;\r\n    const hB0 = CurveCurveIntersectXY._workPointB0H;\r\n    const hB1 = CurveCurveIntersectXY._workPointB1H;\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointA0, 1, hA0);\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointA1, 1, hA1);\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointB0, 1, hB0);\r\n    this._worldToLocalPerspective!.multiplyPoint3d(pointB1, 1, hB1);\r\n    const fractionAB = SmallSystem.lineSegment3dHXYTransverseIntersectionUnbounded(hA0, hA1, hB0, hB1);\r\n    if (fractionAB !== undefined) {\r\n      const fractionA = fractionAB.x;\r\n      const fractionB = fractionAB.y;\r\n      if (this.acceptFraction(extendA0, fractionA, extendA1) && this.acceptFraction(extendB0, fractionB, extendB1)) {\r\n        // final fraction acceptance uses original world points, with perspective-aware fractions\r\n        this.recordPointWithLocalFractions(fractionA, cpA, fractionA0, fractionA1,\r\n          fractionB, cpB, fractionB0, fractionB1, reversed);\r\n      }\r\n    }\r\n  }\r\n  // Caller accesses data from a linesegment and passes to here.\r\n  // (The linesegment in question might be (a) a full linesegment or (b) a fragment within a linestring.  The fraction and extend parameters\r\n  // allow all combinations to be passed in)\r\n  // This method applies transform.\r\n  private dispatchSegmentSegment(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    cpB: CurvePrimitive,\r\n    extendB0: boolean,\r\n    pointB0: Point3d,\r\n    fractionB0: number,\r\n    pointB1: Point3d,\r\n    fractionB1: number,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    if (this._worldToLocalAffine) {\r\n      // non-perspective projection\r\n      CurveCurveIntersectXY.setTransformedWorkPoints(this._worldToLocalAffine, pointA0, pointA1, pointB0, pointB1);\r\n      this.computeSegmentSegment3D(\r\n        cpA, extendA0, CurveCurveIntersectXY._workPointA0, fractionA0, CurveCurveIntersectXY._workPointA1, fractionA1, extendA1,\r\n        cpB, extendB0, CurveCurveIntersectXY._workPointB0, fractionB0, CurveCurveIntersectXY._workPointB1, fractionB1, extendB1,\r\n        reversed);\r\n    } else if (this._worldToLocalPerspective) {\r\n      this.computeSegmentSegment3DH(\r\n        cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1,\r\n        cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1,\r\n        reversed);\r\n    } else {\r\n      this.computeSegmentSegment3D(\r\n        cpA, extendA0, pointA0, fractionA0, pointA1, fractionA1, extendA1,\r\n        cpB, extendB0, pointB0, fractionB0, pointB1, fractionB1, extendB1,\r\n        reversed);\r\n    }\r\n  }\r\n\r\n  // Caller accesses data from a linestring or segment and passes it here.\r\n  // (The linesegment in question might be (a) a full linesegment or (b) a fragment within a linestring.  The fraction and extend parameters\r\n  // allow all combinations to be passed in)\r\n  private dispatchSegmentArc(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    arc: Arc3d,\r\n    extendB0: boolean,\r\n    extendB1: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // Arc: X = C + cU + sV\r\n    // Line:  contains points A0,A1\r\n    // Arc point colinear with line if det (A0, A1, X) = 0\r\n    // with homogeneous xyw points and vectors.\r\n    // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.\r\n    // solve for theta.\r\n    // evaluate points.\r\n    // project back to line.\r\n    if (this._worldToLocalPerspective) {\r\n      const data = arc.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      const pointA0H = this._worldToLocalPerspective.multiplyPoint3d(pointA0, 1);\r\n      const pointA1H = this._worldToLocalPerspective.multiplyPoint3d(pointA1, 1);\r\n      const alpha = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.center);\r\n      const beta = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector0);\r\n      const gamma = Geometry.tripleProductPoint4dXYW(pointA0H, pointA1H, data.vector90);\r\n      const cosines = new GrowableFloat64Array(2);\r\n      const sines = new GrowableFloat64Array(2);\r\n      const radians = new GrowableFloat64Array(2);\r\n      const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);\r\n      for (let i = 0; i < numRoots; i++) {\r\n        const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\r\n        const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\r\n        const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, arcPoint);\r\n        if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {\r\n          this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n            arcFraction, arc, 0, 1, reversed);\r\n        }\r\n      }\r\n    } else {\r\n      const data = arc.toTransformedVectors(this._worldToLocalAffine);\r\n      let pointA0Local = pointA0;\r\n      let pointA1Local = pointA1;\r\n      if (this._worldToLocalAffine) {\r\n        pointA0Local = this._worldToLocalAffine.multiplyPoint3d(pointA0);\r\n        pointA1Local = this._worldToLocalAffine.multiplyPoint3d(pointA1);\r\n      }\r\n      const alpha = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.center, 1);\r\n      const beta = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector0, 0);\r\n      const gamma = Geometry.tripleProductXYW(pointA0Local, 1, pointA1Local, 1, data.vector90, 0);\r\n      const cosines = new GrowableFloat64Array(2);\r\n      const sines = new GrowableFloat64Array(2);\r\n      const radians = new GrowableFloat64Array(2);\r\n      const numRoots = AnalyticRoots.appendImplicitLineUnitCircleIntersections(alpha, beta, gamma, cosines, sines, radians);\r\n      for (let i = 0; i < numRoots; i++) {\r\n        const arcPoint = data.center.plus2Scaled(data.vector0, cosines.atUncheckedIndex(i), data.vector90, sines.atUncheckedIndex(i));\r\n        const arcFraction = data.sweep.radiansToSignedPeriodicFraction(radians.atUncheckedIndex(i));\r\n        const lineFraction = SmallSystem.lineSegment3dXYClosestPointUnbounded(pointA0Local, pointA1Local, arcPoint);\r\n        if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB0, arcFraction, extendB1)) {\r\n          this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n            arcFraction, arc, 0, 1, reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  // Caller accesses data from two arcs.\r\n  // each matrix has [U V C] in (x,y,w) form from projection.\r\n  // invert the projection matrix matrixA.\r\n  // apply the inverse to matrixB. Then arcb is an ellipse in the circular space of A\r\n\r\n  private dispatchArcArcThisOrder(\r\n    cpA: Arc3d,\r\n    matrixA: Matrix3d,  // homogeneous xyw projection !!!\r\n    extendA: boolean,\r\n    cpB: Arc3d,\r\n    matrixB: Matrix3d,  // homogeneous xyw projection !!!\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const inverseA = matrixA.inverse();\r\n    if (inverseA) {\r\n      const localB = inverseA.multiplyMatrixMatrix(matrixB);\r\n      const ellipseRadians: number[] = [];\r\n      const circleRadians: number[] = [];\r\n      TrigPolynomial.solveUnitCircleHomogeneousEllipseIntersection(\r\n        localB.coffs[2], localB.coffs[5], localB.coffs[8],  // center xyw\r\n        localB.coffs[0], localB.coffs[3], localB.coffs[6],  // center xyw\r\n        localB.coffs[1], localB.coffs[4], localB.coffs[7],  // center xyw\r\n        ellipseRadians, circleRadians);\r\n      for (let i = 0; i < ellipseRadians.length; i++) {\r\n        const fractionA = cpA.sweep.radiansToSignedPeriodicFraction(circleRadians[i]);\r\n        const fractionB = cpA.sweep.radiansToSignedPeriodicFraction(ellipseRadians[i]);\r\n        // hm .. do we really need to check the fractions?  We know they are internal to the beziers\r\n        if (this.acceptFraction(extendA, fractionA, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n          this.recordPointWithLocalFractions(fractionA, cpA, 0, 1,\r\n            fractionB, cpB, 0, 1, reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchArcArc(\r\n    cpA: Arc3d,\r\n    extendA: boolean,\r\n    cpB: Arc3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // Arc: X = C + cU + sV\r\n    // Line:  contains points A0,A1\r\n    // Arc point colinear with line if det (A0, A1, X) = 0\r\n    // with homogeneous xyw points and vectors.\r\n    // With equational X:   det (A0, A1, C) + c det (A0, A1,U) + s det (A0, A1, V) = 0.\r\n    // solve for theta.\r\n    // evaluate points.\r\n    // project back to line.\r\n    let matrixA: Matrix3d;\r\n    let matrixB: Matrix3d;\r\n    if (this._worldToLocalPerspective) {\r\n      const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      const dataB = cpB.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\r\n      matrixB = Matrix3d.createColumnsXYW(dataB.vector0, dataB.vector0.w, dataB.vector90, dataA.vector90.w, dataB.center, dataB.center.w);\r\n    } else {\r\n      const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\r\n      const dataB = cpB.toTransformedVectors(this._worldToLocalAffine);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\r\n      matrixB = Matrix3d.createColumnsXYW(dataB.vector0, 0, dataB.vector90, 0, dataB.center, 1);\r\n    }\r\n    const conditionA = matrixA.conditionNumber();\r\n    const conditionB = matrixB.conditionNumber();\r\n    if (conditionA > conditionB)\r\n      this.dispatchArcArcThisOrder(cpA, matrixA, extendA, cpB, matrixB, extendB, reversed);\r\n    else\r\n      this.dispatchArcArcThisOrder(cpB, matrixB, extendB, cpA, matrixA, extendA, !reversed);\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchArcBsplineCurve3d(\r\n    cpA: Arc3d,\r\n    extendA: boolean,\r\n    cpB: BSplineCurve3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    // Arc: X = C + cU + sV\r\n    // implicitize the arc as viewed.  This \"3d\" matrix is homogeneous \"XYW\" not \"xyz\"\r\n    let matrixA: Matrix3d;\r\n    if (this._worldToLocalPerspective) {\r\n      const dataA = cpA.toTransformedPoint4d(this._worldToLocalPerspective);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, dataA.vector0.w, dataA.vector90, dataA.vector90.w, dataA.center, dataA.center.w);\r\n    } else {\r\n      const dataA = cpA.toTransformedVectors(this._worldToLocalAffine);\r\n      matrixA = Matrix3d.createColumnsXYW(dataA.vector0, 0, dataA.vector90, 0, dataA.center, 1);\r\n    }\r\n    // The worldToLocal has moved the arc vectors into screen space.\r\n    // matrixA captures the xyw parts (ignoring z)\r\n    // for any point in world space,\r\n    // THIS CODE ONLY WORKS FOR\r\n    const matrixAinverse = matrixA.inverse();\r\n    if (matrixAinverse) {\r\n      const orderF = cpB.order; // order of the beziers for simple coordinates\r\n      const orderG = 2 * orderF - 1;  // order of the (single) bezier for squared coordinates.\r\n      const coffF = new Float64Array(orderF);\r\n      const univariateBezierG = new UnivariateBezier(orderG);\r\n      const axx = matrixAinverse.at(0, 0); const axy = matrixAinverse.at(0, 1); const axz = 0.0; const axw = matrixAinverse.at(0, 2);\r\n      const ayx = matrixAinverse.at(1, 0); const ayy = matrixAinverse.at(1, 1); const ayz = 0.0; const ayw = matrixAinverse.at(1, 2);\r\n      const awx = matrixAinverse.at(2, 0); const awy = matrixAinverse.at(2, 1); const awz = 0.0; const aww = matrixAinverse.at(2, 2);\r\n\r\n      if (matrixAinverse) {\r\n        let bezier: BezierCurve3dH | undefined;\r\n        for (let spanIndex = 0; ; spanIndex++) {\r\n          bezier = cpB.getSaturatedBezierSpan3dH(spanIndex, bezier);\r\n          if (!bezier) break;\r\n          if (this._worldToLocalPerspective)\r\n            bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\r\n          else if (this._worldToLocalAffine)\r\n            bezier.tryTransformInPlace(this._worldToLocalAffine);\r\n          univariateBezierG.zero();\r\n          bezier.poleProductsXYZW(coffF, axx, axy, axz, axw);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\r\n          bezier.poleProductsXYZW(coffF, ayx, ayy, ayz, ayw);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, 1.0);\r\n          bezier.poleProductsXYZW(coffF, awx, awy, awz, aww);\r\n          univariateBezierG.addSquaredSquaredBezier(coffF, -1.0);\r\n          const roots = univariateBezierG.roots(0.0, true);\r\n          if (roots) {\r\n            for (const root of roots) {\r\n              const fractionB = bezier.fractionToParentFraction(root);\r\n              // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\r\n              const bcurvePoint4d = bezier.fractionToPoint4d(root);\r\n              const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\r\n              const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\r\n              const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\r\n              if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n                this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\r\n                  fractionB, cpB, 0, 1, reversed);\r\n              }\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** apply the transformation to bezier curves. optionally construct ranges.\r\n   *\r\n   */\r\n  private transformBeziers(beziers: BezierCurve3dH[]) {\r\n    if (this._worldToLocalAffine) {\r\n      for (const bezier of beziers) bezier.tryTransformInPlace(this._worldToLocalAffine);\r\n    } else if (this._worldToLocalPerspective) {\r\n      for (const bezier of beziers) bezier.tryMultiplyMatrix4dInPlace(this._worldToLocalPerspective);\r\n    }\r\n  }\r\n  private getRanges(beziers: BezierCurveBase[]): Range3d[] {\r\n    const ranges: Range3d[] = [];\r\n    ranges.length = 0;\r\n    for (const b of beziers) {\r\n      ranges.push(b.range());\r\n    }\r\n    return ranges;\r\n  }\r\n  private _xyzwA0?: Point4d;\r\n  private _xyzwA1?: Point4d;\r\n  private _xyzwPlane?: Point4d;\r\n  private _xyzwB?: Point4d;\r\n\r\n  private dispatchBezierBezierStrokeFirst(\r\n    bezierA: BezierCurve3dH,\r\n    bcurveA: BSplineCurve3dBase,\r\n    strokeCountA: number,\r\n    bezierB: BezierCurve3dH,\r\n    bcurveB: BSplineCurve3dBase,\r\n    _strokeCountB: number,\r\n    univariateBezierB: UnivariateBezier,  // caller-allocated for univariate coefficients.\r\n    reversed: boolean) {\r\n    if (!this._xyzwA0) this._xyzwA0 = Point4d.create();\r\n    if (!this._xyzwA1) this._xyzwA1 = Point4d.create();\r\n    if (!this._xyzwPlane) this._xyzwPlane = Point4d.create();\r\n    if (!this._xyzwB) this._xyzwB = Point4d.create();\r\n    /*\r\n\r\n              const roots = univariateBezierG.roots(0.0, true);\r\n              if (roots) {\r\n                for (const root of roots) {\r\n                  const fractionB = bezier.fractionToParentFraction(root);\r\n                  // The univariate bezier (which has been transformed by the view transform) evaluates into xyw space\r\n                  const bcurvePoint4d = bezier.fractionToPoint4d(root);\r\n                  const c = bcurvePoint4d.dotProductXYZW(axx, axy, axz, axw);\r\n                  const s = bcurvePoint4d.dotProductXYZW(ayx, ayy, ayz, ayw);\r\n                  const arcFraction = cpA.sweep.radiansToSignedPeriodicFraction(Math.atan2(s, c));\r\n                  if (this.acceptFraction(extendA, arcFraction, extendA) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n                    this.recordPointWithLocalFractions(arcFraction, cpA, 0, 1,\r\n                      fractionB, cpB, 0, 1, reversed);\r\n                  }\r\n                }\r\n    */\r\n    bezierA.fractionToPoint4d(0.0, this._xyzwA0);\r\n    let f0 = 0.0;\r\n    let f1 = 1.0;\r\n    const intervalTolerance = 1.0e-5;\r\n    const df = 1.0 / strokeCountA;\r\n    for (let i = 1; i <= strokeCountA; i++ , f0 = f1, this._xyzwA0.setFrom(this._xyzwA1)) {\r\n      f1 = i * df;\r\n      bezierA.fractionToPoint4d(f1, this._xyzwA1);\r\n      Point4d.createPlanePointPointZ(this._xyzwA0, this._xyzwA1, this._xyzwPlane);\r\n      bezierB.poleProductsXYZW(univariateBezierB.coffs, this._xyzwPlane.x, this._xyzwPlane.y, this._xyzwPlane.z, this._xyzwPlane.w);\r\n      let errors = 0;\r\n      const roots = univariateBezierB.roots(0.0, true);\r\n      if (roots)\r\n        for (const r of roots) {\r\n          let bezierBFraction = r;\r\n          bezierB.fractionToPoint4d(bezierBFraction, this._xyzwB);\r\n          const segmentAFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(this._xyzwA0, this._xyzwA1, this._xyzwB);\r\n          if (segmentAFraction && Geometry.isIn01WithTolerance(segmentAFraction, intervalTolerance)) {\r\n            let bezierAFraction = Geometry.interpolate(f0, segmentAFraction, f1);\r\n            const xyMatchingFunction = new BezierBezierIntersectionXYRRToRRD(bezierA, bezierB);\r\n            const newtonSearcher = new Newton2dUnboundedWithDerivative(xyMatchingFunction);\r\n            newtonSearcher.setUV(bezierAFraction, bezierBFraction);\r\n            if (newtonSearcher.runIterations()) {\r\n              bezierAFraction = newtonSearcher.getU();\r\n              bezierBFraction = newtonSearcher.getV();\r\n            }\r\n            // We have a near intersection at fractions on the two beziers !!!\r\n            // Iterate on the curves for a true intersection ....\r\n            // NEEDS WORK -- just accept . . .\r\n            const bcurveAFraction = bezierA.fractionToParentFraction(bezierAFraction);\r\n            const bcurveBFraction = bezierB.fractionToParentFraction(bezierBFraction);\r\n            const xyzA0 = bezierA.fractionToPoint(bezierAFraction);\r\n            const xyzA1 = bcurveA.fractionToPoint(bcurveAFraction);\r\n            const xyzB0 = bezierB.fractionToPoint(bezierBFraction);\r\n            const xyzB1 = bcurveB.fractionToPoint(bcurveBFraction);\r\n            if (!xyzA0.isAlmostEqualXY(xyzA1))\r\n              errors++;\r\n            if (!xyzB0.isAlmostEqualXY(xyzB1))\r\n              errors++;\r\n            if (errors > 0 && !xyzA0.isAlmostEqual(xyzB0))\r\n              errors++;\r\n            if (errors > 0 && !xyzA1.isAlmostEqual(xyzB1))\r\n              errors++;\r\n            if (this.acceptFraction(false, bcurveAFraction, false) && this.acceptFraction(false, bcurveBFraction, false)) {\r\n              this.recordPointWithLocalFractions(bcurveAFraction, bcurveA, 0, 1,\r\n                bcurveBFraction, bcurveB, 0, 1, reversed);\r\n            }\r\n          }\r\n        }\r\n    }\r\n  }\r\n  // Caller accesses data from two arcs.\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchBSplineCurve3dBSplineCurve3d(\r\n    bcurveA: BSplineCurve3dBase,\r\n    bcurveB: BSplineCurve3dBase,\r\n    _reversed: boolean) {\r\n    const bezierSpanA = bcurveA.collectBezierSpans(true) as BezierCurve3dH[];\r\n    const bezierSpanB = bcurveB.collectBezierSpans(true) as BezierCurve3dH[];\r\n    const numA = bezierSpanA.length;\r\n    const numB = bezierSpanB.length;\r\n    this.transformBeziers(bezierSpanA);\r\n    this.transformBeziers(bezierSpanB);\r\n    const rangeA = this.getRanges(bezierSpanA);\r\n    const rangeB = this.getRanges(bezierSpanB);\r\n    const orderA = bcurveA.order;\r\n    const orderB = bcurveB.order;\r\n    const univariateCoffsA = new UnivariateBezier(orderA);\r\n    const univariateCoffsB = new UnivariateBezier(orderB);\r\n    for (let a = 0; a < numA; a++) {\r\n      for (let b = 0; b < numB; b++) {\r\n        if (rangeA[a].intersectsRangeXY(rangeB[b])) {\r\n          const strokeCountA = bezierSpanA[a].computeStrokeCountForOptions();\r\n          const strokeCountB = bezierSpanB[b].computeStrokeCountForOptions();\r\n          if (strokeCountA < strokeCountB)\r\n            this.dispatchBezierBezierStrokeFirst(bezierSpanA[a], bcurveA, strokeCountA, bezierSpanB[b], bcurveB, strokeCountB, univariateCoffsB, !_reversed);\r\n          else\r\n            this.dispatchBezierBezierStrokeFirst(bezierSpanB[b], bcurveB, strokeCountB, bezierSpanA[a], bcurveA, strokeCountA, univariateCoffsA, _reversed);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Apply the projection transform (if any) to (xyz, w)\r\n   * @param xyz xyz parts of input point.\r\n   * @param w   weight to use for homogeneous effects\r\n   */\r\n  private projectPoint(xyz: XYAndZ, w: number = 1.0): Point4d {\r\n    if (this._worldToLocalPerspective)\r\n      return this._worldToLocalPerspective.multiplyPoint3d(xyz, w);\r\n    if (this._worldToLocalAffine)\r\n      return this._worldToLocalAffine.multiplyXYZW(xyz.x, xyz.y, xyz.z, w);\r\n    return Point4d.createFromPointAndWeight(xyz, w);\r\n  }\r\n  private mapNPCPlaneToWorld(npcPlane: Point4d, worldPlane: Point4d) {\r\n    // for NPC pointY, Y^ * H = 0 is \"on\" plane H.  (Hat is transpose)\r\n    // NPC Y is A*X for our transform A and worldPointX.\r\n    // hence (A X)^ * H = 0\r\n    // hence X^ * A^ * H = 0\r\n    // hence K = A^ * H\r\n    if (this._worldToLocalAffine) {\r\n      this._worldToLocalAffine.multiplyTransposeXYZW(npcPlane.x, npcPlane.y, npcPlane.z, npcPlane.w, worldPlane);\r\n    } else if (this._worldToLocalPerspective) {\r\n      this._worldToLocalPerspective.multiplyTransposePoint4d(npcPlane, worldPlane);\r\n    } else {\r\n      npcPlane.clone(worldPlane);\r\n    }\r\n  }\r\n  // Caller accesses data from segment and bsplineCurve\r\n  // Selects the best conditioned arc (in xy parts) as \"circle after inversion\"\r\n  // Solves the arc-arc equations\r\n  private dispatchSegmentBsplineCurve(\r\n    cpA: CurvePrimitive,\r\n    extendA0: boolean,\r\n    pointA0: Point3d,\r\n    fractionA0: number,\r\n    pointA1: Point3d,\r\n    fractionA1: number,\r\n    extendA1: boolean,\r\n    bcurve: BSplineCurve3d,\r\n    extendB: boolean,\r\n    reversed: boolean,\r\n  ) {\r\n    const pointA0H = this.projectPoint(pointA0);\r\n    const pointA1H = this.projectPoint(pointA1);\r\n    const planeCoffs = Point4d.createPlanePointPointZ(pointA0H, pointA1H);\r\n    this.mapNPCPlaneToWorld(planeCoffs, planeCoffs);\r\n    // NOW .. we have a plane in world space.  Intersect it with the bspline:\r\n    const intersections: CurveLocationDetail[] = [];\r\n    bcurve.appendPlaneIntersectionPoints(planeCoffs, intersections);\r\n    // intersections has WORLD points with bspline fractions.   (The bspline fractions are all good 0..1 fractions within the spline.)\r\n    // accept those that are within the segment range.\r\n    for (const detail of intersections) {\r\n      const fractionB = detail.fraction;\r\n      const curvePoint = detail.point;\r\n      const curvePointH = this.projectPoint(curvePoint);\r\n      const lineFraction = SmallSystem.lineSegment3dHXYClosestPointUnbounded(pointA0H, pointA1H, curvePointH);\r\n      if (lineFraction !== undefined && this.acceptFraction(extendA0, lineFraction, extendA1) && this.acceptFraction(extendB, fractionB, extendB)) {\r\n        this.recordPointWithLocalFractions(lineFraction, cpA, fractionA0, fractionA1,\r\n          fractionB, bcurve, 0, 1, reversed);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static _workPointAA0 = Point3d.create();\r\n  private static _workPointAA1 = Point3d.create();\r\n  private static _workPointBB0 = Point3d.create();\r\n  private static _workPointBB1 = Point3d.create();\r\n\r\n  public dispatchLineStringBSplineCurve(lsA: LineString3d, extendA: boolean, curveB: BSplineCurve3d, extendB: boolean, reversed: boolean): any {\r\n    const numA = lsA.numPoints();\r\n    if (numA > 1) {\r\n      const dfA = 1.0 / (numA - 1);\r\n      let fA0;\r\n      let fA1;\r\n      fA0 = 0.0;\r\n      const pointA0 = CurveCurveIntersectXY._workPointA0;\r\n      const pointA1 = CurveCurveIntersectXY._workPointA1;\r\n      lsA.pointAt(0, pointA0);\r\n      for (let iA = 1; iA < numA; iA++ , pointA0.setFrom(pointA1), fA0 = fA1) {\r\n        lsA.pointAt(iA, pointA1);\r\n        fA1 = iA * dfA;\r\n        this.dispatchSegmentBsplineCurve(\r\n          lsA, iA === 1 && extendA, pointA0, fA0, pointA1, fA1, (iA + 1) === numA && extendA,\r\n          curveB, extendB, reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  public computeSegmentLineString(lsA: LineSegment3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any {\r\n    const pointA0 = lsA.point0Ref;\r\n    const pointA1 = lsA.point1Ref;\r\n    const pointB0 = CurveCurveIntersectXY._workPointBB0;\r\n    const pointB1 = CurveCurveIntersectXY._workPointBB1;\r\n    const numB = lsB.numPoints();\r\n    if (numB > 1) {\r\n      const dfB = 1.0 / (numB - 1);\r\n      let fB0;\r\n      let fB1;\r\n      fB0 = 0.0;\r\n      lsB.pointAt(0, pointB0);\r\n      for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n        lsB.pointAt(ib, pointB1);\r\n        fB1 = ib * dfB;\r\n        this.dispatchSegmentSegment(\r\n          lsA, extendA, pointA0, 0.0, pointA1, 1.0, extendA,\r\n          lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n          reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  public computeArcLineString(arcA: Arc3d, extendA: boolean, lsB: LineString3d, extendB: boolean, reversed: boolean): any {\r\n    const pointB0 = CurveCurveIntersectXY._workPointBB0;\r\n    const pointB1 = CurveCurveIntersectXY._workPointBB1;\r\n    const numB = lsB.numPoints();\r\n    if (numB > 1) {\r\n      const dfB = 1.0 / (numB - 1);\r\n      let fB0;\r\n      let fB1;\r\n      fB0 = 0.0;\r\n      lsB.pointAt(0, pointB0);\r\n      for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n        lsB.pointAt(ib, pointB1);\r\n        fB1 = ib * dfB;\r\n        this.dispatchSegmentArc(\r\n          lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n          arcA, extendA, extendA,\r\n          !reversed);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  private static _workPointA0 = Point3d.create();\r\n  private static _workPointA1 = Point3d.create();\r\n  private static _workPointB0 = Point3d.create();\r\n  private static _workPointB1 = Point3d.create();\r\n  private static setTransformedWorkPoints(transform: Transform, pointA0: Point3d, pointA1: Point3d, pointB0: Point3d, pointB1: Point3d) {\r\n    transform.multiplyPoint3d(pointA0, this._workPointA0);\r\n    transform.multiplyPoint3d(pointA1, this._workPointA1);\r\n    transform.multiplyPoint3d(pointB0, this._workPointB0);\r\n    transform.multiplyPoint3d(pointB1, this._workPointB1);\r\n  }\r\n\r\n  public handleLineSegment3d(segmentA: LineSegment3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      const segmentB = this._geometryB;\r\n      this.dispatchSegmentSegment(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        segmentB, this._extendB, segmentB.point0Ref, 0.0, segmentB.point1Ref, 1.0, this._extendB,\r\n        false);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.computeSegmentLineString(segmentA, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchSegmentArc(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        this._geometryB, this._extendB, this._extendB, false);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        segmentA, this._extendA, segmentA.point0Ref, 0.0, segmentA.point1Ref, 1.0, this._extendA,\r\n        this._geometryB, this._extendB, false);\r\n    }\r\n  }\r\n\r\n  public handleLineString3d(lsA: LineString3d): any {\r\n    if (this._geometryB instanceof LineString3d) {\r\n      const lsB = this._geometryB as LineString3d;\r\n      const pointA0 = CurveCurveIntersectXY._workPointAA0;\r\n      const pointA1 = CurveCurveIntersectXY._workPointAA1;\r\n      const pointB0 = CurveCurveIntersectXY._workPointBB0;\r\n      const pointB1 = CurveCurveIntersectXY._workPointBB1;\r\n      const numA = lsA.numPoints();\r\n      const numB = lsB.numPoints();\r\n      if (numA > 1 && numB > 1) {\r\n        lsA.pointAt(0, pointA0);\r\n        const dfA = 1.0 / (numA - 1);\r\n        const dfB = 1.0 / (numB - 1);\r\n        let fA0 = 0.0;\r\n        let fB0;\r\n        let fA1;\r\n        let fB1;\r\n        const extendA = this._extendA;\r\n        const extendB = this._extendB;\r\n        lsA.pointAt(0, pointA0);\r\n        for (let ia = 1; ia < numA; ia++ , pointA0.setFrom(pointA1), fA0 = fA1) {\r\n          fA1 = ia * dfA;\r\n          fB0 = 0.0;\r\n          lsA.pointAt(ia, pointA1);\r\n          lsB.pointAt(0, pointB0);\r\n          for (let ib = 1; ib < numB; ib++ , pointB0.setFrom(pointB1), fB0 = fB1) {\r\n            lsB.pointAt(ib, pointB1);\r\n            fB1 = ib * dfB;\r\n            this.dispatchSegmentSegment(\r\n              lsA, ia === 1 && extendA, pointA0, fA0, pointA1, fA1, (ia + 1) === numA && extendA,\r\n              lsB, ib === 1 && extendB, pointB0, fB0, pointB1, fB1, (ib + 1) === numB && extendB,\r\n              false);\r\n          }\r\n        }\r\n      }\r\n    } else if (this._geometryB instanceof LineSegment3d) {\r\n      this.computeSegmentLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.computeArcLineString(this._geometryB, this._extendB, lsA, this._extendA, true);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchLineStringBSplineCurve(lsA, this._extendA, this._geometryB, this._extendB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentArc(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        arc0, this._extendA, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.computeArcLineString(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcArc(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    } else if (this._geometryB instanceof BSplineCurve3d) {\r\n      this.dispatchArcBsplineCurve3d(arc0, this._extendA, this._geometryB, this._extendB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  public handleBSplineCurve3d(curve: BSplineCurve3d): any {\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof BSplineCurve3dBase) {\r\n      this.dispatchBSplineCurve3dBSplineCurve3d(curve, this._geometryB, false);\r\n    }\r\n    return undefined;\r\n  }\r\n  public handleBSplineCurve3dH(_curve: BSplineCurve3dH): any {\r\n    /* NEEDS WORK -- make \"dispatch\" methods tolerant of both 3d and 3dH ...\"easy\" if both present BezierCurve3dH span loaders\r\n    if (this._geometryB instanceof LineSegment3d) {\r\n      this.dispatchSegmentBsplineCurve(\r\n        this._geometryB, this._extendB, this._geometryB.point0Ref, 0.0, this._geometryB.point1Ref, 1.0, this._extendB,\r\n        curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof LineString3d) {\r\n      this.dispatchLineStringBSplineCurve(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    } else if (this._geometryB instanceof Arc3d) {\r\n      this.dispatchArcBsplineCurve3d(this._geometryB, this._extendB, curve, this._extendA, true);\r\n    }\r\n    */\r\n    return undefined;\r\n  }\r\n\r\n}\r\n/**\r\n * `CurveCurve` has static method for various computations that work on a pair of curves or curve collections.\r\n * @public\r\n */\r\nexport class CurveCurve {\r\n  /**\r\n   * Return xy intersections of 2 curves.\r\n   * @param geometryA second geometry\r\n   * @param extendA true to allow geometryA to extend\r\n   * @param geometryB second geometry\r\n   * @param extendB true to allow geometryB to extend\r\n   */\r\n  public static intersectionXY(geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailArrayPair {\r\n    const handler = new CurveCurveIntersectXY(undefined, geometryA, extendA, geometryB, extendB);\r\n    geometryA.dispatchToGeometryHandler(handler);\r\n    return handler.grabResults();\r\n  }\r\n\r\n  /**\r\n   * Return xy intersections of 2 projected curves\r\n   * @param geometryA second geometry\r\n   * @param extendA true to allow geometryA to extend\r\n   * @param geometryB second geometry\r\n   * @param extendB true to allow geometryB to extend\r\n   */\r\n  public static intersectionProjectedXY(worldToLocal: Matrix4d,\r\n    geometryA: GeometryQuery, extendA: boolean, geometryB: GeometryQuery, extendB: boolean): CurveLocationDetailArrayPair {\r\n    const handler = new CurveCurveIntersectXY(worldToLocal, geometryA, extendA, geometryB, extendB);\r\n    geometryA.dispatchToGeometryHandler(handler);\r\n    return handler.grabResults();\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * An enumeration of special conditions being described by a CurveLocationDetail.\r\n * @public\r\n */\r\nexport enum CurveIntervalRole {\r\n  /** This point is an isolated point NOT at a primary vertex. */\r\n  isolated = 0,\r\n  /**  This point is an isolated vertex hit */\r\n  isolatedAtVertex = 1,\r\n  /** This is the beginning of an interval */\r\n  intervalStart = 10,\r\n  /** This is an interior point of an interval. */\r\n  intervalInterior = 11,\r\n  /** This is the end of an interval */\r\n  intervalEnd = 12,\r\n}\r\n/**\r\n * Return code for CurvePrimitive method `moveSignedDistanceFromFraction`\r\n * @public\r\n */\r\nexport enum CurveSearchStatus {\r\n  /** unimplemented or zero length curve  */\r\n  error,\r\n  /** complete success of search */\r\n  success = 1,\r\n  /** search ended prematurely (e.g. at incomplete distance moved) at start or end of curve */\r\n  stoppedAtBoundary = 2,\r\n}\r\n\r\n/**\r\n * use to update a vector in case where source and prior result are both possibly undefined.\r\n * * Any undefined source returns undefined.\r\n * * For defined source, reuse optional result if available.\r\n * @param source optional source\r\n * @param result optional result\r\n */\r\nfunction optionalVectorUpdate(source: Vector3d | undefined, result: Vector3d | undefined): Vector3d | undefined {\r\n  if (source) {\r\n    return source.clone(result);\r\n  }\r\n  return undefined;\r\n}\r\n/**\r\n * CurveLocationDetail carries point and paramter data about a point evaluated on a curve.\r\n * * These are returned by a variety of queries.\r\n * * Particular contents can vary among the queries.\r\n * @public\r\n */\r\nexport class CurveLocationDetail {\r\n  /** The curve being evaluated */\r\n  public curve?: CurvePrimitive;\r\n  /** optional ray */\r\n  public ray?: Ray3d;\r\n  /** The fractional position along the curve */\r\n  public fraction: number;\r\n  /** Detail condition of the role this point has in some context */\r\n  public intervalRole?: CurveIntervalRole;\r\n  /** The point on the curve */\r\n  public point: Point3d;\r\n  /** A vector (e.g. tangent vector) in context */\r\n  public vectorInCurveLocationDetail?: Vector3d;\r\n  /** A context-specific numeric value.  (E.g. a distance) */\r\n  public a: number;\r\n  /** optional CurveLocationDetail with more detail of location.  For instance, a detail for fractional position within\r\n   * a CurveChainWithDistanceIndex returns fraction and distance along the chain as its primary data and\r\n   * further detail of the particular curve within the chain in the childDetail.\r\n   */\r\n  public childDetail?: CurveLocationDetail;\r\n  /** A status indicator for certain searches.\r\n   * * e.g. CurvePrimitive.moveSignedDistanceFromFraction\r\n   */\r\n  public curveSearchStatus?: CurveSearchStatus;\r\n  /** A context-specific additional point */\r\n  public pointQ: Point3d;  // extra point for use in computations\r\n\r\n  public constructor() {\r\n    this.pointQ = Point3d.createZero();\r\n    this.fraction = 0;\r\n    this.point = Point3d.createZero();\r\n    this.a = 0.0;\r\n  }\r\n  /** Set the (optional) intervalRole field */\r\n  public setIntervalRole(value: CurveIntervalRole): void {\r\n    this.intervalRole = value;\r\n  }\r\n  /** test if this is an isolated point. This is true if intervalRole is any of (undefined, isolated, isolatedAtVertex) */\r\n  public get isIsolated(): boolean {\r\n    return this.intervalRole === undefined\r\n      || this.intervalRole === CurveIntervalRole.isolated\r\n      || this.intervalRole === CurveIntervalRole.isolatedAtVertex;\r\n  }\r\n\r\n  /** Return a complete copy, WITH CAVEATS . . .\r\n   * * curve member is copied as a reference.\r\n   * * point and vector members are cloned.\r\n   */\r\n  public clone(result?: CurveLocationDetail): CurveLocationDetail {\r\n    if (result === this)\r\n      return result;\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = this.curve;\r\n    result.fraction = this.fraction;\r\n    result.point.setFromPoint3d(this.point);\r\n    result.vectorInCurveLocationDetail = optionalVectorUpdate(this.vectorInCurveLocationDetail, result.vectorInCurveLocationDetail);\r\n    result.a = this.a;\r\n    result.curveSearchStatus = this.curveSearchStatus;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Updated in this instance.\r\n   * * Note that if caller omits `vector` and `a`, those fields are updated to the call-list defaults (NOT left as-is)\r\n   * * point and vector updates are by data copy (not capture of arglist pointers)\r\n   * @param fraction (required) fraction to install\r\n   * @param point  (required) point to install\r\n   * @param vector (optional) vector to install.\r\n   * @param a (optional) numeric value to install.\r\n   */\r\n  public setFP(fraction: number, point: Point3d, vector?: Vector3d, a: number = 0.0) {\r\n    this.fraction = fraction;\r\n    this.point.setFrom(point);\r\n    this.vectorInCurveLocationDetail = optionalVectorUpdate(vector, this.vectorInCurveLocationDetail);\r\n    this.a = a;\r\n  }\r\n\r\n  /**\r\n   * Updated in this instance.\r\n   * * Note that if caller omits a`, that field is updated to the call-list default (NOT left as-is)\r\n   * * point and vector updates are by data copy (not capture of arglist data.\r\n   * @param fraction (required) fraction to install\r\n   * @param ray  (required) point and vector to install\r\n   * @param a (optional) numeric value to install.\r\n   */\r\n  public setFR(fraction: number, ray: Ray3d, a: number = 0) {\r\n    return this.setFP(fraction, ray.origin, ray.direction, a);\r\n  }\r\n  /** Set the CurvePrimitive pointer, leaving all other properties untouched.\r\n   */\r\n  public setCurve(curve: CurvePrimitive) { this.curve = curve; }\r\n\r\n  /** record the distance from the CurveLocationDetail's point to the parameter point. */\r\n  public setDistanceTo(point: Point3d) {\r\n    this.a = this.point.distance(point);\r\n  }\r\n\r\n  /** create with a CurvePrimitive pointer but no coordinate data.\r\n   */\r\n  public static create(\r\n    curve: CurvePrimitive,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    return result;\r\n  }\r\n\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates.\r\n   */\r\n  public static createCurveFractionPoint(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point.setFromPoint3d(point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = 0.0;\r\n    result.curveSearchStatus = undefined;\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a new detail with only ray, fraction, and point.\r\n   */\r\n  public static createRayFractionPoint(ray: Ray3d, fraction: number, point: Point3d, result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.fraction = fraction;\r\n    result.ray = ray;\r\n    result.point.setFromPoint3d(point);\r\n    return result;\r\n  }\r\n\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates\r\n   */\r\n  public static createCurveFractionPointDistanceCurveSearchStatus(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    distance: number,\r\n    status: CurveSearchStatus,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point.setFromPoint3d(point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = distance;\r\n    result.curveSearchStatus = status;\r\n    return result;\r\n  }\r\n  /** create with curveSearchStatus affected by allowExtension.\r\n   * *\r\n   */\r\n  public static createConditionalMoveSignedDistance(\r\n    allowExtension: boolean,\r\n    curve: CurvePrimitive,\r\n    startFraction: number,\r\n    endFraction: number,\r\n    requestedSignedDistance: number,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    let a = requestedSignedDistance;\r\n    let status = CurveSearchStatus.success;\r\n    if (!allowExtension && !Geometry.isIn01(endFraction)) {\r\n      // cap the movement at the endpoint\r\n      if (endFraction < 0.0) {\r\n        a = - curve.curveLengthBetweenFractions(startFraction, 0.0);\r\n        endFraction = 0.0;\r\n        status = CurveSearchStatus.stoppedAtBoundary;\r\n      } else if (endFraction > 1.0) {\r\n        endFraction = 1.0;\r\n        a = curve.curveLengthBetweenFractions(startFraction, 1.0);\r\n        status = CurveSearchStatus.stoppedAtBoundary;\r\n      }\r\n    }\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = endFraction;\r\n    result.point = curve.fractionToPoint(endFraction, result.point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = a;\r\n    result.curveSearchStatus = status;\r\n    return result;\r\n  }\r\n\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates.\r\n   */\r\n  public static createCurveEvaluatedFraction(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point = curve.fractionToPoint(fraction);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.curveSearchStatus = undefined;\r\n    result.a = 0.0;\r\n    return result;\r\n  }\r\n  /** create with CurvePrimitive pointer, fraction, and point coordinates.\r\n   */\r\n  public static createCurveFractionPointDistance(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    a: number,\r\n    result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = result ? result : new CurveLocationDetail();\r\n    result.curve = curve;\r\n    result.fraction = fraction;\r\n    result.point.setFromPoint3d(point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = a;\r\n    result.curveSearchStatus = undefined;\r\n    return result;\r\n  }\r\n\r\n  /** update or create if closer than current contents.\r\n   * @param curve candidate curve\r\n   * @param fraction candidate fraction\r\n   * @param point candidate point\r\n   * @param a candidate distance\r\n   * @returns true if the given distance is smaller (and hence this detail was updated.)\r\n   */\r\n  public updateIfCloserCurveFractionPointDistance(\r\n    curve: CurvePrimitive,\r\n    fraction: number,\r\n    point: Point3d,\r\n    a: number): boolean {\r\n    if (this.a < a)\r\n      return false;\r\n    CurveLocationDetail.createCurveFractionPointDistance(curve, fraction, point, a, this);\r\n    return true;\r\n  }\r\n\r\n}\r\n/** Enumeration of configurations for intersections and min/max distance-between-curve\r\n * @public\r\n */\r\nexport enum CurveCurveApproachType {\r\n  /** Intersection at a single point */\r\n  Intersection = 0,\r\n  /** Distinct points on the two curves, with each curve's tangent perpendicular to the chord between the points */\r\n  PerpendicularChord = 1,\r\n  /** Completely coincident geometry */\r\n  CoincidentGeometry = 2,\r\n  /** Completely parallel geometry. */\r\n  ParallelGeometry = 3,\r\n}\r\n/** A pair of CurveLocationDetail.\r\n * @public\r\n */\r\nexport class CurveLocationDetailPair {\r\n  /** The first of the two details ... */\r\n  public detailA: CurveLocationDetail;\r\n  /** The second of the two details ... */\r\n  public detailB: CurveLocationDetail;\r\n  /** enumeration of how the detail pairs relate.\r\n   * * This is set only by certain closeApproach calculations.\r\n   */\r\n  public approachType?: CurveCurveApproachType;\r\n\r\n  public constructor() {\r\n    this.detailA = new CurveLocationDetail();\r\n    this.detailB = new CurveLocationDetail();\r\n  }\r\n\r\n  /** Create a curve detail pair using references to two CurveLocationDetails */\r\n  public static createCapture(detailA: CurveLocationDetail, detailB: CurveLocationDetail, result?: CurveLocationDetailPair): CurveLocationDetailPair {\r\n    result = result ? result : new CurveLocationDetailPair();\r\n    result.detailA = detailA;\r\n    result.detailB = detailB;\r\n    return result;\r\n  }\r\n\r\n  /** Make a deep copy of this CurveLocationDetailPair */\r\n  public clone(result?: CurveLocationDetailPair): CurveLocationDetailPair {\r\n    result = result ? result : new CurveLocationDetailPair();\r\n    result.detailA = this.detailA.clone();\r\n    result.detailB = this.detailB.clone();\r\n    result.approachType = this.approachType;\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { AxisOrder, Geometry, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { Order2Bezier } from \"../numerics/BezierPolynomials\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { NewtonEvaluatorRtoR, Newton1dUnboundedApproximateDerivative } from \"../numerics/Newton\";\r\nimport { Quadrature } from \"../numerics/Quadrature\";\r\nimport { IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\nimport { CurveLocationDetail, CurveSearchStatus } from \"./CurveLocationDetail\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { StrokeCountMap } from \"../curve/Query/StrokeCountMap\";\r\n\r\n/** function signature for callback which announces a pair of numbers, such as a fractional interval, along with a containing CurvePrimitive.\r\n * @public\r\n */\r\nexport type AnnounceNumberNumberCurvePrimitive = (a0: number, a1: number, cp: CurvePrimitive) => void;\r\n/** Function signature for a callback which announces a pair of numbers\r\n * @public\r\n */\r\n\r\nexport type AnnounceNumberNumber = (a0: number, a1: number) => void;\r\n/** Function signature for a callback which announces a curve primitive\r\n * @public\r\n */\r\nexport type AnnounceCurvePrimitive = (cp: CurvePrimitive) => void;\r\n\r\n/**\r\n * A curve primitive is bounded\r\n * A curve primitive maps fractions in 0..1 to points in space.\r\n * As the fraction proceeds from 0 towards 1, the point moves \"forward\" along the curve.\r\n * True distance along the curve is not always strictly proportional to fraction.\r\n * * LineSegment3d always has proportional fraction and distance\r\n * * an Arc3d which is true circular has proportional fraction and distance\r\n * *  A LineString3d is not proportional (except for special case of all segments of equal length)\r\n * * A Spiral3d is proportional\r\n * * A BsplineCurve3d is only proportional for special cases.\r\n *\r\n * For fractions outside 0..1, the curve primitive class may either (a) return the near endpoint or (b) evaluate an extended curve.\r\n * @public\r\n */\r\nexport abstract class CurvePrimitive extends GeometryQuery {\r\n  protected constructor() { super(); }\r\n  /**\r\n   * data attached during stroking for facets.\r\n   */\r\n  public strokeData?: StrokeCountMap;\r\n\r\n  /** Return the point (x,y,z) on the curve at fractional position.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a point on the curve.\r\n   */\r\n  public abstract fractionToPoint(fraction: number, result?: Point3d): Point3d;\r\n  /** Return the point (x,y,z) and derivative on the curve at fractional position.\r\n   *\r\n   * * Note that this derivative is \"derivative of xyz with respect to fraction.\"\r\n   * * this derivative shows the speed of the \"fractional point\" moving along the curve.\r\n   * * this is not generally a unit vector.  use fractionToPointAndUnitTangent for a unit vector.\r\n   * @param fraction fractional position along the geometry.\r\n   * @returns Returns a ray whose origin is the curve point and direction is the derivative with respect to the fraction.\r\n   */\r\n  public abstract fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d;\r\n  /**\r\n   * Returns a ray whose origin is the curve point and direction is the unit tangent.\r\n   * @param fraction fractional position on the curve\r\n   * @param result optional preallocated ray.\r\n   */\r\n  public fractionToPointAndUnitTangent(fraction: number, result?: Ray3d): Ray3d {\r\n    const ray = this.fractionToPointAndDerivative(fraction, result);\r\n    ray.trySetDirectionMagnitudeInPlace(1.0);\r\n    return ray;\r\n  }\r\n  /** Return a plane with\r\n   *\r\n   * * origin at fractional position along the curve\r\n   * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\r\n   * * vectorV is the second derivative, i.e.derivative of vectorU.\r\n   */\r\n  public abstract fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined;\r\n\r\n  /** Construct a frenet frame:\r\n   * * origin at the point on the curve\r\n   * * x axis is unit vector along the curve (tangent)\r\n   * * y axis is perpendicular and in the plane of the osculating circle.\r\n   * * z axis perpendicular to those.\r\n   */\r\n  public fractionToFrenetFrame(fraction: number, result?: Transform): Transform | undefined {\r\n    const plane = this.fractionToPointAnd2Derivatives(fraction);\r\n    if (!plane) return undefined;\r\n    let axes = Matrix3d.createRigidFromColumns(plane.vectorU, plane.vectorV, AxisOrder.XYZ);\r\n    if (axes)\r\n      return Transform.createRefs(plane.origin, axes, result);\r\n    // 2nd derivative not distinct -- do arbitrary headsup ...\r\n    const perpVector = Matrix3d.createPerpendicularVectorFavorXYPlane(plane.vectorU, plane.vectorV);\r\n    axes = Matrix3d.createRigidFromColumns(plane.vectorU, perpVector, AxisOrder.XYZ);\r\n    if (axes)\r\n      return Transform.createRefs(plane.origin, axes, result);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Construct a point extrapolated along tangent at fraction.\r\n   * @param fraction fractional position on the primitive\r\n   * @param distance (signed) distance to move on the tangent.\r\n   */\r\n  public fractionAndDistanceToPointOnTangent(fraction: number, distance: number): Point3d {\r\n    const ray = this.fractionToPointAndUnitTangent(fraction);\r\n    return ray.fractionToPoint(distance);\r\n  }\r\n\r\n  /**\r\n   * return the length of the curve.\r\n   * * Curve length is always positive.\r\n   */\r\n  public curveLength(): number {\r\n    const context = new CurveLengthContext();\r\n    this.emitStrokableParts(context);\r\n    return context.getSum();\r\n  }\r\n  /**\r\n   * Returns a (high accuracy) length of the curve between fractional positions\r\n   * * Curve length is always positive.\r\n   * * Default implementation applies a generic gaussian integration.\r\n   * * Most curve classes (certainly LineSegment, LineString, Arc) are expected to provide efficient implementations.\r\n   */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    if (fraction0 === fraction1)\r\n      return 0.0;\r\n    const scale = this.getFractionToDistanceScale();\r\n    if (scale !== undefined) {\r\n      // We are in luck! simple proportions determine it all  !!!\r\n      // (for example, a LineSegment3d or a circular arc)\r\n      const totalLength = this.curveLength();\r\n      return Math.abs((fraction1 - fraction0) * totalLength);\r\n    }\r\n    const context = new CurveLengthContext(fraction0, fraction1);\r\n    this.emitStrokableParts(context);\r\n    return Math.abs(context.getSum());\r\n  }\r\n\r\n  /**\r\n   *\r\n   * * Run an integration (with a default gaussian quadrature) with a fixed fractional step\r\n   * * This is typically called by specific curve type implementations of curveLengthBetweenFractions.\r\n   *   * For example, in Arc3d implementation of curveLengthBetweenFractions:\r\n   *     * If the Arc3d is true circular, it the arc is true circular, use the direct `arcLength = radius * sweepRadians`\r\n   *     * If the Arc3d is not true circular, call this method with an interval count appropriate to eccentricity and sweepRadians.\r\n   * @returns Returns an integral estimated by numerical quadrature between the fractional positions.\r\n   * @param fraction0 start fraction for integration\r\n   * @param fraction1 end fraction for integration\r\n   * @param numInterval number of quadrature intervals\r\n   */\r\n  public curveLengthWithFixedIntervalCountQuadrature(fraction0: number, fraction1: number, numInterval: number, numGauss: number = 5): number {\r\n    if (fraction0 > fraction1) {\r\n      const fSave = fraction0;\r\n      fraction0 = fraction1;\r\n      fraction1 = fSave;\r\n    }\r\n    const context = new CurveLengthContext(fraction0, fraction1, numGauss);\r\n    context.announceIntervalForUniformStepStrokes(this, numInterval, fraction0, fraction1);\r\n    return Math.abs(context.getSum());\r\n  }\r\n\r\n  /**\r\n   *\r\n   * * (Attempt to) find a position on the curve at a signed distance from start fraction.\r\n   * * Return the position as a CurveLocationDetail.\r\n   * * In the `CurveLocationDetail`, record:\r\n   *   * `fractional` position\r\n   *   * `fraction` = coordinates of the point\r\n   *   * `search\r\n   *   * `a` = (signed!) distance moved.   If `allowExtension` is false and the move reached the start or end of the curve, this distance is smaller than the requested signedDistance.\r\n   *   * `curveSearchStatus` indicates one of:\r\n   *     * `error` (unusual) computation failed not supported for this curve.\r\n   *     * `success` full movement completed\r\n   *     * `stoppedAtBoundary` partial movement completed. This can be due to either\r\n   *        * `allowExtension` parameter sent as `false`\r\n   *        * the curve type (e.g. bspline) does not support extended range.\r\n   * * if `allowExtension` is true, movement may still end at the startpoint or endpoint for curves that do not support extended geometry (specifically bsplines)\r\n   * * if the curve returns a value (i.e. not `undefined`) for `curve.getFractionToDistanceScale()`, the base class carries out the computation\r\n   *    and returns a final location.\r\n   *   * LineSegment3d relies on this.\r\n   * * If the curve does not implement the computation or the curve has zero length, the returned `CurveLocationDetail` has\r\n   *    * `fraction` = the value of `startFraction`\r\n   *    * `point` = result of `curve.fractionToPoint(startFraction)`\r\n   *    * `a` = 0\r\n   *    * `curveStartState` = `CurveSearchStatus.error`\r\n   * @param startFraction fractional position where the move starts\r\n   * @param signedDistance distance to move.   Negative distance is backwards in the fraction space\r\n   * @param allowExtension if true, all the move to go beyond the startpoint or endpoint of the curve.  If false, do not allow movement beyond the startpoint or endpoint\r\n   * @param result optional result.\r\n   * @returns A CurveLocationDetail annotated as above.  Note that if the curve does not support the calculation, there is still a result which contains the point at the input startFraction, with failure indicated in the `curveStartState` member\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const scale = this.getFractionToDistanceScale();\r\n    if (scale !== undefined) {\r\n      // We are in luck! simple proportions determine it all  !!!\r\n      // (for example, a LineSegment3d or a circular arc)\r\n      const totalLength = this.curveLength();\r\n      const signedFractionMove = Geometry.conditionalDivideFraction(signedDistance, totalLength);\r\n      if (signedFractionMove === undefined) {\r\n        return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(\r\n          this, startFraction, this.fractionToPoint(startFraction), 0.0, CurveSearchStatus.error);\r\n      }\r\n      return CurveLocationDetail.createConditionalMoveSignedDistance(\r\n        allowExtension,\r\n        this,\r\n        startFraction,\r\n        startFraction + signedFractionMove,\r\n        signedDistance,\r\n        result);\r\n    }\r\n    return this.moveSignedDistanceFromFractionGeneric(startFraction, signedDistance, allowExtension, result);\r\n  }\r\n  /**\r\n   * Generic algorithm to search for point at signed distance from a fractional start point.\r\n   * * This will work for well for smooth curves.\r\n   * * Curves with tangent or other low-order-derivative discontinuities may need to implement specialized algorithms.\r\n   * * We need to find an endFraction which is the end-of-interval (usually upper) limit of integration of the tangent magnitude from startFraction to endFraction\r\n   * * That integral is a function of endFraction.\r\n   * * The derivative of that integral with respect to end fraction is the tangent magnitude at end fraction.\r\n   * * Use that function and (easily evaluated!) derivative for a Newton iteration\r\n   * * TO ALL WHO HAVE FUZZY MEMORIES OF CALCULUS CLASS: \"The derivative of the integral wrt upper limit is the value of the integrand there\" is the\r\n   *       fundamental theorem of integral calculus !!! The fundamental theorem is not just an abstraction !!! It is being used\r\n   *       here in its barest possible form !!!\r\n   * * See https://en.wikipedia.org/wiki/Fundamental_theorem_of_calculus\r\n   * @param startFraction\r\n   * @param signedDistance\r\n   * @param _allowExtension\r\n   * @param result\r\n   */\r\n  protected moveSignedDistanceFromFractionGeneric(startFraction: number, signedDistance: number, allowExtension: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const limitFraction = signedDistance > 0.0 ? 1.0 : 0.0;\r\n    const absDistance = Math.abs(signedDistance);\r\n    const directionFactor = signedDistance < 0.0 ? -1.0 : 1.0;\r\n    const availableLength = this.curveLengthBetweenFractions(startFraction, limitFraction);    // that is always positive\r\n    if (availableLength < absDistance && !allowExtension)\r\n      return CurveLocationDetail.createConditionalMoveSignedDistance(allowExtension, this, startFraction, limitFraction, signedDistance, result);\r\n    const fractionStep = absDistance / availableLength;\r\n    let fractionB = Geometry.interpolate(startFraction, fractionStep, limitFraction);\r\n    let fractionA = startFraction;\r\n    let distanceA = 0.0;\r\n    const tol = 1.0e-12 * availableLength;\r\n    let numConverged = 0;\r\n    const tangent = Ray3d.createXAxis();\r\n    // on each loop entry:\r\n    // fractionA is the most recent endOfInterval.  (It may have been reached by a mixture of forward and backward step.)\r\n    // distanceA is the distance to (the point at) fractionA\r\n    // fractionB is the next end fraction\r\n    for (let iterations = 0; iterations < 10; iterations++) {\r\n      const distanceAB = this.curveLengthBetweenFractions(fractionA, fractionB);\r\n      const directionAB = fractionB > fractionA ? directionFactor : -directionFactor;\r\n      const distance0B = distanceA + directionAB * distanceAB;\r\n      const distanceError = absDistance - distance0B;\r\n      if (Math.abs(distanceError) < tol) {\r\n        numConverged++;\r\n        if (numConverged > 1)\r\n          break;\r\n      } else {\r\n        numConverged = 0;\r\n      }\r\n      this.fractionToPointAndDerivative(fractionB, tangent);\r\n      const tangentMagnitude = tangent.direction.magnitude();\r\n      fractionA = fractionB;\r\n      fractionB = fractionA + directionFactor * distanceError / tangentMagnitude;\r\n      if (fractionA === fractionB) { // YES -- that is an exact equality test.   When it happens, there's no need for confirming with another iteration.\r\n        numConverged = 100;\r\n        break;\r\n      }\r\n      distanceA = distance0B;\r\n    }\r\n    if (numConverged > 1)\r\n      return CurveLocationDetail.createConditionalMoveSignedDistance(false, this, startFraction, fractionB, signedDistance, result);\r\n\r\n    result = CurveLocationDetail.createCurveEvaluatedFraction(this, startFraction, result);\r\n    result.a = 0.0;\r\n    result.curveSearchStatus = CurveSearchStatus.error;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * Returns true if the curve's fraction queries extend beyond 0..1.\r\n   * * Base class default implementation returns false.\r\n   * * These class (and perhaps others in the future) will return true:\r\n   *   * LineSegment3d\r\n   *   * LineString3d\r\n   *   * Arc3d\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return false; }\r\n  /**\r\n   * Compute a length which may be an fast approximation to the true length.\r\n   * This is expected to be either (a) exact or (b) larger than the actual length, but by no more than\r\n   * a small multiple, perhaps up to PI/2, but commonly much closer to 1.\r\n   *\r\n   * * An example use of this is for setting a tolerance which is a small multiple of the curve length.\r\n   * * Simple line, circular arc, and transition spiral may return exact length\r\n   * * Ellipse may return circumference of some circle or polygon that encloses the ellipse.\r\n   * * bspline curve may return control polygon length\r\n   * *\r\n   */\r\n  public abstract quickLength(): number;\r\n  /** Search for the curve point that is closest to the spacePoint.\r\n   *\r\n   * * If the space point is exactly on the curve, this is the reverse of fractionToPoint.\r\n   * * Since CurvePrimitive should always have start and end available as candidate points, this method should always succeed\r\n   * @param spacePoint point in space\r\n   * @param extend true to extend the curve (if possible)\r\n   * @returns Returns a CurveLocationDetail structure that holds the details of the close point.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: boolean): CurveLocationDetail | undefined {\r\n    const strokeHandler = new ClosestPointStrokeHandler(spacePoint, extend);\r\n    this.emitStrokableParts(strokeHandler);\r\n    return strokeHandler.claimResult();\r\n  }\r\n  /**\r\n   * Find intervals of this curvePrimitive that are interior to a clipper\r\n   * @param clipper clip structure (e.g. clip planes)\r\n   * @param announce (optional) function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   * @returns true if any \"in\" segments are announced.\r\n   */\r\n  public announceClipIntervals(_clipper: Clipper, _announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    // DEFAULT IMPLEMENTATION -- no interior parts\r\n    return false;\r\n  }\r\n\r\n  /** Return (if possible) a curve primitive which is a portion of this curve.\r\n   * @param _fractionA [in] start fraction\r\n   * @param _fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(_fractionA: number, _fractionB: number): CurvePrimitive | undefined {\r\n    return undefined;\r\n  }\r\n  /**\r\n   * * If the curve primitive has distance-along-curve strictly proportional to curve fraction, return true\r\n   * * If distance-along-the-curve is not proportional, return undefined.\r\n   * * When defined, the scale factor is always the length of the curve.\r\n   * * This scale factor is typically available for these curve types:\r\n   * * * All `LineSegment3d`\r\n   * * * Arc3d which is a true circular arc (axes perpendicular and of equal length).\r\n   * * * CurveChainWithDistanceIndex\r\n   * * This scale factor is undefined for these curve types:\r\n   * * * Arc3d which is a true ellipse, i.e. unequal lengths of defining vectors or non-perpendicular defining vectors.\r\n   * * * bspline and bezier curves\r\n   * @returns scale factor or undefined\r\n   */\r\n  public getFractionToDistanceScale(): number | undefined { return undefined; }\r\n\r\n  /** Reverse the curve's data so that its fractional stroking moves in the opposite direction. */\r\n  public abstract reverseInPlace(): void;\r\n  /**\r\n   * Compute intersections with a plane.\r\n   * The intersections are appended to the result array.\r\n   * The base class implementation emits strokes to an AppendPlaneIntersectionStrokeHandler object, which uses a Newton iteration to get\r\n   * high-accuracy intersection points within strokes.\r\n   * Derived classes should override this default implementation if there are easy analytic solutions.\r\n   * @param plane The plane to be intersected.\r\n   * @param result Array to receive intersections\r\n   * @returns Return the number of CurveLocationDetail's added to the result array.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const strokeHandler = new AppendPlaneIntersectionStrokeHandler(plane, result);\r\n    const n0 = result.length;\r\n    this.emitStrokableParts(strokeHandler);\r\n    return result.length - n0;\r\n  }\r\n  /** Ask if the curve is within tolerance of a plane.\r\n   * @returns Returns true if the curve is completely within tolerance of the plane.\r\n   */\r\n  public abstract isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean;\r\n  /** return the start point of the primitive.  The default implementation returns fractionToPoint (0.0) */\r\n  public startPoint(result?: Point3d): Point3d { return this.fractionToPoint(0.0, result); }\r\n  /** return the end point of the primitive. The default implementation returns fractionToPoint(1.0) */\r\n  public endPoint(result?: Point3d): Point3d { return this.fractionToPoint(1.0, result); }\r\n  /** Add strokes to caller-supplied linestring */\r\n  public abstract emitStrokes(dest: LineString3d, options?: StrokeOptions): void;\r\n  /** Ask the curve to announce points and simple subcurve fragments for stroking.\r\n   * See IStrokeHandler for description of the sequence of the method calls.\r\n   */\r\n  public abstract emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void;\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * * This returns a single number\r\n   * * See computeComponentStrokeCountForOptions to get structured per-component counts and fraction mappings.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public abstract computeStrokeCountForOptions(options?: StrokeOptions): number;\r\n\r\n  /**\r\n   * attach StrokeCountMap structure to this primitive (and recursively to any children)\r\n   * * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and attaches it.\r\n   * * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.\r\n   * * Subdivided primitives (linestring, bspline curve) implment themselves and attach a StrokeCountMap containing the\r\n   *       total count, and also containing an array of StrokeCountMap per component.\r\n   * * For CurvePrimitiveWithDistanceIndex, the top level gets (only) a total count, and each child gets\r\n   *       its own StrokeCountMap with appropriate structure.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap optional map from parent.  Its count, curveLength, and a1 values are increased with count and distance from this primitive.\r\n   * @return sum of `a0+this.curveLength()`, for use as `a0` of successor in chain.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentMap?: StrokeCountMap) {\r\n    const n = this.computeStrokeCountForOptions(options);\r\n    const a = this.curveLength();\r\n    CurvePrimitive.installStrokeCountMap(\r\n      this,\r\n      StrokeCountMap.createWithCurvePrimitive(this, n, a, 0, a),\r\n      parentMap);\r\n  }\r\n\r\n  /**\r\n   * * evaluate strokes at fractions indicated in a StrokeCountMap.\r\n   *   * Base class implementation (here) gets the simple count from computeStrokeCountForOptions and strokes at uniform fractions.\r\n   *   * LineString3d, arc3d, BezierCurve3d, BezierCurve3dH accept that default.\r\n   *   * Subdivided primitives (linestring, bspline curve) implment themselves and evaluate within components.\r\n   *   * CurvePrimitiveWithDistanceIndex recurses to its children.\r\n   * * if packedFraction and packedDerivative arrays are present in the LineString3d, fill them.\r\n   * @param map = stroke count data.\r\n   * @param linestring = receiver linestring.\r\n   * @return number of strokes added.  0 if any errors matching the map to the curve primitive.\r\n   */\r\n  public addMappedStrokesToLineString3D(map: StrokeCountMap, linestring: LineString3d): number {\r\n    const numPoint0 = linestring.numPoints();\r\n    if (map.primitive && map.primitive === this && map.numStroke > 0) {\r\n      for (let i = 0; i <= map.numStroke; i++) {\r\n        const fraction = i / map.numStroke;\r\n        linestring.appendFractionToPoint(this, fraction);\r\n      }\r\n    }\r\n    return linestring.numPoints() - numPoint0;\r\n  }\r\n\r\n  /**\r\n   * final install step to save curveMap in curve.  If parentMap is given, update its length, count, and a1 fields\r\n   * @param curve curve to receive the annotation\r\n   * @param map\r\n   * @param parentMap\r\n   */\r\n  public static installStrokeCountMap(curve: CurvePrimitive, curveMap: StrokeCountMap, parentMap?: StrokeCountMap) {\r\n    if (parentMap)\r\n      parentMap.addToCountAndLength(curveMap.numStroke, curveMap.curveLength);\r\n    curve.strokeData = curveMap;\r\n  }\r\n}\r\n\r\n/** Intermediate class for managing the parentCurve announcements from an IStrokeHandler */\r\nabstract class NewtonRotRStrokeHandler extends NewtonEvaluatorRtoR {\r\n  protected _parentCurvePrimitive: CurvePrimitive | undefined;\r\n  constructor() {\r\n    super();\r\n    this._parentCurvePrimitive = undefined;\r\n  }\r\n  /** retain the parentCurvePrimitive.\r\n   * * Calling this method tells the handler that the parent curve is to be used for detail searches.\r\n   * * Example: Transition spiral search is based on linestring first, then the exact spiral.\r\n   * * Example: CurveChainWithDistanceIndex does NOT do this announcement -- the constituents act independently.\r\n   */\r\n  public startParentCurvePrimitive(curve: CurvePrimitive | undefined) { this._parentCurvePrimitive = curve; }\r\n  /** Forget the parentCurvePrimitive */\r\n  public endParentCurvePrimitive(_curve: CurvePrimitive | undefined) { this._parentCurvePrimitive = undefined; }\r\n}\r\n\r\nclass AppendPlaneIntersectionStrokeHandler extends NewtonRotRStrokeHandler implements IStrokeHandler {\r\n  private _curve: CurvePrimitive | undefined;\r\n  private _plane: PlaneAltitudeEvaluator;\r\n  private _intersections: CurveLocationDetail[];\r\n  private _fractionA: number = 0;\r\n  private _functionA: number = 0;\r\n  // private derivativeA: number;   <---- Not currently used\r\n  private _functionB: number = 0;\r\n  private _fractionB: number = 0;\r\n  private _derivativeB: number = 0;\r\n  private _numThisCurve: number = 0;\r\n  // scratch vars for use within methods.\r\n  private _ray: Ray3d;\r\n  private _newtonSolver: Newton1dUnboundedApproximateDerivative;\r\n\r\n  // Return the first defined curve among: this.parentCurvePrimitive, this.curve;\r\n  public effectiveCurve(): CurvePrimitive | undefined {\r\n    if (this._parentCurvePrimitive)\r\n      return this._parentCurvePrimitive;\r\n    return this._curve;\r\n  }\r\n  public get getDerivativeB() { return this._derivativeB; }    // <--- DerivativeB is not currently used anywhere. Provided getter to suppress tslint error\r\n\r\n  public constructor(plane: PlaneAltitudeEvaluator, intersections: CurveLocationDetail[]) {\r\n    super();\r\n    this._plane = plane;\r\n    this._intersections = intersections;\r\n    this.startCurvePrimitive(undefined);\r\n    this._ray = Ray3d.createZero();\r\n    this._newtonSolver = new Newton1dUnboundedApproximateDerivative(this);\r\n  }\r\n  public startCurvePrimitive(curve: CurvePrimitive | undefined) {\r\n    this._curve = curve;\r\n    this._fractionA = 0.0;\r\n    this._numThisCurve = 0;\r\n    this._functionA = 0.0;\r\n    // this.derivativeA = 0.0;\r\n  }\r\n  public endCurvePrimitive() { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    this.startCurvePrimitive(cp);\r\n    if (numStrokes < 1) numStrokes = 1;\r\n    const df = 1.0 / numStrokes;\r\n    for (let i = 0; i <= numStrokes; i++) {\r\n      const fraction = Geometry.interpolate(fraction0, i * df, fraction1);\r\n      cp.fractionToPointAndDerivative(fraction, this._ray);\r\n      this.announcePointTangent(this._ray.origin, fraction, this._ray.direction);\r\n    }\r\n  }\r\n  public announceSegmentInterval(\r\n    _cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    const h0 = this._plane.altitude(point0);\r\n    const h1 = this._plane.altitude(point1);\r\n    if (h0 * h1 > 0.0)\r\n      return;\r\n    const fraction01 = Order2Bezier.solveCoffs(h0, h1);\r\n    // let numIntersection = 0;\r\n    if (fraction01 !== undefined) {\r\n      // numIntersection++;\r\n      const fraction = Geometry.interpolate(fraction0, fraction01, fraction1);\r\n      this._newtonSolver.setX(fraction);\r\n      if (this._newtonSolver.runIterations()) {\r\n        this.announceSolutionFraction(this._newtonSolver.getX());\r\n      }\r\n      // this.intersections.push(CurveLocationDetail.createCurveFractionPoint(cp, fraction, cp.fractionToPoint(fraction)));\r\n    }\r\n  }\r\n  private announceSolutionFraction(fraction: number) {\r\n    const curve = this.effectiveCurve();\r\n    if (curve) {\r\n      this._ray = curve.fractionToPointAndDerivative(fraction, this._ray);\r\n      this._intersections.push(CurveLocationDetail.createCurveFractionPoint(curve, fraction, this._ray.origin));\r\n    }\r\n  }\r\n  public evaluate(fraction: number): boolean {\r\n    const curve = this.effectiveCurve();\r\n    if (!curve)\r\n      return false;\r\n    this.currentF = this._plane.altitude(curve.fractionToPoint(fraction));\r\n    return true;\r\n  }\r\n  /**\r\n   * * ASSUME both the \"A\" and \"B\"  evaluations (fraction, function, and derivative) are known.\r\n   * * If function value changed sign between, interpolate an approximate root and improve it with\r\n   *     the newton solver.\r\n   */\r\n  private searchInterval() {\r\n    if (this._functionA * this._functionB > 0) return;\r\n    if (this._functionA === 0) this.announceSolutionFraction(this._fractionA);\r\n    if (this._functionB === 0) this.announceSolutionFraction(this._fractionB);\r\n    if (this._functionA * this._functionB < 0) {\r\n      const fraction = Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);\r\n      if (fraction) {\r\n        this._newtonSolver.setX(fraction);\r\n        if (this._newtonSolver.runIterations())\r\n          this.announceSolutionFraction(this._newtonSolver.getX());\r\n      }\r\n    }\r\n  }\r\n  /** Evaluate and save _functionB, _derivativeB, and _fractionB. */\r\n  private evaluateB(xyz: Point3d, fraction: number, tangent: Vector3d) {\r\n    this._functionB = this._plane.altitude(xyz);\r\n    this._derivativeB = this._plane.velocity(tangent);\r\n    this._fractionB = fraction;\r\n  }\r\n  /**\r\n   * Announce point and tangent for evaluations.\r\n   * * The function evaluation is saved as the \"B\" function point.\r\n   * * The function point count is incremented\r\n   * * If function point count is greater than 1, the current interval is searched.\r\n   * * The just-evaluated point (\"B\") is saved as the \"old\" (\"A\") evaluation point.\r\n   * @param xyz\r\n   * @param fraction\r\n   * @param tangent\r\n   */\r\n  public announcePointTangent(xyz: Point3d, fraction: number, tangent: Vector3d): void {\r\n    this.evaluateB(xyz, fraction, tangent);\r\n    if (this._numThisCurve++ > 0) this.searchInterval();\r\n    this._functionA = this._functionB;\r\n    this._fractionA = this._fractionB;\r\n    this._fractionA = this._fractionB;\r\n  }\r\n}\r\n\r\nclass CurveLengthContext implements IStrokeHandler {\r\n  private _curve: CurvePrimitive | undefined;\r\n  private _summedLength: number;\r\n  private _ray: Ray3d;\r\n  private _fraction0: number;\r\n  private _fraction1: number;\r\n  private _gaussX: Float64Array;\r\n  private _gaussW: Float64Array;\r\n  private _gaussMapper: (xA: number, xB: number, xx: Float64Array, ww: Float64Array) => number;\r\n\r\n  private tangentMagnitude(fraction: number): number {\r\n    this._ray = (this._curve as CurvePrimitive).fractionToPointAndDerivative(fraction, this._ray);\r\n    return this._ray.direction.magnitude();\r\n  }\r\n  public getSum() { return this._summedLength; }\r\n\r\n  public constructor(fraction0: number = 0.0, fraction1: number = 1.0, numGaussPoints: number = 5) {\r\n    this.startCurvePrimitive(undefined);\r\n    this._summedLength = 0.0;\r\n    this._ray = Ray3d.createZero();\r\n    if (fraction0 < fraction1) {\r\n      this._fraction0 = fraction0;\r\n      this._fraction1 = fraction1;\r\n    } else {\r\n      this._fraction0 = fraction1;\r\n      this._fraction1 = fraction0;\r\n    }\r\n    const maxGauss = 7;  // (As of Nov 2 2018, 7 is a fluffy overallocation-- the quadrature class only handles up to 5.)\r\n    this._gaussX = new Float64Array(maxGauss);\r\n    this._gaussW = new Float64Array(maxGauss);\r\n    // This sets the number of gauss points.  This intgetes exactly for polynomials of (degree 2*numGauss - 1).\r\n    if (numGaussPoints > 5 || numGaussPoints < 1)\r\n      numGaussPoints = 5;\r\n    switch (numGaussPoints) {\r\n      case 1: this._gaussMapper = Quadrature.setupGauss1; break;\r\n      case 2: this._gaussMapper = Quadrature.setupGauss2; break;\r\n      case 3: this._gaussMapper = Quadrature.setupGauss3; break;\r\n      case 4: this._gaussMapper = Quadrature.setupGauss4; break;\r\n      default: this._gaussMapper = Quadrature.setupGauss5; break;\r\n    }\r\n\r\n  }\r\n  public startCurvePrimitive(curve: CurvePrimitive | undefined) {\r\n    this._curve = curve;\r\n  }\r\n  public startParentCurvePrimitive(_curve: CurvePrimitive) { }\r\n  public endParentCurvePrimitive(_curve: CurvePrimitive) { }\r\n\r\n  public endCurvePrimitive() { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    if (fraction0 < this._fraction0) fraction0 = this._fraction0;\r\n    if (fraction1 > this._fraction1) fraction1 = this._fraction1;\r\n    if (fraction1 > fraction0) {\r\n      this.startCurvePrimitive(cp);\r\n      if (numStrokes < 1) numStrokes = 1;\r\n      const df = 1.0 / numStrokes;\r\n      for (let i = 1; i <= numStrokes; i++) {\r\n        const fractionA = Geometry.interpolate(fraction0, (i - 1) * df, fraction1);\r\n        const fractionB = i === numStrokes ? fraction1 : Geometry.interpolate(fraction0, (i) * df, fraction1);\r\n        const numGauss = this._gaussMapper(fractionA, fractionB, this._gaussX, this._gaussW);\r\n        for (let k = 0; k < numGauss; k++) {\r\n          this._summedLength += this._gaussW[k] * this.tangentMagnitude(this._gaussX[k]);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  public announceSegmentInterval(\r\n    _cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    const segmentLength = point0.distance(point1);\r\n    if (this._fraction0 <= fraction0 && fraction1 <= this._fraction1)\r\n      this._summedLength += segmentLength;\r\n    else {\r\n      let g0 = fraction0;\r\n      let g1 = fraction1;\r\n      if (g0 < this._fraction0) g0 = this._fraction0;\r\n      if (g1 > this._fraction1) g1 = this._fraction1;\r\n      if (g1 > g0) {\r\n        this._summedLength += segmentLength * (g1 - g0) / (fraction1 - fraction0);\r\n      }\r\n    }\r\n  }\r\n  public announcePointTangent(_xyz: Point3d, _fraction: number, _tangent: Vector3d): void {\r\n    // uh oh -- need to retain point for next interval\r\n  }\r\n}\r\n// context for searching for closest point .. .\r\nclass ClosestPointStrokeHandler extends NewtonRotRStrokeHandler implements IStrokeHandler {\r\n  private _curve: CurvePrimitive | undefined;\r\n  private _closestPoint: CurveLocationDetail | undefined;\r\n  private _spacePoint: Point3d;\r\n  private _extend: boolean;\r\n  private _fractionA: number = 0;\r\n  private _functionA: number = 0;\r\n  private _functionB: number = 0;\r\n  private _fractionB: number = 0;\r\n  private _numThisCurve: number = 0;\r\n  // scratch vars for use within methods.\r\n  private _workPoint: Point3d;\r\n  private _workRay: Ray3d;\r\n  private _newtonSolver: Newton1dUnboundedApproximateDerivative;\r\n\r\n  public constructor(spacePoint: Point3d, extend: boolean) {\r\n    super();\r\n    this._spacePoint = spacePoint;\r\n    this._workPoint = Point3d.create();\r\n    this._workRay = Ray3d.createZero();\r\n    this._closestPoint = undefined;\r\n    this._extend = extend;\r\n    this.startCurvePrimitive(undefined);\r\n    this._newtonSolver = new Newton1dUnboundedApproximateDerivative(this);\r\n  }\r\n\r\n  public claimResult(): CurveLocationDetail | undefined {\r\n    if (this._closestPoint) {\r\n      this._newtonSolver.setX(this._closestPoint.fraction);\r\n      this._curve = this._closestPoint.curve;\r\n      if (this._newtonSolver.runIterations())\r\n        this.announceSolutionFraction(this._newtonSolver.getX());\r\n    }\r\n    return this._closestPoint;\r\n  }\r\n  public startCurvePrimitive(curve: CurvePrimitive | undefined) {\r\n    this._curve = curve;\r\n    this._fractionA = 0.0;\r\n    this._numThisCurve = 0;\r\n    this._functionA = 0.0;\r\n  }\r\n  public endCurvePrimitive() { }\r\n  public announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    this.startCurvePrimitive(cp);\r\n    if (numStrokes < 1) numStrokes = 1;\r\n    const df = 1.0 / numStrokes;\r\n    for (let i = 0; i <= numStrokes; i++) {\r\n      const fraction = Geometry.interpolate(fraction0, i * df, fraction1);\r\n      cp.fractionToPointAndDerivative(fraction, this._workRay);\r\n      this.announceRay(fraction, this._workRay);\r\n    }\r\n  }\r\n\r\n  private announceCandidate(cp: CurvePrimitive, fraction: number, point: Point3d) {\r\n    const distance = this._spacePoint.distance(point);\r\n    if (this._closestPoint && distance > this._closestPoint.a)\r\n      return;\r\n    this._closestPoint = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point, this._closestPoint);\r\n    this._closestPoint.a = distance;\r\n    if (this._parentCurvePrimitive !== undefined)\r\n      this._closestPoint.curve = this._parentCurvePrimitive;\r\n  }\r\n  public announceSegmentInterval(\r\n    cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    _numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void {\r\n    let localFraction = this._spacePoint.fractionOfProjectionToLine(point0, point1, 0.0);\r\n    // only consider extending the segment if the immediate caller says we are at endpoints ...\r\n    if (!this._extend)\r\n      localFraction = Geometry.clampToStartEnd(localFraction, 0.0, 1.0);\r\n    else {\r\n      if (fraction0 !== 0.0)\r\n        localFraction = Math.max(localFraction, 0.0);\r\n      if (fraction1 !== 1.0)\r\n        localFraction = Math.min(localFraction, 1.0);\r\n    }\r\n    this._workPoint = point0.interpolate(localFraction, point1);\r\n    const globalFraction = Geometry.interpolate(fraction0, localFraction, fraction1);\r\n    this.announceCandidate(cp, globalFraction, this._workPoint);\r\n  }\r\n  private searchInterval() {\r\n    if (this._functionA * this._functionB > 0) return;\r\n    if (this._functionA === 0) this.announceSolutionFraction(this._fractionA);\r\n    if (this._functionB === 0) this.announceSolutionFraction(this._fractionB);\r\n    if (this._functionA * this._functionB < 0) {\r\n      const fraction = Geometry.inverseInterpolate(this._fractionA, this._functionA, this._fractionB, this._functionB);\r\n      if (fraction) {\r\n        this._newtonSolver.setX(fraction);\r\n        if (this._newtonSolver.runIterations())\r\n          this.announceSolutionFraction(this._newtonSolver.getX());\r\n      }\r\n    }\r\n  }\r\n  private evaluateB(fractionB: number, dataB: Ray3d) {\r\n    this._functionB = dataB.dotProductToPoint(this._spacePoint);\r\n    this._fractionB = fractionB;\r\n  }\r\n  private announceSolutionFraction(fraction: number) {\r\n    if (this._curve)\r\n      this.announceCandidate(this._curve, fraction, this._curve.fractionToPoint(fraction));\r\n  }\r\n  public evaluate(fraction: number): boolean {\r\n    let curve = this._curve;\r\n    if (this._parentCurvePrimitive)\r\n      curve = this._parentCurvePrimitive;\r\n    if (curve) {\r\n      this._workRay = curve.fractionToPointAndDerivative(fraction, this._workRay);\r\n      this.currentF = this._workRay.dotProductToPoint(this._spacePoint);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  public announceRay(fraction: number, data: Ray3d): void {\r\n    this.evaluateB(fraction, data);\r\n    if (this._numThisCurve++ > 0) this.searchInterval();\r\n    this._functionA = this._functionB;\r\n    this._fractionA = this._fractionB;\r\n    this._fractionA = this._fractionB;\r\n  }\r\n  public announcePointTangent(point: Point3d, fraction: number, tangent: Vector3d) {\r\n    this._workRay.set(point, tangent);\r\n    this.announceRay(fraction, this._workRay);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { UnionRegion } from \"./UnionRegion\";\r\nimport { BagOfCurves, CurveCollection } from \"./CurveCollection\";\r\nimport { ParityRegion } from \"./ParityRegion\";\r\nimport { Loop } from \"./Loop\";\r\nimport { Path } from \"./Path\";\r\n/* tslint:disable:variable-name no-empty*/\r\n\r\n/** base class for detailed traversal of curve artifacts.\r\n * * This recurses to children in the quickest way (no records of path)\r\n * * Use the RecursiveCurveProcessorWithStack to record the path along the visit.\r\n * @public\r\n */\r\nexport abstract class RecursiveCurveProcessor {\r\n  protected constructor() {\r\n  }\r\n\r\n  /** process error content */\r\n  public announceUnexpected(_data: AnyCurve, _indexInParent: number) { }\r\n  /** process a leaf primitive. */\r\n  public announceCurvePrimitive(_data: CurvePrimitive, _indexInParent = -1): void { }\r\n\r\n  /** announce a path (recurse to children) */\r\n  public announcePath(data: Path, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const curve of data.children)\r\n      this.announceCurvePrimitive(curve, i++);\r\n  }\r\n  /** announce a loop (recurse to children) */\r\n  public announceLoop(data: Loop, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const curve of data.children)\r\n      this.announceCurvePrimitive(curve, i++);\r\n  }\r\n\r\n  /** announce beginning or end of loops in a parity region */\r\n  public announceParityRegion(data: ParityRegion, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const loop of data.children)\r\n      this.announceLoop(loop, i++);\r\n  }\r\n  /** announce beginning or end of a parity region */\r\n  public announceUnionRegion(data: UnionRegion, _indexInParent: number = -1): void {\r\n    let i = 0;\r\n    for (const child of data.children) {\r\n      child.announceToCurveProcessor(this, i++);\r\n    }\r\n  }\r\n\r\n  /** announce a bag of curves.\r\n   * * The default implementation visits each child and calls the appropriate dispatch to\r\n   * * `this.announceCurvePrimitive(child)`\r\n   * * `child.announceToCurveProcessor(this)`\r\n   */\r\n  public announceBagOfCurves(data: BagOfCurves, _indexInParent: number = -1): void {\r\n    for (const child of data.children) {\r\n      if (child instanceof CurvePrimitive)\r\n        this.announceCurvePrimitive(child);\r\n      else\r\n        child.announceToCurveProcessor(this);\r\n    }\r\n  }\r\n}\r\n\r\n/** base class for detailed traversal of curve artifacts\r\n * * During recursion,  maintains a stack that shows complete path to each artifact.\r\n * * Use the QuickRecursiveCurveProcessor to visit without recording the path.\r\n * @public\r\n */\r\nexport abstract class RecursiveCurveProcessorWithStack extends RecursiveCurveProcessor {\r\n  /** Stack of curve collections that are \"up the tree\" from the current point of the traversal. */\r\n  protected _stack: CurveCollection[];\r\n  protected constructor() {\r\n    super();\r\n    this._stack = [];\r\n  }\r\n  /** Push `data` onto the stack so its status is available during processing of children.\r\n   * * Called when `data` is coming into scope.\r\n   */\r\n  public enter(data: CurveCollection) { this._stack.push(data); }\r\n  /** Pop the stack\r\n   * * called when the top of the stack goes out of scope\r\n   */\r\n  public leave(): CurveCollection | undefined { return this._stack.pop(); }\r\n\r\n  /** process error content */\r\n  public announceUnexpected(_data: AnyCurve, _indexInParent: number) { }\r\n  /** process a leaf primitive. */\r\n  public announceCurvePrimitive(_data: CurvePrimitive, _indexInParent = -1): void { }\r\n\r\n  /** announce a path (recurse to children) */\r\n  public announcePath(data: Path, indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    super.announcePath(data, indexInParent);\r\n    this.leave();\r\n  }\r\n  /** announce a loop (recurse to children) */\r\n  public announceLoop(data: Loop, indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    super.announceLoop(data, indexInParent);\r\n    this.leave();\r\n  }\r\n\r\n  /** announce beginning or end of loops in a parity region */\r\n  public announceParityRegion(data: ParityRegion, _indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    let i = 0;\r\n    for (const loop of data.children)\r\n      this.announceLoop(loop, i++);\r\n    this.leave();\r\n  }\r\n  /** announce beginning or end of a parity region */\r\n  public announceUnionRegion(data: UnionRegion, indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    super.announceUnionRegion(data, indexInParent);\r\n    this.leave();\r\n  }\r\n  /**\r\n   * Announce members of an unstructured collection.\r\n   * * push the collection reference on the stack\r\n   * * announce children\r\n   * * pop the stack\r\n   * @param data the collection\r\n   * @param _indexInParent index where the collection appears in its parent.\r\n   */\r\n  public announceBagOfCurves(data: BagOfCurves, _indexInParent: number = -1): void {\r\n    this.enter(data);\r\n    let i = 0;\r\n    for (const child of data.children) {\r\n      if (child instanceof CurvePrimitive)\r\n        this.announceCurvePrimitive(child, i++);\r\n      else\r\n        child.announceToCurveProcessor(this);\r\n    }\r\n    this.leave();\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\n/** Queries to be supported by Curve, Surface, and Solid objects */\r\n/**\r\n * * `GeometryQuery` is an abstract base class with (abstract) methods for querying curve, solid primitive, mesh, and bspline surfaces\r\n * @public\r\n */\r\nexport abstract class GeometryQuery {\r\n\r\n  /** return the range of the entire (tree) GeometryQuery */\r\n  public range(transform?: Transform, result?: Range3d): Range3d {\r\n    if (result) result.setNull();\r\n    const range = result ? result : Range3d.createNull();\r\n    this.extendRange(range, transform);\r\n    return range;\r\n  }\r\n\r\n  /** extend rangeToExtend by the range of this geometry multiplied by the transform */\r\n  public abstract extendRange(rangeToExtend: Range3d, transform?: Transform): void;\r\n\r\n  /** Attempt to transform in place.\r\n   *\r\n   * * LineSegment3d, Arc3d, LineString3d, BsplineCurve3d always succeed.\r\n   * * Some geometry types may fail if scaling is non-uniform.\r\n   */\r\n  public abstract tryTransformInPlace(transform: Transform): boolean;\r\n\r\n  /** try to move the geometry by dx,dy,dz */\r\n  public tryTranslateInPlace(dx: number, dy: number = 0.0, dz: number = 0.0): boolean {\r\n    return this.tryTransformInPlace(Transform.createTranslationXYZ(dx, dy, dz));\r\n  }\r\n  /** return a transformed clone.\r\n   */\r\n  public abstract cloneTransformed(transform: Transform): GeometryQuery | undefined;\r\n  /** return a clone */\r\n  public abstract clone(): GeometryQuery | undefined;\r\n  /** return GeometryQuery children for recursive queries.\r\n   *\r\n   * * leaf classes do not need to implement.\r\n   */\r\n  public get children(): GeometryQuery[] | undefined { return undefined; }\r\n  /** test if (other instanceof this.Type).  REQUIRED IN ALL CONCRETE CLASSES */\r\n  public abstract isSameGeometryClass(other: GeometryQuery): boolean;\r\n  /** test for exact structure and nearly identical geometry.\r\n   *\r\n   * *  Leaf classes must implement !!!\r\n   * *  base class implementation recurses through children.\r\n   * *  base implementation is complete for classes with children and no properties.\r\n   * *  classes with both children and properties must implement for properties, call super for children.\r\n   */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (this.isSameGeometryClass(other)) {\r\n      const childrenA = this.children;\r\n      const childrenB = other.children;\r\n      if (childrenA && childrenB) {\r\n        if (childrenA.length !== childrenB.length)\r\n          return false;\r\n        for (let i = 0; i < childrenA.length; i++) {\r\n          if (!childrenA[i].isAlmostEqual(childrenB[i])) return false;\r\n        }\r\n        return true;\r\n      } else if (childrenA || childrenB) {  // CurveCollections satr with empty arrays for children.  So these null pointer cases are never reached.\r\n        return false;   // plainly different .\r\n      } else {\r\n        // both children null. call it equal?   This class should probably have implemented.\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * * \"double dispatch\" call pattern.\r\n   * * User code implements a `GeometryHandler` with specialized methods to handle `LineSegment3d`, `Arc3d` etc as relevant to its use case.\r\n   * * Each such `GeometryQuery` class implements this method as a one-line method containing the appropriate call such as `handler.handleLineSegment3d ()`\r\n   * * This allows each type-specific method to be called without a switch or `instanceof` test.\r\n   * @param handler handler to be called by the particular geometry class\r\n   */\r\n  public abstract dispatchToGeometryHandler(handler: GeometryHandler): any;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, BeJSONFunctions, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Order2Bezier } from \"../numerics/BezierPolynomials\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive, AnnounceNumberNumberCurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveLocationDetail } from \"./CurveLocationDetail\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\n/* tslint:disable:variable-name no-empty*/\r\n/**\r\n * A LineSegment3d is:\r\n *\r\n * * A 3d line segment represented by its start and end coordinates\r\n *   * startPoint\r\n *   * endPoint\r\n * * The segment is parameterized with fraction 0 at the start and fraction 1 at the end, i.e. either of these equivalent forms to map fraction `f` to a point `X(f)`\r\n *   *  `X(f) = startPoint + f * (endPoint - startPoint)`\r\n *   * `X(f) = (1-f)*startPoint  + f * endPoint`\r\n * @public\r\n */\r\nexport class LineSegment3d extends CurvePrimitive implements BeJSONFunctions {\r\n  /** test if `other` is of class `LineSegment3d` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof LineSegment3d; }\r\n  private _point0: Point3d;\r\n  private _point1: Point3d;\r\n  /** Return REFERENCE to the start point of this segment.\r\n   * * (This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point\r\n   */\r\n  public get point0Ref(): Point3d { return this._point0; }\r\n  /** Return REFERENCE to the end point of this segment.\r\n   * * (This is distinct from the `CurvePrimitive` abstract method `endPoint()` which creates a returned point\r\n   */\r\n  public get point1Ref(): Point3d { return this._point1; }\r\n  /**\r\n   * A LineSegment3d extends along its infinite line.\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return true; }\r\n\r\n  /**\r\n   * CAPTURE point references as a `LineSegment3d`\r\n   * @param point0\r\n   * @param point1\r\n   */\r\n  private constructor(point0: Point3d, point1: Point3d) { super(); this._point0 = point0; this._point1 = point1; }\r\n  /** Set the start and endpoints by capturing input references. */\r\n  public setRefs(point0: Point3d, point1: Point3d) { this._point0 = point0; this._point1 = point1; }\r\n  /** Set the start and endpoints by cloning the input parameters. */\r\n  public set(point0: Point3d, point1: Point3d) { this._point0 = point0.clone(); this._point1 = point1.clone(); }\r\n  /** copy (clone) data from other */\r\n  public setFrom(other: LineSegment3d) { this._point0.setFrom(other._point0); this._point1.setFrom(other._point1); }\r\n  /** Return a (clone of) the start point. (This is NOT a reference to the stored start point) */\r\n  public startPoint(result?: Point3d): Point3d {\r\n    if (result) { result.setFrom(this._point0); return result; }\r\n    return this._point0.clone();\r\n  }\r\n  /** Return a (clone of) the end point. (This is NOT a reference to the stored end point) */\r\n  public endPoint(result?: Point3d): Point3d {\r\n    if (result) { result.setFrom(this._point1); return result; }\r\n    return this._point1.clone();\r\n  }\r\n  /** Return the point and derivative vector at fractional position along the line segment. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    result.direction.setStartEnd(this._point0, this._point1);\r\n    this._point0.interpolate(fraction, this._point1, result.origin);\r\n    return result;\r\n  }\r\n  /** Construct a plane with\r\n   * * origin at the fractional position along the line segment\r\n   * * x axis is the first derivative, i.e. along the line segment\r\n   * * y axis is the second derivative, i.e. 000\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    result = result ? result : Plane3dByOriginAndVectors.createXYPlane();\r\n    result.vectorU.setStartEnd(this._point0, this._point1);\r\n    result.vectorV.set(0, 0, 0);\r\n    this._point0.interpolate(fraction, this._point1, result.origin);\r\n    return result;\r\n  }\r\n\r\n  /** Clone the LineSegment3d */\r\n  public clone(): LineSegment3d { return LineSegment3d.create(this._point0, this._point1); }\r\n  /** Clone and apply transform to the clone. */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n  /** Create with start and end points.  The point contents are cloned into the LineSegment3d. */\r\n  public static create(point0: Point3d, point1: Point3d, result?: LineSegment3d) {\r\n    if (result) {\r\n      result.set(point0, point1);  // and this will clone them !!\r\n      return result;\r\n    }\r\n    return new LineSegment3d(point0.clone(), point1.clone());\r\n  }\r\n  /** create a LineSegment3d from xy coordinates of start and end, with common z.\r\n   * @param x0 start point x coordinate.\r\n   * @param y0 start point y coordinate.\r\n   * @param x1 end point x coordinate.\r\n   * @param y1 end point y coordinate.\r\n   * @param z z coordinate to use for both points.\r\n   * @param result optional existing LineSegment to be reinitialized.\r\n   */\r\n  public static createXYXY(x0: number, y0: number, x1: number, y1: number, z: number = 0, result?: LineSegment3d) {\r\n    if (result) {\r\n      result._point0.set(x0, y0, z);\r\n      result._point1.set(x1, y1, z);\r\n      return result;\r\n    }\r\n    return new LineSegment3d(Point3d.create(x0, y0, z), Point3d.create(x1, y1, z));\r\n  }\r\n\r\n  /** create a LineSegment3d from xy coordinates of start and end, with common z.\r\n   * @param x0 start point x coordinate.\r\n   * @param y0 start point y coordinate.\r\n   * @param x1 end point x coordinate.\r\n   * @param y1 end point y coordinate.\r\n   * @param z z coordinate to use for both points.\r\n   * @param result optional existing LineSegment to be reinitialized.\r\n   */\r\n  public static createXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, result?: LineSegment3d) {\r\n    if (result) {\r\n      result._point0.set(x0, y0, z0);\r\n      result._point1.set(x1, y1, z1);\r\n      return result;\r\n    }\r\n    return new LineSegment3d(Point3d.create(x0, y0, z0), Point3d.create(x1, y1, z1));\r\n  }\r\n\r\n  /** Return the point at fractional position along the line segment. */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d { return this._point0.interpolate(fraction, this._point1, result); }\r\n  /** Return the length of the segment. */\r\n  public curveLength(): number { return this._point0.distance(this._point1); }\r\n  /** Return the length of the partial segment between fractions. */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    return Math.abs(fraction1 - fraction0) * this._point0.distance(this._point1);\r\n  }\r\n  /** Return the length of the segment. */\r\n  public quickLength(): number { return this.curveLength(); }\r\n\r\n  /**\r\n   * Returns a curve location detail with both xyz and fractional coordinates of the closest point.\r\n   * @param spacePoint point in space\r\n   * @param extend if false, only return points within the bounded line segment. If true, allow the point to be on the unbounded line that contains the bounded segment.\r\n   */\r\n  public closestPoint(spacePoint: Point3d, extend: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    let fraction = spacePoint.fractionOfProjectionToLine(this._point0, this._point1, 0.0);\r\n    if (!extend) {\r\n      if (fraction > 1.0)\r\n        fraction = 1.0;\r\n      else if (fraction < 0.0)\r\n        fraction = 0.0;\r\n    }\r\n    result = CurveLocationDetail.create(this, result);\r\n    // remark: This can be done by result.setFP (fraction, thePoint, undefined, a)\r\n    //   but that creates a temporary point.\r\n    result.fraction = fraction;\r\n    this._point0.interpolate(fraction, this._point1, result.point);\r\n    result.vectorInCurveLocationDetail = undefined;\r\n    result.a = result.point.distance(spacePoint);\r\n    return result;\r\n  }\r\n  /** swap the endpoint references. */\r\n  public reverseInPlace(): void {\r\n    const a = this._point0;\r\n    this._point0 = this._point1;\r\n    this._point1 = a;\r\n  }\r\n  /** Transform the two endpoints of this LinSegment. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    this._point0 = transform.multiplyPoint3d(this._point0, this._point0);\r\n    this._point1 = transform.multiplyPoint3d(this._point1, this._point1);\r\n    return true;\r\n  }\r\n  /** Test if both endpoints are in a plane (within tolerance) */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Geometry.isSmallMetricDistance(plane.altitude(this._point0))\r\n      && Geometry.isSmallMetricDistance(plane.altitude(this._point1));\r\n  }\r\n  /** Compute points of simple (transverse) with a plane.\r\n   * * Use isInPlane to test if the linesegment is completely in the plane.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    const h0 = plane.altitude(this._point0);\r\n    const h1 = plane.altitude(this._point1);\r\n    const fraction = Order2Bezier.solveCoffs(h0, h1);\r\n    let numIntersection = 0;\r\n    if (fraction !== undefined) {\r\n      numIntersection++;\r\n      result.push(CurveLocationDetail.createCurveFractionPoint(this, fraction, this.fractionToPoint(fraction)));\r\n    }\r\n    return numIntersection;\r\n  }\r\n  /**\r\n   * Extend a range to include the (optionally transformed) line segment\r\n   * @param range range to extend\r\n   * @param transform optional transform to apply to the end points\r\n   */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    if (transform) {\r\n      range.extendTransformedPoint(transform, this._point0);\r\n      range.extendTransformedPoint(transform, this._point1);\r\n    } else {\r\n      range.extendPoint(this._point0);\r\n      range.extendPoint(this._point1);\r\n    }\r\n  }\r\n  /**\r\n   * Construct a line from either of these json forms:\r\n   *\r\n   * * object with named start and end:\r\n   * `{startPoint: pointValue, endPoint: pointValue}`\r\n   * * array of two point values:\r\n   * `[pointValue, pointValue]`\r\n   * The point values are any values accepted by the Point3d method setFromJSON.\r\n   * @param json data to parse.\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    if (!json) {\r\n      this._point0.set(0, 0, 0);\r\n      this._point1.set(1, 0, 0);\r\n      return;\r\n    } else if (json.startPoint && json.endPoint) { // {startPoint:JSONPOINT, endPoint:JSONPOINT}\r\n      this._point0.setFromJSON(json.startPoint);\r\n      this._point1.setFromJSON(json.endPoint);\r\n    } else if (Array.isArray(json)\r\n      && json.length > 1) { // [JSONPOINT, JSONPOINT]\r\n      this._point0.setFromJSON(json[0]);\r\n      this._point1.setFromJSON(json[1]);\r\n    }\r\n  }\r\n  /** A simple line segment's fraction and distance are proportional. */\r\n  public getFractionToDistanceScale(): number | undefined { return this.curveLength(); }\r\n  /**\r\n   * Place the lineSegment3d start and points in a json object\r\n   * @return {*} [[x,y,z],[x,y,z]]\r\n   */\r\n  public toJSON(): any { return [this._point0.toJSON(), this._point1.toJSON()]; }\r\n  /** Create a new `LineSegment3d` with coordinates from json object.   See `setFromJSON` for object layout description. */\r\n  public static fromJSON(json?: any): LineSegment3d {\r\n    const result = new LineSegment3d(Point3d.createZero(), Point3d.create());\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Near equality test with `other`. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof LineSegment3d) {\r\n      const ls = other as LineSegment3d;\r\n      return this._point0.isAlmostEqual(ls._point0) && this._point1.isAlmostEqual(ls._point1);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const numStroke = this.computeStrokeCountForOptions(options);\r\n    dest.appendFractionalStrokePoints(this, numStroke, 0.0, 1.0);\r\n  }\r\n  /** Emit strokes to caller-supplied handler */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    handler.startCurvePrimitive(this);\r\n    const numStroke = this.computeStrokeCountForOptions(options);\r\n    handler.announceSegmentInterval(this, this._point0, this._point1, numStroke, 0.0, 1.0);\r\n    handler.endCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 1;\r\n    if (options) {\r\n      if (options.maxEdgeLength)\r\n        numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());\r\n      numStroke = options.applyMinStrokesPerPrimitive(numStroke);\r\n    }\r\n    return numStroke;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleLineSegment3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLineSegment3d(this);\r\n  }\r\n\r\n  /**\r\n   * Find intervals of this curve primitive that are interior to a clipper\r\n   * @param clipper clip structure (e.g. clip planes)\r\n   * @param announce function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   */\r\n  public announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    return clipper.announceClippedSegmentIntervals(0.0, 1.0, this._point0, this._point1,\r\n      announce ? (fraction0: number, fraction1: number) => announce(fraction0, fraction1, this) : undefined);\r\n  }\r\n\r\n  /** Return (if possible) a curve primitive which is a portion of this curve.\r\n   * @param fractionA [in] start fraction\r\n   * @param fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined {\r\n    return LineString3d.create(this.fractionToPoint(fractionA), this.fractionToPoint(fractionB));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Curve */\r\nimport { Geometry, AxisOrder, BeJSONFunctions, PlaneAltitudeEvaluator } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { XAndY } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive, AnnounceNumberNumberCurvePrimitive } from \"./CurvePrimitive\";\r\nimport { StrokeCountMap } from \"./Query/StrokeCountMap\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { CurveLocationDetail, CurveSearchStatus, CurveIntervalRole } from \"./CurveLocationDetail\";\r\nimport { Clipper } from \"../clipping/ClipUtils\";\r\nimport { LineSegment3d } from \"./LineSegment3d\";\r\n\r\n/* tslint:disable:variable-name no-empty*/\r\n\r\n/* Starting with baseIndex and moving index by stepDirection:\r\nIf the vector from baseIndex to baseIndex +1 crossed with vectorA can be normalized, accumulate it (scaled) to normal.\r\nReturn when successful.\r\n(Do nothing if everything is parallel through limits of the array)\r\n*/\r\nfunction accumulateGoodUnitPerpendicular(\r\n  points: GrowableXYZArray,\r\n  vectorA: Vector3d,\r\n  baseIndex: number,\r\n  stepDirection: number,\r\n  weight: number,\r\n  normal: Vector3d,\r\n  workVector: Vector3d): boolean {\r\n  const n = points.length;\r\n  if (stepDirection > 0) {\r\n    for (let i = baseIndex; i + 1 < n; i++) {\r\n      points.vectorIndexIndex(i, i + 1, workVector);\r\n      vectorA.crossProduct(workVector, workVector);\r\n      if (workVector.normalizeInPlace()) {\r\n        normal.addScaledInPlace(workVector, weight);\r\n        return true;\r\n      }\r\n    }\r\n  } else {\r\n    if (baseIndex + 1 >= n)\r\n      baseIndex = n - 2;\r\n    for (let i = baseIndex; i >= 0; i--) {\r\n      points.vectorIndexIndex(i, i + 1, workVector);\r\n      workVector.crossProduct(vectorA, workVector);\r\n      if (workVector.normalizeInPlace()) {\r\n        normal.addScaledInPlace(workVector, weight);\r\n        return true;\r\n      }\r\n    }\r\n  }\r\n  return false;\r\n}\r\n/**\r\n * * A LineString3d (sometimes called a PolyLine) is a sequence of xyz coordinates that are to be joined by line segments.\r\n * * The point coordinates are stored in a GrowableXYZArray, not as full point objects\r\n * * The parameterization of \"fraction along\" is\r\n *    * In a linestring with `N` segments (i.e. `N+1` points), each segment (regardless of physical length) occupies the same fraction (1/N) of the 0-to-1 fraction space.\r\n *    * Within segment `i`, the fraction interval `i/N` to `(i+1)/N` is mapped proportionally to the segment\r\n *    * Note that this `fraction` is therefore NOT fraction of true distance along.\r\n *       * Use `moveSignedDistanceFromFraction` to do true-length evaluations.\r\n * @public\r\n */\r\nexport class LineString3d extends CurvePrimitive implements BeJSONFunctions {\r\n  private static _workPointA = Point3d.create();\r\n  private static _workPointB = Point3d.create();\r\n  private static _workPointC = Point3d.create();\r\n  private static _workRay = Ray3d.createXAxis();\r\n  /** test if `other` is an instance of `LineString3d` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof LineString3d; }\r\n  /**\r\n   * A LineString3d extends along its first and final segments.\r\n   */\r\n  public get isExtensibleFractionSpace(): boolean { return true; }\r\n\r\n  private _points: GrowableXYZArray;\r\n  private _fractions?: GrowableFloat64Array;\r\n  private _uvParams?: GrowableXYArray;\r\n  private _derivatives?: GrowableXYZArray;\r\n  private _surfaceNormals?: GrowableXYZArray;\r\n\r\n  private _pointIndices?: GrowableFloat64Array;\r\n  private _uvIndices?: GrowableFloat64Array;\r\n  private _normalIndices?: GrowableFloat64Array;\r\n\r\n  /** return the points array (cloned). */\r\n  public get points(): Point3d[] { return this._points.getPoint3dArray(); }\r\n  /** Return (reference to) point data in packed GrowableXYZArray. */\r\n  public get packedPoints(): GrowableXYZArray { return this._points; }\r\n  /** Return array of fraction parameters.\r\n   * * These Are only present during certain constructions such as faceting.\r\n   * * When present, these fractions are fractions of some other curve being stroked, and are NOT related to the linestring fraction parameters.\r\n   */\r\n  public get fractions(): GrowableFloat64Array | undefined { return this._fractions; }\r\n  /** Return the (optional) array of derivatives. These Are only present during certain constructions such as faceting. */\r\n  public get packedDerivatives(): GrowableXYZArray | undefined { return this._derivatives; }\r\n  /** Return the (optional) array of uv params. These Are only present during certain constructions such as faceting. */\r\n  public get packedUVParams(): GrowableXYArray | undefined { return this._uvParams; }\r\n  /** Return the (optional) array of surface normals. These Are only present during certain constructions such as faceting. */\r\n  public get packedSurfaceNormals(): GrowableXYZArray | undefined { return this._surfaceNormals; }\r\n  /** Return the (optional) array of normal indices. These Are only present during certain constructions such as faceting. */\r\n  public get normalIndices(): GrowableFloat64Array | undefined { return this._normalIndices; }\r\n  /** Return the (optional) array of param indices. These Are only present during certain constructions such as faceting. */\r\n  public get paramIndices(): GrowableFloat64Array | undefined { return this._uvIndices; }\r\n  /** Return the (optional) array of point indices. These Are only present during certain constructions such as faceting. */\r\n  public get pointIndices(): GrowableFloat64Array | undefined { return this._pointIndices; }\r\n\r\n  private constructor() {\r\n    super();\r\n    this._points = new GrowableXYZArray();\r\n  }\r\n  /** Clone this linestring and apply the transform to the clone points. */\r\n  public cloneTransformed(transform: Transform): CurvePrimitive {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n  /** Create a linestring, using flex length arg list and any typical combination of points such as\r\n   * Point3d, Point2d, `[1,2,3]', array of any of those, or GrowableXYZArray\r\n   */\r\n  public static create(...points: any[]): LineString3d {\r\n    const result = new LineString3d();\r\n    result.addPoints(points);\r\n    return result;\r\n  }\r\n  /** Create a linestring from `XAndY` points, with a specified z applied to all. */\r\n  public static createXY(points: XAndY[], z: number, enforceClosure: boolean = false): LineString3d {\r\n    const result = new LineString3d();\r\n    const xyz = result._points;\r\n    for (const xy of points) {\r\n      xyz.pushXYZ(xy.x, xy.y, z);\r\n    }\r\n    if (enforceClosure && points.length > 1) {\r\n      const distance = xyz.distance(0, xyz.length - 1);\r\n      if (distance !== undefined && distance !== 0.0) {\r\n        if (Geometry.isSameCoordinate(0, distance)) {\r\n          xyz.pop();   // nonzero but small distance -- to be replaced by point 0 exactly.\r\n          const xyzA = xyz.front();\r\n          xyz.push(xyzA!);\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Add points to the linestring.\r\n   * Valid inputs are:\r\n   * * a Point2d\r\n   * * a point3d\r\n   * * An array of 2 doubles\r\n   * * An array of 3 doubles\r\n   * * A GrowableXYZArray\r\n   * * An array of any of the above\r\n   */\r\n  public addPoints(...points: any[]) {\r\n    this._points.pushFrom(points);\r\n  }\r\n  /** Add points accessed by index in a GrowableXYZArray, with a specified index step. */\r\n  public addSteppedPoints(source: GrowableXYZArray, pointIndex0: number, step: number, numAdd: number) {\r\n    this._points.addSteppedPoints(source, pointIndex0, step, numAdd);\r\n  }\r\n\r\n  /**\r\n   * Add a point to the linestring.\r\n   * @param point\r\n   */\r\n  public addPoint(point: Point3d) {\r\n    this._points.push(point);\r\n  }\r\n  /**\r\n   * Add a point to the linestring.\r\n   * @param point\r\n   */\r\n  public addPointXYZ(x: number, y: number, z: number = 0) {\r\n    this._points.pushXYZ(x, y, z);\r\n  }\r\n  /**\r\n   * Append a fraction to the fractions array.\r\n   * @param fraction\r\n   */\r\n  public addFraction(fraction: number) {\r\n    if (!this._fractions)\r\n      this._fractions = new GrowableFloat64Array();\r\n    this._fractions.push(fraction);\r\n  }\r\n\r\n  /** Ensure that the fraction array exists with no fractions but at least the capacity of the point array. */\r\n  public ensureEmptyFractions(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._fractions) {\r\n      this._fractions = new GrowableFloat64Array(n);\r\n      return this._fractions;\r\n    }\r\n    this._fractions.clear();\r\n    this._fractions.ensureCapacity(n);\r\n    return this._fractions;\r\n  }\r\n  /** Ensure that the parameter array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyUVParams(): GrowableXYArray {\r\n    const n = this.numPoints();\r\n    if (!this._uvParams) {\r\n      this._uvParams = new GrowableXYArray(n);\r\n      return this._uvParams;\r\n    }\r\n    this._uvParams.clear();\r\n    this._uvParams.ensureCapacity(n);\r\n    return this._uvParams;\r\n  }\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptySurfaceNormals(): GrowableXYZArray {\r\n    const n = this.numPoints();\r\n    if (!this._surfaceNormals) {\r\n      this._surfaceNormals = new GrowableXYZArray(n);\r\n      return this._surfaceNormals;\r\n    }\r\n    this._surfaceNormals.clear();\r\n    this._surfaceNormals.ensureCapacity(n);\r\n    return this._surfaceNormals;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyDerivatives(): GrowableXYZArray {\r\n    const n = this.numPoints();\r\n    if (!this._derivatives) {\r\n      this._derivatives = new GrowableXYZArray(n);\r\n      return this._derivatives;\r\n    }\r\n    this._derivatives.clear();\r\n    this._derivatives.ensureCapacity(n);\r\n    return this._derivatives;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyNormalIndices(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._normalIndices) {\r\n      this._normalIndices = new GrowableFloat64Array(n);\r\n      return this._normalIndices;\r\n    }\r\n    this._normalIndices.clear();\r\n    this._normalIndices.ensureCapacity(n);\r\n    return this._normalIndices;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyUVIndices(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._uvIndices) {\r\n      this._uvIndices = new GrowableFloat64Array(n);\r\n      return this._uvIndices;\r\n    }\r\n    this._uvIndices.clear();\r\n    this._uvIndices.ensureCapacity(n);\r\n    return this._uvIndices;\r\n  }\r\n\r\n  /** Ensure that the surfaceNormals array exists with no points but at least the capacity of the point array. */\r\n  public ensureEmptyPointIndices(): GrowableFloat64Array {\r\n    const n = this.numPoints();\r\n    if (!this._pointIndices) {\r\n      this._pointIndices = new GrowableFloat64Array(n);\r\n      return this._pointIndices;\r\n    }\r\n    this._pointIndices.clear();\r\n    this._pointIndices.ensureCapacity(n);\r\n    return this._pointIndices;\r\n  }\r\n\r\n  /**\r\n   * Append a uv coordinate to the uvParams array\r\n   * @param uv\r\n   */\r\n  public addUVParam(uvParam: XAndY) {\r\n    if (!this._uvParams)\r\n      this._uvParams = new GrowableXYArray();\r\n    this._uvParams.pushXY(uvParam.x, uvParam.y);\r\n  }\r\n\r\n  /**\r\n   * Append a uv coordinate to the uvParams array\r\n   * @param uv\r\n   */\r\n  public addUVParamAsUV(u: number, v: number) {\r\n    if (!this._uvParams)\r\n      this._uvParams = new GrowableXYArray();\r\n    this._uvParams.pushXY(u, v);\r\n  }\r\n\r\n  /**\r\n   * Append a derivative to the derivative array\r\n   * @param vector\r\n   */\r\n  public addDerivative(vector: Vector3d) {\r\n    if (!this._derivatives)\r\n      this._derivatives = new GrowableXYZArray();\r\n    this._derivatives.push(vector);\r\n  }\r\n\r\n  /**\r\n   * Append a surface normal to the surface normal array.\r\n   * @param vector\r\n   */\r\n  public addSurfaceNormal(vector: Vector3d) {\r\n    if (!this._surfaceNormals)\r\n      this._surfaceNormals = new GrowableXYZArray();\r\n    this._surfaceNormals.push(vector);\r\n  }\r\n\r\n  /**\r\n   * If the linestring is not already closed, add a closure point.\r\n   */\r\n  public addClosurePoint() {\r\n    const distance = this._points.distance(0, this._points.length - 1);\r\n    if (distance !== undefined && !Geometry.isSameCoordinate(distance, 0))\r\n      this._points.pushWrap(1);\r\n  }\r\n  /** Eliminate (but do not return!!) the final point of the linestring */\r\n  public popPoint() {\r\n    this._points.pop();\r\n  }\r\n  /** Compute `uvParams` array as (xy parts of) a linear transform of the xyz coordinates */\r\n  public computeUVFromXYZTransform(transform: Transform) {\r\n    this._uvParams = GrowableXYArray.createFromGrowableXYZArray(this._points, transform);\r\n  }\r\n  /** Create the linestring for a rectangle parallel to the xy plane.\r\n   * * The z coordinate from `point0` is used for all points.\r\n   * * `ax` and `ay` are signed.\r\n   * * The point sequence is:\r\n   *    * Start at `point0`\r\n   *    * move by (signed !) `ax` in the x direction.\r\n   *    * move by (signed !) `ay` in the y direction.\r\n   *    * move by (signed !) negative `ax` in the x direction.\r\n   *    * move by (signed !) negative `ay` in the y direction.\r\n   *    * (this returns to `point0`)\r\n   */\r\n  public static createRectangleXY(point0: Point3d, ax: number, ay: number, closed: boolean = true): LineString3d {\r\n    const ls = LineString3d.create();\r\n    const x0 = point0.x;\r\n    const x1 = point0.x + ax;\r\n    const y0 = point0.y;\r\n    const y1 = point0.y + ay;\r\n    const z = point0.z;\r\n    ls.addPointXYZ(x0, y0, z);\r\n    ls.addPointXYZ(x1, y0, z);\r\n    ls.addPointXYZ(x1, y1, z);\r\n    ls.addPointXYZ(x0, y1, z);\r\n    if (closed)\r\n      ls.addClosurePoint();\r\n    return ls;\r\n  }\r\n  /**\r\n   * Create a regular polygon centered\r\n   * @param center center of the polygon.\r\n   * @param edgeCount number of edges.\r\n   * @param radius distance to vertex or edge (see `radiusToVertices`)\r\n   * @param radiusToVertices true if polygon is inscribed in circle (radius measured to vertices); false if polygon is outside circle (radius to edges)\r\n   */\r\n  public static createRegularPolygonXY(center: Point3d, edgeCount: number, radius: number, radiusToVertices: boolean = true): LineString3d {\r\n    if (edgeCount < 3)\r\n      edgeCount = 3;\r\n    const ls = LineString3d.create();\r\n    const i0 = radiusToVertices ? 0 : -1;   // offset to make first vector (radius,0,0)\r\n    const radiansStep = Math.PI / edgeCount;\r\n    let c;\r\n    let s;\r\n    let radians;\r\n    if (!radiusToVertices)\r\n      radius = radius / Math.cos(radiansStep);\r\n    for (let i = 0; i < edgeCount; i++) {\r\n      radians = (i0 + 2 * i) * radiansStep;\r\n      c = Angle.cleanupTrigValue(Math.cos(radians));\r\n      s = Angle.cleanupTrigValue(Math.sin(radians));\r\n      ls.addPointXYZ(center.x + radius * c, center.y + radius * s, center.z);\r\n    }\r\n    ls.addClosurePoint();\r\n    return ls;\r\n  }\r\n\r\n  /**\r\n   * Copy coordinate data from another linestring.\r\n   *  * The copied content is:\r\n   *    * points\r\n   *    * derivatives (if present)\r\n   *    * fractions (if present)\r\n   *    * surfaceNormals (if present)\r\n   *    * uvParams (if present)\r\n   * @param other\r\n   */\r\n  public setFrom(other: LineString3d) {\r\n    // ugly -- \"clone\" methods are inconsistent about 'reuse' and 'result' parameter . . .\r\n    this._points = other._points.clone(this._points);\r\n    if (other._derivatives)\r\n      this._derivatives = other._derivatives.clone(this._derivatives);\r\n    else\r\n      this._derivatives = undefined;\r\n    if (other._fractions)\r\n      this._fractions = other._fractions.clone(false);\r\n    else this._fractions = undefined;\r\n    if (other._surfaceNormals)\r\n      this._surfaceNormals = other._surfaceNormals.clone(this._surfaceNormals);\r\n    else\r\n      this._surfaceNormals = undefined;\r\n    if (other._uvParams)\r\n      this._uvParams = other._uvParams.clone();\r\n    else\r\n      this._uvParams = undefined;\r\n  }\r\n  /** Create a linestring from an array of points. */\r\n  public static createPoints(points: Point3d[]): LineString3d {\r\n    const ls = new LineString3d();\r\n    let point;\r\n    for (point of points)\r\n      ls._points.push(point);\r\n    return ls;\r\n  }\r\n  /** Create a linestring, taking points at specified indices from an array of points. */\r\n  public static createIndexedPoints(points: Point3d[], index: number[], addClosure: boolean = false): LineString3d {\r\n    const ls = new LineString3d();\r\n    for (const i of index)\r\n      ls._points.push(points[i]); // no clone needed -- we know this reformats to packed array.\r\n    if (addClosure && index.length > 1)\r\n      ls._points.push(points[index[0]]);\r\n    return ls;\r\n  }\r\n\r\n  /** Create a LineString3d from xyz coordinates packed in a Float64Array */\r\n  public static createFloat64Array(xyzData: Float64Array): LineString3d {\r\n    const ls = new LineString3d();\r\n    for (let i = 0; i + 3 <= xyzData.length; i += 3)\r\n      ls._points.push(Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));\r\n    return ls;\r\n  }\r\n  /** Return a clone of this linestring. */\r\n  public clone(): LineString3d {\r\n    const retVal = new LineString3d();\r\n    retVal.setFrom(this);\r\n    return retVal;\r\n  }\r\n  /** Set point coordinates from a json array, e.g. `[[1,2,3],[4,5,6] . . .]`\r\n   * * The `json` parameter must be an array.\r\n   * * Each member `i` of the array is converted to a point with `Point3d.fromJSON(json[i]`)\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    this._points.clear();\r\n    if (Array.isArray(json)) {\r\n      let xyz;\r\n      for (xyz of json)\r\n        this._points.push(Point3d.fromJSON(xyz));\r\n    }\r\n  }\r\n  /**\r\n   * Convert an LineString3d to a JSON object.\r\n   * * The returned object is an array of arrays of x,y,z coordinates, `[[x,y,z],...[x,y,z]]`\r\n   */\r\n  public toJSON(): any {\r\n    const value = [];\r\n    let i = 0;\r\n    while (this._points.isIndexValid(i)) {\r\n      value.push(this._points.getPoint3dAtUncheckedPointIndex(i).toJSON());\r\n      i++;\r\n    }\r\n    return value;\r\n  }\r\n  /** construct a new linestring.\r\n   * * See `LineString3d.setFromJSON ()` for remarks on `json` structure.\r\n   */\r\n  public static fromJSON(json?: any): LineString3d {\r\n    const ls = new LineString3d(); ls.setFromJSON(json); return ls;\r\n  }\r\n  /**\r\n   * Evaluate a point a fractional position along this linestring.\r\n   * * See `LineString3d` class comments for description of how fraction relates to the linestring points.\r\n   * @param fraction fractional position\r\n   * @param result optional result\r\n   */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    const n = this._points.length;\r\n    if (n === 0)\r\n      return Point3d.createZero();\r\n    if (n === 1)\r\n      return Point3d.createFrom(this._points.getPoint3dAtUncheckedPointIndex(0), result);\r\n    const df = 1.0 / (n - 1);\r\n    if (fraction <= df)\r\n      return this._points.interpolate(0, fraction / df, 1, result)!;\r\n    if (fraction + df >= 1.0)\r\n      return this._points.interpolate(n - 1, (1.0 - fraction) / df, n - 2, result)!;\r\n    const index0 = Math.floor(fraction / df);\r\n    return this._points.interpolate(index0, (fraction - index0 * df) / df, index0 + 1, result)!;\r\n  }\r\n\r\n  /**\r\n   * Evaluate a point a fractional position and derivative with respect to fraction along this linestring.\r\n   * * See `LineString3d` class comments for description of how fraction relates to the linestring points.\r\n   * @param fraction fractional position\r\n   * @param result optional result\r\n   */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const n = this._points.length;\r\n    if (n <= 1) {\r\n      result.direction.setZero();\r\n      if (n === 1)\r\n        result.origin.setFrom(this._points.getPoint3dAtUncheckedPointIndex(0));\r\n      else result.origin.setZero();\r\n      return result;\r\n    }\r\n    const numSegment = n - 1;\r\n    const df = 1.0 / numSegment;\r\n    if (fraction <= df) {\r\n      result = result ? result : Ray3d.createZero();\r\n      this._points.interpolate(0, fraction / df, 1, result.origin);\r\n      this._points.vectorIndexIndex(0, 1, result.direction);\r\n      result.direction.scaleInPlace(1.0 / df);\r\n      return result;\r\n    }\r\n\r\n    if (fraction + df >= 1.0) {\r\n      result = result ? result : Ray3d.createZero();\r\n      this._points.interpolate(n - 2, 1.0 - (1.0 - fraction) / df, n - 1, result.origin);\r\n      this._points.vectorIndexIndex(n - 2, n - 1, result.direction);\r\n      result.direction.scaleInPlace(1.0 / df);\r\n      return result;\r\n    }\r\n\r\n    /* true interior point */\r\n    result = result ? result : Ray3d.createZero();\r\n    const index0 = Math.floor(fraction / df);\r\n    const localFraction = (fraction - index0 * df) / df;\r\n    this._points.interpolate(index0, localFraction, index0 + 1, result.origin);\r\n    this._points.vectorIndexIndex(index0, index0 + 1, result.direction);\r\n    result.direction.scaleInPlace(1.0 / df);\r\n    return result;\r\n  }\r\n\r\n  /** Return point and derivative at fraction, with 000 second derivative. */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const ray = this.fractionToPointAndDerivative(fraction);\r\n    result = Plane3dByOriginAndVectors.createCapture(ray.origin, ray.direction, Vector3d.createZero(), result);\r\n    return result;\r\n  }\r\n  /**\r\n   * Convert a segment index and local fraction to a global fraction.\r\n   * @param index index of segment being evaluated\r\n   * @param localFraction local fraction within that segment\r\n   */\r\n  public segmentIndexAndLocalFractionToGlobalFraction(index: number, localFraction: number): number {\r\n    const numSegment = this._points.length - 1;\r\n    if (numSegment < 1)\r\n      return 0.0;\r\n    return (index + localFraction) / numSegment;\r\n  }\r\n  /** Return a frenet frame, using nearby points to estimate a plane. */\r\n  public fractionToFrenetFrame(fraction: number, result?: Transform): Transform {\r\n    const n = this._points.length;\r\n    if (n <= 1) {\r\n      if (n === 1)\r\n        return Transform.createTranslation(this._points.getPoint3dAtUncheckedPointIndex(0), result);\r\n      return Transform.createIdentity(result);\r\n    }\r\n\r\n    if (n === 2)\r\n      return Transform.createRefs(\r\n        this._points.interpolate(0, fraction, 1)!,\r\n        Matrix3d.createRigidHeadsUp(this._points.vectorIndexIndex(0, 1)!, AxisOrder.XYZ));\r\n\r\n    /** 3 or more points. */\r\n    const numSegment = n - 1;\r\n    const df = 1.0 / numSegment;\r\n    let baseIndex = 0;\r\n    let localFraction = 0;\r\n    if (fraction <= df) {\r\n      localFraction = fraction / df;\r\n      baseIndex = 0;\r\n    } else if (fraction + df >= 1.0) {\r\n      baseIndex = n - 2;\r\n      localFraction = 1.0 - (1.0 - fraction) / df;\r\n    } else {\r\n      baseIndex = Math.floor(fraction / df);\r\n      localFraction = fraction * numSegment - baseIndex;\r\n    }\r\n\r\n    const origin = this._points.interpolate(baseIndex, localFraction, baseIndex + 1)!;\r\n    const vectorA = this._points.vectorIndexIndex(baseIndex, baseIndex + 1)!;\r\n    // tricky stuff to handle colinear points.   But if vectorA is zero it is still a mess . ..\r\n    const normal = Vector3d.create();\r\n    const workVector = Vector3d.create();\r\n    if (baseIndex === 0) {  // only look forward\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, 1.0, normal, workVector);\r\n    } else if (baseIndex + 2 >= n) { // only look back\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, 1.0, normal, workVector);\r\n    } else {\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex - 1, -1, (1.0 - localFraction), normal, workVector);\r\n      accumulateGoodUnitPerpendicular(this._points, vectorA, baseIndex + 1, 1, (localFraction), normal, workVector);\r\n    }\r\n    const matrix = Matrix3d.createRigidFromColumns(normal, vectorA, AxisOrder.ZXY);\r\n    if (matrix)\r\n      return Transform.createOriginAndMatrix(origin, matrix, result);\r\n    return Transform.createTranslation(origin, result);\r\n  }\r\n  /** evaluate the start point of the linestring. */\r\n  public startPoint() {\r\n    if (this._points.length === 0)\r\n      return Point3d.createZero();\r\n    return this._points.getPoint3dAtUncheckedPointIndex(0);\r\n  }\r\n  /** If i is a valid index, return that point. */\r\n  public pointAt(i: number, result?: Point3d): Point3d | undefined {\r\n    if (this._points.isIndexValid(i))\r\n      return this._points.getPoint3dAtUncheckedPointIndex(i, result);\r\n    return undefined;\r\n  }\r\n  /** If i and j are both valid indices, return the vector from point i to point j\r\n   */\r\n  public vectorBetween(i: number, j: number, result?: Vector3d): Vector3d | undefined {\r\n    return this._points.vectorIndexIndex(i, j, result);\r\n  }\r\n  /** If i is a valid index, return that stored derivative vector. */\r\n  public derivativeAt(i: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this._derivatives && this._derivatives.isIndexValid(i))\r\n      return this._derivatives.getVector3dAtCheckedVectorIndex(i, result);\r\n    return undefined;\r\n  }\r\n\r\n  /** If i is a valid index, return that stored surfaceNormal vector. */\r\n  public surfaceNormalAt(i: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this._surfaceNormals && this._surfaceNormals.isIndexValid(i))\r\n      return this._surfaceNormals.getVector3dAtCheckedVectorIndex(i, result);\r\n    return undefined;\r\n  }\r\n  /** Return the number of points in this linestring. */\r\n  public numPoints(): number { return this._points.length; }\r\n  /** evaluate the end point of the linestring. */\r\n  public endPoint() {\r\n    if (this._points.length === 0)\r\n      return Point3d.createZero();\r\n    return this._points.getPoint3dAtUncheckedPointIndex(this._points.length - 1);\r\n  }\r\n  /** Reverse the points within the linestring. */\r\n  public reverseInPlace(): void {\r\n    if (this._points.length >= 2) {\r\n      let i0 = 0;\r\n      let i1 = this._points.length - 1;\r\n      let a: Point3d = this._points.getPoint3dAtUncheckedPointIndex(0);\r\n      while (i0 < i1) {\r\n        a = this._points.getPoint3dAtUncheckedPointIndex(i0);\r\n        this._points.setAtCheckedPointIndex(i0, this._points.getPoint3dAtUncheckedPointIndex(i1));\r\n        this._points.setAtCheckedPointIndex(i1, a);\r\n        i0++;\r\n        i1--;\r\n      }\r\n    }\r\n  }\r\n  /** Apply `transform` to each point of this linestring. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    this._points.multiplyTransformInPlace(transform);\r\n    if (this._derivatives)\r\n      this._derivatives.multiplyMatrix3dInPlace(transform.matrix);\r\n    if (this._surfaceNormals)\r\n      this._surfaceNormals.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);\r\n    return true;\r\n  }\r\n\r\n  /** Sum the lengths of segments within the linestring */\r\n  public curveLength(): number { return this._points.sumLengths(); }\r\n  /** Sum the lengths of segments between fractional positions on a linestring. */\r\n  public curveLengthBetweenFractions(fraction0: number, fraction1: number): number {\r\n    const numSegments = this._points.length - 1;\r\n    if (fraction1 === fraction0 || numSegments < 1)\r\n      return 0.0;\r\n    if (fraction1 < fraction0)\r\n      return this.curveLengthBetweenFractions(fraction1, fraction0);\r\n    const scaledFraction0 = fraction0 * numSegments;\r\n    const scaledFraction1 = fraction1 * numSegments;\r\n    const index0 = Math.max(1, Math.ceil(scaledFraction0));\r\n    const index1 = Math.min(Math.floor(scaledFraction1), numSegments - 1);\r\n    const localFraction0 = index0 - scaledFraction0;\r\n    const localFraction1 = scaledFraction1 - index1;\r\n    if (index0 > index1) {\r\n      // the interval is entirely within a single segment\r\n      return Math.abs(scaledFraction1 - scaledFraction0) * this._points.distance(index0 - 1, index0)!;\r\n    } else {\r\n      // there is leading partial interval, 0 or more complete segments, and a trailing partial interval.\r\n      // (either or both partial may be zero length)\r\n      let sum = localFraction0 * this._points.distance(index0 - 1, index0)!\r\n        + localFraction1 * (this._points.distance(index1, index1 + 1))!;\r\n      for (let i = index0; i < index1; i++)\r\n        sum += this._points.distance(i, i + 1)!;\r\n      return sum;\r\n    }\r\n  }\r\n  /**\r\n   * * Implementation of `CurvePrimitive.moveSignedDistanceFromFraction`.  (see comments there!)\r\n   * * Find the segment that contains the start fraction\r\n   * * Move point-by-point from that position to the start or end (respectively for negative or positive signedDistance)\r\n   * * Optionally extrapolate\r\n   * @param startFraction\r\n   * @param signedDistance\r\n   * @param allowExtension\r\n   * @param result\r\n   */\r\n  public moveSignedDistanceFromFraction(startFraction: number, signedDistance: number, allowExtension: false, result?: CurveLocationDetail): CurveLocationDetail {\r\n    const numSegments = this._points.length - 1;\r\n    const scaledFraction = startFraction * numSegments;\r\n    let leftPointIndex = Geometry.restrictToInterval(Math.floor(scaledFraction), 0, numSegments - 1);  // lower point index on active segment.\r\n    const localFraction = scaledFraction - leftPointIndex;\r\n    const point0 = this._points.interpolate(leftPointIndex, localFraction, leftPointIndex + 1, LineString3d._workPointA)!;\r\n    const point1 = LineString3d._workPointB;\r\n    const context = new MoveByDistanceContext(point0, startFraction, signedDistance);\r\n\r\n    if (signedDistance > 0.0) {\r\n      for (; leftPointIndex <= numSegments;) {\r\n        leftPointIndex++;\r\n        this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);\r\n        if (context.announcePoint(point1, leftPointIndex / numSegments))\r\n          return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n            signedDistance, CurveSearchStatus.success, result);\r\n      }\r\n      // fall through for extrapolation from final segment\r\n      if (allowExtension)\r\n        context.announceExtrapolation(this._points, numSegments - 1, numSegments,\r\n          (numSegments - 1) / numSegments, 1.0);\r\n      return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n        signedDistance, context.distanceStatus(), result);\r\n    } else { // (moving backwards)\r\n      if (localFraction <= 0.0)\r\n        leftPointIndex--;\r\n      for (; leftPointIndex >= 0; leftPointIndex--) {\r\n        this._points.getPoint3dAtCheckedPointIndex(leftPointIndex, point1);\r\n        if (context.announcePoint(point1, leftPointIndex / numSegments))\r\n          return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n            signedDistance, CurveSearchStatus.success, result);\r\n      }\r\n      // fall through for backward extrapolation from initial segment\r\n      if (allowExtension)\r\n        context.announceExtrapolation(this._points, 1, 0, 1.0 / numSegments, 0.0);\r\n      return CurveLocationDetail.createCurveFractionPointDistanceCurveSearchStatus(this, context.fraction0, context.point0,\r\n        -context.distance0, context.distanceStatus(), result);\r\n    }\r\n  }\r\n\r\n  /** sum lengths of segments in the linestring.  (This is a true length.) */\r\n  public quickLength(): number { return this.curveLength(); }\r\n  /**\r\n   * compute and normalize cross product among 3 points on the linestring.\r\n   * * \"any\" 3 points are acceptable -- no test for positive overall sense.\r\n   * * This is appropriate for polygon known to be convex.\r\n   * * use points spread at index step n/3, hopefully avoiding colinear points.\r\n   * * If that fails, try points 012\r\n   * @param result computed normal.\r\n   */\r\n  public quickUnitNormal(result?: Vector3d): Vector3d | undefined {\r\n    let step = Math.floor(this._points.length / 3);\r\n    if (step < 1)\r\n      step = 1;\r\n    result = this._points.crossProductIndexIndexIndex(0, step, step + step);\r\n    if (result && result.normalizeInPlace())\r\n      return result;\r\n    return undefined;\r\n  }\r\n\r\n  /** Find the point on the linestring (including its segment interiors) that is closest to spacePoint. */\r\n  public closestPoint(spacePoint: Point3d, extend: boolean, result?: CurveLocationDetail): CurveLocationDetail {\r\n    result = CurveLocationDetail.create(this, result);\r\n\r\n    const numPoints = this._points.length;\r\n    if (numPoints > 0) {\r\n      const lastIndex = numPoints - 1;\r\n      result.setFP(1.0, this._points.getPoint3dAtUncheckedPointIndex(lastIndex), undefined);\r\n      result.setDistanceTo(spacePoint);\r\n      if (numPoints > 1) {\r\n        let segmentFraction = 0;\r\n        let d = 0;\r\n        const df = 1.0 / lastIndex;\r\n        for (let i = 1; i < numPoints; i++) {\r\n          segmentFraction = spacePoint.fractionOfProjectionToLine(this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i));\r\n          if (segmentFraction < 0) {\r\n            if (!extend || i > 1)\r\n              segmentFraction = 0.0;\r\n          } else if (segmentFraction > 1.0) {\r\n            if (!extend || i < lastIndex)\r\n              segmentFraction = 1.0;\r\n          }\r\n          this._points.getPoint3dAtUncheckedPointIndex(i - 1).interpolate(segmentFraction, this._points.getPoint3dAtUncheckedPointIndex(i), result.pointQ);\r\n          d = result.pointQ.distance(spacePoint);\r\n          if (d < result.a) {\r\n            result.setFP((i - 1 + segmentFraction) * df, result.pointQ, undefined, d);\r\n          }\r\n        }\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Test if all points of the linestring are in a plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return this._points.isCloseToPlane(plane, Geometry.smallMetricDistance);\r\n  }\r\n\r\n  /** push a hit, fixing up the prior entry if needed.\r\n   * return the incremented counter.\r\n   */\r\n  private static pushVertexHit(result: CurveLocationDetail[], counter: number, cp: CurvePrimitive, fraction: number, point: Point3d) {\r\n    const detail = CurveLocationDetail.createCurveFractionPoint(cp, fraction, point);\r\n    result.push(detail);\r\n    if (counter === 0) {\r\n      detail.setIntervalRole(CurveIntervalRole.isolatedAtVertex);\r\n    } else if (counter === 1) {  // last entry must be isolatedAtVertex !!!\r\n      result[result.length - 2].setIntervalRole(CurveIntervalRole.intervalStart);\r\n      detail.setIntervalRole(CurveIntervalRole.intervalEnd);\r\n    } else {\r\n      result[result.length - 2].setIntervalRole(CurveIntervalRole.intervalInterior);\r\n      detail.setIntervalRole(CurveIntervalRole.intervalEnd);\r\n    }\r\n  }\r\n  /** find intersections with a plane.\r\n   *  Intersections within segments are recorded as CurveIntervalRole.isolated\r\n   *   Intersections at isolated \"on\" vertex are recoded as CurveIntervalRole.isolatedAtVertex.\r\n   */\r\n  public appendPlaneIntersectionPoints(plane: PlaneAltitudeEvaluator, result: CurveLocationDetail[]): number {\r\n    if (this._points.length < 1) return 0;\r\n    const initialLength = result.length;\r\n    const n = this._points.length;\r\n    const divisor = n === 1 ? 1.0 : n - 1;\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n    const pointC = LineString3d._workPointC;\r\n    this._points.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n    let hB = 0;\r\n    let numConsecutiveZero = 0;\r\n    let hA = 0;\r\n    let segmentFraction = 0;\r\n    for (let i = 0; i < this._points.length; i++ , pointA.setFrom(pointB), hA = hB) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n      hB = Geometry.correctSmallMetricDistance(plane.altitude(pointB));\r\n      if (hB === 0.0)\r\n        LineString3d.pushVertexHit(result, numConsecutiveZero++, this, i / divisor, pointB);\r\n      else {\r\n        if (hA * hB < 0.0) {  // at point0, hA=0 will keep us out of here . ..\r\n          segmentFraction = hA / (hA - hB); // this division is safe because the signs are different.\r\n          pointA.interpolate(segmentFraction, pointB, pointC);\r\n          const detail = CurveLocationDetail.createCurveFractionPoint(this, (i - 1 + segmentFraction) / divisor, pointC);\r\n          detail.setIntervalRole(CurveIntervalRole.isolated);\r\n          result.push(detail);\r\n          numConsecutiveZero = 0;\r\n        }\r\n      }\r\n    }\r\n    return result.length - initialLength;\r\n  }\r\n  /** Extend `rangeToExtend` to include all points of this linestring. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void { this._points.extendRange(rangeToExtend, transform); }\r\n  /** Test if each point of this linestring isAlmostEqual with corresponding point in `other`. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (!(other instanceof LineString3d))\r\n      return false;\r\n    if (!GrowableXYZArray.isAlmostEqual(this._points, other._points)) return false;\r\n    return true;\r\n  }\r\n  /** Append (clone of) one point.\r\n   * * BUT ... skip if duplicates the tail of prior points.\r\n   * * if fraction is given, \"duplicate\" considers both point and fraction.\r\n   */\r\n  public appendStrokePoint(point: Point3d, fraction?: number) {\r\n    const n = this._points.length;\r\n    let add = true;\r\n    const addFraction = fraction !== undefined && this._fractions !== undefined;\r\n    if (n > 0) {\r\n      if (addFraction && Geometry.isSameCoordinate(fraction!, this._fractions!.back()))\r\n        add = false;\r\n      if (point.isAlmostEqual(this._points.getPoint3dAtUncheckedPointIndex(n - 1)))\r\n        add = false;\r\n    }\r\n\r\n    if (add) {\r\n      this._points.push(point);\r\n      if (addFraction)\r\n        this.addFraction(fraction!);\r\n    }\r\n\r\n  }\r\n\r\n  /** Append a suitable evaluation of a curve ..\r\n   * * always append the curve point\r\n   * * if fraction array is present, append the fraction\r\n   * * if derivative array is present, append the derivative\r\n   * BUT ... skip if duplicates the tail of prior points.\r\n   */\r\n  public appendFractionToPoint(curve: CurvePrimitive, fraction: number) {\r\n    if (this._derivatives) {\r\n      const ray = curve.fractionToPointAndDerivative(fraction, LineString3d._workRay);\r\n      if (this._fractions)\r\n        this._fractions.push(fraction);\r\n      this._points.push(ray.origin);\r\n      if (this._derivatives)\r\n        this._derivatives.push(ray.direction);\r\n\r\n    } else {\r\n      const point = curve.fractionToPoint(fraction, LineString3d._workPointA);\r\n      if (this._fractions)\r\n        this._fractions.push(fraction);\r\n      this._points.push(point);\r\n    }\r\n  }\r\n  /**\r\n   * clear all array data:\r\n   * * points\r\n   * * optional fractions.\r\n   * * optional derivatives.\r\n   */\r\n  public clear() {\r\n    this._points.clear();\r\n    if (this._fractions)\r\n      this._fractions.clear();\r\n    if (this._derivatives)\r\n      this._derivatives.clear();\r\n  }\r\n  /**\r\n   * * options.needParams triggers creation of fraction array and uvParams array.\r\n   * * options.needNormals triggers creation of derivatives array\r\n   * @param capacity if positive, initial capacity of arrays\r\n   * @param options  optional, to indicate if fraction and derivative arrays are required.\r\n   */\r\n  public static createForStrokes(capacity: number = 0, options: StrokeOptions | undefined): LineString3d {\r\n    const ls = LineString3d.create();\r\n    if (capacity > 0)\r\n      ls._points.ensureCapacity(capacity);\r\n    if (options) {\r\n      if (options.needParams) {\r\n        ls._fractions = new GrowableFloat64Array(capacity);\r\n        ls._uvParams = new GrowableXYArray(capacity);\r\n      }\r\n      if (options.needNormals) {\r\n        ls._derivatives = new GrowableXYZArray(capacity);\r\n        ls._surfaceNormals = new GrowableXYZArray(capacity);\r\n      }\r\n    }\r\n    return ls;\r\n  }\r\n\r\n  /** Evaluate a curve at uniform fractions.  Append the evaluations to this linestring.\r\n   * @param curve primitive to evaluate.\r\n   * @param numStrokes number of strokes (edges).\r\n   * @param fraction0 starting fraction coordinate\r\n   * @param fraction1 end fraction coordinate\r\n   * @param include01 if false, points at fraction0 and fraction1 are omitted.\r\n   */\r\n  public appendFractionalStrokePoints(\r\n    curve: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number = 0,\r\n    fraction1: number = 1,\r\n    include01: boolean = true): void {\r\n    let i0 = 1;\r\n    let i1 = numStrokes - 1;\r\n    if (include01) {\r\n      i0 = 0;\r\n      i1 = numStrokes;\r\n    }\r\n    if (numStrokes >= 1) {\r\n      const df = (fraction1 - fraction0) / numStrokes;\r\n      for (let i = i0; i <= i1; i++)\r\n        this.appendFractionToPoint(curve, fraction0 + i * df);\r\n    }\r\n  }\r\n\r\n  /** Append points constructed as interpolation between two points.\r\n   * @param numStrokes number of strokes.\r\n   * @param point0 first point\r\n   * @param point1 last point\r\n   * @param include01 if false, OMIT both start and end points (i.e. only compute and add true interior points)\r\n   */\r\n  public appendInterpolatedStrokePoints(numStrokes: number, point0: Point3d, point1: Point3d, include01: boolean): void {\r\n    if (include01)\r\n      this.appendStrokePoint(point0, 0.0);\r\n    if (numStrokes > 1) {\r\n      const df = 1.0 / numStrokes;\r\n      for (let i = 1; i < numStrokes; i++) {\r\n        const f = i * df;\r\n        this.appendStrokePoint(point0.interpolate(f, point1), f);\r\n      }\r\n    }\r\n    if (include01)\r\n      this.appendStrokePoint(point1, 1.0);\r\n  }\r\n\r\n  /** Emit strokes to caller-supplied linestring */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void {\r\n    const n = this._points.length;\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n\r\n    if (n > 0) {\r\n      // This is a linestring.\r\n      // There is no need for chordTol and angleTol within a segment.\r\n      // Do NOT apply minstrokes per primitive.\r\n      if (options && options.hasMaxEdgeLength) {\r\n        dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(0));\r\n        for (let i = 1; i < n; i++) {\r\n          this._points.getPoint3dAtUncheckedPointIndex(i - 1, pointA);\r\n          this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n          const numStroke = options.applyMaxEdgeLength(1, pointA.distance(pointB));\r\n          if (numStroke > 1)\r\n            dest.appendInterpolatedStrokePoints(numStroke, pointA, pointB, false);\r\n          dest.appendStrokePoint(pointB);\r\n        }\r\n      } else {\r\n        for (let i = 0; i < n; i++) {\r\n          dest.appendStrokePoint(this._points.getPoint3dAtUncheckedPointIndex(i));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Emit strokable parts of the curve to a caller-supplied handler.\r\n   * If the stroke options does not have a maxEdgeLength, one stroke is emitted for each segment of the linestring.\r\n   * If the stroke options has a maxEdgeLength, smaller segments are emitted as needed.\r\n   */\r\n  public emitStrokableParts(handler: IStrokeHandler, options?: StrokeOptions): void {\r\n    const n = this._points.length;\r\n    handler.startCurvePrimitive(this);\r\n    if (n > 1) {\r\n      const df = 1.0 / (n - 1);\r\n      // This is a linestring.\r\n      // There is no need for chordTol and angleTol within a segment.\r\n      // Do NOT apply minstrokes per primitive.\r\n      if (options && options.hasMaxEdgeLength) {\r\n        for (let i = 1; i < n; i++) {\r\n          const numStroke = options.applyMaxEdgeLength(1, this._points.getPoint3dAtUncheckedPointIndex(i - 1).distance(this._points.getPoint3dAtUncheckedPointIndex(i)));\r\n          handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), numStroke, (i - 1) * df, i * df);\r\n        }\r\n      } else {\r\n        for (let i = 1; i < n; i++) {\r\n          handler.announceSegmentInterval(this, this._points.getPoint3dAtUncheckedPointIndex(i - 1), this._points.getPoint3dAtUncheckedPointIndex(i), 1, (i - 1) * df, i * df);\r\n        }\r\n      }\r\n    }\r\n    handler.endCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    const numPoints = this._points.length;\r\n    let numStroke = numPoints - 1;\r\n\r\n    if (options && options.hasMaxEdgeLength) {\r\n      numStroke = 0;\r\n      for (let i = 1; i < numPoints; i++) {\r\n        numStroke += options.applyMaxEdgeLength(1, this._points.distance(i - 1, i)!);\r\n      }\r\n    }\r\n    return numStroke;\r\n  }\r\n  /**\r\n   * Compute individual segment stroke counts.  Attach in a StrokeCountMap.\r\n   * @param options StrokeOptions that determine count\r\n   * @param parentStrokeMap evolving parent map.\r\n   */\r\n  public computeAndAttachRecursiveStrokeCounts(options?: StrokeOptions, parentStrokeMap?: StrokeCountMap) {\r\n    const numPoints = this._points.length;\r\n    const applyOptions = options !== undefined && options.hasMaxEdgeLength;\r\n    const myData = StrokeCountMap.createWithCurvePrimitiveAndOptionalParent(this, parentStrokeMap, []);\r\n    for (let i = 1; i < numPoints; i++) {\r\n      const segmentLength = this._points.distance(i - 1, i)!;\r\n      const numStrokeOnSegment = applyOptions ? options!.applyMaxEdgeLength(1, segmentLength)! : 1;\r\n      myData.addToCountAndLength(numStrokeOnSegment, segmentLength);\r\n    }\r\n    CurvePrimitive.installStrokeCountMap(this, myData, parentStrokeMap);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleLineString3d(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLineString3d(this);\r\n  }\r\n  // HARD TO TEST -- tests that get to announceClipInterval for arc, bspline do NOT get here with\r\n  // linestring because the controller has special case loops through segments?\r\n  /**\r\n   * Find intervals of this curveprimitve that are interior to a clipper\r\n   * @param clipper clip structure (e.g. clip planes)\r\n   * @param announce (optional) function to be called announcing fractional intervals\"  ` announce(fraction0, fraction1, curvePrimitive)`\r\n   * @returns true if any \"in\" segments are announced.\r\n   */\r\n  public announceClipIntervals(clipper: Clipper, announce?: AnnounceNumberNumberCurvePrimitive): boolean {\r\n    const n = this._points.length;\r\n    if (n < 2) return false;\r\n    let globalFractionA = 0.0;\r\n    let globalFractionB = 1.0;\r\n    const capture = (localFraction0: number, localFraction1: number) => {\r\n      if (announce)\r\n        announce(\r\n          Geometry.interpolate(globalFractionA, localFraction0, globalFractionB),\r\n          Geometry.interpolate(globalFractionA, localFraction1, globalFractionB),\r\n          this);\r\n    };\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n    this._points.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n    let status = false;\r\n    for (let i = 1; i < n; i++ , pointA.setFrom(pointB), globalFractionA = globalFractionB) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(i, pointB);\r\n      globalFractionB = i / (n - 1);\r\n      if (clipper.announceClippedSegmentIntervals(0.0, 1.0, pointA, pointB, capture))\r\n        status = true;\r\n    }\r\n    return status;\r\n  }\r\n  private static _indexPoint = Point3d.create();  // private point for indexAndFractionToPoint.\r\n  private addResolvedPoint(index: number, fraction: number, dest: GrowableXYZArray) {\r\n    const n = this._points.length;\r\n    if (n === 0) return;\r\n    if (n === 1) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(0, LineString3d._indexPoint);\r\n      dest.push(LineString3d._indexPoint);\r\n      return;\r\n    }\r\n    if (index < 0)\r\n      index = 0;\r\n    if (index >= n) {\r\n      index = n - 1;\r\n      fraction += 1;\r\n    }\r\n    this._points.interpolate(index, fraction, index + 1, LineString3d._indexPoint);\r\n    dest.push(LineString3d._indexPoint);\r\n  }\r\n  /** Return (if possible) a LineString which is a portion of this curve.\r\n   * * This implementation does NOT extrapolate the linestring -- fractions are capped at 0 and 1.\r\n   * @param fractionA [in] start fraction\r\n   * @param fractionB [in] end fraction\r\n   */\r\n  public clonePartialCurve(fractionA: number, fractionB: number): CurvePrimitive | undefined {\r\n    if (fractionB < fractionA) {\r\n      const linestringA = this.clonePartialCurve(fractionB, fractionA);\r\n      if (linestringA)\r\n        linestringA.reverseInPlace();\r\n      return linestringA;\r\n    }\r\n    const n = this._points.length;\r\n    const numEdge = n - 1;\r\n    if (n < 2 || fractionA >= 1.0 || fractionB <= 0.0)\r\n      return undefined;\r\n    if (fractionA < 0)\r\n      fractionA = 0;\r\n    if (fractionB > 1)\r\n      fractionB = 1;\r\n    const gA = fractionA * numEdge;\r\n    const gB = fractionB * numEdge;\r\n    const indexA = Math.floor(gA);\r\n    const indexB = Math.floor(gB);\r\n    const localFractionA = gA - indexA;\r\n    const localFractionB = gB - indexB;\r\n    const result = LineString3d.create();\r\n    this.addResolvedPoint(indexA, localFractionA, result._points);\r\n    for (let index = indexA + 1; index <= indexB; index++) {\r\n      this._points.getPoint3dAtUncheckedPointIndex(index, LineString3d._workPointA);\r\n      result._points.push(LineString3d._workPointA);\r\n    }\r\n    if (!Geometry.isSmallRelative(localFractionB)) {\r\n      this.addResolvedPoint(indexB, localFractionB, result._points);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return (if possible) a specific segment of the linestring */\r\n  public getIndexedSegment(index: number): LineSegment3d | undefined {\r\n    if (index >= 0 && index + 1 < this._points.length)\r\n      return LineSegment3d.create(this._points.getPoint3dAtCheckedPointIndex(index)!, this._points.getPoint3dAtCheckedPointIndex(index + 1)!);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Returns true if first and last points are within metric tolerance.\r\n   */\r\n  public get isPhysicallyClosed(): boolean {\r\n    return this._points.length > 0 && Geometry.isSmallMetricDistance(this._points.distance(0, this._points.length - 1)!);\r\n  }\r\n\r\n  /**\r\n   * evaluate strokes at fractions indicated in a StrokeCountMap.\r\n   * * The map must have an array of component counts corresponding to the segment of this linestring.\r\n   * * \"fractions\" in the output are mapped within a0,a1 of the map.componentData\r\n   * @param map = stroke count data.\r\n   * @param destLinestring = receiver linestring.\r\n   * @return number of strokes added.  0 if `map.componentData` does not match the linestring\r\n   */\r\n  public addMappedStrokesToLineString3D(map: StrokeCountMap, destLinestring: LineString3d): number {\r\n    const numPoint0 = destLinestring.numPoints();\r\n    const needFractions = destLinestring._fractions !== undefined;\r\n    const needDerivatives = destLinestring._derivatives !== undefined;\r\n    const points = this._points;\r\n    const pointA = LineString3d._workPointA;\r\n    const pointB = LineString3d._workPointB;\r\n    const pointC = LineString3d._workPointC;\r\n    const numParentPoint = points.length;\r\n    if (map.primitive && map.primitive === this && map.componentData && map.componentData.length + 1 === numParentPoint) {\r\n      points.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n      for (let k = 0; k + 1 < numParentPoint; k++ , pointA.setFromPoint3d(pointB)) {\r\n        points.getPoint3dAtUncheckedPointIndex(k + 1, pointB);\r\n        const segmentMap = map.componentData![k];\r\n        const m = segmentMap.numStroke;\r\n        const vectorAB = pointA.vectorTo(pointB);\r\n        vectorAB.scale(m);\r\n        for (let i = 0; i <= m; i++) {\r\n          const fraction = i / m;\r\n          const outputFraction = segmentMap.fractionToA(fraction);\r\n          destLinestring.addPoint(pointA.interpolate(fraction, pointB, pointC));\r\n          if (needFractions)\r\n            destLinestring._fractions!.push((outputFraction));\r\n          if (needDerivatives)\r\n            destLinestring._derivatives!.push(vectorAB);\r\n\r\n        }\r\n      }\r\n    }\r\n    return destLinestring.numPoints() - numPoint0;\r\n  }\r\n}\r\n/** An AnnotatedLineString3d is a linestring with additional surface-related data attached to each point\r\n * * This is useful in facet construction.\r\n * @internal\r\n */\r\nexport class AnnotatedLineString3d {\r\n  /** parameter along curve being faceted.  */\r\n  public curveParam?: GrowableFloat64Array;\r\n  /** uv parameters, stored as uvw with the w possibly used for distinguishing among multiple \"faces\". */\r\n  public uvwParam?: GrowableXYZArray;\r\n  /** u direction tangent vectors from surface being faceted. */\r\n  public vectorU?: GrowableXYZArray;\r\n  /** v direction tangent vectors from surface being faceted. */\r\n  public vectorV?: GrowableXYZArray;\r\n}\r\n/**\r\n * context to be called to incrementally accumulate distance along line segments.\r\n */\r\nclass MoveByDistanceContext {\r\n  public distance0: number;   // accumulated distance through point0\r\n  public point0: Point3d;      // most recent point\r\n  public fraction0: number;   // most recent fraction position\r\n  public targetDistance: number;  // this is always positive.\r\n  /** CAPTURE point0, fraction0, targetDistance */\r\n  public constructor(point0: Point3d, fraction0: number, targetDistance: number) {\r\n    this.point0 = point0;\r\n    this.distance0 = 0.0;\r\n    this.targetDistance = Math.abs(targetDistance);\r\n    this.fraction0 = fraction0;\r\n  }\r\n  // Return CurveSearchStatus indicating whether the accumulated distance has reached the target.\r\n  public distanceStatus(): CurveSearchStatus {\r\n    return Geometry.isSameCoordinate(this.distance0, this.targetDistance) ?\r\n      CurveSearchStatus.success : CurveSearchStatus.stoppedAtBoundary;\r\n  }\r\n  /**\r\n   * Announce next point on the polyline.\r\n   * * if the additional segment does NOT reach the target:\r\n   *   * accumulate the segment length\r\n   *   * update point0 and fraction0\r\n   *   * return false\r\n   *  * if the additional segment DOES reach the target:\r\n   *    * update point0 and fraction0 to the (possibly interpolated) final point and fraction\r\n   *    * return true\r\n   * @param point1 new point\r\n   * @param fraction1 fraction at point1\r\n   * @return true if targetDistance reached.\r\n   */\r\n  public announcePoint(point1: Point3d, fraction1: number): boolean {\r\n    const a = this.point0.distance(point1);\r\n    const distance1 = this.distance0 + a;\r\n    if (distance1 < this.targetDistance && !Geometry.isSameCoordinate(distance1, this.targetDistance)) {\r\n      this.point0.setFromPoint3d(point1);\r\n      this.distance0 = distance1;\r\n      this.fraction0 = fraction1;\r\n      return false;\r\n    }\r\n    const b = this.targetDistance - this.distance0;\r\n    const intervalFraction = Geometry.safeDivideFraction(b, a, 0.0);\r\n    this.point0.interpolate(intervalFraction, point1, this.point0);\r\n    this.fraction0 = Geometry.interpolate(this.fraction0, intervalFraction, fraction1);\r\n    this.distance0 = this.targetDistance;\r\n    return true;\r\n  }\r\n  /**\r\n   * Update point0, fraction0, and distance0 based on extrapolation of a segment between indices of a point array.\r\n   * @returns true if extrapolation succeeded.  (False if indexed points are coincident)\r\n   * @param points\r\n   * @param index0\r\n   * @param index1\r\n   * @param fraction0\r\n   * @param fraction1\r\n   * @param result\r\n   * @param CurveLocationDetail\r\n   */\r\n  public announceExtrapolation(points: GrowableXYZArray,\r\n    index0: number, index1: number,\r\n    fraction0: number, fraction1: number): boolean {\r\n    const residual = this.targetDistance - this.distance0;\r\n    const d01 = points.distance(index0, index1);\r\n    if (!d01)\r\n      return false;\r\n    const extensionFraction = Geometry.conditionalDivideFraction(residual, d01);\r\n    if (extensionFraction === undefined)\r\n      return false;\r\n    // (Remark: indices are swapped and extensionFraction negated to prevent incidental precision\r\n    // loss with the alternative call with (index0, 1 + extensionFraction, index1);\r\n    points.interpolate(index1, -extensionFraction, index0, this.point0);\r\n    this.distance0 = this.targetDistance;\r\n    this.fraction0 = Geometry.interpolate(fraction1, -extensionFraction, fraction0);\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { Geometry } from \"../Geometry\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { CurveChain } from \"./CurveCollection\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n\r\n/**\r\n * A `Loop` is a curve chain that is the boundary of a closed (planar) loop.\r\n * @public\r\n */\r\nexport class Loop extends CurveChain {\r\n  /** tag value that can be set to true for user code to mark inner and outer loops. */\r\n  public isInner: boolean = false;\r\n  /** Test if `other` is an instance of `Loop` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof Loop; }\r\n  public constructor() { super(); }\r\n  /**\r\n   * Create a loop from variable length list of CurvePrimitives\r\n   * @param curves array of individual curve primitives\r\n   */\r\n  public static create(...curves: CurvePrimitive[]): Loop {\r\n    const result = new Loop();\r\n    for (const curve of curves) {\r\n      result.children.push(curve);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a loop from an array of curve primitives\r\n   * @param curves array of individual curve primitives\r\n   */\r\n  public static createArray(curves: CurvePrimitive[]): Loop {\r\n    const result = new Loop();\r\n    for (const curve of curves) {\r\n      result.children.push(curve);\r\n    }\r\n    return result;\r\n  }\r\n  /** Create a loop from an array of points */\r\n  public static createPolygon(points: GrowableXYZArray | Point3d[]): Loop {\r\n    const linestring = LineString3d.create(points);\r\n    linestring.addClosurePoint();\r\n    return Loop.create(linestring);\r\n  }\r\n  /** Create a loop with the stroked form of this loop. */\r\n  public cloneStroked(options?: StrokeOptions): AnyCurve {\r\n    const strokes = LineString3d.create();\r\n    for (const curve of this.children)\r\n      curve.emitStrokes(strokes, options);\r\n    return Loop.create(strokes);\r\n  }\r\n  /** Return the boundary type (2) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 2; } // (2) all \"Loop\" become \"outer\"\r\n  /** invoke `processor.announceLoop(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceLoop(this, indexInParent);\r\n  }\r\n  /** Return the curve primitive identified by `index`, with cyclic indexing. */\r\n  public cyclicCurvePrimitive(index: number): CurvePrimitive | undefined {\r\n    const n = this.children.length;\r\n    if (n >= 1) {\r\n      index = Geometry.modulo(index, this.children.length);\r\n      return this.children[index];\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Create a new `Loop` with no children */\r\n  public cloneEmptyPeer(): Loop { return new Loop(); }\r\n  /** Second step of double dispatch:  call `handler.handleLoop(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLoop(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { Loop } from \"./Loop\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\n/**\r\n * * A `ParityRegion` is a collection of `Loop` objects.\r\n * * The loops collectively define a planar region.\r\n * * A point is \"in\" the composite region if it is \"in\" an odd number of the loops.\r\n * @public\r\n */\r\nexport class ParityRegion extends CurveCollection {\r\n  /** Test if `other` is an instance of `ParityRegion` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof ParityRegion; }\r\n  /** Array of loops in this parity region. */\r\n  protected _children: Loop[];\r\n  /** Return the array of loops in this parity region. */\r\n  public get children(): Loop[] { return this._children; }\r\n  /** Construct parity region with empty loop array */\r\n  public constructor() { super(); this._children = []; }\r\n  /** Create a parity region with given loops */\r\n  public static create(...data: Loop[]): ParityRegion {\r\n    const result = new ParityRegion();\r\n    for (const child of data) {\r\n      result.children.push(child);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the boundary type (4) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 4; }\r\n  /** invoke `processor.announceParityRegion(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceParityRegion(this, indexInParent);\r\n  }\r\n  /** Return a deep copy. */\r\n  public clone(): ParityRegion {\r\n    const clone = new ParityRegion();\r\n    let child;\r\n    for (child of this.children) {\r\n      const childClone = child.clone();\r\n      if (childClone instanceof Loop)\r\n        clone.children.push(childClone);\r\n    }\r\n    return clone;\r\n  }\r\n  /** Stroke these curves into a new ParityRegion. */\r\n  public cloneStroked(options?: StrokeOptions): ParityRegion {\r\n    const clone = new ParityRegion();\r\n    let child;\r\n    for (child of this.children) {\r\n      const childStrokes = child.cloneStroked(options) as Loop;\r\n      if (childStrokes)\r\n        clone.children.push(childStrokes);\r\n    }\r\n    return clone;\r\n  }\r\n  /** Create a new empty parity region. */\r\n  public cloneEmptyPeer(): ParityRegion { return new ParityRegion(); }\r\n  /** Add `child` to this parity region.\r\n   * * any child type other than `Loop` is ignored.\r\n   */\r\n  public tryAddChild(child: AnyCurve): boolean {\r\n    if (child instanceof Loop) {\r\n      this._children.push(child);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Get child `i` by index. */\r\n  public getChild(i: number): Loop | undefined {\r\n    if (i < this._children.length)\r\n      return this._children[i];\r\n    return undefined;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleRegion(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleParityRegion(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"./LineString3d\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\nimport { CurveChain } from \"./CurveCollection\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n\r\n/**\r\n * * A `Path` object is a collection of curves that join head-to-tail to form a path.\r\n * * A `Path` object does not bound a planar region.  Use `Loop` to indicate region bounding.\r\n * @public\r\n */\r\nexport class Path extends CurveChain {\r\n  /** Test if `other` is an instance of `Path` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof Path; }\r\n  /** invoke `processor.announcePath(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announcePath(this, indexInParent);\r\n  }\r\n  /** Construct an empty path. */\r\n  public constructor() { super(); }\r\n  /**\r\n   * Create a path from a variable length list of curve primitives\r\n   * * CurvePrimitive params are captured !!!\r\n   * @param curves variable length list of individual curve primitives or point arrays.\r\n   */\r\n  public static create(...curves: Array<CurvePrimitive | Point3d[]>): Path {\r\n    const result = new Path();\r\n    for (const curve of curves) {\r\n      if (curve instanceof CurvePrimitive)\r\n        result.children.push(curve);\r\n      else if (Array.isArray(curve) && curve.length > 0 && curve[0] instanceof Point3d) {\r\n        result.children.push(LineString3d.create(curve));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a path from a an array of curve primitives\r\n   * @param curves array of individual curve primitives\r\n   */\r\n  public static createArray(curves: CurvePrimitive[]): Path {\r\n    const result = new Path();\r\n    for (const curve of curves) {\r\n      result.children.push(curve);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a deep copy, with leaf-level curve primitives stroked. */\r\n  public cloneStroked(options?: StrokeOptions): AnyCurve {\r\n    const strokes = LineString3d.create();\r\n    for (const curve of this.children)\r\n      curve.emitStrokes(strokes, options);\r\n    return Path.create(strokes);\r\n  }\r\n  /** Return the boundary type (1) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 1; }\r\n  /**\r\n   * Return the `[index]` curve primitive, using `modulo` to map`index` to the cyclic indexing.\r\n   * * In particular, `-1` is the final curve.\r\n   * @param index cyclid index\r\n   */\r\n  public cyclicCurvePrimitive(index: number): CurvePrimitive | undefined {\r\n    const n = this.children.length;\r\n    if (n === 0)\r\n      return undefined;\r\n\r\n    const index2 = Geometry.modulo(index, n);\r\n    return this.children[index2];\r\n  }\r\n  /** Clone as a new `Path` with no primitives */\r\n  public cloneEmptyPeer(): Path { return new Path(); }\r\n  /** Second step of double dispatch:  call `handler.handlePath(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handlePath(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Point3dArray } from \"../geometry3d/PointHelpers\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\n/* tslint:disable:variable-name no-empty*/\r\n\r\n/**\r\n * A PointString3d is an array of points.\r\n * * PointString3D is first class (persistible, displayable) geometry derived from the GeometryQuery base class.\r\n * * The various points in the PointString3d are NOT connected by line segments for display or other calculations.\r\n * @public\r\n */\r\nexport class PointString3d extends GeometryQuery implements BeJSONFunctions {\r\n  /** Test if `other` is a PointString3d */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof PointString3d; }\r\n  private _points: Point3d[];\r\n  /** return a clone of the points array. */\r\n  public get points(): Point3d[] { return this._points; }\r\n  private constructor() {\r\n    super();\r\n    this._points = [];\r\n  }\r\n  /** Clone and apply a transform. */\r\n  public cloneTransformed(transform: Transform): PointString3d {  // we know tryTransformInPlace succeeds.\r\n    const c = this.clone();\r\n    c.tryTransformInPlace(transform);\r\n    return c;\r\n  }\r\n  private static flattenArray(arr: any): any {\r\n    return arr.reduce((flat: any, toFlatten: any) => {\r\n      return flat.concat(Array.isArray(toFlatten) ? PointString3d.flattenArray(toFlatten) : toFlatten);\r\n    }, []);\r\n  }\r\n  /** Create a PointString3d from points. */\r\n  public static create(...points: any[]): PointString3d {\r\n    const result = new PointString3d();\r\n    result.addPoints(points);\r\n    return result;\r\n  }\r\n\r\n  /** Add multiple points to the PointString3d */\r\n  public addPoints(...points: any[]) {\r\n    const toAdd: any[] = PointString3d.flattenArray(points);\r\n    for (const p of toAdd) {\r\n      if (p instanceof Point3d)\r\n        this._points.push(p);\r\n    }\r\n  }\r\n  /** Add a single point to the PointString3d */\r\n  public addPoint(point: Point3d) {\r\n    this._points.push(point);\r\n  }\r\n  /** Remove the last point added to the PointString3d */\r\n  public popPoint() {\r\n    this._points.pop();\r\n  }\r\n\r\n  /** Replace this PointString3d's point array by a clone of the array in `other` */\r\n  public setFrom(other: PointString3d) {\r\n    this._points = Point3dArray.clonePoint3dArray(other._points);\r\n  }\r\n  /** Create from an array of Point3d */\r\n  public static createPoints(points: Point3d[]): PointString3d {\r\n    const ps = new PointString3d();\r\n    ps._points = Point3dArray.clonePoint3dArray(points);\r\n    return ps;\r\n  }\r\n  /** Create a PointString3d from xyz coordinates packed in a Float64Array */\r\n  public static createFloat64Array(xyzData: Float64Array): PointString3d {\r\n    const ps = new PointString3d();\r\n    for (let i = 0; i + 3 <= xyzData.length; i += 3)\r\n      ps._points.push(Point3d.create(xyzData[i], xyzData[i + 1], xyzData[i + 2]));\r\n    return ps;\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): PointString3d {\r\n    const retVal = new PointString3d();\r\n    retVal.setFrom(this);\r\n    return retVal;\r\n  }\r\n  /** Replace this instance's points by those from a json array, e.g. `[[1,2,3], [4,2,2]]` */\r\n  public setFromJSON(json?: any) {\r\n    this._points.length = 0;\r\n    if (Array.isArray(json)) {\r\n      let xyz;\r\n      for (xyz of json)\r\n        this._points.push(Point3d.fromJSON(xyz));\r\n    }\r\n  }\r\n  /**\r\n   * Convert an PointString3d to a JSON object.\r\n   * @return {*} [[x,y,z],...[x,y,z]]\r\n   */\r\n  public toJSON(): any {\r\n    const value = [];\r\n    for (const p of this._points) value.push(p.toJSON());\r\n    return value;\r\n  }\r\n  /** Create a PointString3d from a json array, e.g. `[[1,2,3], [4,2,2]]` */\r\n  public static fromJSON(json?: any): PointString3d {\r\n    const ps = new PointString3d(); ps.setFromJSON(json); return ps;\r\n  }\r\n  /** Access a single point by index. */\r\n  public pointAt(i: number, result?: Point3d): Point3d | undefined {\r\n    if (i >= 0 && i < this._points.length) {\r\n      if (result) { result.setFrom(this._points[i]); return result; }\r\n      return this._points[i].clone();\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the number of points. */\r\n  public numPoints(): number { return this._points.length; }\r\n\r\n  /** Reverse the point order */\r\n  public reverseInPlace(): void {\r\n    if (this._points.length >= 2) {\r\n      let i0 = 0;\r\n      let i1 = this._points.length - 1;\r\n      while (i0 < i1) {\r\n        const a = this._points[i0];\r\n        this._points[i1] = this._points[i0];\r\n        this._points[i0] = a;\r\n        i0++;\r\n        i1--;\r\n      }\r\n    }\r\n  }\r\n  /** Return the number of points. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyPoint3dArrayInPlace(this._points);\r\n    return true;\r\n  }\r\n  /** Return the index and coordinates of the closest point to spacepoint. */\r\n  public closestPoint(spacePoint: Point3d): { index: number, xyz: Point3d } {\r\n    const result = { index: -1, xyz: Point3d.create() };\r\n    const index = Point3dArray.closestPointIndex(this._points, spacePoint);\r\n    if (index >= 0) {\r\n      result.index = index;\r\n      result.xyz.setFrom(this._points[index]);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return true if all points are in the given plane. */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return Point3dArray.isCloseToPlane(this._points, plane, Geometry.smallMetricDistance);\r\n  }\r\n  /** Extend a range to include the points in this PointString3d. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    rangeToExtend.extendArray(this._points, transform);\r\n  }\r\n  /** Return true if corresponding points are almost equal. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (!(other instanceof PointString3d))\r\n      return false;\r\n    return Point3dArray.isAlmostEqual(this._points, other._points);\r\n  }\r\n  /** Reduce to empty set of points. */\r\n  public clear() { this._points.length = 0; }\r\n  /** Second step of double dispatch:  call `handler.handlePointString(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handlePointString3d(this);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { GeometryQuery } from \"../GeometryQuery\";\r\nimport { RecurseToCurvesGeometryHandler } from \"../../geometry3d/GeometryHandler\";\r\n\r\nimport { LineSegment3d } from \"../LineSegment3d\";\r\nimport { Point3d, Vector3d } from \"../../geometry3d/Point3dVector3d\";\r\nimport { LineString3d } from \"../LineString3d\";\r\nimport { Transform } from \"../../geometry3d/Transform\";\r\nimport { StrokeOptions } from \"../StrokeOptions\";\r\nimport { Arc3d } from \"../Arc3d\";\r\nimport { Ray3d } from \"../../geometry3d/Ray3d\";\r\nimport { AnyCurve } from \"../CurveChain\";\r\n\r\n/**\r\n * Context for computing geometry range around an axis.\r\n * * The publicly called method is `computeZRRange (ray, geometry)\r\n */\r\nexport class CylindricalRangeQuery extends RecurseToCurvesGeometryHandler {\r\n  // private geometry0: GeometryQuery;  <-- Never used\r\n  private _perpVector: Vector3d;\r\n  private _maxDistance: number;\r\n  private _localToWorld: Transform;\r\n  /** capture ray and initialize evolving ranges. */\r\n  private constructor(ray: Ray3d) {\r\n    super();\r\n    this._perpVector = Vector3d.createZero();\r\n    this._maxDistance = 0.0;\r\n    this._localToWorld = ray.toRigidZFrame()!;\r\n  }\r\n  private _localPoint = Point3d.create();\r\n  private _worldPoint = Point3d.create();\r\n  private announcePoint(xyz: Point3d) {\r\n    this._localToWorld.multiplyInversePoint3d(xyz, this._localPoint);\r\n    const distance = this._localPoint.magnitudeXY();\r\n    if (distance >= this._maxDistance) {\r\n      this._maxDistance = distance;\r\n      this._perpVector.setFromPoint3d(this._localPoint);\r\n      this._perpVector.z = 0.0;\r\n      this._localToWorld.matrix.multiplyXY(this._localPoint.x, this._localPoint.y, this._perpVector);\r\n    }\r\n  }\r\n\r\n  public handleLineSegment3d(segment0: LineSegment3d) {\r\n    this.announcePoint(segment0.startPoint(this._worldPoint));\r\n    this.announcePoint(segment0.endPoint(this._worldPoint));\r\n  }\r\n  public handleLineString3d(ls0: LineString3d) {\r\n    for (let i = 0; i < ls0.numPoints(); i++) {\r\n      ls0.pointAt(i, this._worldPoint);\r\n      this.announcePoint(this._worldPoint);\r\n    }\r\n  }\r\n\r\n  public handleArc3d(arc0: Arc3d): any {\r\n    // humbug .. just stroke it ..\r\n    // exact solution is:\r\n    //   project the arc to the z=0 plane of the local system.\r\n    //   find max distance to origin.\r\n    const numStroke = StrokeOptions.applyAngleTol(undefined, 3, arc0.sweep.sweepRadians, 0.1);\r\n    const df = 1.0 / numStroke;\r\n    for (let i = 0; i <= numStroke; i++) {\r\n      arc0.fractionToPoint(i * df, this._worldPoint);\r\n      this.announcePoint(this._worldPoint);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Compute the largest vector perpendicular to a ray and ending on the geometry.\r\n   * @param geometry0 geometry to search\r\n   * @returns vector from ray to geometry.\r\n   */\r\n  public static computeMaxVectorFromRay(ray: Ray3d, geometry: GeometryQuery): Vector3d {\r\n    const accumulator = new CylindricalRangeQuery(ray);\r\n    geometry.dispatchToGeometryHandler(accumulator);\r\n    return accumulator._perpVector.clone();\r\n  }\r\n\r\n  /**\r\n   * Recurse through geometry.children to find linestrings.\r\n   * In each linestring, compute the surface normal annotation from\r\n   *  * the curve tangent stored in the linestring\r\n   *  * the axis of rotation\r\n   *  * a default V vector to be used when the linestring point is close to the axis.\r\n   * @param geometry\r\n   * @param axis\r\n   * @param defaultVectorV\r\n   */\r\n  public static buildRotationalNormalsInLineStrings(geometry: AnyCurve, axis: Ray3d, defaultVectorFromAxis: Vector3d) {\r\n    if (geometry instanceof LineString3d) {\r\n      const points = geometry.packedPoints;\r\n      const derivatives = geometry.packedDerivatives;\r\n      const normals = geometry.ensureEmptySurfaceNormals();\r\n      if (derivatives && normals) {\r\n        const vectorU = Vector3d.create();\r\n        const vectorV = Vector3d.create();  // v direction (forwward along sweep) for surface of rotation.\r\n        const xyz = Point3d.create();\r\n        const n = points.length;\r\n        for (let i = 0; i < n; i++) {\r\n          points.getPoint3dAtUncheckedPointIndex(i, xyz);\r\n          axis.perpendicularPartOfVectorToTarget(xyz, vectorU);\r\n          if (vectorU.isAlmostZero)\r\n            axis.direction.crossProduct(defaultVectorFromAxis, vectorV);\r\n          else\r\n            axis.direction.crossProduct(vectorU, vectorV);\r\n          geometry.packedDerivatives!.getVector3dAtCheckedVectorIndex(i, vectorU); // reuse vector U as curve derivative\r\n          vectorU.crossProduct(vectorV, vectorV);  // reuse vector V as normal!\r\n          vectorV.normalizeInPlace();\r\n          normals.push(vectorV);\r\n        }\r\n      }\r\n    } else if (geometry.children) {\r\n      const children = geometry.children;\r\n      for (const child of children) {\r\n        this.buildRotationalNormalsInLineStrings(child as AnyCurve, axis, defaultVectorFromAxis);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { StrokeCountMap } from \"./StrokeCountMap\";\r\nimport { CurveCollection, CurveChain } from \"../CurveCollection\";\r\nimport { ParityRegion } from \"../ParityRegion\";\r\nimport { StrokeOptions } from \"../StrokeOptions\";\r\nimport { LineString3d } from \"../LineString3d\";\r\nimport { AnyCurve } from \"../CurveChain\";\r\n\r\nimport { Loop } from \"../Loop\";\r\nimport { Range1d } from \"../../geometry3d/Range\";\r\nimport { Point3d } from \"../../geometry3d/Point3dVector3d\";\r\nimport { Geometry } from \"../../Geometry\";\r\n\r\n/**\r\n * abstract methods for callbacks during sweeps of collections of StrokeCount Structures.\r\n * * A set of StrokeCountMaps are to be visited multiple times.\r\n * * The logic that controls the sweep is as below.\r\n * * The callback object controls the number of sweeps and can adapt its action to the respective sweeps.\r\n * * Note that a \"false\" from cb.startPass() terminates passes for this chainIndex and primitiveIndex, but all others exit the whole sequence.\r\n * * This logic occurs 2 or three levels deep\r\n *   * outer level is \"chains\".   Simple swept path or loops have only one outer; parity regions have one outer per loop of the parity region\r\n *   * second level is primitive within chain.\r\n *     * If the primitives in a set are \"single component\", second level is lowest.\r\n *        * startSweep() and endSweep() calls are two parameters, with undefined componentIndex\r\n *     * If the primitives in a set are multicomponet, there is a third level looping through corresponding components.\r\n * `\r\n *    if (!cb.startSweeps (chainIndex, primitiveIndex, componentIndex))\r\n *      return false;\r\n *    for (let pass = 0;cb.startPass (pass); pass++){\r\n *      for (each map in working set)\r\n *            if (!cb.visit (pass, map)) return false;\r\n *       if (!cb.endPass ()) return false;\r\n *        }\r\n *      }\r\n * if (!cb.endSweeps (chainIndex, primitiveIndex, componentIndex)) return false;\r\n * return true;\r\n * `\r\n * @internal\r\n */\r\nexport abstract class StrokeCountMapMultipassVisitor {\r\n  /**\r\n   * called to announce the begnining of one or more sweeps through related StrokeCountMap's\r\n   * @param chainIndex index of loop or path within the various contours.\r\n   * @param primitiveIndexx index of primitive within the loop or path.\r\n   * @param componentIndex optional component index.\r\n   * @returns the number of sweeps to perform.\r\n   */\r\n  public startSweeps(_chainIndex: number, _primitiveIndex: number, _componentIndex?: number): boolean { return true; }\r\n  /**\r\n   * announce the begninning of a sweep pass.\r\n   * @param pass the index (0,1...) for this sweep pass.\r\n   * @return true to execute this pass.  false to break from the pass loop (next method called is endSweeps)\r\n   */\r\n  public abstract startPass(pass: number): boolean;\r\n  public abstract visit(pass: number, map: StrokeCountMap): boolean;\r\n  /**\r\n   * announce the end of a pass\r\n   * @param pass the index (0,1...) for this sweep pass.\r\n   * @return true to continue the sweeps.\r\n   */\r\n\r\n  public abstract endPass(pass: number): boolean;\r\n  /**\r\n   * announce the end of handling for particular chainIndex and primitiveIndex;\r\n   * @return true to continue outer loops.\r\n   */\r\n  public endSweeps(_chainIndex: number, _primitiveIndex: number, _componentIndex?: number): boolean { return true; }\r\n\r\n}\r\n/**\r\n * * pass 1: determine max numStroke\r\n * * pass 2: impose max numStroke\r\n * @internal\r\n */\r\nexport class StrokeCountMapVisitorApplyMaxCount extends StrokeCountMapMultipassVisitor {\r\n  public myMap: StrokeCountMap;\r\n  public constructor() {\r\n    super();\r\n    this.myMap = StrokeCountMap.createWithComponentIndex();\r\n  }\r\n  /** set up for a pass through corresponding maps. */\r\n  public startPass(pass: number): boolean {\r\n    if (pass === 0) {\r\n      this.myMap.numStroke = 0;\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // nothing to change == numStroke will be applied to each primitive.\r\n      return true;\r\n    }\r\n    // all other pass numbers are rejected ...\r\n    return false;\r\n  }\r\n  /** visit one of the set of corresponding maps. */\r\n  public visit(pass: number, map: StrokeCountMap): boolean {\r\n    if (pass === 0) {\r\n      if (map.numStroke > this.myMap.numStroke)\r\n        this.myMap.numStroke = map.numStroke;\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // apply the max from prior pass\r\n      map.numStroke = this.myMap.numStroke;\r\n      return true;\r\n    }\r\n    // no other pass values should happen -- canceled by startPass.\r\n    return false;\r\n  }\r\n\r\n  public endPass(_pass: number): boolean { return true; }\r\n}\r\n/**\r\n * * pass 1: determine max curveLength among maps presented.\r\n * * pass 2: set the a0 and a1 values to 0 and that max distance\r\n * @internal\r\n */\r\nexport class StrokeCountMapVisitorApplyMaxCurveLength extends StrokeCountMapMultipassVisitor {\r\n  public maxCurveLength: number;\r\n  public constructor() {\r\n    super();\r\n    this.maxCurveLength = 0.0;\r\n  }\r\n  /** set up for a pass through corresponding maps. */\r\n  public startPass(pass: number): boolean {\r\n    if (pass === 0) {\r\n      this.maxCurveLength = 0;\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // nothing to change == numStroke will be applied to each primitive.\r\n      return true;\r\n    }\r\n    // all other pass numbers are rejected ...\r\n    return false;\r\n  }\r\n  /** visit one of the set of corresponding maps. */\r\n  public visit(pass: number, map: StrokeCountMap): boolean {\r\n    if (pass === 0) {\r\n      this.maxCurveLength = Geometry.maxXY(map.curveLength, this.maxCurveLength);\r\n      return true;\r\n    } else if (pass === 1) {\r\n      // apply the max from prior pass\r\n      map.a0 = 0.0;\r\n      map.a1 = this.maxCurveLength;\r\n      return true;\r\n    }\r\n    // no other pass values should happen -- canceled by startPass.\r\n    return false;\r\n  }\r\n\r\n  public endPass(_pass: number): boolean { return true; }\r\n}\r\n/**\r\n * class `StrokeCountChain` contains:\r\n * * `maps` = an array of `StrokeCountMap`\r\n * * `parent` = parent CurveCollection.\r\n *\r\n * An instance is normally created with either a `Path` or `Loop` as the parent.\r\n */\r\nexport class StrokeCountChain {\r\n  public maps: StrokeCountMap[];\r\n  public parent?: CurveCollection;\r\n  /**\r\n   * options are used (with different purposes) at two times:\r\n   * * When the StrokeCountChain is created, the options affect the stroke counts.  This is just creating markup, not actual strokes.\r\n   * * When actual stroking happens, the options control creation of parameters and tangents.\r\n   */\r\n  public options?: StrokeOptions;\r\n\r\n  private constructor(parent?: CurveCollection, options?: StrokeOptions) {\r\n    this.parent = parent;\r\n    this.maps = [];\r\n    this.options = options;\r\n  }\r\n  public static createForCurveChain(chain: CurveChain, options?: StrokeOptions): StrokeCountChain {\r\n    const result = new StrokeCountChain(chain, options);\r\n    result.parent = chain;\r\n    // A chain can only contain primitives !!!!\r\n    for (const p of chain.children) {\r\n      p.computeAndAttachRecursiveStrokeCounts(options);\r\n      if (p.strokeData)\r\n        result.maps.push(p.strokeData);\r\n    }\r\n    return result;\r\n  }\r\n  public getStrokes(): LineString3d {\r\n    const ls = LineString3d.create();\r\n    if (this.options) {\r\n      if (this.options.needNormals || this.options.needParams) {\r\n        ls.ensureEmptyFractions();\r\n        ls.ensureEmptyDerivatives();\r\n        ls.ensureEmptyUVParams();\r\n      }\r\n    }\r\n    for (const m of this.maps) {\r\n      if (m.primitive)\r\n        m.primitive.addMappedStrokesToLineString3D(m, ls);\r\n    }\r\n    return ls;\r\n\r\n  }\r\n  /** internal form of  */\r\n  private static applySummed01LimitsWithinArray(maps: StrokeCountMap[], incomingSum: number): number {\r\n    let movingSum = incomingSum;\r\n    for (const m of maps) {\r\n      m.a0 += movingSum;\r\n      if (m.componentData) {\r\n        m.a1 = this.applySummed01LimitsWithinArray(m.componentData, m.a0);\r\n      } else {\r\n        m.a1 += movingSum;\r\n      }\r\n      movingSum = m.a1;\r\n    }\r\n    return movingSum;\r\n  }\r\n  /**\r\n   * walk the maps in the array.\r\n   * * in maps with no component data\r\n   *   * increment map.a0 and map.a1 by the incoming distance a0\r\n   * * in maps with component data:\r\n   *   * recurse through the component array.\r\n   *   * increment map.a0 by the incoming a0.\r\n   *   * returned a1 from the componentData array becomes a1\r\n   * @returns upper value of a1 in final map.\r\n   * @param maps\r\n   * @param incomingSum lower value to add to a0 for first map.\r\n   */\r\n  public applySummed01Limits(incomingSum: number): number {\r\n    return StrokeCountChain.applySummed01LimitsWithinArray(this.maps, incomingSum);\r\n  }\r\n}\r\n\r\n/**\r\n * class `StrokeCountSection`\\\r\n * * contains an array of `StrokeCountChain`.\r\n * * Hence it is the internal node level of a (1-level-deep) tree of `StrokeCountChain`\r\n * @internal\r\n */\r\nexport class StrokeCountSection {\r\n  public chains: StrokeCountChain[];\r\n  public parent?: CurveCollection;\r\n  private constructor(parent?: CurveCollection) { this.parent = parent; this.chains = []; }\r\n  /**\r\n   * construct array of arrays of `StrokeCountMap`s\r\n   * @param parent\r\n   */\r\n  public static createForParityRegionOrChain(parent: CurveCollection, options?: StrokeOptions): StrokeCountSection {\r\n    const result = new StrokeCountSection(parent);\r\n    if (parent instanceof ParityRegion) {\r\n      for (const child of parent.children) {\r\n        const p = StrokeCountChain.createForCurveChain(child, options);\r\n        result.chains.push(p);\r\n      }\r\n    } else if (parent instanceof CurveChain) {\r\n      result.chains.push(StrokeCountChain.createForCurveChain(parent, options));\r\n    }\r\n    return result;\r\n  }\r\n  /** test if all sections have the same structure. */\r\n  public static areSectionsCompatible(sections: StrokeCountSection[], enforceCounts: boolean): boolean {\r\n    if (sections.length < 2)\r\n      return true;  // hm.. don't know if that is useful, but nothing to check here.\r\n    const numChains = sections[0].chains.length;\r\n    for (let i = 1; i < sections.length; i++) {\r\n      // first level: must match number of paths or loops\r\n      if (sections[i].chains.length !== numChains)\r\n        return false;\r\n      // second level: must have same number of primitives in each path or loop\r\n      for (let j = 0; j < sections[0].chains.length; j++) {\r\n        const numPrimitive = sections[0].chains[j].maps.length;\r\n        if (sections[i].chains[j].maps.length !== numPrimitive)\r\n          return false;\r\n        for (let k = 0; k < numPrimitive; k++) {\r\n          if (!sections[0].chains[j].maps[k].isCompatibleComponentStructure(sections[i].chains[j].maps[k], enforceCounts))\r\n            return false;\r\n        }\r\n      }\r\n\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Within each section, sweep accumulate curveLength field, recording entry and exit sum in each map.\r\n   * * In expected use, (a0,a1) are (0,a) where a is the (previously computed) max length among corresponding maps up and down the section arrays.\r\n   */\r\n  public static remapa0a1WithinEachChain(sections: StrokeCountSection[]) {\r\n    for (const section of sections) {\r\n      for (const chain of section.chains) {\r\n        chain.applySummed01Limits(0.0);\r\n      }\r\n    }\r\n  }\r\n\r\n  private static applyMultipassVisitorCallbackNoComponents(sections: StrokeCountSection[], chainIndex: number, primitiveIndex: number,\r\n    componentIndex: number | undefined, callback: StrokeCountMapMultipassVisitor) {\r\n    const numSection = sections.length;\r\n    if (!callback.startSweeps(chainIndex, primitiveIndex, componentIndex)) return false;\r\n    if (componentIndex === undefined) {\r\n      // there are corresponding primitves directly at the section, chain, primitive index:\r\n      for (let pass = 0; ; pass++) {\r\n        if (!callback.startPass(pass))\r\n          break;\r\n        for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)\r\n          if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex]))\r\n            return false;\r\n        if (!callback.endPass(pass))\r\n          return false;\r\n      }\r\n    } else {\r\n      // there are corresponding primitves at the section, chain, primitive,componentIndex\r\n      // there are corresponding primitves directly at the section, chain, primitive index:\r\n      for (let pass = 0; ; pass++) {\r\n        if (!callback.startPass(pass))\r\n          break;\r\n        for (let sectionIndex = 0; sectionIndex < numSection; sectionIndex++)\r\n          if (!callback.visit(pass, sections[sectionIndex].chains[chainIndex].maps[primitiveIndex].componentData![componentIndex]))\r\n            return false;\r\n        if (!callback.endPass(pass))\r\n          return false;\r\n      }\r\n\r\n    }\r\n    if (!callback.endSweeps(chainIndex, primitiveIndex, componentIndex)) return false;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Walk through the sections, emitting callbacks delimiting groups of corresponding primitives.\r\n   * @param sections array of sections (possibly a single path or loop at each section, or possibly a set of parity loops.)\r\n   * @param callback object to be notified during the traversal\r\n   */\r\n  public static runMultiPassVisitorAtCorrespondingPrimitives(sections: StrokeCountSection[], callback: StrokeCountMapMultipassVisitor): boolean {\r\n    const numChainPerSection = sections[0].chains.length;\r\n    for (let chainIndex = 0; chainIndex < numChainPerSection; chainIndex++) {\r\n      const numPrimitive = sections[0].chains[chainIndex].maps.length;\r\n      for (let primitiveIndex = 0; primitiveIndex < numPrimitive; primitiveIndex++) {\r\n        if (sections[0].chains[chainIndex].maps[primitiveIndex].componentData) {\r\n          const numComponent = sections[0].chains[chainIndex].maps[primitiveIndex]!.componentData!.length;\r\n          for (let i = 0; i < numComponent; i++)\r\n            if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, i, callback))\r\n              return false;\r\n\r\n        } else {\r\n          if (!this.applyMultipassVisitorCallbackNoComponents(sections, chainIndex, primitiveIndex, undefined, callback))\r\n            return false;\r\n        }\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * * Confirm that all sections in the array have the same structure.\r\n   * * Within each corresponding set of entries, apply the max count to all.\r\n   * @param sections array of per-section stroke count entries\r\n   */\r\n  public static enforceStrokeCountCompatibility(sections: StrokeCountSection[]): boolean {\r\n\r\n    if (sections.length < 2)\r\n      return true;\r\n    if (!StrokeCountSection.areSectionsCompatible(sections, false))\r\n      return false;\r\n    const visitor = new StrokeCountMapVisitorApplyMaxCount();\r\n    this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);\r\n    return true;\r\n\r\n  }\r\n  /**\r\n   * * Confirm that all sections in the array have the same structure.\r\n   * * Within each corresponding set of entries up and down the sections, set curveLength as the maximum of the respective curve lengths.\r\n   * * Along each section, sum curveLengths (which were just reset) to get consistent along-chain parameters\r\n   * @param sections array of per-section stroke count entries\r\n   */\r\n  public static enforceCompatibleDistanceSums(sections: StrokeCountSection[]): boolean {\r\n\r\n    if (sections.length < 2)\r\n      return true;\r\n    if (!StrokeCountSection.areSectionsCompatible(sections, false))\r\n      return false;\r\n    const visitor = new StrokeCountMapVisitorApplyMaxCurveLength();\r\n    this.runMultiPassVisitorAtCorrespondingPrimitives(sections, visitor);\r\n    this.remapa0a1WithinEachChain(sections);\r\n    return true;\r\n\r\n  }\r\n\r\n  /**\r\n   * Return stroked form of the section.\r\n   */\r\n  public getStrokes(): AnyCurve {\r\n    if (this.chains.length === 1) {\r\n      return this.chains[0].getStrokes();\r\n    } else {\r\n      const region = ParityRegion.create();\r\n      for (const c of this.chains) {\r\n        const strokes = c.getStrokes();\r\n        if (strokes instanceof LineString3d)\r\n          region.tryAddChild(Loop.create(strokes));\r\n      }\r\n      return region;\r\n    }\r\n  }\r\n  /**\r\n   * Given two compatibile stroke sets (as returned by getStrokes) extend a range\r\n   * with the distances between corresponding points.\r\n   * * Each set of strokes may be:\r\n   *   * linestring\r\n   *   * ParityRegion\r\n   *   * CurveChain (Loop or Path)\r\n   * @param strokeA first set of strokes\r\n   * @param strokeB second set of strokes\r\n   * @param rangeToExtend caller-allocated range to be extended.\r\n   * @returns true if structures are compatible.\r\n   */\r\n  public static extendDistanceRangeBetweenStrokes(strokeA: AnyCurve, strokeB: AnyCurve, rangeToExtend: Range1d): boolean {\r\n    if (!strokeA.isSameGeometryClass(strokeB))\r\n      return false;\r\n    if (strokeA instanceof LineString3d) {\r\n      if (!(strokeB instanceof LineString3d))\r\n        return false;\r\n      if (strokeA.numPoints() === strokeB.numPoints()) {\r\n        const n = strokeA.numPoints();\r\n        const pointA = Point3d.create();\r\n        const pointB = Point3d.create();\r\n        const allPointA = strokeA.packedPoints;\r\n        const allPointB = strokeB.packedPoints;\r\n\r\n        for (let i = 0; i < n; i++) {\r\n          allPointA.getPoint3dAtCheckedPointIndex(i, pointA);\r\n          allPointB.getPoint3dAtCheckedPointIndex(i, pointB);\r\n          rangeToExtend.extendX(pointA.distance(pointB));\r\n        }\r\n        return true;\r\n      }\r\n    } else if (strokeA instanceof ParityRegion) {\r\n      if (!(strokeB instanceof ParityRegion))\r\n        return false;\r\n      const childrenA = strokeA.children;\r\n      const childrenB = strokeB.children;\r\n      const n = childrenA.length;\r\n      if (n === childrenB.length) {\r\n        for (let i = 0; i < n; i++) {\r\n          if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))\r\n            return false;\r\n        }\r\n        return true;\r\n      }\r\n    } else if (strokeA instanceof CurveChain) {\r\n      if (!(strokeB instanceof CurveChain))\r\n        return false;\r\n      const childrenA = strokeA.children;\r\n      const childrenB = strokeB.children;\r\n      const n = childrenA.length;\r\n      if (n === childrenB.length) {\r\n        for (let i = 0; i < n; i++) {\r\n          if (!this.extendDistanceRangeBetweenStrokes(childrenA[i], childrenB[i], rangeToExtend))\r\n            return false;\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { CurvePrimitive } from \"../CurvePrimitive\";\r\nimport { Geometry } from \"../../Geometry\";\r\n\r\n/** @module Curve */\r\n/**\r\n * data carrier interface for per-primitive stroke counts and distances used by PolyfaceBuilder.\r\n * * For a simple primitive (Line segment or arc) that is stroked with uniform fraction, the members are:\r\n *   * `numStroke` = total number of strokes\r\n *   * `curveLength` = length of this curve\r\n *   * `a0` = external mapped coordinate for fraction 0 on this primitive or component\r\n *   * `a1` = external mapped coordinate for fraction 1 on this primitive or component\r\n *\r\n * * For linestring and bspline curve, those numbers are totals for the overall curve, and breakdown within\r\n *     the components (line segments or bezier spans) is recoreded on the optional array `componentData[]`\r\n *   * Members of the array are annotated with componentIndex within the linestring or bspline curve\r\n * @public\r\n */\r\nexport class StrokeCountMap {\r\n/** number of strokes expected in this interval. */\r\n  public numStroke: number;\r\n  /** Length of the curve interval. */\r\n  public curveLength: number;\r\n  /** start coordinate (in user-defined space) for fraction 0 on this primitive or component */\r\n  public a0: number;\r\n  /** end coordinate (in user-defined space) for fraction 0 on this primitive or component */\r\n  public a1: number;\r\n  /** further StrokeCountMap's within this interval (e.g. for individual segments of a linestring.) */\r\n  public componentData?: StrokeCountMap[];\r\n  /** The curve that this map represents */\r\n  public primitive?: CurvePrimitive;\r\n  /** this curve's index within its parent. */\r\n  public componentIndex?: number;\r\n  /**\r\n   * Constructor.  Initialize all fields from arguments.\r\n   * * Callers that expect to announce numStroke and curveLength for multiple components send an empty componentData array.\r\n   * * Callers that do not have multiple components send undefined component data.\r\n   * @param numStroke\r\n   * @param curveLength\r\n   * @param a0\r\n   * @param a1\r\n   * @param componentData\r\n   */\r\n  private constructor(numStroke: number, curveLength: number, a0: number, a1: number, componentData?: StrokeCountMap[]) {\r\n    this.numStroke = numStroke;\r\n    this.curveLength = curveLength;\r\n    this.a0 = a0;\r\n    this.a1 = a1;\r\n    this.componentData = componentData;\r\n  }\r\n  /**\r\n   * Create a `StrokeCountMap` with curve primitive and optional compontnData array.\r\n   * @param primitive\r\n   * @param numStroke\r\n   * @param curveLength\r\n   * @param a0\r\n   * @param a1\r\n   * @param componentData\r\n   */\r\n  public static createWithCurvePrimitive(primitive: CurvePrimitive, numStroke: number, curveLength: number, a0: number, a1: number, componentData?: StrokeCountMap[]) {\r\n    const result = new StrokeCountMap(numStroke, curveLength, a0, a1, componentData);\r\n    result.primitive = primitive;\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a `StrokeCountMap` with `componentIndex` (but no primitive or componentData array)\r\n   * @param index\r\n   * @param numStroke\r\n   * @param curveLength\r\n   * @param a0\r\n   * @param a1\r\n   */\r\n  public static createWithComponentIndex(componentIndex: number = 0, numStroke: number = 0, curveLength: number = 0, a0: number = 0, a1: number = 0) {\r\n    const result = new StrokeCountMap(numStroke, curveLength, a0, a1);\r\n    result.componentIndex = componentIndex;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * create a StrokeCountMap, optionally\r\n   * * (a) use parent a1 as new a0\r\n   * * (b) attach a (usually empty) array for component counts.\r\n   * @param parentMap optional map whose a1 becomes a0 in the new map.\r\n   * @param componentData optional array of component StrokeCountMaps.\r\n   */\r\n  public static createWithCurvePrimitiveAndOptionalParent(curvePrimitive: CurvePrimitive, parentMap?: StrokeCountMap, componentData?: StrokeCountMap[]): StrokeCountMap {\r\n    const a0 = parentMap ? parentMap.a1 : 0.0;\r\n    const result = new StrokeCountMap(0, 0, a0, a0, componentData);\r\n    result.primitive = curvePrimitive;\r\n    return result;\r\n\r\n  }\r\n  /**\r\n   * Apply stroke count and curve length from a component to a parent map.\r\n   * If componentData is present, install the new count and length with distance limits\r\n   * @param parentMap map to be updated.\r\n   * @param numStroke number of strokes on new child curve\r\n   * @param curveLength curve length for new child curve.\r\n   */\r\n  public addToCountAndLength(numStroke: number, curveLength: number) {\r\n    const a2 = this.a1 + curveLength;\r\n    if (this.componentData) {\r\n      this.componentData.push(\r\n        new StrokeCountMap(numStroke, curveLength, this.a1, a2));\r\n    }\r\n    this.numStroke += numStroke;\r\n    this.curveLength += curveLength;\r\n    this.a1 = a2;\r\n  }\r\n  /** return true if `other` has the same component structure as `this`\r\n   * * testing recursives through corresponding members of cmomponentData arrays.\r\n   */\r\n  public isCompatibleComponentStructure(other: StrokeCountMap, enforceCounts: boolean): boolean {\r\n    if (enforceCounts && this.numStroke !== other.numStroke)\r\n      return false;\r\n    if (this.componentData === undefined && other.componentData === undefined)\r\n      return true;\r\n    if (this.componentData && other.componentData) {\r\n      // both have components. Recurse . . ..\r\n      if (this.componentData.length !== other.componentData.length)\r\n        return false;\r\n      const n = this.componentData.length;\r\n      for (let i = 0; i < n; i++)\r\n        if (!this.componentData[i].isCompatibleComponentStructure(other.componentData[i], enforceCounts))\r\n          return false;\r\n      return true;\r\n    }\r\n    // one has componentData, the other not.\r\n    return false;\r\n  }\r\n  /**\r\n   * * clone all data from root.\r\n   * * clone componentData arrays recursively.\r\n   */\r\n  public clone(): StrokeCountMap {\r\n    const a = new StrokeCountMap(this.numStroke, this.curveLength, this.a0, this.a1);\r\n    if (this.componentData) {\r\n      a.componentData = [];\r\n      for (const child of this.componentData)\r\n        a.componentData.push(child.clone());\r\n    }\r\n    return a;\r\n  }\r\n  /**\r\n   * interpolate in the a0,a1 mapping.\r\n   * @param fraction fractional position between a0 and a1\r\n   */\r\n  public fractionToA(fraction: number) {\r\n    return Geometry.interpolate(this.a0, fraction, this.a1);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\n/* tslint:disable:variable-name no-empty */\r\n\r\n/** tolerance blob for various stroking methods.\r\n *\r\n * * Across many applications, the critical concepts are:   chordTol, angleTol, maxEdgeLength\r\n * * Chord error is an distance measured from a curve or facet to its approximating stroke or facet.\r\n * * angle is the angle between two contiguous strokes or across a facet edge.\r\n * * maxEdgeLength is the length of a stroke or a edge of a facet.\r\n *\r\n * It is rare for all three to be active at once:\r\n * * Nearly all stroke and facet use cases will apply an angle tolerance.\r\n * * * For curves, 15 degrees is typical\r\n * * * For facets, 22.5 degrees is typical.\r\n * * * Halving the angle tolerance will (roughly) make curves get twice as many strokes, and surfaces get 4 times as many facets.\r\n * * * The angle tolerance has the useful property that its effect is independent of scale of that data.  If data is suddenly scaled into millimeters rather than meters, the facet counts remain the same.\r\n * * When creating output for devices such as 3D printing will want a chord tolerance.\r\n * * For graphics display, use an angle tolerance of around 15 degrees and an chord tolerance which is the size of several pixels.\r\n * * Analysis meshes (e.g. Finite Elements) commonly need to apply maxEdgeLength.\r\n * * * Using maxEdgeLength for graphics probably produces too many facets.   For example, it causes long cylinders to get many nearly-square facets instead of the small number of long quads usually used for graphics.\r\n * * Facet tolerances are, as the Pirates' Code, guidelines, not absolute rules.   Facet and stroke code may ignore tolerances in awkward situations.\r\n * * If multiple tolerances are in effect, the actual count will usually be based on the one that demands the most strokes or facets, unless it is so high that it violates some upper limit on the number of facets on an arc or a section of a curve.\r\n * @public\r\n */\r\nexport class StrokeOptions {\r\n\r\n  /** distance from stroke to actual geometry */\r\n  public chordTol?: number;\r\n  /** turning angle between strokes. */\r\n  public angleTol?: Angle;\r\n  /** maximum length of a single stroke. */\r\n  public maxEdgeLength?: number;\r\n  /** caller expects convex facets.  */\r\n  public needConvexFacets?: boolean;\r\n  /** minimum strokes on a primitive */\r\n  public minStrokesPerPrimitive?: number;\r\n  /** whether or not to triangulate each added facet */\r\n  public shouldTriangulate: boolean = false;\r\n  private _needNormals?: boolean;\r\n  private _needParams?: boolean;\r\n  /** ask if params are requested. */\r\n  public get needParams(): boolean { return this._needParams !== undefined ? this._needParams : false; }\r\n  /** set the params request flag */\r\n  public set needParams(value: boolean) { this._needParams = value; }\r\n  /** ask if normals are requested */\r\n  public get needNormals(): boolean { return this._needNormals !== undefined ? this._needNormals : false; }\r\n  /** set the normals request flag */\r\n  public set needNormals(value: boolean) { this._needNormals = value; }\r\n  /** optional color request flag */\r\n  public needColors?: boolean;\r\n  /** default number of strokes for a circle. */\r\n  public defaultCircleStrokes = 16;\r\n  /** ask if maxEdgeLength is specified */\r\n  public get hasMaxEdgeLength(): boolean { return this.maxEdgeLength !== undefined && this.maxEdgeLength > 0.0; }\r\n  /** return stroke count which is the larger of the minCount or count needed for edge length condition. */\r\n  public applyMaxEdgeLength(minCount: number, totalLength: number): number {\r\n    if (this.maxEdgeLength && this.maxEdgeLength > 0.0 && minCount * this.maxEdgeLength < totalLength) {\r\n      minCount = Geometry.stepCount(this.maxEdgeLength, totalLength, minCount);\r\n    }\r\n    return minCount;\r\n  }\r\n\r\n  /**\r\n   * return stroke count which is the larger of the existing count or count needed for angle condition for given sweepRadians\r\n   * * defaultStepRadians is assumed to be larger than zero.\r\n   */\r\n  public applyAngleTol(minCount: number, sweepRadians: number, defaultStepRadians: number): number {\r\n    return StrokeOptions.applyAngleTol(this, minCount, sweepRadians, defaultStepRadians);\r\n  }\r\n  /**\r\n   * return stroke count which is the larger of minCount and the count required to turn sweepRadians, using tolerance from the options.\r\n   */\r\n  public static applyAngleTol(options: StrokeOptions | undefined, minCount: number, sweepRadians: number, defaultStepRadians?: number): number {\r\n    sweepRadians = Math.abs(sweepRadians);\r\n    let stepRadians = defaultStepRadians ? defaultStepRadians : Math.PI / 8.0;\r\n    if (options && options.angleTol && options.angleTol.radians > 0.0)\r\n      stepRadians = options.angleTol.radians;\r\n    if (minCount * stepRadians < sweepRadians)\r\n      minCount = Geometry.stepCount(stepRadians, sweepRadians, minCount);\r\n    return minCount;\r\n  }\r\n  /**\r\n   * Return the number of strokes needed for given edgeLength curve.\r\n   * @param options\r\n   * @param minCount smallest allowed count\r\n   * @param edgeLength\r\n   */\r\n  public static applyMaxEdgeLength(options: StrokeOptions | undefined, minCount: number, edgeLength: number): number {\r\n    if (edgeLength < 0)\r\n      edgeLength = - edgeLength;\r\n    if (minCount < 1)\r\n      minCount = 1;\r\n    if (options && options.maxEdgeLength && options.maxEdgeLength * minCount < edgeLength) {\r\n      minCount = Geometry.stepCount(options.maxEdgeLength, edgeLength, minCount);\r\n    }\r\n    return minCount;\r\n  }\r\n  /**\r\n   * Determine a stroke count for a (partial) circular arc of given radius. This considers angle, maxEdgeLength, chord, and minimum stroke.\r\n   */\r\n  public applyTolerancesToArc(radius: number, sweepRadians: number = Math.PI * 2): number {\r\n    let numStrokes = 1;\r\n    numStrokes = this.applyAngleTol(numStrokes, sweepRadians, Math.PI * 0.25);\r\n    numStrokes = this.applyMaxEdgeLength(numStrokes, sweepRadians * radius);\r\n    numStrokes = this.applyChordTol(numStrokes, radius, sweepRadians);\r\n    numStrokes = this.applyMinStrokesPerPrimitive(numStrokes);\r\n    return numStrokes;\r\n  }\r\n\r\n  /** return stroke count which is the larger of existing count or count needed for circular arc chord tolerance condition. */\r\n  public applyChordTol(minCount: number, radius: number, sweepRadians: number): number {\r\n    if (this.chordTol && this.chordTol > 0.0 && this.chordTol < radius) {\r\n      const a = this.chordTol;\r\n      const stepRadians = 2.0 * Math.acos((1.0 - a / radius));\r\n      minCount = Geometry.stepCount(stepRadians, sweepRadians, minCount);\r\n    }\r\n    return minCount;\r\n  }\r\n  /** return stroke count which is the larger of existing count or `this.minStrokesPerPrimitive` */\r\n  public applyMinStrokesPerPrimitive(minCount: number): number {\r\n    if (this.minStrokesPerPrimitive !== undefined && Number.isFinite(this.minStrokesPerPrimitive)\r\n      && this.minStrokesPerPrimitive > minCount)\r\n      minCount = this.minStrokesPerPrimitive;\r\n    return minCount;\r\n  }\r\n\r\n  /** create `StrokeOptions` with defaults appropriate for curves.\r\n   * * angle tolerance of 15 degrees.\r\n   * * all others inactive.\r\n   */\r\n  public static createForCurves(): StrokeOptions {\r\n    const options = new StrokeOptions();\r\n    options.angleTol = Angle.createDegrees(15.0);\r\n    return options;\r\n  }\r\n  /** create `StrokeOptions` with defaults appropriate for surfaces facets\r\n   * * angle tolerance of 22.5 degrees.\r\n   * * all others inactive.\r\n   */\r\n  public static createForFacets(): StrokeOptions {\r\n    const options = new StrokeOptions();\r\n    options.angleTol = Angle.createDegrees(22.5);\r\n    return options;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\n\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Quadrature } from \"../numerics/Quadrature\";\r\nimport { GeometryHandler, IStrokeHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { CurvePrimitive } from \"./CurvePrimitive\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\n\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { LineString3d } from \"./LineString3d\";\r\n// import {} from \"./\";\r\n\r\n/** A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.\r\n * * The symmetry condition creates a relationship among the following 4 quantities:\r\n * ** curvature0 = curvature (i.e. 1/radius) at start\r\n * ** curvature1 = curvature (i.e. 1/radius) at end\r\n * ** sweepRadians = signed turning angle from start to end\r\n * ** arcLength = length of curve\r\n * * The relationship is the equation\r\n * ** `sweepRadians = arcLength * average Curvature = arcLength * 0.5 * (curvature0 + curvature1)`\r\n * * That is, regardless of any curvature properties other than symmetry, specifying any 3 of the quantities fully determines the remaining one.\r\n * @alpha\r\n */\r\nexport class TransitionConditionalProperties {\r\n  /** radius (or 0 at start) */\r\n  public radius0: number | undefined;\r\n  /** radius (or 0) at end */\r\n  public radius1: number | undefined;\r\n  /** bearing at start, measured from x towards y */\r\n  public bearing0: Angle | undefined;\r\n  /** bearing at end, measured from x towards y */\r\n  public bearing1: Angle | undefined;\r\n  /** curve length */\r\n  public curveLength: number | undefined;\r\n  /**\r\n   * capture numeric or undefined values\r\n   * @param radius0 start radius or undefined\r\n   * @param radius1 end radius or undefined\r\n   * @param bearing0 start bearing or undefined\r\n   * @param bearing1 end bearing or undefined\r\n   * @param arcLength arc length or undefined\r\n   */\r\n  public constructor(\r\n    radius0: number | undefined,\r\n    radius1: number | undefined,\r\n    bearing0: Angle | undefined,\r\n    bearing1: Angle | undefined,\r\n    arcLength: number | undefined,\r\n  ) {\r\n    this.radius0 = radius0;\r\n    this.radius1 = radius1;\r\n    this.bearing0 = bearing0;\r\n    this.bearing1 = bearing1;\r\n    this.curveLength = arcLength;\r\n  }\r\n  /** return the number of defined values among the 5 properties. */\r\n  public numDefinedProperties() {\r\n    return Geometry.defined01(this.radius0)\r\n      + Geometry.defined01(this.radius1)\r\n      + Geometry.defined01(this.bearing0)\r\n      + Geometry.defined01(this.bearing1)\r\n      + Geometry.defined01(this.curveLength);\r\n  }\r\n  /** clone with all properties (i.e. preserve undefined states) */\r\n  public clone(): TransitionConditionalProperties {\r\n    return new TransitionConditionalProperties(\r\n      this.radius0,\r\n      this.radius1,\r\n      this.bearing0 === undefined ? undefined : this.bearing0.clone(),\r\n      this.bearing1 === undefined ? undefined : this.bearing1.clone(),\r\n      this.curveLength);\r\n  }\r\n  /** Examine which properties are defined and compute the (single) undefined.\r\n   * @returns Return true if the input state had precisely one undefined member.\r\n   */\r\n  public tryResolveAnySingleUnknown(): boolean {\r\n    if (this.bearing0 && this.bearing1) {\r\n      const sweepRadians = this.bearing1.radians - this.bearing0.radians;\r\n      if (this.curveLength === undefined && this.radius0 !== undefined && this.radius1 !== undefined) {\r\n        this.curveLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(this.radius0, this.radius1, sweepRadians);\r\n        return true;\r\n      }\r\n      if (this.curveLength !== undefined && this.radius0 === undefined && this.radius1 !== undefined) {\r\n        this.radius0 = TransitionSpiral3d.radius1LengthSweepRadiansToRadius0(this.radius1, this.curveLength, sweepRadians);\r\n        return true;\r\n      }\r\n      if (this.curveLength !== undefined && this.radius0 !== undefined && this.radius1 === undefined) {\r\n        this.radius1 = TransitionSpiral3d.radius0LengthSweepRadiansToRadius1(this.radius0, this.curveLength, sweepRadians);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    // at least one bearing is undefined ...\r\n    if (this.curveLength === undefined || this.radius0 === undefined || this.radius1 === undefined)\r\n      return false;\r\n\r\n    if (this.bearing0) {// bearing 1 is undefined\r\n      this.bearing1 = Angle.createRadians(this.bearing0.radians + TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));\r\n      return true;\r\n    }\r\n\r\n    if (this.bearing1) {// bearing 0 is undefined\r\n      this.bearing0 = Angle.createRadians(this.bearing1.radians - TransitionSpiral3d.radiusRadiusLengthToSweepRadians(this.radius0, this.radius1, this.curveLength));\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  private almostEqualCoordinate(a: number | undefined, b: number | undefined): boolean {\r\n    if (a === undefined && b === undefined)\r\n      return true;\r\n    if (a !== undefined && b !== undefined)\r\n      return Geometry.isSameCoordinate(a, b);\r\n    return false;\r\n  }\r\n  private almostEqualBearing(a: Angle | undefined, b: Angle | undefined): boolean {\r\n    if (a === undefined && b === undefined)\r\n      return true;\r\n    if (a !== undefined && b !== undefined)\r\n      return a.isAlmostEqualNoPeriodShift(b);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Test if this and other have matching numeric and undefined members.\r\n   */\r\n  public isAlmostEqual(other: TransitionConditionalProperties) {\r\n    if (!this.almostEqualCoordinate(this.radius0, other.radius0))\r\n      return false;\r\n    if (!this.almostEqualCoordinate(this.radius1, other.radius1))\r\n      return false;\r\n    if (!this.almostEqualBearing(this.bearing0, other.bearing0))\r\n      return false;\r\n    if (!this.almostEqualBearing(this.bearing1, other.bearing1))\r\n      return false;\r\n    if (!this.almostEqualCoordinate(this.curveLength, other.curveLength))\r\n      return false;\r\n    return true;\r\n  }\r\n}\r\n/**\r\n * A transition spiral is a curve defined by its curvature, with the curvature function symmetric about midpoint.\r\n * * `TransitionConditionalProperties` implements the computations of the interrelationship of radii, bearing, and length.\r\n * @alpha\r\n */\r\nexport class TransitionSpiral3d extends CurvePrimitive {\r\n  /** Return 1/r with convention that if true zero is given as radius it represents infinite radius (0 curvature, straight line) */\r\n  public static radiusToCurvature(radius: number): number { return (radius === 0.0) ? 0.0 : 1.0 / radius; }\r\n\r\n  /** Return 1/k with convention that if near-zero is given as curvature, its infinite radius is returned as 0 */\r\n  public static curvatureToRadius(curvature: number): number {\r\n    if (Math.abs(curvature) < Geometry.smallAngleRadians)\r\n      return 0.0;\r\n    return 1.0 / curvature;\r\n  }\r\n\r\n  /** Return the average of the start and end curvatures. */\r\n  public static averageCurvature(radiusLimits: Segment1d): number {\r\n    return 0.5 * (TransitionSpiral3d.radiusToCurvature(radiusLimits.x0) + TransitionSpiral3d.radiusToCurvature(radiusLimits.x1));\r\n  }\r\n  /**\r\n   * Given two radii (or zeros for 0 curvature) return the average curvature\r\n   * @param r0 start radius, or 0 for line\r\n   * @param r1 end radius, or 0 for line\r\n   */\r\n  public static averageCurvatureR0R1(r0: number, r1: number): number {\r\n    return 0.5 * (TransitionSpiral3d.radiusToCurvature(r0) + TransitionSpiral3d.radiusToCurvature(r1));\r\n  }\r\n  /** Return the arc length of a transition spiral with given sweep and radius pair. */\r\n  public static radiusRadiusSweepRadiansToArcLength(radius0: number, radius1: number, sweepRadians: number): number {\r\n    return Math.abs(sweepRadians / TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1));\r\n  }\r\n\r\n  /** Return the turn angle for spiral of given length between two radii */\r\n  public static radiusRadiusLengthToSweepRadians(radius0: number, radius1: number, arcLength: number): number {\r\n    return TransitionSpiral3d.averageCurvatureR0R1(radius0, radius1) * arcLength;\r\n  }\r\n\r\n  /** Return the end radius for spiral of given start radius, length, and turn angle. */\r\n  public static radius0LengthSweepRadiansToRadius1(radius0: number, arcLength: number, sweepRadians: number) {\r\n    return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius0));\r\n  }\r\n  /** Return the start radius for spiral of given end radius, length, and turn angle. */\r\n  public static radius1LengthSweepRadiansToRadius0(radius1: number, arcLength: number, sweepRadians: number) {\r\n    return TransitionSpiral3d.curvatureToRadius((2.0 * sweepRadians / arcLength) - TransitionSpiral3d.radiusToCurvature(radius1));\r\n  }\r\n  /** Fractional interval for the \"active\" part of a containing spiral.\r\n   * (The radius, angle, and length conditions define a complete spiral, and some portion of it is \"active\")\r\n   */\r\n  public activeFractionInterval: Segment1d;\r\n  /** start and end radii as a Segment1d */\r\n  public radius01: Segment1d;\r\n  /** start and end bearings as an AngleSweep */\r\n  public bearing01: AngleSweep;\r\n  /** Placement transform */\r\n  public localToWorld: Transform;\r\n  /** stroked approximation */\r\n  private _strokes: LineString3d;\r\n  /** Total curve arc length (computed) */\r\n  private _arcLength01: number;\r\n  /** Curvatures (inverse radii) at start and end */\r\n  private _curvature01: Segment1d;\r\n  /** string name of spiral type */\r\n  private _spiralType: string | undefined;\r\n  /** Original defining properties. */\r\n  private _properties: TransitionConditionalProperties | undefined;\r\n  // constructor demands all bearing, radius, and length data -- caller determines usual dependency of \"any 4 determine the 5th\"\r\n  constructor(spiralType: string | undefined,\r\n    radius01: Segment1d,\r\n    bearing01: AngleSweep,\r\n    activeFractionInterval: Segment1d,\r\n    localToWorld: Transform,\r\n    arcLength: number,\r\n    properties: TransitionConditionalProperties | undefined) {\r\n    super();\r\n    this._spiralType = spiralType;\r\n    this.localToWorld = localToWorld;\r\n    this.radius01 = radius01;\r\n    this.bearing01 = bearing01;\r\n    this.localToWorld = localToWorld;\r\n    this.activeFractionInterval = activeFractionInterval;\r\n    this._arcLength01 = arcLength;\r\n    this._strokes = LineString3d.create();\r\n    // initialize for compiler -- but this will be recomputed in refreshComputeProperties ...\r\n    this._curvature01 = Segment1d.create(0, 1);\r\n    this.refreshComputedProperties();\r\n    this._properties = properties;\r\n  }\r\n  /** Return the original defining properties (if any) saved by the constructor. */\r\n  public get originalProperties(): TransitionConditionalProperties | undefined { return this._properties; }\r\n  /** default spiral type name. (clothoid) */\r\n  public static readonly defaultSpiralType = \"clothoid\";\r\n  /** return the spiral type as a string (undefined resolves to default type \"clothoid\") */\r\n  public getSpiralType(): string { if (this._spiralType === undefined) return TransitionSpiral3d.defaultSpiralType; return this._spiralType; }\r\n  /** Return the bearing at given fraction .... */\r\n  public fractionToBearingRadians(fraction: number): number {\r\n    // BUG? active interval?\r\n    return this.bearing01.startRadians + fraction * (this._curvature01.x0 + 0.5 * fraction * (this._curvature01.x1 - this._curvature01.x0));\r\n  }\r\n  /** Return the curvature at given fraction ... */\r\n  public fractionToCurvature(fraction: number): number {\r\n    // BUG? active interval\r\n    return this._curvature01.fractionToPoint(fraction);\r\n  }\r\n\r\n  // These static variables are reused on calls to integrateFromStartFraction\r\n  private static _gaussFraction: Float64Array;\r\n  private static _gaussWeight: Float64Array;\r\n  private static _gaussMapper: (xA: number, xB: number, arrayX: Float64Array, arrayW: Float64Array) => number;\r\n  /** Initialize class level work arrays. */\r\n  public static initWorkSpace() {\r\n    TransitionSpiral3d._gaussFraction = new Float64Array(5);\r\n    TransitionSpiral3d._gaussWeight = new Float64Array(5);\r\n    TransitionSpiral3d._gaussMapper = Quadrature.setupGauss5;\r\n  }\r\n  /** Evaluate and sum the gauss quadrature formulas to integrate cos(theta), sin(theta) fractional subset of a reference length.\r\n   * (recall that theta is a nonlinear function of the fraction.)\r\n   * * This is a single interval of gaussian integration.\r\n   * * The fraction is on the full spiral (not in the mapped active interval)\r\n   * @param xyz advancing integrated point.\r\n   * @param fractionA fraction at start of interval\r\n   * @param fractionB fraction at end of interval.\r\n   * @param unitArcLength length of curve for 0 to 1 fractional\r\n   */\r\n  private fullSpiralIncrementalIntegral(xyz: Point3d, fractionA: number, fractionB: number) {\r\n    const gaussFraction = TransitionSpiral3d._gaussFraction;\r\n    const gaussWeight = TransitionSpiral3d._gaussWeight;\r\n    const numEval = TransitionSpiral3d._gaussMapper(fractionA, fractionB, gaussFraction, gaussWeight);\r\n    const deltaL = this._arcLength01;\r\n    let w = 0;\r\n    for (let k = 0; k < numEval; k++) {\r\n      const radians = this.fractionToBearingRadians(gaussFraction[k]);\r\n      w = gaussWeight[k] * deltaL;\r\n      xyz.x += w * Math.cos(radians);\r\n      xyz.y += w * Math.sin(radians);\r\n    }\r\n\r\n  }\r\n  /** Recompute strokes */\r\n  public refreshComputedProperties() {\r\n    this._curvature01 = Segment1d.create(\r\n      TransitionSpiral3d.radiusToCurvature(this.radius01.x0),\r\n      TransitionSpiral3d.radiusToCurvature(this.radius01.x1));\r\n    this._strokes.clear();\r\n    const currentPoint = Point3d.create();\r\n    this._strokes.appendStrokePoint(currentPoint);\r\n    const numInterval = 8;\r\n\r\n    const fractionStep = 1.0 / numInterval;\r\n    for (let i = 1; i <= numInterval; i++) {\r\n      const fraction0 = (i - 1) * fractionStep;\r\n      const fraction1 = i * fractionStep;\r\n      this.fullSpiralIncrementalIntegral(currentPoint, fraction0, fraction1);\r\n      this._strokes.appendStrokePoint(currentPoint);\r\n    }\r\n    this._strokes.tryTransformInPlace(this.localToWorld);\r\n  }\r\n  /**\r\n   * Create a transition spiral with radius and bearing conditions.\r\n   * @param radius01 radius (inverse curvature) at start and end. (radius of zero means straight line)\r\n   * @param bearing01 bearing angles at start and end.  bearings are measured from the x axis, positive clockwise towards y axis\r\n   * @param activeFractionInterval fractional limits of the active portion of the spiral.\r\n   * @param localToWorld placement frame.  Fractional coordinate 0 is at the origin.\r\n   */\r\n  public static createRadiusRadiusBearingBearing(radius01: Segment1d, bearing01: AngleSweep, activeFractionInterval: Segment1d, localToWorld: Transform) {\r\n    const arcLength = TransitionSpiral3d.radiusRadiusSweepRadiansToArcLength(radius01.x0, radius01.x1, bearing01.sweepRadians);\r\n    return new TransitionSpiral3d(\"clothoid\",\r\n      radius01.clone(),\r\n      bearing01.clone(), activeFractionInterval.clone(), localToWorld.clone(), arcLength,\r\n      new TransitionConditionalProperties(radius01.x0, radius01.x1,\r\n        bearing01.startAngle.clone(), bearing01.endAngle.clone(),\r\n        undefined));\r\n  }\r\n  /**\r\n   * Create a transition spiral.\r\n   * * Inputs must provide exactly 4 of the 5 values `[radius0,radius1,bearing0,bearing1,length`.\r\n   * @param spiralType one of \"clothoid\", \"bloss\", \"biquadratic\", \"cosine\", \"sine\".  If undefined, \"clothoid\" is used.\r\n   * @param radius0 radius (or 0 for tangent to line) at start\r\n   * @param radius1 radius (or 0 for tangent to line) at end\r\n   * @param bearing0 bearing, measured CCW from x axis at start.\r\n   * @param bearing1 bearing, measured CCW from x axis at end.\r\n   * @param fractionInterval optional fractional interval for an \"active\" portion of the curve.   if omitted, the full [0,1] is used.\r\n   * @param localToWorld placement transform\r\n   */\r\n  public static create(\r\n    spiralType: string | undefined,\r\n    radius0: number | undefined,\r\n    radius1: number | undefined,\r\n    bearing0: Angle | undefined,\r\n    bearing1: Angle | undefined,\r\n    arcLength: number | undefined,\r\n    fractionInterval: undefined | Segment1d,\r\n    localToWorld: Transform): TransitionSpiral3d | undefined {\r\n    const data = new TransitionConditionalProperties(radius0, radius1, bearing0, bearing1, arcLength);\r\n    const data1 = data.clone();\r\n    if (!data.tryResolveAnySingleUnknown())\r\n      return undefined;\r\n    if (fractionInterval === undefined)\r\n      fractionInterval = Segment1d.create(0, 1);\r\n    return new TransitionSpiral3d(\r\n      spiralType,\r\n      Segment1d.create(data.radius0, data.radius1),\r\n      AngleSweep.createStartEnd(data.bearing0!, data.bearing1!),\r\n      fractionInterval ? fractionInterval.clone() : Segment1d.create(0, 1),\r\n      localToWorld, data.curveLength!, data1);\r\n  }\r\n  /** Copy all defining data from another spiral. */\r\n  public setFrom(other: TransitionSpiral3d): TransitionSpiral3d {\r\n    this.localToWorld.setFrom(other.localToWorld);\r\n    this.radius01.setFrom(other.radius01);\r\n    this._curvature01.setFrom(other._curvature01);\r\n    this.bearing01.setFrom(other.bearing01);\r\n    this.localToWorld.setFrom(other.localToWorld);\r\n    this.activeFractionInterval.setFrom(other.activeFractionInterval);\r\n    this._arcLength01 = other._arcLength01;\r\n    return this;\r\n  }\r\n  /** Deep clone of this spiral */\r\n  public clone(): TransitionSpiral3d {\r\n    return TransitionSpiral3d.createRadiusRadiusBearingBearing(this.radius01, this.bearing01, this.activeFractionInterval, this.localToWorld);\r\n  }\r\n  /** apply `transform` to this spiral's local to world transform. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyTransformTransform(this.localToWorld, this.localToWorld);\r\n    return true;\r\n  }\r\n  /** Clone with a transform applied  */\r\n  public cloneTransformed(transform: Transform): TransitionSpiral3d {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);  // ok, we're confident it will always work.\r\n    return result;\r\n  }\r\n  /** Return the spiral start point. */\r\n  public startPoint(): Point3d { return this._strokes.startPoint(); }\r\n  /** return the spiral end point. */\r\n  public endPoint(): Point3d { return this._strokes.endPoint(); }\r\n  /** test if the local to world transform places the spiral xy plane into `plane` */\r\n  public isInPlane(plane: Plane3dByOriginAndUnitNormal): boolean {\r\n    return plane.isPointInPlane(this.localToWorld.origin as Point3d)\r\n      && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnX(plane.getNormalRef()))\r\n      && Geometry.isSameCoordinate(0.0, this.localToWorld.matrix.dotColumnY(plane.getNormalRef()));\r\n  }\r\n  /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\r\n  public quickLength() { return this._arcLength01; }\r\n  /** Return length of the spiral.  Because TransitionSpiral is parameterized directly in terms of distance along, this is a simple return value. */\r\n  public curveLength() { return this._arcLength01; }\r\n  /** Test if `other` is an instance of `TransitionSpiral3d` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof TransitionSpiral3d; }\r\n  /** Add strokes from this spiral to `dest` */\r\n  public emitStrokes(dest: LineString3d, options?: StrokeOptions): void { this._strokes.emitStrokes(dest, options); }\r\n  /** emit srokeable fragments to `dest` handler. */\r\n  public emitStrokableParts(dest: IStrokeHandler, options?: StrokeOptions): void {\r\n    dest.startParentCurvePrimitive(this);\r\n    this._strokes.emitStrokableParts(dest, options);\r\n    dest.endParentCurvePrimitive(this);\r\n  }\r\n\r\n  /**\r\n   * return the stroke count required for given options.\r\n   * @param options StrokeOptions that determine count\r\n   */\r\n  public computeStrokeCountForOptions(options?: StrokeOptions): number {\r\n    let numStroke = 1;\r\n    if (options) {\r\n      const rMin = Math.min(Math.abs(this.radius01.x0), Math.abs(this.radius01.x1));\r\n      numStroke = options.applyTolerancesToArc(rMin, this.bearing01.sweepRadians);\r\n      numStroke = options.applyMaxEdgeLength(numStroke, this.curveLength());\r\n      numStroke = options.applyMinStrokesPerPrimitive(numStroke);\r\n    } else {\r\n      numStroke = StrokeOptions.applyAngleTol(undefined, 4, this.bearing01.sweepRadians);\r\n    }\r\n    return numStroke;\r\n  }\r\n\r\n  /** Reverse the active interval and strokes. */\r\n  public reverseInPlace(): void {\r\n    this.activeFractionInterval.reverseInPlace();\r\n    this._strokes.reverseInPlace();\r\n  }\r\n  /** Evaluate curve point with respect to fraction. */\r\n  public fractionToPoint(fraction: number, result?: Point3d): Point3d {\r\n    fraction = Geometry.clampToStartEnd(fraction, 0, 1);\r\n    const numStrokes = this._strokes.points.length - 1;\r\n    const index0 = Math.trunc(fraction * numStrokes); // This indexes the point to the left of the query\r\n    const fraction0 = index0 / numStrokes;\r\n    result = result ? result : new Point3d();\r\n    result.setFrom(this._strokes.points[index0]);\r\n    const globalFraction0 = this.activeFractionInterval.fractionToPoint(fraction0);\r\n    const globalFraction1 = this.activeFractionInterval.fractionToPoint(fraction);\r\n    this.fullSpiralIncrementalIntegral(result, globalFraction0, globalFraction1);\r\n    this.localToWorld.multiplyPoint3d(result, result);\r\n    return result;\r\n  }\r\n  /** Evaluate curve point and derivative with respect to fraction. */\r\n  public fractionToPointAndDerivative(fraction: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    this.fractionToPoint(fraction, result.origin);\r\n    const radians = this.fractionToBearingRadians(fraction);\r\n    const a = this._arcLength01;\r\n    this.localToWorld.matrix.multiplyXY(a * Math.cos(radians), a * Math.sin(radians), result.direction);\r\n    return result;\r\n  }\r\n\r\n  /** Return the frenet frame at fractional position. */\r\n  public fractionToFrenetFrame(fraction: number, result?: Transform): Transform {\r\n    result = result ? result : Transform.createIdentity();\r\n    result.origin.setFrom(this.fractionToPoint(fraction));\r\n    Matrix3d.createRigidFromMatrix3d(this.localToWorld.matrix, AxisOrder.XYZ, result.matrix);\r\n\r\n    const radians = this.fractionToBearingRadians(fraction);\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    result.matrix.applyGivensColumnOp(0, 1, c, -s);\r\n    return result;\r\n  }\r\n  /** Return a plane with\r\n   *\r\n   * * origin at fractional position along the curve\r\n   * * vectorU is the first derivative, i.e. tangent vector with length equal to the rate of change with respect to the fraction.\r\n   * * vectorV is the second derivative, i.e.derivative of vectorU.\r\n   */\r\n  public fractionToPointAnd2Derivatives(fraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors | undefined {\r\n    const origin = this.fractionToPoint(fraction);\r\n    const radians = this.fractionToBearingRadians(fraction);\r\n    const c = Math.cos(radians);\r\n    const s = Math.sin(radians);\r\n    const vectorX = this.localToWorld.matrix.multiplyXY(c, s);\r\n    const vectorY = this.localToWorld.matrix.multiplyXY(-s, c);\r\n    vectorY.scaleInPlace(this.fractionToCurvature(fraction));\r\n    return Plane3dByOriginAndVectors.createCapture(origin, vectorX, vectorY, result);\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleTransitionSpiral(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleTransitionSpiral(this);\r\n  }\r\n  /** extend the range by the strokes of the spiral */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    this._strokes.extendRange(rangeToExtend, transform);\r\n  }\r\n  /** compare various coordinate quantities */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof TransitionSpiral3d) {\r\n      return this.radius01.isAlmostEqual(other.radius01)\r\n        && this.bearing01.isAlmostEqualAllowPeriodShift(other.bearing01)\r\n        && this.localToWorld.isAlmostEqual(other.localToWorld)\r\n        && Geometry.isSameCoordinate(this._arcLength01, other._arcLength01)\r\n        && this.activeFractionInterval.isAlmostEqual(other.activeFractionInterval)\r\n        && this._curvature01.isAlmostEqual(other._curvature01);\r\n    }\r\n    return false;\r\n  }\r\n\r\n}\r\n// at load time, initialize gauss quadrature workspace\r\nTransitionSpiral3d.initWorkSpace();\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Curve */\r\nimport { StrokeOptions } from \"./StrokeOptions\";\r\nimport { GeometryQuery } from \"./GeometryQuery\";\r\nimport { RecursiveCurveProcessor } from \"./CurveProcessor\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { CurveCollection } from \"./CurveCollection\";\r\nimport { Loop } from \"./Loop\";\r\nimport { ParityRegion } from \"./ParityRegion\";\r\nimport { AnyCurve } from \"./CurveChain\";\r\n/**\r\n * * A `UnionRegion` is a collection of other planar region types -- `Loop` and `ParityRegion`.\r\n * * The composite is the union of the contained regions.\r\n * * A point is \"in\" the composite if it is \"in\" one or more of the contained regions.\r\n * @public\r\n */\r\nexport class UnionRegion extends CurveCollection {\r\n  /** test if `other` is a `UnionRegion` */\r\n  public isSameGeometryClass(other: GeometryQuery): boolean { return other instanceof UnionRegion; }\r\n  /** collection of Loop and ParityRegion children. */\r\n  protected _children: Array<ParityRegion | Loop>;\r\n  /** Return the array of regions */\r\n  public get children(): Array<ParityRegion | Loop> { return this._children; }\r\n  /** Constructor -- initialize with no children */\r\n  public constructor() { super(); this._children = []; }\r\n  /** Create a `UnionRegion` with given region children */\r\n  public static create(...data: Array<ParityRegion | Loop>): UnionRegion {\r\n    const result = new UnionRegion();\r\n    for (const child of data) {\r\n      result.tryAddChild(child);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the boundary type (5) of a corresponding  MicroStation CurveVector */\r\n  public dgnBoundaryType(): number { return 5; }\r\n  /** dispatch to more strongly typed  `processor.announceUnionRegion(this, indexInParent)` */\r\n  public announceToCurveProcessor(processor: RecursiveCurveProcessor, indexInParent: number = -1): void {\r\n    return processor.announceUnionRegion(this, indexInParent);\r\n  }\r\n  /** Return structural clone with stroked primitives. */\r\n  public cloneStroked(options?: StrokeOptions): UnionRegion {\r\n    const clone = new UnionRegion();\r\n    let child;\r\n    for (child of this._children) {\r\n      const childStrokes = child.cloneStroked(options) as ParityRegion | Loop;\r\n      if (childStrokes)\r\n        clone.children.push(childStrokes);\r\n    }\r\n    return clone;\r\n  }\r\n  /** Return new empty `UnionRegion` */\r\n  public cloneEmptyPeer(): UnionRegion { return new UnionRegion(); }\r\n  /** add a child.\r\n   * * Returns false if the `AnyCurve` child is not a region type.\r\n   */\r\n  public tryAddChild(child: AnyCurve): boolean {\r\n    if (child instanceof ParityRegion || child instanceof Loop) {\r\n      this._children.push(child);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a child identified by index. */\r\n  public getChild(i: number): Loop | ParityRegion | undefined {\r\n    if (i < this._children.length)\r\n      return this._children[i];\r\n    return undefined;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleUnionRegion(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleUnionRegion(this);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Utility */\n\n// REMARK:\n// The docs-group-description comments are followed by empty classes with names corresponding to the doc-group.\n// Normally (in committed code) these are commented out.\n// The comments have distinctive strings so that simple search and replace can make the \"real\".\n// This is useful when working on the documentation:  When the empty classes are present, VSCode will format the doc comments\n// for and display them when the mouse hovers over the class name.\n\n/**\n * @docs-package-description\n * The geometry-core package contains classes for working with CAD geometry:  points, vectors, curves, surfaces, and analytic solids\n */\n/**\n * @docs-group-description CartesianGeometry\n * Points, Vectors, Planes, and Transformations for x,y,z geometry.\n * * Fundamental cartesian geometry objects:\n * * * Point2d, Point3d -- points with x,y,z coordinates\n * * * Vector2d, Vector3d -- vectors with x,y,z coordinates\n * * * Matrix3d -- 3x3 matrix\n * * * * commonly used for pure rotations\n * * * * scale and skew entries are also allowed.\n * * * Transform -- an origin and axes.\n * * * Range1d, Range2d, Range3d -- subsets of 1d, 2d, and 3d space bounded by low and high values.\n * * * Ray3d -- a ray defined by origin and direction vector\n * * * Plane3dByOriginAndUnitNormal -- a plane defined by an origin and a single vector which is perpendicular to the plane\n * * * plane3dByOriginAndVectors -- a plane defined by an origin and two vectors in the plane.\n * * Angles\n * * * Angle -- a strongly typed angle object whose method names make it clear whether input and outputs are degrees or radians.\n * * * AngleSweep -- an angular interval\n * * * YawPitchAndRollAngles -- 3 angles that define a rotated coordinate system.\n * * Utility classes\n * * * FrameBuilder -- construction of coordinate frames from mixed data sources.\n * * * ClipPlane -- a single plane\n * * * ConvexClipPlaneSet -- an array of planes bounding a convex volume\n * * * ClipPlaneSet -- an array of ConvexClipPlaneSet, defining the union of their volumes\n * * * Constant -- various numeric values exported as readonly constants\n */\n// doc:export class CartesianGeometryDoc { }\n/**\n * @docs-group-description ArraysAndInterfaces\n * These classes support array operations and inheritance-based algorithms.\n * * Arrays\n * * * GrowableArray -- A carrier for a Float64Array, with methods that hide reallocation of the underlying array as contents are added.\n * * * Point2dArray, Point3dArray, Point4dArray, Vector3dArray -- miscellaneous operations on arrays of 2d and 3d points.\n * * Interfaces\n * * * GeometryHandler -- a double-dispatch protocol used for efficient implementation of algorithms that work on many geometry types.\n *\n */\n// doc:export class ArraysAndInterfacesDoc { }\n\n/**\n * @docs-group-description Bspline\n * A bspline curve or surface is used for curved freeform geometry defined by controls points (sometimes called poles).\n * * BSplineCurve --  a curve in XYZ coordinates\n * * BSplineSurfaceXYZ -- a surface with XYZ\n * * BsplineSurfaceXYZW -- a surface with weighted (rational) XYZ coordinates\n * * KnotVector -- vector of breakpoints in bspline definitions.\n */\n// doc:export class BsplineDoc { }\n\n/**\n * @docs-group-description Curve\n * Curves in the GeometryQuery hierarchy: LineSegment3d, LineString3d, Arc3d, TransitionSpiral3d\n * * CurvePrimitive -- base class for parametric curves\n * * * LineSegment3d -- a (bounded) portion of an unbounded line\n * * * Arc3d -- a circular or elliptic arc\n * * * LineString3d -- a sequence of points joined by line segments\n * * * TransitionSpiral -- controlled transition between curvatures\n * * Support classes\n * * PointString3d -- a sequence of isolated points\n * * StrokeOptions -- tolerances to describe stroking accuracy\n * * RecursiveCurveProcessor, RecursiveCurveProcessorWithStack -- algorithmic support for trees with CurvePrimitives at the leaf level.\n */\n// doc:export class CurveDoc { }\n/**\n * @docs-group-description Numerics\n * The Numerics classes have geometric and numeric methods used during large algorithms in other classes.\n */\n// doc:export class NumericsDoc { }\n/**\n * @docs-group-description Polyface\n * A Polyface is a mesh structure with arrays of points that are shared among multiple incident facets.\n */\n// doc:export class PolyfaceDoc { }\n/**\n * @docs-group-description Serialization\n * These classes are related to serialization of geometry classes.\n * * IModelJson.Reader, IModelJson.Writer -- Conversion of in-memory geometry objects to json objects for persistence and transmission.\n */\n// doc:export class SerializationDoc { }\n/**\n * @docs-group-description Solid\n * Analytic Solids in the GeometryQuery hierarchy: Box, Sphere, Cone, TorusPipe, LinearSweep, RotationalSweep, RuledSweep\n * * Box -- a box solid.  This is usually rectangular on all faces, but can in one directly like a view frustum\n * * Sphere -- a sphere\n * * Cone -- a cone or cylinder\n * * TorusPipe -- a pipe elbow\n * * LinearSweep -- a linear sweep of a base contour\n * * RotationalSweep -- a rotational sweep of a base contour\n * * RuledSweep -- two or more similarly structured contours joined by linear rule lines.\n */\n// doc:export class SolidDOc { }\n/**\n * @docs-group-description Utility\n * These modules and classes are outside the geometric structure\n * * geometry-core.ts -- gathers and exports class, so callers can import from geometry-core without knowning which classes\n *        are in which files.\n */\n// doc:export class Utility { }\n/**\n * @docs-group-description Topology\n * The Topology classes provide adjacency structures used in triangulations.\n */\n// doc:export class TopologyDoc { }\n\nexport * from \"./geometry3d/Angle\";\nexport * from \"./geometry3d/AngleSweep\";\nexport * from \"./geometry3d/FrameBuilder\";\nexport * from \"./geometry3d/GeometryHandler\";\nexport * from \"./geometry3d/GrowableBlockedArray\";\nexport * from \"./geometry3d/GrowableFloat64Array\";\nexport * from \"./geometry3d/GrowableXYArray\";\nexport * from \"./geometry3d/GrowableXYZArray\";\nexport * from \"./geometry3d/IndexedXYCollection\";\nexport * from \"./geometry3d/IndexedXYZCollection\";\nexport * from \"./geometry3d/Matrix3d\";\nexport * from \"./geometry3d/OrderedRotationAngles\";\nexport * from \"./geometry3d/Plane3dByOriginAndUnitNormal\";\nexport * from \"./geometry3d/Plane3dByOriginAndVectors\";\nexport * from \"./geometry3d/Point2dArrayCarrier\";\nexport * from \"./geometry3d/Point2dVector2d\";\nexport * from \"./geometry3d/Point3dVector3d\";\nexport * from \"./geometry3d/PointHelpers\";\nexport * from \"./geometry3d/PolygonOps\";\nexport * from \"./geometry3d/Range\";\nexport * from \"./geometry3d/Ray3d\";\nexport * from \"./geometry3d/Segment1d\";\nexport * from \"./geometry3d/Transform\";\nexport * from \"./geometry3d/XYZProps\";\nexport * from \"./geometry3d/YawPitchRollAngles\";\nexport * from \"./geometry3d/FrustumAnimation\";\n\nexport * from \"./Geometry\";\nexport * from \"./Constant\";\nexport * from \"./clipping/ClipPlane\";\nexport * from \"./clipping/ConvexClipPlaneSet\";\nexport * from \"./clipping/UnionOfConvexClipPlaneSets\";\nexport * from \"./clipping/ClipPrimitive\";\nexport * from \"./clipping/ClipVector\";\nexport * from \"./clipping/ClipUtils\";\nexport * from \"./numerics/ConvexPolygon2d\";\nexport * from \"./geometry4d/PlaneByOriginAndVectors4d\";\nexport * from \"./geometry4d/Point4d\";\nexport * from \"./geometry4d/Matrix4d\";\nexport * from \"./geometry4d/Map4d\";\nexport * from \"./geometry4d/MomentData\";\nexport * from \"./numerics/BezierPolynomials\";\nexport * from \"./numerics/ClusterableArray\";\nexport * from \"./numerics/Newton\";\nexport * from \"./numerics/Complex\";\nexport * from \"./numerics/ConvexPolygon2d\";\nexport * from \"./numerics/Newton\";\nexport * from \"./numerics/PascalCoefficients\";\nexport * from \"./numerics/Polynomials\";\nexport * from \"./numerics/Quadrature\";\nexport * from \"./numerics/Range1dArray\";\nexport * from \"./numerics/TriDiagonalSystem\";\n\nexport * from \"./curve/Arc3d\";\nexport * from \"./curve/ConstructCurveBetweenCurves\";\nexport * from \"./curve/CoordinateXYZ\";\nexport * from \"./curve/CurveChain\";\nexport * from \"./curve/CurveChainWithDistanceIndex\";\nexport * from \"./curve/CurveCollection\";\nexport * from \"./curve/CurveCurveIntersectXY\";\nexport * from \"./curve/CurveLocationDetail\";\nexport * from \"./curve/CurvePrimitive\";\nexport * from \"./curve/CurveProcessor\";\nexport * from \"./curve/GeometryQuery\";\nexport * from \"./curve/LineSegment3d\";\nexport * from \"./curve/LineString3d\";\nexport * from \"./curve/Loop\";\nexport * from \"./curve/ParityRegion\";\nexport * from \"./curve/Path\";\nexport * from \"./curve/PointString3d\";\nexport * from \"./curve/StrokeOptions\";\nexport * from \"./curve/TransitionSpiral\";\nexport * from \"./curve/UnionRegion\";\nexport * from \"./curve/Query/StrokeCountMap\";\nexport * from \"./solid/Box\";\nexport * from \"./solid/Cone\";\nexport * from \"./solid/LinearSweep\";\nexport * from \"./solid/RotationalSweep\";\nexport * from \"./solid/RuledSweep\";\nexport * from \"./solid/SolidPrimitive\";\nexport * from \"./solid/Sphere\";\nexport * from \"./solid/SweepContour\";\nexport * from \"./solid/TorusPipe\";\nexport * from \"./bspline/Bezier1dNd\";\nexport * from \"./bspline/BezierCurveBase\";\nexport * from \"./bspline/BezierCurve3d\";\nexport * from \"./bspline/BezierCurve3dH\";\nexport * from \"./bspline/BSplineCurve\";\nexport * from \"./bspline/BSpline1dNd\";\nexport * from \"./bspline/BSplineCurve3dH\";\nexport * from \"./bspline/BSplineSurface\";\nexport * from \"./bspline/KnotVector\";\nexport * from \"./polyface/AuxData\";\nexport * from \"./polyface/BoxTopology\";\nexport * from \"./polyface/FacetFaceData\";\nexport * from \"./polyface/Polyface\";\nexport * from \"./polyface/PolyfaceBuilder\";\nexport * from \"./polyface/PolyfaceData\";\nexport * from \"./polyface/PolyfaceQuery\";\nexport * from \"./polyface/PolyfaceClip\";\nexport * from \"./topology/Graph\";\nexport * from \"./topology/Triangulation\";\nexport * from \"./serialization/IModelJsonSchema\";\nexport * from \"./serialization/DeepCompare\";\nexport * from \"./serialization/GeometrySamples\";\n\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\ndeclare var BUILD_SEMVER: string;\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\n  if (!(window as any).iModelJsVersions)\n    (window as any).iModelJsVersions = new Map<string, string>();\n  (window as any).iModelJsVersions.set(\"geometry-core\", BUILD_SEMVER);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BeJSONFunctions, AngleProps, Geometry, TrigValues } from \"../Geometry\";\r\n/**\r\n * An `Angle` carries the numeric value of an angle, with methods to allow (require!) callers to be clear about whether their angle is degrees or radians.\r\n * * The numeric value is private, and callers should not know or care whether it is in degrees or radians.\r\n * * The various access method are named so that callers can specify whether untyped numbers passed in or out are degrees or radians.\r\n * @public\r\n */\r\nexport class Angle implements BeJSONFunctions {\r\n    /** maximal accuracy value of pi/4 ( 45 degrees), in radians */\r\n    public static readonly piOver4Radians = 7.85398163397448280000e-001;\r\n    /** maximal accuracy value of pi/2 ( 90 degrees), in radians */\r\n    public static readonly piOver2Radians = 1.57079632679489660000e+000;\r\n    /** maximal accuracy value of pi ( 180 degrees), in radians */\r\n    public static readonly piRadians = 3.14159265358979310000e+000;\r\n    /** maximal accuracy value of pi/2 ( 90 degrees), in radians */\r\n    public static readonly pi2Radians = 6.28318530717958620000e+000;\r\n    /** scale factor for converting degrees to radians */\r\n    public static readonly degreesPerRadian = (45.0 / Angle.piOver4Radians);\r\n    /** scale factor for converting radians to degrees */\r\n    public static readonly radiansPerDegree = (Angle.piOver4Radians / 45.0);\r\n    /** maximal accuracy value of pi/12 ( 15 degrees), in radians */\r\n    public static readonly piOver12Radians = 0.26179938779914943653855361527329;\r\n    private _radians: number;\r\n    private _degrees?: number;\r\n    private constructor(radians = 0, degrees?: number) { this._radians = radians; this._degrees = degrees; }\r\n    /** Return a new angle with the same content. */\r\n    public clone(): Angle { return new Angle(this._radians, this._degrees); }\r\n    /** Freeze this instance so it can be considered read-only */\r\n    public freeze() { Object.freeze(this); }\r\n\r\n    /**\r\n     * Return a new Angle object for angle given in degrees.\r\n     * @param degrees angle in degrees\r\n     */\r\n    public static createDegrees(degrees: number) { return new Angle(Angle.degreesToRadians(degrees), degrees); }\r\n    /**\r\n     * Return a (new) Angle object for a value given in radians.\r\n     * @param radians angle in radians\r\n     */\r\n    public static createRadians(radians: number) { return new Angle(radians); }\r\n    /**\r\n     * Return a (new) Angle object, with angle scaled from existing angle.\r\n     * @param scale scale factor to apply to angle.\r\n     */\r\n    public cloneScaled(scale: number) { return new Angle(this.radians * scale); }\r\n\r\n    /**\r\n     * Set this angle to a value given in radians.\r\n     * @param radians angle given in radians\r\n     */\r\n    public setRadians(radians: number) { this._radians = radians; this._degrees = undefined; }\r\n    /**\r\n     * Set this angle to a value given in degrees.\r\n     * @param degrees angle given in degrees.\r\n     */\r\n    public setDegrees(degrees: number) { this._radians = Angle.degreesToRadians(degrees); this._degrees = degrees; }\r\n    /** Create an angle for a full circle. */\r\n    public static create360() { return new Angle(Math.PI * 2.0, 360.0); }\r\n    /**\r\n     * @return a (strongly typed) Angle whose tangent is `numerator/denominator`, using the signs of both in determining the (otherwise ambiguous)\r\n     * quadrant.\r\n     * @param numerator numerator for tangent\r\n     * @param denominator denominator for tangent\r\n     */\r\n    public static createAtan2(numerator: number, denominator: number): Angle { return new Angle(Math.atan2(numerator, denominator)); }\r\n    /**\r\n     * Copy all contents of `other` to this Angle.\r\n     * @param other source data\r\n     */\r\n    public setFrom(other: Angle) { this._radians = other._radians; this._degrees = other._degrees; }\r\n    /**\r\n     * Create an Angle from a JSON object\r\n     * @param json object from JSON.parse. If a number, value is in *DEGREES*\r\n     * @param defaultValRadians if json is undefined, default value in radians.\r\n     * @return a new Angle\r\n     */\r\n    public static fromJSON(json?: AngleProps, defaultValRadians?: number): Angle {\r\n        const val = new Angle();\r\n        val.setFromJSON(json, defaultValRadians);\r\n        return val;\r\n    }\r\n    /**\r\n     * set an Angle from a JSON object\r\n     * * A simple number is degrees.\r\n     * * specified `json.degrees` or `json._degrees` is degree value.\r\n     * * specified `son.radians` or `json._radians` is radians value.\r\n     * @param json object from JSON.parse. If a number, value is in *DEGREES*\r\n     * @param defaultValRadians if json is undefined, default value in radians.\r\n     */\r\n    public setFromJSON(json?: AngleProps, defaultValRadians?: number) {\r\n        this._radians = defaultValRadians ? defaultValRadians : 0;\r\n        if (!json)\r\n            return;\r\n        if (typeof json === \"number\") {\r\n            this.setDegrees(json);\r\n        } else if (typeof (json as any).degrees === \"number\") {\r\n            this.setDegrees((json as any).degrees);\r\n        } else if (typeof (json as any)._degrees === \"number\") {\r\n            this.setDegrees((json as any)._degrees);\r\n        } else if (typeof (json as any).radians === \"number\") {\r\n            this.setRadians((json as any).radians);\r\n        } else if (typeof (json as any)._radians === \"number\") {\r\n            this.setRadians((json as any)._radians);\r\n        }\r\n    }\r\n    /** Convert an Angle to a JSON object as a number in degrees */\r\n    public toJSON(): AngleProps { return this.degrees; }\r\n    /** Return a json object with radians keyword, e.g. `{ radians: 0.10}` */\r\n    public toJSONRadians(): AngleProps { return { radians: this.radians }; }\r\n    /**  Return the angle measured in radians. */\r\n    public get radians(): number { return this._radians; }\r\n    /**  Return the angle measured in degrees. */\r\n    public get degrees(): number { return this._degrees !== undefined ? this._degrees : Angle.radiansToDegrees(this._radians); }\r\n    /**\r\n     * Convert an angle in degrees to radians.\r\n     * @param degrees angle in degrees\r\n     */\r\n    public static degreesToRadians(degrees: number) { return degrees * Math.PI / 180; }\r\n    /**\r\n     * Convert an angle in radians to degrees.\r\n     * @param degrees angle in radians\r\n     */\r\n    public static radiansToDegrees(radians: number): number {\r\n        if (radians < 0)\r\n            return -Angle.radiansToDegrees(-radians);\r\n        // Now radians is positive ...\r\n        const pi = Math.PI;\r\n        const factor = 180.0 / pi;\r\n        if (radians <= 0.25 * pi)\r\n            return factor * radians;\r\n        if (radians < 0.75 * pi)\r\n            return 90.0 + 180 * ((radians - 0.5 * pi) / pi);\r\n        if (radians <= 1.25 * pi)\r\n            return 180.0 + 180 * ((radians - pi) / pi);\r\n        if (radians <= 1.75 * pi)\r\n            return 270.0 + 180 * ((radians - 1.5 * pi) / pi);\r\n        // all larger radians reference from 360 degrees (2PI)\r\n        return 360.0 + 180 * ((radians - 2.0 * pi) / pi);\r\n    }\r\n    /**\r\n     * Return the cosine of this Angle object's angle.\r\n     */\r\n    public cos(): number { return Math.cos(this._radians); }\r\n    /**\r\n     * Return the sine of this Angle object's angle.\r\n     */\r\n    public sin(): number { return Math.sin(this._radians); }\r\n    /**\r\n     * Return the tangent of this Angle object's angle.\r\n     */\r\n    public tan(): number { return Math.tan(this._radians); }\r\n    /** Test if a radians value is nearly 2PI or larger (!) */\r\n    public static isFullCircleRadians(radians: number) { return Math.abs(radians) >= Geometry.fullCircleRadiansMinusSmallAngle; }\r\n    /** Test if the radians value  is a complete circle */\r\n    public static isHalfCircleRadians(radians: number) { return (Math.abs(Math.abs(radians)) - Math.PI) <= Geometry.smallAngleRadians; }\r\n    /** test if the angle is aa full circle */\r\n    public get isFullCircle(): boolean { return Angle.isFullCircleRadians(this._radians); }\r\n    /** test if the angle is a half circle (in either direction) */\r\n    public get isHalfCircle(): boolean { return Angle.isHalfCircleRadians(this._radians); }\r\n    /** Adjust a radians value so it is positive in 0..360 */\r\n    public static adjustDegrees0To360(degrees: number): number {\r\n        if (degrees >= 0) {\r\n            const period = 360.0;\r\n            if (degrees < period)\r\n                return degrees;\r\n            const numPeriods = Math.floor(degrees / period);\r\n            return degrees - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        const radians1 = Angle.adjustDegrees0To360(-degrees);\r\n        return 360.0 - radians1;\r\n    }\r\n    /** Adjust a radians value so it is positive in -180..180 */\r\n    public static adjustDegreesSigned180(degrees: number): number {\r\n        if (Math.abs(degrees) <= 180.0)\r\n            return degrees;\r\n        if (degrees >= 0) {\r\n            const period = 360.0;\r\n            const numPeriods = 1 + Math.floor((degrees - 180.0) / period);\r\n            return degrees - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        return -Angle.adjustDegreesSigned180(-degrees);\r\n    }\r\n    /** Adjust a radians value so it is positive in 0..2Pi */\r\n    public static adjustRadians0To2Pi(radians: number): number {\r\n        if (radians >= 0) {\r\n            const period = Math.PI * 2.0;\r\n            if (radians < period)\r\n                return radians;\r\n            const numPeriods = Math.floor(radians / period);\r\n            return radians - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        const radians1 = Angle.adjustRadians0To2Pi(-radians);\r\n        return Math.PI * 2.0 - radians1;\r\n    }\r\n    /** Adjust a radians value so it is positive in -PI..PI */\r\n    public static adjustRadiansMinusPiPlusPi(radians: number): number {\r\n        if (Math.abs(radians) <= Math.PI)\r\n            return radians;\r\n        if (radians >= 0) {\r\n            const period = Math.PI * 2.0;\r\n            const numPeriods = 1 + Math.floor((radians - Math.PI) / period);\r\n            return radians - numPeriods * period;\r\n        }\r\n        // negative angle ...\r\n        return -Angle.adjustRadiansMinusPiPlusPi(-radians);\r\n    }\r\n    /** return a (newly allocated) Angle object with value 0 radians */\r\n    public static zero() { return new Angle(0); }\r\n    /** Test if the angle is exactly zero. */\r\n    public get isExactZero() { return this.radians === 0; }\r\n    /** Test if the angle is almost zero (within tolerance `Geometry.smallAngleRadians`) */\r\n    public get isAlmostZero() { return Math.abs(this.radians) < Geometry.smallAngleRadians; }\r\n    /** Create an angle object with degrees adjusted into 0..360. */\r\n    public static createDegreesAdjustPositive(degrees: number): Angle { return Angle.createDegrees(Angle.adjustDegrees0To360(degrees)); }\r\n    /** Create an angle object with degrees adjusted into -180..180. */\r\n    public static createDegreesAdjustSigned180(degrees: number): Angle { return Angle.createDegrees(Angle.adjustDegreesSigned180(degrees)); }\r\n    /**\r\n     * Test if two radians values are equivalent, allowing shift by full circle (i.e. by a multiple of `2*PI`)\r\n     * @param radiansA first radians value\r\n     * @param radiansB second radians value\r\n     */\r\n    public static isAlmostEqualRadiansAllowPeriodShift(radiansA: number, radiansB: number): boolean {\r\n        // try to get simple conclusions with un-shifted radians ...\r\n        const delta = Math.abs(radiansA - radiansB);\r\n        if (delta <= Geometry.smallAngleRadians)\r\n            return true;\r\n        const period = Math.PI * 2.0;\r\n        if (Math.abs(delta - period) <= Geometry.smallAngleRadians)\r\n            return true;\r\n        const numPeriod = Math.round(delta / period);\r\n        const delta1 = delta - numPeriod * period;\r\n        return Math.abs(delta1) <= Geometry.smallAngleRadians;\r\n    }\r\n    /**\r\n     * Test if this angle and other are equivalent, allowing shift by full circle (i.e. by a multiple of 360 degrees)\r\n     */\r\n    public isAlmostEqualAllowPeriodShift(other: Angle): boolean {\r\n        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians, other._radians);\r\n    }\r\n    /**\r\n     * Test if two this angle and other are almost equal, NOT allowing shift by full circle multiples of 360 degrees.\r\n     */\r\n    public isAlmostEqualNoPeriodShift(other: Angle): boolean { return Math.abs(this._radians - other._radians) < Geometry.smallAngleRadians; }\r\n    /**\r\n     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.\r\n     * * (Same test as isAlmostEqualRadiansNoPeriodShift)\r\n     */\r\n    public isAlmostEqual(other: Angle): boolean { return this.isAlmostEqualNoPeriodShift(other); }\r\n    /**\r\n     * Test if two angle (in radians)  almost equal, NOT allowing shift by full circle multiples of `2 * PI`.\r\n     */\r\n    public static isAlmostEqualRadiansNoPeriodShift(radiansA: number, radiansB: number): boolean { return Math.abs(radiansA - radiansB) < Geometry.smallAngleRadians; }\r\n    /**\r\n     * Test if dot product values indicate non-zero length perpendicular vectors.\r\n     * @param dotUU dot product of vectorU with itself\r\n     * @param dotVV dot product of vectorV with itself\r\n     * @param dotUV dot product of vectorU with vectorV\r\n     */\r\n    public static isPerpendicularDotSet(dotUU: number, dotVV: number, dotUV: number) {\r\n        return dotUU > Geometry.smallMetricDistanceSquared\r\n            && dotVV > Geometry.smallMetricDistanceSquared\r\n            && dotUV * dotUV <= Geometry.smallAngleRadiansSquared * dotUU * dotVV;\r\n    }\r\n    /**\r\n     * Return cosine, sine, and radians for the half angle of a cosine,sine pair.\r\n     * @param rCos2A cosine value (scaled by radius) for initial angle.\r\n     * @param rSin2A sine value (scaled by radius) for final angle.\r\n     */\r\n    public static trigValuesToHalfAngleTrigValues(rCos2A: number, rSin2A: number): TrigValues {\r\n        const r = Geometry.hypotenuseXY(rCos2A, rSin2A);\r\n        if (r < Geometry.smallMetricDistance) {\r\n            return { c: 1.0, s: 0.0, radians: 0.0 };\r\n        } else {\r\n            /* If the caller really gave you sine and cosine values, r should be 1.  However,*/\r\n            /* to allow scaled values -- e.g. the x and y components of any vector -- we normalize*/\r\n            /* right here.  This adds an extra sqrt and 2 divides to the whole process, but improves*/\r\n            /* both the usefulness and robustness of the computation.*/\r\n            let cosA = 1.0;\r\n            let sinA = 0.0;\r\n            const cos2A = rCos2A / r;\r\n            const sin2A = rSin2A / r;\r\n            if (cos2A >= 0.0) {\r\n                /* Original angle in NE and SE quadrants.  Half angle in same quadrant */\r\n                cosA = Math.sqrt(0.5 * (1.0 + cos2A));\r\n                sinA = sin2A / (2.0 * (cosA));\r\n            } else {\r\n                if (sin2A > 0.0) {\r\n                    /* Original angle in NW quadrant. Half angle in NE quadrant */\r\n                    sinA = Math.sqrt(0.5 * (1.0 - cos2A));\r\n                } else {\r\n                    /* Original angle in SW quadrant. Half angle in SE quadrant*/\r\n                    /* cosA comes out positive because both sines are negative. */\r\n                    sinA = -Math.sqrt(0.5 * (1.0 - cos2A));\r\n                }\r\n                cosA = sin2A / (2.0 * (sinA));\r\n            }\r\n            return { c: cosA, s: sinA, radians: Math.atan2(sinA, cosA) };\r\n        }\r\n    }\r\n    /** If value is close to -1, -0.5, 0, 0.5, 1, adjust it to the exact value. */\r\n    public static cleanupTrigValue(value: number, tolerance: number = 1.0e-15): number {\r\n        const absValue = Math.abs(value);\r\n        if (absValue <= tolerance)\r\n            return 0;\r\n        let a = Math.abs(absValue - 0.5);\r\n        if (a <= tolerance)\r\n            return value < 0.0 ? -0.5 : 0.5;\r\n        a = Math.abs(absValue - 1.0);\r\n        if (a <= tolerance)\r\n            return value < 0.0 ? -1.0 : 1.0;\r\n        return value;\r\n    }\r\n    /**\r\n     * Return the half angle cosine, sine, and radians for given dot products between vectors.\r\n     * @param dotUU dot product of vectorU with itself\r\n     * @param dotVV dot product of vectorV with itself\r\n     * @param dotUV dot product of vectorU with vectorV\r\n     */\r\n    public static dotProductsToHalfAngleTrigValues(dotUU: number, dotVV: number, dotUV: number, favorZero: boolean = true): TrigValues {\r\n        const rcos = dotUU - dotVV;\r\n        const rsin = 2.0 * dotUV;\r\n        if (favorZero && Math.abs(rsin) < Geometry.smallAngleRadians * (Math.abs(dotUU) + Math.abs(dotVV)))\r\n            return { c: 1.0, s: 0.0, radians: 0.0 };\r\n        return Angle.trigValuesToHalfAngleTrigValues(rcos, rsin);\r\n    }\r\n    /**\r\n     * * Returns the angle between two vectors, with the vectors given as xyz components\r\n     * * The returned angle is between 0 and PI\r\n     *\r\n     * @param ux x component of vector u\r\n     * @param uy y component of vector u\r\n     * @param uz z component of vector u\r\n     * @param vx x component of vector v\r\n     * @param vy y component of vector v\r\n     * @param vz z component of vector v\r\n     */\r\n    public static radiansBetweenVectorsXYZ(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): number {\r\n        //  const uu = ux * ux + uy * uy + uz * uz;\r\n        const uDotV = ux * vx + uy * vy + uz * vz; // magU magV cos(theta)\r\n        //    const vv = vx * vx + vy * vy + vz * vz;\r\n        return Math.atan2(Geometry.crossProductMagnitude(ux, uy, uz, vx, vy, vz), uDotV);\r\n    }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { GrowableFloat64Array } from \"./GrowableFloat64Array\";\r\nimport { Angle } from \"./Angle\";\r\nimport { BeJSONFunctions, Geometry, AngleSweepProps } from \"../Geometry\";\r\n/**\r\n * An `AngleSweep` is a pair of angles at start and end of an interval.\r\n *\r\n * *  For stroking purposes, the \"included interval\" is all angles numerically reached by theta = start + f*(end-start), where f is between 0 and 1.\r\n * *  This stroking formula is simple numbers -- 2PI shifts are not involved.\r\n * *  2PI shifts do become important in the reverse mapping of an angle to a fraction.\r\n * *  If (start < end) the angle proceeds CCW around the unit circle.\r\n * *  If (end < start) the angle proceeds CW around the unit circle.\r\n * *  Angles beyond 360 are fine as endpoints.\r\n *   *  (350,370) covers the same unit angles as (-10,10).\r\n *   *  (370,350) covers the same unit angles as (10,-10).\r\n * @public\r\n */\r\nexport class AngleSweep implements BeJSONFunctions {\r\n    private _radians0: number;\r\n    private _radians1: number;\r\n    /** Read-property for degrees at the start of this AngleSweep. */\r\n    public get startDegrees() { return Angle.radiansToDegrees(this._radians0); }\r\n    /** Read-property for degrees at the end of this AngleSweep. */\r\n    public get endDegrees() { return Angle.radiansToDegrees(this._radians1); }\r\n    /** Read-property for signed start-to-end sweep in degrees. */\r\n    public get sweepDegrees() { return Angle.radiansToDegrees(this._radians1 - this._radians0); }\r\n    /** Read-property for degrees at the start of this AngleSweep. */\r\n    public get startRadians() { return this._radians0; }\r\n    /** Read-property for degrees at the end of this AngleSweep. */\r\n    public get endRadians() { return this._radians1; }\r\n    /** Read-property for signed start-to-end sweep in radians. */\r\n    public get sweepRadians() { return this._radians1 - this._radians0; }\r\n    /** Return the (strongly typed) start angle */\r\n    public get startAngle() { return Angle.createRadians(this._radians0); }\r\n    /** Return the (strongly typed) end angle */\r\n    public get endAngle() { return Angle.createRadians(this._radians1); }\r\n    /** (private) constructor with start and end angles in radians.\r\n     *  * Use explicitly named static methods to clarify intent and units of inputs:\r\n     *\r\n     * * createStartEndRadians (startRadians:number, endRadians:number)\r\n     * * createStartEndDegrees (startDegrees:number, endDegrees:number)\r\n     * * createStartEnd (startAngle:Angle, endAngle:Angle)\r\n     * * createStartSweepRadians (startRadians:number, sweepRadians:number)\r\n     * * createStartSweepDegrees (startDegrees:number, sweepDegrees:number)\r\n     * * createStartSweep (startAngle:Angle, sweepAngle:Angle)\r\n     */\r\n    private constructor(startRadians: number = 0, endRadians: number = 0) { this._radians0 = startRadians; this._radians1 = endRadians; }\r\n    /** create an AngleSweep from start and end angles given in radians. */\r\n    public static createStartEndRadians(startRadians: number = 0, endRadians: number = 2.0 * Math.PI, result?: AngleSweep): AngleSweep {\r\n        result = result ? result : new AngleSweep();\r\n        result.setStartEndRadians(startRadians, endRadians);\r\n        return result;\r\n    }\r\n    /** Return the angle obtained by subtracting radians from this angle. */\r\n    public cloneMinusRadians(radians: number): AngleSweep { return new AngleSweep(this._radians0 - radians, this._radians1 - radians); }\r\n    /** create an AngleSweep from start and end angles given in degrees. */\r\n    public static createStartEndDegrees(startDegrees: number = 0, endDegrees: number = 360, result?: AngleSweep): AngleSweep {\r\n        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees), result);\r\n    }\r\n    /** create an angle sweep from strongly typed start and end angles */\r\n    public static createStartEnd(startAngle: Angle, endAngle: Angle, result?: AngleSweep): AngleSweep {\r\n        result = result ? result : new AngleSweep();\r\n        result.setStartEndRadians(startAngle.radians, endAngle.radians);\r\n        return result;\r\n    }\r\n    /** Create an angle sweep with limits given as (strongly typed) angles for start and sweep */\r\n    public static createStartSweep(startAngle: Angle, sweepAngle: Angle, result?: AngleSweep): AngleSweep {\r\n        return AngleSweep.createStartSweepRadians(startAngle.radians, sweepAngle.radians, result);\r\n    }\r\n    /** Return a sweep with limits interpolated between this and other. */\r\n    public interpolate(fraction: number, other: AngleSweep): AngleSweep {\r\n        return new AngleSweep(Geometry.interpolate(this._radians0, fraction, other._radians0), Geometry.interpolate(this._radians1, fraction, other._radians1));\r\n    }\r\n    /** create an AngleSweep from start and end angles given in radians. */\r\n    public static createStartSweepRadians(startRadians: number = 0, sweepRadians: number = Math.PI, result?: AngleSweep): AngleSweep {\r\n        result = result ? result : new AngleSweep();\r\n        result.setStartEndRadians(startRadians, startRadians + sweepRadians);\r\n        return result;\r\n    }\r\n    /** create an AngleSweep from start and sweep given in degrees.  */\r\n    public static createStartSweepDegrees(startDegrees: number = 0, sweepDegrees: number = 360, result?: AngleSweep): AngleSweep {\r\n        return AngleSweep.createStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(startDegrees + sweepDegrees), result);\r\n    }\r\n    /** directly set the start and end angles in radians */\r\n    public setStartEndRadians(startRadians: number = 0, endRadians: number = 2.0 * Math.PI) {\r\n        const delta = endRadians - startRadians;\r\n        if (Angle.isFullCircleRadians(delta)) {\r\n            endRadians = startRadians + (delta > 0 ? 2.0 : -2.0) * Math.PI;\r\n        }\r\n        this._radians0 = startRadians;\r\n        this._radians1 = endRadians;\r\n    }\r\n    /** directly set the start and end angles in degrees */\r\n    public setStartEndDegrees(startDegrees: number = 0, endDegrees: number = 360.0) {\r\n        this.setStartEndRadians(Angle.degreesToRadians(startDegrees), Angle.degreesToRadians(endDegrees));\r\n    }\r\n    /** copy from other AngleSweep. */\r\n    public setFrom(other: AngleSweep) { this._radians0 = other._radians0; this._radians1 = other._radians1; }\r\n    /** create a full circle sweep (CCW). startRadians defaults to 0 */\r\n    public static create360(startRadians?: number): AngleSweep {\r\n        startRadians = startRadians ? startRadians : 0.0;\r\n        return new AngleSweep(startRadians, startRadians + 2.0 * Math.PI);\r\n    }\r\n    /** create a sweep from the south pole to the north pole. */\r\n    public static createFullLatitude() { return AngleSweep.createStartEndRadians(-0.5 * Math.PI, 0.5 * Math.PI); }\r\n    /** Reverse the start and end angle in place. */\r\n    public reverseInPlace() { const a = this._radians0; this._radians0 = this._radians1; this._radians1 = a; }\r\n    /** Restrict start and end angles into the range (-90,+90) in degrees. */\r\n    public capLatitudeInPlace() {\r\n        const limit = 0.5 * Math.PI;\r\n        this._radians0 = Geometry.clampToStartEnd(this._radians0, -limit, limit);\r\n        this._radians1 = Geometry.clampToStartEnd(this._radians1, -limit, limit);\r\n    }\r\n    /** Ask if the sweep is counterclockwise, i.e. positive sweep */\r\n    public get isCCW(): boolean { return this._radians1 >= this._radians0; }\r\n    /** Ask if the sweep is a full circle. */\r\n    public get isFullCircle(): boolean { return Angle.isFullCircleRadians(this.sweepRadians); }\r\n    /** Ask if the sweep is a full sweep from south pole to north pole. */\r\n    public get isFullLatitudeSweep(): boolean {\r\n        const a = Math.PI * 0.5;\r\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, -a)\r\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1, a);\r\n    }\r\n    /** return a clone of this sweep. */\r\n    public clone(): AngleSweep { return new AngleSweep(this._radians0, this._radians1); }\r\n    /** Convert fractional position in the sweep to radians. */\r\n    public fractionToRadians(fraction: number) {\r\n        return fraction < 0.5 ?\r\n            this._radians0 + fraction * (this._radians1 - this._radians0)\r\n            : this._radians1 + (fraction - 1.0) * (this._radians1 - this._radians0);\r\n    }\r\n    /** Convert fractional position in the sweep to strongly typed Angle object. */\r\n    public fractionToAngle(fraction: number) {\r\n        return Angle.createRadians(this.fractionToRadians(fraction));\r\n    }\r\n    /** return 2PI divided by the sweep radians (i.e. 360 degrees divided by sweep angle).\r\n     * This is the number of fractional intervals required to cover a whole circle.\r\n     */\r\n    public fractionPeriod(): number {\r\n        return Geometry.safeDivideFraction(Math.PI * 2.0, Math.abs(this._radians1 - this._radians0), 1.0);\r\n    }\r\n    /** return the fractional ized position of the angle,\r\n     * computed without consideration of 2PI period.\r\n     * That is, an angle that is numerically much beyond than the end angle\r\n     * will produce a large fraction and an angle much beyond the start angle\r\n     * will produce a large negative fraction.\r\n     *\r\n     */\r\n    public angleToUnboundedFraction(theta: Angle): number {\r\n        return Geometry.safeDivideFraction(theta.radians - this._radians0, this._radians1 - this._radians0, 1.0);\r\n    }\r\n    /** map an angle to a fractional coordinate which is:\r\n     *\r\n     * *  the start angle is at fraction 0\r\n     * *  the end angle is at fraction 1\r\n     * *  interior angles are between 0 and 1\r\n     * *  all exterior angles are at fractions greater than 1\r\n     * *  the periodic jump is at full wraparound to the start angle\r\n     */\r\n    public angleToPositivePeriodicFraction(theta: Angle): number { return this.radiansToPositivePeriodicFraction(theta.radians); }\r\n    /**\r\n     * Convert each value in an array from radians to fraction.\r\n     * @param data array that is input as radians, output as fractions\r\n     */\r\n    public radiansArraytoPositivePeriodicFractions(data: GrowableFloat64Array) {\r\n        const n = data.length;\r\n        for (let i = 0; i < n; i++) {\r\n            data.reassign(i, this.radiansToPositivePeriodicFraction(data.atUncheckedIndex(i)));\r\n        }\r\n    }\r\n    /**\r\n     * Convert a radians value to a fraction that is always positive and can wrap.  See `angleToPositivePeriodicFraction` for detailed description.\r\n     * @param radians\r\n     */\r\n    public radiansToPositivePeriodicFraction(radians: number): number {\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))\r\n            return 0.0;\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))\r\n            return 1.0;\r\n        const sweep = this._radians1 - this._radians0;\r\n        const delta = radians - this._radians0;\r\n        if (sweep > 0) {\r\n            const delta1 = Angle.adjustRadians0To2Pi(delta);\r\n            const fraction1 = Geometry.safeDivideFraction(delta1, sweep, 0.0);\r\n            return fraction1;\r\n        }\r\n        const delta2 = Angle.adjustRadians0To2Pi(-delta);\r\n        const fraction2 = Geometry.safeDivideFraction(delta2, -sweep, 0.0);\r\n        return fraction2;\r\n    }\r\n    /** map an angle to a fractional coordinate which is:\r\n     *\r\n     * *  the start angle is at fraction 0\r\n     * *  the end angle is at fraction 1\r\n     * *  interior angles are between 0 and 1\r\n     * *  small negative for angles just \"before\" the start angle\r\n     * *  more than one for angles just \"after\" the end angle\r\n     * *  the periodic jump is at the middle of the \"outside\" interval\r\n     */\r\n    public angleToSignedPeriodicFraction(theta: Angle): number {\r\n        return this.radiansToSignedPeriodicFraction(theta.radians);\r\n    }\r\n    /**\r\n     * Convert a radians value to a fraction, allowing wraparound.  See `angleToSignedPeriodicFraction` for detailed description.\r\n     */\r\n    public radiansToSignedPeriodicFraction(radians: number): number {\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians0))\r\n            return 0.0;\r\n        if (Angle.isAlmostEqualRadiansAllowPeriodShift(radians, this._radians1))\r\n            return 1.0;\r\n        const sweep = this._radians1 - this._radians0;\r\n        // measure from middle of interval ...\r\n        const delta = radians - this._radians0 - 0.5 * sweep;\r\n        if (sweep > 0) {\r\n            const delta1 = Angle.adjustRadiansMinusPiPlusPi(delta);\r\n            const fraction1 = 0.5 + Geometry.safeDivideFraction(delta1, sweep, 0.0);\r\n            return fraction1;\r\n        }\r\n        const delta2 = Angle.adjustRadiansMinusPiPlusPi(-delta);\r\n        const fraction = 0.5 + Geometry.safeDivideFraction(delta2, -sweep, 0.0);\r\n        return fraction;\r\n    }\r\n    /** test if an angle is within the sweep */\r\n    public isAngleInSweep(angle: Angle): boolean { return this.isRadiansInSweep(angle.radians); }\r\n    /** test if radians are within sweep  */\r\n    public isRadiansInSweep(radians: number): boolean {\r\n        // quick out for simple inside ...\r\n        const delta0 = radians - this._radians0;\r\n        const delta1 = radians - this._radians1;\r\n        if (delta0 * delta1 <= 0.0)\r\n            return true;\r\n        return this.radiansToPositivePeriodicFraction(radians) <= 1.0;\r\n    }\r\n    /** set this AngleSweep from various sources:\r\n     *\r\n     * * if json is undefined, a full-circle sweep is returned.\r\n     * * If json is an AngleSweep object it is is cloned\r\n     * * If json is an array of 2 numbers, those numbers are start and end angles in degrees.\r\n     * * If `json.degrees` is an array of 2 numbers, those numbers are start and end angles in degrees.\r\n     * * If `json.radians` is an array of 2 numbers, those numbers are start and end angles in radians.\r\n     */\r\n    public setFromJSON(json?: any) {\r\n        if (!json)\r\n            this.setStartEndRadians(); // default full circle\r\n        else if (json instanceof AngleSweep)\r\n            this.setFrom(json as AngleSweep);\r\n        else if (Geometry.isNumberArray(json.degrees, 2))\r\n            this.setStartEndDegrees(json.degrees[0], json.degrees[1]);\r\n        else if (Geometry.isNumberArray(json.radians, 2))\r\n            this.setStartEndRadians(json.radians[0], json.radians[1]);\r\n        else if (Geometry.isNumberArray(json, 2))\r\n            this.setStartEndDegrees(json[0], json[1]);\r\n    }\r\n    /** create an AngleSweep from a json object. */\r\n    public static fromJSON(json?: AngleSweepProps) {\r\n        const result = AngleSweep.create360();\r\n        result.setFromJSON(json);\r\n        return result;\r\n    }\r\n    /**\r\n     * Convert an AngleSweep to a JSON object.\r\n     * @return {*} {degrees: [startAngleInDegrees, endAngleInDegrees}\r\n     */\r\n    public toJSON(): any {\r\n        // return { degrees: [this.startDegrees, this.endDegrees] };\r\n        return [this.startDegrees, this.endDegrees];\r\n    }\r\n    /** test if start and end angles match, with explicit name to clarify that there is no test for 360-degree shifts. */\r\n    public isAlmostEqualAllowPeriodShift(other: AngleSweep): boolean {\r\n        return Angle.isAlmostEqualRadiansAllowPeriodShift(this._radians0, other._radians0)\r\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);\r\n    }\r\n    /** test if start and end angles match, explicit name to clarify that 360-degree shifts are allowed. */\r\n    public isAlmostEqualNoPeriodShift(other: AngleSweep): boolean {\r\n        return Angle.isAlmostEqualRadiansNoPeriodShift(this._radians0, other._radians0)\r\n            && Angle.isAlmostEqualRadiansNoPeriodShift(this._radians1 - this._radians0, other._radians1 - other._radians0);\r\n    }\r\n    /** test if start and end angles match with radians tolerance.\r\n     * * This is equivalent to isAlmostEqualNoPeriodShift.\r\n     * * it is present for consistency with other classes\r\n     * * It is recommended that all callers use one of he longer names to be clear of their intentions:\r\n     * * * isAlmostEqualAllowPeriodShift\r\n     * * * isAlmostEqualRadiansNoPeriodShift\r\n     */\r\n    public isAlmostEqual(other: AngleSweep): boolean { return this.isAlmostEqualNoPeriodShift(other); }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d } from \"./Point3dVector3d\";\r\nimport { Range3d } from \"./Range\";\r\nimport { Transform } from \"./Transform\";\r\n\r\nimport { UVSurface } from \"./GeometryHandler\";\r\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * * A Bilinear patch is defined by its 4 corner points.\r\n * * the corner points do not have to be coplanar\r\n *\r\n * *    v direction (up)\r\n *      |\r\n *      |\r\n *      |\r\n *  point01---A1-----------point11\r\n *      |     |             |\r\n *      B0----X------------B1\r\n *      |     |             |\r\n *  point00--A0-----------point10 -----------> u direction\r\n *\r\n * * To evaluate aa point at (u,v), the following are equivalent:\r\n *   * interpolate with u to get both A0 and A1, viz\r\n *      * A0 = interpolate between point00 and point10 at fraction u\r\n *      * A1 = interpolate between point01 and point11 at fraction u\r\n *      * X = interpolate between A0 and A1 at fraction v\r\n *   * interpolate first with v to get B0 and B1, viz\r\n *      * B0 = interpolate between point00 and point01 at fraction v\r\n *      * B1 = interpolate between point10 and point11 at fraction v\r\n *      * X = interpolate between B0 and B1 at fraction u\r\n *   * sum all at once as\r\n *      * X = (1-u)* (1-v) *point00 + (1-u)*v * point01 + u * (1-v) *point10 + u* v * point11\r\n *\r\n */\r\nexport class BilinearPatch implements UVSurface {\r\n  public point00: Point3d;\r\n  public point10: Point3d;\r\n  public point01: Point3d;\r\n  public point11: Point3d;\r\n  /**\r\n   * Capture (not clone) corner points, in u direction at v=0, then in same direction at v=1\r\n   * @param point00 Point at uv=0,0\r\n   * @param point10 Point at uv=1,0\r\n   * @param point10 Point at uv=0,1\r\n   * @param point11 Point at uv=11\r\n   */\r\n  public constructor(point00: Point3d, point10: Point3d, point01: Point3d, point11: Point3d) {\r\n    this.point00 = point00;\r\n    this.point10 = point10;\r\n    this.point01 = point01;\r\n    this.point11 = point11;\r\n  }\r\n  /** clone (not capture) corners to create a new BilinearPatch\r\n   * @param point00 Point at uv=0,0\r\n   * @param point10 Point at uv=1,0\r\n   * @param point10 Point at uv=0,1\r\n   * @param point11 Point at uv=11\r\n   */\r\n  public static create(point00: Point3d, point10: Point3d, point01: Point3d, point11: Point3d) {\r\n    return new BilinearPatch(point00.clone(), point10.clone(), point01.clone(), point11.clone());\r\n  }\r\n\r\n  /** create a patch with from xyz values of the 4 corners\r\n   */\r\n  public static createXYZ(x00: number, y00: number, z00: number,\r\n    x10: number, y10: number, z10: number,\r\n    x01: number, y01: number, z01: number,\r\n    x11: number, y11: number, z11: number) {\r\n    return new BilinearPatch(Point3d.create(x00, y00, z00),\r\n      Point3d.create(x10, y10, z10),\r\n      Point3d.create(x01, y01, z01),\r\n      Point3d.create(x11, y11, z11));\r\n  }\r\n\r\n  /** return a clone with same coordinates */\r\n  public clone(): BilinearPatch {\r\n    return new BilinearPatch(\r\n      this.point00.clone(),\r\n      this.point10.clone(),\r\n      this.point01.clone(),\r\n      this.point11.clone());\r\n  }\r\n  /** test equality of the 4 points */\r\n  public isAlmostEqual(other: BilinearPatch): boolean {\r\n    return this.point00.isAlmostEqual(other.point00)\r\n      && this.point10.isAlmostEqual(other.point10)\r\n      && this.point01.isAlmostEqual(other.point01)\r\n      && this.point11.isAlmostEqual(other.point11);\r\n  }\r\n  /** Apply the transform to each point */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    transform.multiplyPoint3d(this.point00, this.point00);\r\n    transform.multiplyPoint3d(this.point10, this.point10);\r\n    transform.multiplyPoint3d(this.point01, this.point01);\r\n    transform.multiplyPoint3d(this.point11, this.point11);\r\n    return true;\r\n  }\r\n  /**\r\n   * return a cloned and transformed patch.\r\n   * @param transform\r\n   */\r\n  public cloneTransformed(transform: Transform): BilinearPatch | undefined {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Extend a range by the range of the(optionally transformed) patch\r\n   */\r\n  public extendRange(range: Range3d, transform?: Transform) {\r\n    if (transform) {\r\n      range.extendTransformedPoint(transform, this.point00);\r\n      range.extendTransformedPoint(transform, this.point10);\r\n      range.extendTransformedPoint(transform, this.point01);\r\n      range.extendTransformedPoint(transform, this.point11);\r\n    } else {\r\n      range.extendPoint(this.point00);\r\n      range.extendPoint(this.point10);\r\n      range.extendPoint(this.point01);\r\n      range.extendPoint(this.point11);\r\n    }\r\n  }\r\n  /** Evaluate as a uv surface\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPoint(u: number, v: number, result?: Point3d): Point3d {\r\n    const f00 = (1.0 - u) * (1.0 - v);\r\n    const f10 = u * (1.0 - v);\r\n    const f01 = (1.0 - u) * v;\r\n    const f11 = u * v;\r\n    return Point3d.create(\r\n      f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x,\r\n      f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y,\r\n      f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z,\r\n      result);\r\n  }\r\n  /** Evaluate as a uv surface, returning point and two derivative vectors.\r\n   * @param u fractional position\r\n   * @param v fractional position\r\n   */\r\n  public uvFractionToPointAndTangents(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const u0 = 1.0 - u;\r\n    const v0 = 1.0 - v;\r\n    const f00 = u0 * v0;\r\n    const f10 = u * v0;\r\n    const f01 = u0 * v;\r\n    const f11 = u * v;\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(\r\n      f00 * this.point00.x + f10 * this.point10.x + f01 * this.point01.x + f11 * this.point11.x,\r\n      f00 * this.point00.y + f10 * this.point10.y + f01 * this.point01.y + f11 * this.point11.y,\r\n      f00 * this.point00.z + f10 * this.point10.z + f01 * this.point01.z + f11 * this.point11.z,\r\n      // u derivative ..\r\n      v0 * (this.point10.x - this.point00.x) + v * (this.point11.x - this.point01.x),\r\n      v0 * (this.point10.y - this.point00.y) + v * (this.point11.y - this.point01.y),\r\n      v0 * (this.point10.z - this.point00.z) + v * (this.point11.z - this.point01.z),\r\n      // v derivative ..\r\n      u0 * (this.point01.x - this.point00.x) + u * (this.point11.x - this.point10.x),\r\n      u0 * (this.point01.y - this.point00.y) + u * (this.point11.y - this.point10.y),\r\n      u0 * (this.point01.z - this.point00.z) + u * (this.point11.z - this.point10.z),\r\n      result);\r\n  }\r\n  /**\r\n   * @returns the larger of the u-direction edge lengths at v=0 and v=1\r\n   */\r\n  public maxUEdgeLength(): number {\r\n    return Geometry.maxXY(this.point00.distance(this.point10), this.point01.distance(this.point11));\r\n  }\r\n  /**\r\n   * @returns the larger of the v-direction edge lengths at u=0 and u=1\r\n   */\r\n  public maxVEdgeLength(): number {\r\n    return Geometry.maxXY(this.point00.distance(this.point01), this.point10.distance(this.point11));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Geometry, AxisOrder, AxisScaleSelect } from \"../Geometry\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { Range3d } from \"./Range\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Point3dArray } from \"./PointHelpers\";\r\n/**\r\n * Helper class to accumulate points and vectors until there is enough data to define a coordinate system.\r\n *\r\n * * For the common case of building a right handed frame:\r\n *   * create the FrameBuilder and make calls to announcePoint and announceVector.\r\n *   * the frame will be fully determined by an origin and two vectors.\r\n *   * the first call to announcePoint will set the origin.\r\n *   *  additional calls to announcePoint will produce announceVector call with the vector from the origin.\r\n *   * After each announcement, call getValidatedFrame(false)\r\n *   * getValidatedFrame will succeed when it has two independent vectors.\r\n * *  to build a left handed frame,\r\n *   *  an origin and 3 independent vectors are required.\r\n *   *  announce as above, but query with getValidatedFrame (true).\r\n *   *  this will use the third vector to select right or left handed frame.\r\n * @public\r\n */\r\nexport class FrameBuilder {\r\n  private _origin: undefined | Point3d;\r\n  private _vector0: undefined | Vector3d;\r\n  private _vector1: undefined | Vector3d;\r\n  private _vector2: undefined | Vector3d;\r\n  /** clear all accumulated point and vector data */\r\n  public clear() { this._origin = undefined; this._vector0 = undefined; this._vector1 = undefined; this._vector2 = undefined; }\r\n  constructor() { this.clear(); }\r\n  /** Try to assemble the data into a nonsingular transform.\r\n   *\r\n   * * If allowLeftHanded is false, vector0 and vector1 determine a right handed coordinate system.\r\n   * * if allowLeftHanded is true, the z vector of the right handed system can be flipped to agree with vector2 direction.\r\n   */\r\n  public getValidatedFrame(allowLeftHanded: boolean = false): Transform | undefined {\r\n    if (this._origin && this._vector0 && this._vector1) {\r\n      if (!allowLeftHanded) {\r\n        const matrix = Matrix3d.createRigidFromColumns(this._vector0, this._vector1, AxisOrder.XYZ);\r\n        if (matrix)\r\n          return Transform.createOriginAndMatrix(this._origin, matrix);\r\n        // uh oh -- vector1 was not really independent.  clear everything after vector0.\r\n        this._vector1 = this._vector2 = undefined;\r\n      } else if (this._vector2) {\r\n        const matrix = Matrix3d.createRigidFromColumns(this._vector0, this._vector1, AxisOrder.XYZ);\r\n        if (matrix) {\r\n          if (this._vector0.tripleProduct(this._vector1, this._vector2) < 0)\r\n            matrix.scaleColumns(1.0, 1.0, -1.0);\r\n          return Transform.createOriginAndMatrix(this._origin, matrix);\r\n        }\r\n        // uh oh again -- clear vector1 and vector2, reannounce vector2 as possible vector1??\r\n        const vector2 = this._vector2;\r\n        this._vector1 = this._vector2 = undefined;\r\n        this.announceVector(vector2);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /**If vector0 is known but vector1 is not, make vector1 the cross of the upvector and vector0 */\r\n  public applyDefaultUpVector(vector?: Vector3d) {\r\n    if (vector && this._vector0 && !this._vector1 && !vector.isParallelTo(this._vector0)) {\r\n      this._vector1 = vector.crossProduct(this._vector0);\r\n    }\r\n  }\r\n  /** Ask if there is a defined origin for the evolving frame */\r\n  public get hasOrigin(): boolean { return this._origin !== undefined; }\r\n  /** Return the number of vectors saved.   Because the save process checks numerics, this should be the rank of the system.\r\n   */\r\n  public savedVectorCount(): number {\r\n    if (!this._vector0)\r\n      return 0;\r\n    if (!this._vector1)\r\n      return 1;\r\n    if (!this._vector2)\r\n      return 2;\r\n    return 3;\r\n  }\r\n  /** announce a new point.  If this point is different from the origin, also compute and announce the vector from the origin.*/\r\n  public announcePoint(point: Point3d): number {\r\n    if (!this._origin) {\r\n      this._origin = point.clone();\r\n      return this.savedVectorCount();\r\n    }\r\n    // the new point may provide an additional vector\r\n    if (this._origin.isAlmostEqual(point))\r\n      return this.savedVectorCount();\r\n    return this.announceVector(this._origin.vectorTo(point));\r\n  }\r\n  /** announce a new vector. */\r\n  public announceVector(vector: Vector3d): number {\r\n    if (vector.isAlmostZero)\r\n      return this.savedVectorCount();\r\n\r\n    if (!this._vector0) { this._vector0 = vector; return 1; }\r\n\r\n    if (!this._vector1) {\r\n      if (!vector.isParallelTo(this._vector0)) { this._vector1 = vector; return 2; }\r\n      return 1;\r\n    }\r\n\r\n    // vector0 and vector1 are independent.\r\n    if (!this._vector2) {\r\n      const unitPerpendicular = this._vector0.unitCrossProduct(this._vector1);\r\n      if (unitPerpendicular && !Geometry.isSameCoordinate(0, unitPerpendicular.dotProduct(vector))) {\r\n        this._vector2 = vector;\r\n        return 3;\r\n      }\r\n      return 2;\r\n    }\r\n    // fall through if prior vectors are all there -- no need for the new one.\r\n    return 3;\r\n  }\r\n  /** Inspect the content of the data.  Announce points and vectors.   Return when savedVectorCount becomes\r\n   * sufficient for a coordinate system.\r\n   */\r\n  public announce(data: any) {\r\n    if (this.savedVectorCount() > 1) return;\r\n    if (data instanceof Point3d)\r\n      this.announcePoint(data);\r\n    else if (data instanceof Vector3d)\r\n      this.announceVector(data);\r\n    else if (Array.isArray(data)) {\r\n      for (const child of data) {\r\n        if (this.savedVectorCount() > 1)\r\n          break;\r\n        this.announce(child);\r\n      }\r\n    } else if (data instanceof CurvePrimitive) {\r\n      if (data instanceof LineSegment3d) {\r\n        this.announcePoint(data.startPoint());\r\n        this.announcePoint(data.endPoint());\r\n      } else if (data instanceof Arc3d) {\r\n        const ray = data.fractionToPointAndDerivative(0.0);\r\n        this.announcePoint(ray.origin);\r\n        this.announceVector(ray.direction);\r\n        this.announceVector(data.matrix.columnZCrossVector(ray.direction));\r\n      } else if (data instanceof LineString3d) {\r\n        for (const point of data.points) {\r\n          this.announcePoint(point);\r\n          if (this.savedVectorCount() > 1)\r\n            break;\r\n        }\r\n      } else if (data instanceof BSplineCurve3d) {\r\n        const point = Point3d.create();\r\n        for (let i = 0; this.savedVectorCount() < 2; i++) {\r\n          if (data.getPolePoint3d(i, point) instanceof Point3d)\r\n            this.announcePoint(point);\r\n          else break;\r\n        }\r\n      }\r\n      // TODO: unknown curve type.  Stroke? FrenetFrame?\r\n    } else if (data instanceof CurveCollection) {\r\n      if (data.children)\r\n        for (const child of data.children) {\r\n          this.announce(child);\r\n          if (this.savedVectorCount() > 1)\r\n            break;\r\n        }\r\n    }\r\n  }\r\n  /** create a localToWorld frame for the given data.\r\n   *\r\n   * *  origin is at first point\r\n   * *  x axis in direction of first nonzero vector present or implied by the input.\r\n   * *  y axis is perpendicular to x and contains (in positive side) the next vector present or implied by the input.\r\n   */\r\n  public static createRightHandedFrame(defaultUpVector: Vector3d | undefined, ...params: any[]): Transform | undefined {\r\n    const builder = new FrameBuilder();\r\n    for (const data of params) {\r\n      builder.announce(data);\r\n      builder.applyDefaultUpVector(defaultUpVector);\r\n      const result = builder.getValidatedFrame(false);\r\n      if (result !== undefined)\r\n        return result;\r\n    }\r\n    // try direct evaluation of curve primitives?\r\n    for (const data of params) {\r\n      if (data instanceof CurveCollection) {\r\n        const children = data.children;\r\n        if (children) {\r\n          for (const curve of children) {\r\n            if (curve instanceof CurvePrimitive) {\r\n              const frenetFrame = curve.fractionToFrenetFrame(0.0);\r\n              if (frenetFrame)\r\n                return frenetFrame;\r\n            }\r\n          }\r\n        }\r\n      }\r\n\r\n    }\r\n    return undefined;\r\n  }\r\n  /** create a map with\r\n   * *  transform0 = the local to world\r\n   * *  transform1 = world to local\r\n   * * ideally all points in local xy plane\r\n   */\r\n  public static createRightHandedLocalToWorld(...params: any[]): Transform | undefined {\r\n    const builder = new FrameBuilder();\r\n    for (const data of params) {\r\n      builder.announce(data);\r\n      const localToWorld = builder.getValidatedFrame(false);\r\n      if (localToWorld !== undefined)\r\n        return localToWorld;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * try to create a frame whose xy plane is through points.\r\n   *\r\n   * *  if 3 or more distinct points are present, the x axis is from the first point to the most distance, and y direction is toward the\r\n   * point most distant from that line.\r\n   * @param points array of points\r\n   */\r\n  public static createFrameToDistantPoints(points: Point3d[]): Transform | undefined {\r\n    if (points.length > 2) {\r\n      const origin = points[0].clone();\r\n      const vector01 = Vector3d.create();\r\n      Point3dArray.indexOfMostDistantPoint(points, points[0], vector01);\r\n      const vector02 = Vector3d.create();\r\n      Point3dArray.indexOfPointWithMaxCrossProductMagnitude(points, origin, vector01, vector02);\r\n      const matrix = Matrix3d.createRigidFromColumns(vector01, vector02, AxisOrder.XYZ);\r\n      if (matrix)\r\n        return Transform.createRefs(origin, matrix);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create the localToWorld transform from a range to axes of its parent coordinate system.\r\n   * @param range [in] range to inspect\r\n   * @param fractionX  [in] fractional coordinate of frame origin x\r\n   * @param fractionY [in] fractional coordinate of frame origin y\r\n   * @param fractionZ [in] fractional coordinate of frame origin z\r\n   * @param scaleSelect [in] selects size of localToWorld axes.\r\n   * @param defaultAxisLength [in] if true and any axis length is 0, that axis vector takes this physical length.\r\n   */\r\n  public static createLocalToWorldTransformInRange(\r\n    range: Range3d,\r\n    scaleSelect: AxisScaleSelect = AxisScaleSelect.NonUniformRangeContainment,\r\n    fractionX: number = 0,\r\n    fractionY: number = 0,\r\n    fractionZ: number = 0,\r\n    defaultAxisLength: number = 1.0): Transform {\r\n    if (range.isNull)\r\n      return Transform.createIdentity();\r\n    let a = 1.0;\r\n    let b = 1.0;\r\n    let c = 1.0;\r\n    if (scaleSelect === AxisScaleSelect.LongestRangeDirection) {\r\n      a = b = c = Geometry.correctSmallMetricDistance(range.maxLength(), defaultAxisLength);\r\n    } else if (scaleSelect === AxisScaleSelect.NonUniformRangeContainment) {\r\n      a = Geometry.correctSmallMetricDistance(range.xLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionX, 0, 1);\r\n      b = Geometry.correctSmallMetricDistance(range.yLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionY, 0, 1);\r\n      c = Geometry.correctSmallMetricDistance(range.zLength(), defaultAxisLength) * Geometry.maxAbsDiff(fractionZ, 0, 1);\r\n    }\r\n    return Transform.createRefs(range.fractionToPoint(fractionX, fractionY, fractionZ), Matrix3d.createScale(a, b, c));\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Point3dArray } from \"./PointHelpers\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { AxisOrder, Geometry } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\n/**\r\n * context for constructing smooth motion a startFrustum and endFrustum.\r\n * The externally interesting calls are\r\n * * Create a context to shift corner0 to corner1, with the(NPC coordinate) point(fractionU, fractionV, fractionW) moving along its connecting segment, all other points rotating smoothly from the start orientation to end orientation:\r\n * `const context = SmoothTransformBetweenFrusta (cornerA, cornerB)`\r\n *  * Get any intermediate 8 corners(at fraction) with `context.fractionToWorldCorners(fraction)`\r\n * * Frustum corners are ordered by \"x varies fastest, then y, then z\", hence (xyz) order on nondimensional space is\r\n *   * (left lower rear) (000)\r\n *   * (right lower rear) (100)\r\n *   * (left upper rear) (010)\r\n *   * (right upper rear) (100)\r\n *   * (left lower front) (001)\r\n *   * (right lower front) (101)\r\n *   * (left upper front) (011)\r\n *   * (right upper front) (101)\r\n * * which uses names\r\n *    * (left,right) for horizontal (x)\r\n *    * (bottom, top) for vertical (y)\r\n *    * (rear, front) for back and front planes (z)\r\n * @public\r\n */\r\nexport class SmoothTransformBetweenFrusta {\r\n  // raw frusta:\r\n  private _localCornerA: Point3d[];\r\n  private _localCornerB: Point3d[];\r\n\r\n  private _localToWorldA: Transform;\r\n  private _localToWorldB: Transform;\r\n  /** (property accessor) rigid frame at start of motion */\r\n  public get localToWorldA(): Transform { return this._localToWorldA; }\r\n  /** (property accessor) rigid frame at end of motion */\r\n  public get localToWorldB(): Transform { return this._localToWorldB; }\r\n  private _rotationAxis: Vector3d;\r\n  private _rotationAngle: Angle;\r\n\r\n  /**\r\n   * CAPTURE local corners, pickup and putdown frames, and rotation-around-vector data\r\n   * @param localCornerA\r\n   * @param localCornerB\r\n   * @param localToWordA\r\n   * @param localToWordB\r\n   * @param rotationAxis\r\n   * @param rotationAngle\r\n   */\r\n  private constructor(localToWorldA: Transform, localCornerA: Point3d[], localToWorldB: Transform, localCornerB: Point3d[], rotationAxis: Vector3d, rotationAngle: Angle) {\r\n    this._localCornerA = localCornerA;\r\n    this._localCornerB = localCornerB;\r\n    this._localToWorldA = localToWorldA;\r\n    this._localToWorldB = localToWorldB;\r\n    this._rotationAxis = rotationAxis;\r\n    this._rotationAngle = rotationAngle;\r\n  }\r\n\r\n  /**\r\n   * Set up rotation data for smooth transition from 8 point frusta cornerA and cornerB\r\n   * @param cornerA\r\n   * @param cornerB\r\n   */\r\n  public static create(cornerA: Point3d[], cornerB: Point3d[], preferSimpleRotation: boolean = true): SmoothTransformBetweenFrusta | undefined {\r\n    const localToWorldA = Point3dArray.evaluateTrilinearDerivativeTransform(cornerA, 0.5, 0.5, 0.5);\r\n    const localToWorldB = Point3dArray.evaluateTrilinearDerivativeTransform(cornerB, 0.5, 0.5, 0.5);\r\n    const rigidA = Transform.createOriginAndMatrix(localToWorldA.origin, Matrix3d.createRigidFromMatrix3d(localToWorldA.matrix, AxisOrder.ZXY));\r\n    const rigidB = Transform.createOriginAndMatrix(localToWorldB.origin, Matrix3d.createRigidFromMatrix3d(localToWorldB.matrix, AxisOrder.ZXY));\r\n    if (rigidA.matrix.computeCachedInverse(true) && rigidB.matrix.computeCachedInverse(true)) {\r\n      const spinMatrix = rigidB.matrix.multiplyMatrixMatrixInverse(rigidA.matrix)!;\r\n      const spinAxis = spinMatrix.getAxisAndAngleOfRotation();\r\n      const localCornerA = rigidA.multiplyInversePoint3dArray(cornerA)!;\r\n      const localCornerB = rigidB.multiplyInversePoint3dArray(cornerB)!;\r\n      /** Is this a pure rotation -- i.e. no clip volume resizing for camera or clip changes */\r\n      if (preferSimpleRotation && Point3dArray.isAlmostEqual(localCornerA, localCornerB) && !spinAxis.angle.isAlmostZero) {\r\n        // world vectors\r\n        const worldOriginShift = Vector3d.createStartEnd(localToWorldA.origin, localToWorldB.origin);\r\n        const chordMidPoint = localToWorldA.getOrigin().interpolate(0.5, localToWorldB.getOrigin());\r\n        const bisector = spinAxis.axis.unitCrossProduct(worldOriginShift);\r\n        if (bisector) {\r\n          const halfChordLength = 0.5 * worldOriginShift.magnitude();\r\n          const alpha = Geometry.conditionalDivideFraction(halfChordLength, Math.tan(spinAxis.angle.radians * 0.5));\r\n          if (alpha !== undefined) {\r\n            const spinCenter = chordMidPoint.plusScaled(bisector, alpha);\r\n            const rigidA1 = Transform.createOriginAndMatrix(spinCenter, rigidA.matrix);\r\n            const rigidB1 = Transform.createOriginAndMatrix(spinCenter, rigidB.matrix);\r\n            const localCornerA1 = rigidA1.multiplyInversePoint3dArray(cornerA)!;\r\n            const localCornerB1 = rigidB1.multiplyInversePoint3dArray(cornerB)!;\r\n            return new SmoothTransformBetweenFrusta(rigidA1, localCornerA1, rigidB1, localCornerB1,\r\n              spinAxis.axis, spinAxis.angle);\r\n          }\r\n        }\r\n      }\r\n      return new SmoothTransformBetweenFrusta(rigidA, localCornerA, rigidB, localCornerB,\r\n        spinAxis.axis, spinAxis.angle);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** interpolate local corner coordinates at fractional move from m_localFrustum0 to m_localFrustum1 */\r\n  public interpolateLocalCorners(fraction: number, result?: Point3d[]): Point3d[] {\r\n    result = result || [];\r\n    result.length = 0;\r\n    const n = this._localCornerA.length;\r\n    for (let i = 0; i < n; i++) {\r\n      result.push(this._localCornerA[i].interpolate(fraction, this._localCornerB[i]));\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * After initialization, call this for various intermediate fractions.\r\n   * The returned corner points are in world coordinates \"between\" start and end positions.\r\n   */\r\n  public fractionToWorldCorners(fraction: number, result?: Point3d[]): Point3d[] {\r\n    const corners = this.interpolateLocalCorners(fraction, result);\r\n    const fractionalRotation = Matrix3d.createRotationAroundVector(this._rotationAxis,\r\n      this._rotationAngle.cloneScaled(fraction))!;\r\n    const axes0 = this._localToWorldA.matrix;\r\n    const fractionalAxes = fractionalRotation.multiplyMatrixMatrix(axes0);\r\n    const fractionalOrigin = this._localToWorldA.getOrigin().interpolate(fraction, this._localToWorldB.origin);\r\n    const putdownFrame = Transform.createOriginAndMatrix(fractionalOrigin, fractionalAxes);\r\n    putdownFrame.multiplyPoint3dArray(corners, corners);\r\n    return corners;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\r\nimport { UnionRegion } from \"../curve/UnionRegion\";\r\nimport { BagOfCurves, CurveCollection } from \"../curve/CurveCollection\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { BSplineSurface3d, BSplineSurface3dH } from \"../bspline/BSplineSurface\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\nimport { TransitionSpiral3d } from \"../curve/TransitionSpiral\";\r\n\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PointString3d } from \"../curve/PointString3d\";\r\nimport { Plane3dByOriginAndVectors } from \"./Plane3dByOriginAndVectors\";\r\nimport { BezierCurveBase } from \"../bspline/BezierCurveBase\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Vector2d } from \"./Point2dVector2d\";\r\n/**\r\n * * `GeometryHandler` defines the base abstract methods for double-dispatch geometry computation.\r\n * * User code that wants to handle one or all of the commonly known geometry types implements a handler class.\r\n * * User code that does not handle all types is most likely to start with `NullGeometryHandler`, which will provide no-action implementations for all types.\r\n * @public\r\n */\r\nexport abstract class GeometryHandler {\r\n  /** handle strongly typed LineSegment3d */\r\n  public abstract handleLineSegment3d(g: LineSegment3d): any;\r\n  /** handle strongly typed  LineString3d  */\r\n  public abstract handleLineString3d(g: LineString3d): any;\r\n  /** handle strongly typed  Arc3d  */\r\n  public abstract handleArc3d(g: Arc3d): any;\r\n  /** handle strongly typed  CurveCollection  */\r\n  public handleCurveCollection(_g: CurveCollection): any { }\r\n  /** handle strongly typed  BSplineCurve3d  */\r\n  public abstract handleBSplineCurve3d(g: BSplineCurve3d): any;\r\n  /** handle strongly typed  BSplineCurve3dH  */\r\n  public abstract handleBSplineCurve3dH(g: BSplineCurve3dH): any;\r\n  /** handle strongly typed  BSplineSurface3d  */\r\n  public abstract handleBSplineSurface3d(g: BSplineSurface3d): any;\r\n  /** handle strongly typed  CoordinateXYZ  */\r\n  public abstract handleCoordinateXYZ(g: CoordinateXYZ): any;\r\n  /** handle strongly typed  BSplineSurface3dH  */\r\n  public abstract handleBSplineSurface3dH(g: BSplineSurface3dH): any;\r\n  /** handle strongly typed  IndexedPolyface  */\r\n  public abstract handleIndexedPolyface(g: IndexedPolyface): any;\r\n  /** handle strongly typed TransitionSpiral3d\r\n   * @alpha\r\n   */\r\n  public abstract handleTransitionSpiral(g: TransitionSpiral3d): any;\r\n\r\n  /** handle strongly typed Path (base class method calls handleCurveCollection) */\r\n  public handlePath(g: Path): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  Loop (base class method calls handleCurveCollection) */\r\n  public handleLoop(g: Loop): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  ParityRegion (base class method calls handleCurveCollection) */\r\n  public handleParityRegion(g: ParityRegion): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  UnionRegion (base class method calls handleCurveCollection) */\r\n  public handleUnionRegion(g: UnionRegion): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  BagOfCurves (base class method calls handleCurveCollection) */\r\n  public handleBagOfCurves(g: BagOfCurves): any { return this.handleCurveCollection(g); }\r\n  /** handle strongly typed  Sphere */\r\n  public abstract handleSphere(g: Sphere): any;\r\n  /** handle strongly typed  Cone */\r\n  public abstract handleCone(g: Cone): any;\r\n  /** handle strongly typed  Box */\r\n  public abstract handleBox(g: Box): any;\r\n  /** handle strongly typed  TorusPipe */\r\n  public abstract handleTorusPipe(g: TorusPipe): any;\r\n  /** handle strongly typed  LinearSweep */\r\n  public abstract handleLinearSweep(g: LinearSweep): any;\r\n  /** handle strongly typed  RotationalSweep */\r\n  public abstract handleRotationalSweep(g: RotationalSweep): any;\r\n  /** handle strongly typed  RuledSweep */\r\n  public abstract handleRuledSweep(g: RuledSweep): any;\r\n  /** handle strongly typed  PointString3d */\r\n  public abstract handlePointString3d(g: PointString3d): any;\r\n  /** handle strongly typed  BezierCurve3d */\r\n  public abstract handleBezierCurve3d(g: BezierCurve3d): any;\r\n  /** handle strongly typed  BezierCurve3dH */\r\n  public abstract handleBezierCurve3dH(g: BezierCurve3dH): any;\r\n}\r\n/**\r\n * `NullGeometryHandler` is a base class for dispatching various geometry types to\r\n * application specific implementation of some service.\r\n *\r\n * To use:\r\n * * Derive a class from `NullGeometryHandler`\r\n * * Reimplement any or all of the specific `handleXXXX` methods\r\n * * Create a handler instance `myHandler`\r\n * * To send a `GeometryQuery` object `candidateGeometry` through the (fast) dispatch, invoke   `candidateGeometry.dispatchToHandler (myHandler)\r\n * * The appropriate method or methods will get called with a strongly typed `_g ` value.\r\n * @public\r\n */\r\nexport class NullGeometryHandler extends GeometryHandler {\r\n  /** no-action implementation */\r\n  public handleLineSegment3d(_g: LineSegment3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLineString3d(_g: LineString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleArc3d(_g: Arc3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleCurveCollection(_g: CurveCollection): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3d(_g: BSplineCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3dH(_g: BSplineCurve3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3d(_g: BSplineSurface3d): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handleCoordinateXYZ(_g: CoordinateXYZ): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3dH(_g: BSplineSurface3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleIndexedPolyface(_g: IndexedPolyface): any { return undefined; }\r\n  /** no-action implementation\r\n   * @alpha\r\n   */\r\n  public handleTransitionSpiral(_g: TransitionSpiral3d): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handlePath(_g: Path): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLoop(_g: Loop): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleParityRegion(_g: ParityRegion): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleUnionRegion(_g: UnionRegion): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBagOfCurves(_g: BagOfCurves): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handleSphere(_g: Sphere): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleCone(_g: Cone): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBox(_g: Box): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleTorusPipe(_g: TorusPipe): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLinearSweep(_g: LinearSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRotationalSweep(_g: RotationalSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRuledSweep(_g: RuledSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handlePointString3d(_g: PointString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3d(_g: BezierCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3dH(_g: BezierCurve3dH): any { return undefined; }\r\n}\r\n/**\r\n * Implement GeometryHandler methods, with all curve collection methods recursing to children.\r\n * @public\r\n */\r\nexport class RecurseToCurvesGeometryHandler extends GeometryHandler {\r\n  /** no-action implementation */\r\n  public handleLineSegment3d(_g: LineSegment3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLineString3d(_g: LineString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleArc3d(_g: Arc3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3d(_g: BSplineCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineCurve3dH(_g: BSplineCurve3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3d(_g: BSplineSurface3d): any { return undefined; }\r\n\r\n  /** no-action implementation */\r\n  public handleCoordinateXYZ(_g: CoordinateXYZ): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBSplineSurface3dH(_g: BSplineSurface3dH): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleIndexedPolyface(_g: IndexedPolyface): any { return undefined; }\r\n  /** no-action implementation\r\n   * @alpha\r\n   */\r\n  public handleTransitionSpiral(_g: TransitionSpiral3d): any { return undefined; }\r\n  /** Invoke `child.dispatchToGeometryHandler(this)` for each child in the array returned by the query `g.children` */\r\n  public handleChildren(g: GeometryQuery): any {\r\n    const children = g.children;\r\n    if (children)\r\n      for (const child of children) {\r\n        child.dispatchToGeometryHandler(this);\r\n      }\r\n  }\r\n  /** Recurse to children */\r\n  public handleCurveCollection(g: CurveCollection): any { return this.handleChildren(g); }\r\n\r\n  /** Recurse to children */\r\n  public handlePath(g: Path): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleLoop(g: Loop): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleParityRegion(g: ParityRegion): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleUnionRegion(g: UnionRegion): any { return this.handleChildren(g); }\r\n  /** Recurse to children */\r\n  public handleBagOfCurves(g: BagOfCurves): any { return this.handleChildren(g); }\r\n\r\n  /** no-action implementation */\r\n  public handleSphere(_g: Sphere): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleCone(_g: Cone): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBox(_g: Box): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleTorusPipe(_g: TorusPipe): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleLinearSweep(_g: LinearSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRotationalSweep(_g: RotationalSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleRuledSweep(_g: RuledSweep): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handlePointString3d(_g: PointString3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3d(_g: BezierCurve3d): any { return undefined; }\r\n  /** no-action implementation */\r\n  public handleBezierCurve3dH(_g: BezierCurve3dH): any { return undefined; }\r\n}\r\n\r\n/** IStrokeHandler is an interface with methods to receive data about curves being stroked.\r\n * CurvePrimitives emitStrokes () methods emit calls to a handler object with these methods.\r\n * The various CurvePrimitive types are free to announce either single points (announcePoint), linear fragments,\r\n * or fractional intervals of the parent curve.\r\n * * handler.startCurvePrimitive (cp) -- announce the curve primitive whose strokes will follow.\r\n * * announcePointTangent (xyz, fraction, tangent) -- announce a single point on the curve.\r\n * * announceIntervalForUniformStepStrokes (cp, numStrokes, fraction0, fraction1) -- announce a fraction\r\n * interval in which the curve can be evaluated (e.g. the handler can call cp->fractionToPointAndDerivative ())\r\n * * announceSegmentInterval (cp, point0, point1, numStrokes, fraction0, fraction1) -- announce\r\n *    that the fractional interval fraction0, fraction1 is a straight line which should be broken into\r\n *    numStrokes strokes.\r\n *   * A LineSegment would make a single call to this.\r\n *   * A LineString would make one call to this for each of its segments, with fractions indicating position\r\n * within the linestring.\r\n * * endCurvePrimitive (cp) -- announce the end of the curve primitive.\r\n * @public\r\n */\r\nexport interface IStrokeHandler {\r\n  /** announce a parent curve primitive\r\n   * * startParentCurvePrimitive() ...endParentCurvePrimitive() are wrapped around startCurvePrimitive and endCurvePrimitive when the interior primitive is a proxy.\r\n   */\r\n  startParentCurvePrimitive(cp: CurvePrimitive): void;\r\n  /** Announce the curve primitive that will be described in subsequent calls. */\r\n  startCurvePrimitive(cp: CurvePrimitive): void;\r\n  /**\r\n   * announce a single point with its fraction and tangent.\r\n   * * (IMPORTANT) the same Point3d and Vector3d will be reset and passed on multiple calls.\r\n   * * (THEREFORE) if the implementation is saving coordinates, it must copy the xyz data out into its own data structure rather than save the references.\r\n   */\r\n  announcePointTangent(xyz: Point3d, fraction: number, tangent: Vector3d): void;\r\n\r\n  /** Announce that curve primitive cp should be evaluated in the specified fraction interval. */\r\n  announceIntervalForUniformStepStrokes(\r\n    cp: CurvePrimitive,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void;\r\n  /** Announce numPoints interpolated between point0 and point1, with associated fractions */\r\n  announceSegmentInterval(\r\n    cp: CurvePrimitive,\r\n    point0: Point3d,\r\n    point1: Point3d,\r\n    numStrokes: number,\r\n    fraction0: number,\r\n    fraction1: number): void;\r\n  /** Announce that all data about `cp` has been announced. */\r\n  endCurvePrimitive(cp: CurvePrimitive): void;\r\n  /** Announce that all data about the parent primitive has been announced. */\r\n  endParentCurvePrimitive(cp: CurvePrimitive): void;\r\n  /**\r\n   * Announce a bezier curve fragment.\r\n   * * this is usually a section of BsplineCurve\r\n   * * If this function is missing, the same interval will be passed to announceIntervalForUniformSteps.\r\n   * @param bezier bezier fragment\r\n   * @param numStrokes suggested number of strokes (uniform in bezier interval 0..1)\r\n   * @param parent parent curve\r\n   * @param spanIndex spanIndex within parent\r\n   * @param fraction0 start fraction on parent curve\r\n   * @param fraction1 end fraction on parent curve\r\n   */\r\n  announceBezierCurve?(\r\n    bezier: BezierCurveBase,\r\n    numStrokes: number,\r\n    parent: CurvePrimitive,\r\n    spandex: number,\r\n    fraction0: number,\r\n    fraction1: number): void;\r\n}\r\n\r\n/**\r\n * Interface with methods for mapping (u,v) fractional coordinates to surface xyz and derivatives.\r\n * @public\r\n */\r\nexport interface UVSurface {\r\n  /**\r\n   * Convert fractional u and v coordinates to surface point\r\n   * @param uFraction fractional coordinate in u direction\r\n   * @param vFraction fractional coordinate in the v direction\r\n   * @param result optional pre-allocated point\r\n   */\r\n  uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d;\r\n  /**\r\n   * Convert fractional u and v coordinates to surface point and in-surface tangent directions.\r\n   * * Remark: the vectors are expected to be non-zero tangents which can be crossed to get a normal.\r\n   * * Hence the are NOT precisely either (a) partial derivatives or (b) frenet vectors\r\n   * @param uFraction fractional coordinate in u direction\r\n   * @param vFraction fractional coordinate in the v direction\r\n   * @param result optional pre-allocated carrier for point and vectors\r\n   */\r\n  uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors;\r\n}\r\n/**\r\n * Interface for queries of distance-along in u and v directions\r\n * @public\r\n */\r\nexport interface UVSurfaceIsoParametricDistance {\r\n  /**\r\n   * * Return a vector whose x and y parts are \"size\" of the surface in the u and v directions.\r\n   * * Sizes are use for applying scaling to mesh parameters\r\n   * * These sizes are (reasonable approximations of) the max curve length along u and v isoparameter lines.\r\n   *   * e.g. for a sphere, these are:\r\n   *      * u direction = distance around the equator\r\n   *      * v direction = distance from south pole to north pole.\r\n   */\r\n  maxIsoParametricDistance(): Vector2d;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BlockComparisonFunction } from \"./GrowableFloat64Array\";\r\n/** @module ArraysAndInterfaces */\r\n\r\n/**\r\n * Array of contiguous doubles, indexed by block number and index within block.\r\n * * This is essentially a rectangular matrix (two dimensional array), with each block being a row of the matrix.\r\n * @public\r\n */\r\nexport class GrowableBlockedArray {\r\n  /** underlying contiguous, oversized buffer. */\r\n  protected _data: Float64Array;\r\n  /** Number of blocks (matrix rows) in use. */\r\n  protected _inUse: number;\r\n  /** number of numbers per block in the array.\r\n   * * If viewing the array as a two dimensional array, this is the row size.\r\n   */\r\n  protected _blockSize: number;  // positive integer !!!\r\n  public constructor(blockSize: number, initialBlocks: number = 8) {\r\n    /** array contents in blocked (row-major) order, possibly with extra capacity\r\n     * Total capacity is `this._data.length`\r\n     * Actual in-use count is `this._inUse * this._blockSize`\r\n     */\r\n    this._data = new Float64Array(initialBlocks * blockSize);\r\n    this._inUse = 0;\r\n    this._blockSize = blockSize;\r\n  }\r\n  /** computed property: length (in blocks, not doubles) */\r\n  public get numBlocks(): number { return this._inUse; }\r\n  /** property: number of data values per block */\r\n  public get numPerBlock(): number { return this._blockSize; }\r\n  /**\r\n   * Return a single value indexed within a block\r\n   * @param blockIndex index of block to read\r\n   * @param indexInBlock  offset within the block\r\n   */\r\n  public getWithinBlock(blockIndex: number, indexWithinBlock: number): number {\r\n    return this._data[blockIndex * this._blockSize + indexWithinBlock];\r\n  }\r\n  /** clear the block count to zero, but maintain the allocated memory */\r\n  public clear() { this._inUse = 0; }\r\n  /** Return the capacity in blocks (not doubles) */\r\n  public blockCapacity() {\r\n    return this._data.length / this._blockSize;\r\n  }\r\n  /** ensure capacity (in blocks, not doubles) */\r\n  public ensureBlockCapacity(blockCapacity: number) {\r\n    if (blockCapacity > this.blockCapacity()) {\r\n      const newData = new Float64Array(blockCapacity * this._blockSize);\r\n      for (let i = 0; i < this._data.length; i++) {\r\n        newData[i] = this._data[i];\r\n      }\r\n      this._data = newData;\r\n    }\r\n  }\r\n  /** Add a new block of data.\r\n   * * If newData has fewer than numPerBlock entries, the remaining part of the new block is zeros.\r\n   * * If newData has more entries, only the first numPerBlock are taken.\r\n   */\r\n  public addBlock(newData: number[]) {\r\n    const k0 = this.newBlockIndex();\r\n    let numValue = newData.length;\r\n    if (numValue > this._blockSize)\r\n      numValue = this._blockSize;\r\n    for (let i = 0; i < numValue; i++)\r\n      this._data[k0 + i] = newData[i];\r\n  }\r\n  /**\r\n   * Return the starting index of a block of (zero-initialized) doubles at the end.\r\n   *\r\n   * * this.data is reallocated if needed to include the new block.\r\n   * * The inUse count is incremented to include the new block.\r\n   * * The returned block is an index to the Float64Array (not a block index)\r\n   */\r\n  protected newBlockIndex(): number {\r\n    const index = this._blockSize * this._inUse;\r\n    if ((index + 1) > this._data.length)\r\n      this.ensureBlockCapacity(1 + 2 * this._inUse);\r\n    this._inUse++;\r\n    for (let i = index; i < index + this._blockSize; i++)\r\n      this._data[i] = 0.0;\r\n    return index;\r\n  }\r\n  /** reduce the block count by one. */\r\n  public popBlock() {\r\n    if (this._inUse > 0)\r\n      this._inUse--;\r\n  }\r\n  /** convert a block index to the simple index to the underlying Float64Array. */\r\n  protected blockIndexToDoubleIndex(blockIndex: number) { return this._blockSize * blockIndex; }\r\n  /** Access a single double at offset within a block, with index checking and return undefined if indexing is invalid. */\r\n  public checkedComponent(blockIndex: number, componentIndex: number): number | undefined {\r\n    if (blockIndex >= this._inUse || blockIndex < 0 || componentIndex < 0 || componentIndex >= this._blockSize)\r\n      return undefined;\r\n    return this._data[this._blockSize * blockIndex + componentIndex];\r\n  }\r\n  /** Access a single double at offset within a block.  This has no index checking. */\r\n  public component(blockIndex: number, componentIndex: number): number {\r\n    return this._data[this._blockSize * blockIndex + componentIndex];\r\n  }\r\n  /** compare two blocks in simple lexical order.\r\n   * @param data data array\r\n   * @param blockSize number of items to compare\r\n   * @param ia raw index (not block index) of first block\r\n   * @param ib raw index (not block index) of second block\r\n   */\r\n  public static compareLexicalBlock(data: Float64Array, blockSize: number, ia: number, ib: number): number {\r\n    let ax = 0;\r\n    let bx = 0;\r\n    for (let i = 0; i < blockSize; i++) {\r\n      ax = data[ia + i];\r\n      bx = data[ib + i];\r\n      if (ax > bx) return 1;\r\n      if (ax < bx) return -1;\r\n    }\r\n    return ia - ib; // so original order is maintained among duplicates !!!!\r\n  }\r\n  /** Return an array of block indices sorted per compareLexicalBlock function */\r\n  public sortIndicesLexical(compareBlocks: BlockComparisonFunction = GrowableBlockedArray.compareLexicalBlock): Uint32Array {\r\n    const n = this._inUse;\r\n    // let numCompare = 0;\r\n    const result = new Uint32Array(n);\r\n    const data = this._data;\r\n    const blockSize = this._blockSize;\r\n    for (let i = 0; i < n; i++)result[i] = i;\r\n    result.sort(\r\n      (blockIndexA: number, blockIndexB: number) => {\r\n        // numCompare++;\r\n        return compareBlocks(data, blockSize, blockIndexA * blockSize, blockIndexB * blockSize);\r\n      });\r\n    // console.log (n, numCompare);\r\n    return result;\r\n  }\r\n  /** Return the distance (hypotenuse=sqrt(summed squares)) between indicated blocks */\r\n  public distanceBetweenBlocks(blockIndexA: number, blockIndexB: number): number {\r\n    let dd = 0.0;\r\n    let iA = this.blockIndexToDoubleIndex(blockIndexA);\r\n    let iB = this.blockIndexToDoubleIndex(blockIndexB);\r\n    let a = 0;\r\n    const data = this._data;\r\n    for (let i = 0; i < this._blockSize; i++) {\r\n      a = data[iA++] - data[iB++];\r\n      dd += a * a;\r\n    }\r\n    return Math.sqrt(dd);\r\n  }\r\n\r\n  /** Return the distance (hypotenuse=sqrt(summed squares)) between block entries `iBegin <= i < iEnd` of indicated blocks */\r\n  public distanceBetweenSubBlocks(blockIndexA: number, blockIndexB: number, iBegin: number, iEnd: number): number {\r\n    let dd = 0.0;\r\n    const iA = this.blockIndexToDoubleIndex(blockIndexA);\r\n    const iB = this.blockIndexToDoubleIndex(blockIndexB);\r\n    let a = 0;\r\n    const data = this._data;\r\n    for (let i = iBegin; i < iEnd; i++) {\r\n      a = data[iA + i] - data[iB + i];\r\n      dd += a * a;\r\n    }\r\n    return Math.sqrt(dd);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\n/**\r\n * Type for a OptionalGrowableFloat64Array or undefined.\r\n * @public\r\n */\r\nexport type OptionalGrowableFloat64Array = GrowableFloat64Array | undefined;\r\n/**\r\n * Signature for a function which does lexical comparison of `blockSize` consecutive values as 2 starting indices.\r\n * @public\r\n */\r\nexport type BlockComparisonFunction = (data: Float64Array, blockSize: number, index0: number, index1: number) => number;\r\n/**\r\n * A `GrowableFloat64Array` is Float64Array accompanied by a count of how many of the array's entries are considered in use.\r\n * * In C++ terms, this is like an std::vector\r\n * * As entries are added to the array, the buffer is reallocated as needed to accommodate.\r\n * * The reallocations leave unused space to accept further additional entries without reallocation.\r\n * * The `length` property returns the number of entries in use.\r\n * * the `capacity` property returns the (usually larger) length of the (overallocated) Float64Array.\r\n * @public\r\n */\r\nexport class GrowableFloat64Array {\r\n  private _data: Float64Array;\r\n  private _inUse: number;\r\n  constructor(initialCapacity: number = 8) {\r\n    this._data = new Float64Array(initialCapacity);\r\n    this._inUse = 0;\r\n  }\r\n  /**\r\n   * Create a GrowableFloat64Array with given contents.\r\n   * @param contents data to copy into the array\r\n   */\r\n  public static create(contents: Float64Array | number[]): GrowableFloat64Array {\r\n    const result = new GrowableFloat64Array(contents.length);\r\n    for (const a of contents) {\r\n      result.push(a);\r\n    }\r\n    return result;\r\n  }\r\n  /** sort-compatible comparison.\r\n   * * Returns `(a-b)` which is\r\n   *   * negative if `a<b`\r\n   *   * zero if `a === b` (with exact equality)\r\n   *   * positive if `a>b`\r\n   */\r\n  public static compare(a: any, b: any): number {\r\n    return a - b;\r\n  }\r\n  /** Return a new array with\r\n   * * All active entries copied from this instance\r\n   * * optionally trimmed capacity to the active length or replicate the capacity and unused space.\r\n   */\r\n  public clone(maintainExcessCapacity: boolean = false): GrowableFloat64Array {\r\n    const n = this._inUse;\r\n    const data = this._data;\r\n    const out = new GrowableFloat64Array(maintainExcessCapacity ? this.capacity() : n);\r\n    for (let i = 0; i < n; i++)\r\n      out.push(data[i]);\r\n    return out;\r\n  }\r\n  /**\r\n   * Returns the number of entries in use.\r\n   * * Note that this is typically smaller than the length of the length of the supporting `Float64Array`\r\n   */\r\n  public get length() {\r\n    return this._inUse;\r\n  }\r\n  /**\r\n   * Set the value at specified index.\r\n   * @param index index of entry to set\r\n   * @param value value to set\r\n   */\r\n  public setAtUncheckedIndex(index: number, value: number) {\r\n    this._data[index] = value;\r\n  }\r\n\r\n  /**\r\n   * Move the value at index i to index j.\r\n   * @param i source index\r\n   * @param j destination index.\r\n   */\r\n  public move(i: number, j: number) {\r\n    this._data[j] = this._data[i];\r\n  }\r\n  /**\r\n   * swap the values at indices i and j\r\n   * @param i first index\r\n   * @param j second index\r\n   */\r\n  public swap(i: number, j: number) {\r\n    const a = this._data[i];\r\n    this._data[i] = this._data[j];\r\n    this._data[j] = a;\r\n  }\r\n\r\n  /**\r\n   * append a single value to the array.\r\n   * @param toPush value to append to the active array.\r\n   */\r\n  public push(toPush: number) {\r\n    if (this._inUse + 1 <= this._data.length) {\r\n      this._data[this._inUse] = toPush;\r\n      this._inUse++;\r\n    } else {\r\n      // Make new array (double size), copy values, then push toPush\r\n      const newData = new Float64Array(4 + this._inUse * 2);\r\n      for (let i = 0; i < this._inUse; i++) {\r\n        newData[i] = this._data[i];\r\n      }\r\n      this._data = newData;\r\n      this._data[this._inUse] = toPush;\r\n      this._inUse++;\r\n    }\r\n  }\r\n  /** Push a `numToCopy` consecutive values starting at `copyFromIndex` to the end of the array. */\r\n  public pushBlockCopy(copyFromIndex: number, numToCopy: number) {\r\n    const newLength = this._inUse + numToCopy;\r\n    this.ensureCapacity(newLength);\r\n    const limit = copyFromIndex + numToCopy;\r\n    for (let i = copyFromIndex; i < limit; i++)\r\n      this._data[this._inUse++] = this._data[i];\r\n  }\r\n  /** Clear the array to 0 length.  The underlying memory remains allocated for reuse. */\r\n  public clear() {\r\n    while (this._inUse > 0)\r\n      this.pop();\r\n  }\r\n  /**\r\n   * Returns the number of entries in the supporting Float64Array buffer.\r\n   * * This number can be larger than the `length` property.\r\n   */\r\n  public capacity() {\r\n    return this._data.length;\r\n  }\r\n  /**\r\n   * * If the capacity (Float64Array length) is less than or equal to the requested newCapacity, do nothing\r\n   * * If the requested newCapacity is larger than the existing capacity, reallocate (and copy existing values) with the larger capacity.\r\n   * @param newCapacity\r\n   */\r\n  public ensureCapacity(newCapacity: number) {\r\n    if (newCapacity > this.capacity()) {\r\n      const oldInUse = this._inUse;\r\n      const newData = new Float64Array(newCapacity);\r\n      for (let i = 0; i < oldInUse; i++)\r\n        newData[i] = this._data[i];\r\n      this._data = newData;\r\n    }\r\n  }\r\n  /**\r\n   * * If newLength is less than current (active) length, just set (active) length.\r\n   * * If newLength is greater, ensureCapacity (newSize) and pad with padValue up to newSize;\r\n   * @param newLength new data count\r\n   * @param padValue value to use for padding if the length increases.\r\n   */\r\n  public resize(newLength: number, padValue: number = 0) {\r\n    // quick out for easy case ...\r\n    if (newLength <= this._inUse) {\r\n      this._inUse = newLength;\r\n      return;\r\n    }\r\n    const oldLength = this._inUse;\r\n    this.ensureCapacity(newLength);\r\n    for (let i = oldLength; i < newLength; i++)\r\n      this._data[i] = padValue;\r\n    this._inUse = newLength;\r\n  }\r\n  /**\r\n   * * Reduce the length by one.\r\n   * * Note that there is no method return value -- use `back` to get that value before `pop()`\r\n   * * (As with std::vector, separating the `pop` from the value access eliminates error testing from `pop` call)\r\n   */\r\n  public pop() {\r\n    // Could technically access outside of array, if filled and then reduced using pop (similar to C\r\n    // and accessing out of bounds), but with adjusted inUse counter, that data will eventually be overwritten\r\n    if (this._inUse > 0) {\r\n      this._inUse--;\r\n    }\r\n  }\r\n  /** Access by index, without bounds check */\r\n  public atUncheckedIndex(index: number): number {\r\n    return this._data[index];\r\n  }\r\n  /** Access the 0-index member, without bounds check */\r\n  public front() {\r\n    return this._data[0];\r\n  }\r\n  /** Access the final member, without bounds check */\r\n  public back() {\r\n    return this._data[this._inUse - 1];\r\n  }\r\n  /** set a value by index */\r\n  public reassign(index: number, value: number) {\r\n    this._data[index] = value;\r\n  }\r\n\r\n  /**\r\n   * * Sort the array entries.\r\n   * * Uses insertion sort -- fine for small arrays (less than 30), slow for larger arrays\r\n   * @param compareMethod comparison method\r\n   */\r\n  public sort(compareMethod: (a: any, b: any) => number = GrowableFloat64Array.compare) {\r\n    for (let i = 0; i < this._inUse; i++) {\r\n      for (let j = i + 1; j < this._inUse; j++) {\r\n        const tempI = this._data[i];\r\n        const tempJ = this._data[j];\r\n        if (compareMethod(tempI, tempJ) > 0) {\r\n          this._data[i] = tempJ;\r\n          this._data[j] = tempI;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * compress out values not within the [a,b] interval.\r\n   * * Note that if a is greater than b all values are rejected.\r\n   * @param a low value for accepted interval\r\n   * @param b high value for accepted interval\r\n   */\r\n  public restrictToInterval(a: number, b: number) {\r\n    const data = this._data;\r\n    const n = data.length;\r\n    let numAccept = 0;\r\n    let q = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      q = data[i];\r\n      if (q >= a && q <= b)\r\n        data[numAccept++] = q;\r\n    }\r\n    this._inUse = numAccept;\r\n  }\r\n\r\n  /**\r\n   * * compress out multiple copies of values.\r\n   * * this is done in the current order of the array.\r\n   */\r\n  public compressAdjacentDuplicates(tolerance: number = 0.0) {\r\n    const data = this._data;\r\n    const n = this._inUse;\r\n    if (n === 0)\r\n      return;\r\n\r\n    let numAccepted = 1;\r\n    let a = data[0];\r\n    let b;\r\n    for (let i = 1; i < n; i++) {\r\n      b = data[i];\r\n      if (Math.abs(b - a) > tolerance) {\r\n        data[numAccepted++] = b;\r\n        a = b;\r\n      }\r\n    }\r\n    this._inUse = numAccepted;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { XAndY, XYAndZ } from \"./XYZProps\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\nimport { Range2d } from \"./Range\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { IndexedXYCollection } from \"./IndexedXYCollection\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\nimport { Point3d } from \"./Point3dVector3d\";\r\n\r\n/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.\r\n * @public\r\n */\r\nexport class GrowableXYArray extends IndexedXYCollection {\r\n  /**\r\n   * array of packed xyzxyzxyz components\r\n   */\r\n  private _data: Float64Array;\r\n  /**\r\n   * Number of xyz triples (not floats) in the array\r\n   */\r\n  private _xyInUse: number;\r\n  /**\r\n   * capacity in xyz triples. (not floats)\r\n   */\r\n  private _xyzCapacity: number;\r\n  /** Construct a new GrowablePoint2d array.\r\n   * @param numPoints [in] initial capacity.\r\n   */\r\n  public constructor(numPoints: number = 8) {\r\n    super();\r\n    this._data = new Float64Array(numPoints * 2);   // 8 Points to start (2 values each)\r\n    this._xyInUse = 0;\r\n    this._xyzCapacity = numPoints;\r\n  }\r\n  /** Return the number of points in use. */\r\n  public get length() { return this._xyInUse; }\r\n  /** Return the number of float64 in use. */\r\n  public get float64Length() { return this._xyInUse * 2; }\r\n  /** Return the raw packed data.\r\n   * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity\r\n   */\r\n  public float64Data(): Float64Array { return this._data; }\r\n\r\n  /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */\r\n  public ensureCapacity(pointCapacity: number) {\r\n    if (pointCapacity > this._xyzCapacity) {\r\n      const newData = new Float64Array(pointCapacity * 2);\r\n      const numCopy = this.length * 2;\r\n      for (let i = 0; i < numCopy; i++) newData[i] = this._data[i];\r\n      this._data = newData;\r\n      this._xyzCapacity = pointCapacity;\r\n    }\r\n  }\r\n  /** Resize the actual point count, preserving excess capacity. */\r\n  public resize(pointCount: number) {\r\n    if (pointCount < this.length) {\r\n      this._xyInUse = pointCount >= 0 ? pointCount : 0;\r\n    } else if (pointCount > this._xyzCapacity) {\r\n      const newArray = new Float64Array(pointCount * 2);\r\n      // Copy contents\r\n      for (let i = 0; i < this._data.length; i += 2) {\r\n        newArray[i] = this._data[i];\r\n        newArray[i + 1] = this._data[i + 1];\r\n        newArray[i + 2] = this._data[i + 2];\r\n      }\r\n      this._data = newArray;\r\n      this._xyzCapacity = pointCount;\r\n      this._xyInUse = pointCount;\r\n    }\r\n  }\r\n  /**\r\n   * Make a copy of the (active) points in this array.\r\n   * (The clone does NOT get excess capacity)\r\n   */\r\n  public clone(): GrowableXYArray {\r\n    const newPoints = new GrowableXYArray(this.length);\r\n    const numValue = this.length * 2;\r\n    const newData = newPoints._data;\r\n    const data = this._data;\r\n    for (let i = 0; i < numValue; i++) newData[i] = data[i];\r\n    newPoints._xyInUse = this.length;\r\n    return newPoints;\r\n  }\r\n  /** Create an array populated from\r\n   * * An array of Point2d\r\n   * * An array of Point3d (hidden as XAndY)\r\n   * * An array of objects with keyed values, et `{x:1, y:1}`\r\n   * * A `GrowableXYZArray`\r\n   */\r\n  public static create(data: XAndY[] | GrowableXYZArray): GrowableXYArray {\r\n    const newPoints = new GrowableXYArray(data.length);\r\n    if (data instanceof GrowableXYZArray) {\r\n      newPoints.pushAllXYAndZ(data);\r\n    } else {\r\n      newPoints.pushAll(data);\r\n    }\r\n    return newPoints;\r\n  }\r\n\r\n  /** push a point to the end of the array */\r\n  public push(toPush: XAndY) {\r\n    this.pushXY(toPush.x, toPush.y);\r\n  }\r\n\r\n  /** push all points of an array */\r\n  public pushAll(points: XAndY[]) {\r\n    for (const p of points) this.push(p);\r\n  }\r\n  /** push all points of an array */\r\n  public pushAllXYAndZ(points: XYAndZ[] | GrowableXYZArray) {\r\n    if (points instanceof GrowableXYZArray) {\r\n      const xyzBuffer = points.float64Data();\r\n      const n = points.length * 3;\r\n      for (let i = 0; i + 2 < n; i += 3) {\r\n        this.pushXY(xyzBuffer[i], xyzBuffer[i + 1]);\r\n      }\r\n    } else {\r\n      for (const p of points) this.pushXY(p.x, p.y);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Replicate numWrap xyz values from the front of the array as new values at the end.\r\n   * @param numWrap number of xyz values to replicate\r\n   */\r\n  public pushWrap(numWrap: number) {\r\n    if (this._xyInUse > 0) {\r\n      let k;\r\n      for (let i = 0; i < numWrap; i++) {\r\n        k = 2 * i;\r\n        this.pushXY(this._data[k], this._data[k + 1]);\r\n      }\r\n    }\r\n  }\r\n  /** push a point given by x,y coordinates */\r\n  public pushXY(x: number, y: number) {\r\n    const index = this._xyInUse * 2;\r\n    if (index >= this._data.length)\r\n      this.ensureCapacity(this.length === 0 ? 4 : this.length * 2);\r\n    this._data[index] = x;\r\n    this._data[index + 1] = y;\r\n    this._xyInUse++;\r\n  }\r\n\r\n  /** Remove one point from the back.\r\n   * * NOTE that (in the manner of std::vector native) this is \"just\" removing the point -- no point is NOT returned.\r\n   * * Use `back ()` to get the last x,y,z assembled into a `Point3d `\r\n   */\r\n  public pop() {\r\n    if (this._xyInUse > 0)\r\n      this._xyInUse--;\r\n  }\r\n  /**\r\n   * Test if index is valid for an xyz (point or vector) within this array\r\n   * @param index xyz index to test.\r\n   */\r\n  public isIndexValid(index: number): boolean {\r\n    if (index >= this._xyInUse || index < 0)\r\n      return false;\r\n    return true;\r\n  }\r\n  /**\r\n   * Clear all xyz data, but leave capacity unchanged.\r\n   */\r\n  public clear() {\r\n    this._xyInUse = 0;\r\n  }\r\n  /**\r\n   * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use atPoint2dIndex to have validity test.\r\n   * @param pointIndex index to access\r\n   * @param result optional result\r\n   */\r\n  public getPoint2dAtUncheckedPointIndex(pointIndex: number, result?: Point2d): Point2d {\r\n    const index = 2 * pointIndex;\r\n    return Point2d.create(this._data[index], this._data[index + 1], result);\r\n  }\r\n\r\n  /**\r\n   * Get x coordinate by point index, with no index checking\r\n   * @param pointIndex index to access\r\n   */\r\n  public getXAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this._data[2 * pointIndex];\r\n  }\r\n\r\n  /**\r\n   * Get y coordinate by index, with no index checking\r\n   * @param pointIndex index to access\r\n   */\r\n  public getYAtUncheckedPointIndex(pointIndex: number): number {\r\n    return this._data[2 * pointIndex + 1];\r\n  }\r\n\r\n  /**\r\n   * Gather all points as a Point2d[]\r\n   */\r\n  public getPoint2dArray(): Point2d[] {\r\n    const n = 2 * this._xyInUse;\r\n    const result = [];\r\n    const data = this._data;\r\n    for (let i = 0; i < n; i += 2)\r\n      result.push(Point2d.create(data[i], data[i + 1]));\r\n    return result;\r\n  }\r\n\r\n  /** copy xyz into strongly typed Point2d */\r\n  public getPoint2dAtCheckedPointIndex(pointIndex: number, result?: Point2d): Point2d | undefined {\r\n    const index = 2 * pointIndex;\r\n    if (this.isIndexValid(pointIndex)) {\r\n      return Point2d.create(this._data[index], this._data[index + 1], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** copy xyz into strongly typed Vector2d */\r\n  public getVector2dAtCheckedVectorIndex(vectorIndex: number, result?: Vector2d): Vector2d | undefined {\r\n    const index = 2 * vectorIndex;\r\n    if (this.isIndexValid(vectorIndex)) {\r\n      return Vector2d.create(this._data[index], this._data[index + 1], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Read coordinates from source array, place them at index within this array.\r\n   * @param destIndex point index where coordinates are to be placed in this array\r\n   * @param source source array\r\n   * @param sourceIndex point index in source array\r\n   * @returns true if destIndex and sourceIndex are both valid.\r\n   */\r\n  public transferFromGrowableXYArray(destIndex: number, source: GrowableXYArray, sourceIndex: number): boolean {\r\n    if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {\r\n      const i = destIndex * 2;\r\n      const j = sourceIndex * 2;\r\n      this._data[i] = source._data[j];\r\n      this._data[i + 1] = source._data[j + 1];\r\n      this._data[i + 2] = source._data[j + 2];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * push coordinates from the source array to the end of this array.\r\n   * @param source source array\r\n   * @param sourceIndex xyz index within the source.  If undefined, push entire contents of source\r\n   * @returns true if sourceIndex is valid.\r\n   */\r\n  public pushFromGrowableXYArray(source: GrowableXYArray, sourceIndex?: number): number {\r\n    if (sourceIndex === undefined) {\r\n      const numPresent = this.length;\r\n      const numPush = source.length;\r\n      this.ensureCapacity(numPresent + numPush);\r\n      const numFloatPresent = 2 * numPresent;\r\n      const numFloatAdd = 2 * numPush;\r\n      for (let i = 0; i < numFloatAdd; i++)\r\n        this._data[numFloatPresent + i] = source._data[i];\r\n      this._xyInUse += numPush;\r\n      return numPush;\r\n    }\r\n    if (source.isIndexValid(sourceIndex)) {\r\n      const j = sourceIndex * 2;\r\n      this.pushXY(source._data[j], source._data[j + 1]);\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * push coordinates from the source array to the end of this array.\r\n   * @param source source array\r\n   * @param transform optional transform to apply to points.\r\n   * @param dest optional result.\r\n   */\r\n  public static createFromGrowableXYZArray(source: GrowableXYZArray, transform?: Transform, dest?: GrowableXYArray) {\r\n    const packedXYZ = source.float64Data();\r\n    const numXYZ = source.length;    // this is in xyz points\r\n    const nDouble = 3 * numXYZ;\r\n    if (!dest)\r\n      dest = new GrowableXYArray(numXYZ);\r\n    dest.clear();\r\n    let x;\r\n    let y;\r\n    let z;\r\n    if (transform) {\r\n      for (let i = 0; i < nDouble; i += 3) {\r\n        x = packedXYZ[i];\r\n        y = packedXYZ[i + 1];\r\n        z = packedXYZ[i + 2];\r\n        dest.pushXY(transform.multiplyComponentXYZ(0, x, y, z), transform.multiplyComponentXYZ(1, x, y, z));\r\n      }\r\n    } else {\r\n      for (let i = 0; i < nDouble; i += 3) {\r\n        x = packedXYZ[i];\r\n        y = packedXYZ[i + 1];\r\n        dest.pushXY(x, y);\r\n      }\r\n    }\r\n    return dest;\r\n  }\r\n  /**\r\n   * Return the first point, or undefined if the array is empty.\r\n   */\r\n  public front(result?: Point2d): Point2d | undefined {\r\n    if (this._xyInUse === 0) return undefined;\r\n    return this.getPoint2dAtUncheckedPointIndex(0, result);\r\n  }\r\n  /**\r\n   * Return the last point, or undefined if the array is empty.\r\n   */\r\n  public back(result?: Point2d): Point2d | undefined {\r\n    if (this._xyInUse < 1) return undefined;\r\n    return this.getPoint2dAtUncheckedPointIndex(this._xyInUse - 1, result);\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point.\r\n   * @param pointIndex index of point to set\r\n   * @param value coordinates to set\r\n   */\r\n  public setAtCheckedPointIndex(pointIndex: number, value: XAndY): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    const index = pointIndex * 2;\r\n    this._data[index] = value.x;\r\n    this._data[index + 1] = value.y;\r\n    return true;\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point given as coordinates\r\n   * @param pointIndex index of point to set\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   */\r\n  public setXYZAtCheckedPointIndex(pointIndex: number, x: number, y: number): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    const index = pointIndex * 2;\r\n    this._data[index] = x;\r\n    this._data[index + 1] = y;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Copy all points into a simple array of Point3D with given z.\r\n   */\r\n  public getPoint3dArray(z: number = 0): Point3d[] {\r\n    const result = [];\r\n    const data = this._data;\r\n    const n = this.length;\r\n    for (let i = 0; i < n; i++) {\r\n      result.push(Point3d.create(data[i * 2], data[i * 2 + 1], z));\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply each point by the transform, replace values. */\r\n  public multiplyTransformInPlace(transform: Transform) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = transform.matrix.coffs;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 2) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      data[i] = coffs[0] * x + coffs[1] * y + x0;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + y0;\r\n    }\r\n  }\r\n\r\n  /** multiply each xyz (as a vector) by matrix, replace values. */\r\n  public multiplyMatrix3dInPlace(matrix: Matrix3d) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = matrix.coffs;\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 2) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      data[i] = coffs[0] * x + coffs[1] * y;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y;\r\n    }\r\n  }\r\n\r\n  /** multiply each point by the transform, replace values. */\r\n  public tryTransformInverseInPlace(transform: Transform): boolean {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const matrix = transform.matrix;\r\n    matrix.computeCachedInverse(true);\r\n    const coffs = matrix.inverseCoffs;\r\n    if (!coffs)\r\n      return false;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    let x = 0;\r\n    let y = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 2) {\r\n      x = data[i] - x0;\r\n      y = data[i + 1] - y0;\r\n      data[i] = coffs[0] * x + coffs[1] * y;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y;\r\n    }\r\n    return true;\r\n  }\r\n  /** Extend a `Range2d`, optionally transforming the points. */\r\n  public extendRange(rangeToExtend: Range2d, transform?: Transform) {\r\n    const numDouble = this.float64Length;\r\n    const data = this._data;\r\n    if (transform) {\r\n      for (let i = 0; i + 2 <= numDouble; i += 2)\r\n        rangeToExtend.extendTransformedXY(transform, data[i], data[i + 1]);\r\n    } else {\r\n      for (let i = 0; i + 2 <= numDouble; i += 2)\r\n        rangeToExtend.extendXY(data[i], data[i + 1]);\r\n\r\n    }\r\n  }\r\n  /** sum the lengths of segments between points. */\r\n  public sumLengths(): number {\r\n    let sum = 0.0;\r\n    const n = 2 * (this._xyInUse - 1);  // Length already takes into account what specifically is in use\r\n    const data = this._data;\r\n    for (let i = 0; i < n; i += 2) sum += Geometry.hypotenuseXY(\r\n      data[i + 2] - data[i],\r\n      data[i + 3] - data[i + 1]);\r\n    return sum;\r\n  }\r\n  /**\r\n   * Multiply each x,y,z by the scale factor.\r\n   * @param factor\r\n   */\r\n  public scaleInPlace(factor: number) {\r\n    if (this._data) {\r\n      const numFloat = this.float64Length;\r\n      for (let i = 0; i < numFloat; i++)\r\n        this._data[i] = this._data[i] * factor;\r\n    }\r\n  }\r\n  /** Compute a point at fractional coordinate between points i and j */\r\n  public interpolate(i: number, fraction: number, j: number, result?: Point2d): Point2d | undefined {\r\n    if (this.isIndexValid(i) && this.isIndexValid(j)) {\r\n      const fraction0 = 1.0 - fraction;\r\n      const data = this._data;\r\n      i = 2 * i;\r\n      j = 2 * j;\r\n      return Point2d.create(\r\n        fraction0 * data[i] + fraction * data[j],\r\n        fraction0 * data[i + 1] + fraction * data[j + 1], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Sum the signed areas of the projection to xy plane */\r\n  public areaXY(): number {\r\n    let area = 0.0;\r\n    const n = 2 * this._xyInUse;    // float count !!\r\n    if (n > 4) {\r\n      const x0 = this._data[n - 2];\r\n      const y0 = this._data[n - 1];\r\n      let dx1 = this._data[0] - x0;\r\n      let dy1 = this._data[1] - y0;\r\n      let dx2 = 0;\r\n      let dy2 = 0;\r\n      for (let i = 2; i < n; i += 2, dx1 = dx2, dy1 = dy2) {\r\n        dx2 = this._data[i] - x0;\r\n        dy2 = this._data[i + 1] - y0;\r\n        area += Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);\r\n      }\r\n    }\r\n    return 0.5 * area;\r\n  }\r\n\r\n  /** Compute a vector from index origin i to indexed target j  */\r\n  public vectorIndexIndex(i: number, j: number, result?: Vector2d): Vector2d | undefined {\r\n    if (!this.isIndexValid(i) || !this.isIndexValid(j))\r\n      return undefined;\r\n    const data = this._data;\r\n    i = 2 * i;\r\n    j = 2 * j;\r\n    return Vector2d.create(data[j] - data[i], data[j + 1] - data[i + 1], result);\r\n  }\r\n\r\n  /** Compute a vector from origin to indexed target j */\r\n  public vectorXAndYIndex(origin: XAndY, j: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isIndexValid(j)) {\r\n      const data = this._data;\r\n      j = 2 * j;\r\n      return Vector2d.create(\r\n        data[j] - origin.x,\r\n        data[j + 1] - origin.y, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */\r\n  public crossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number): number | undefined {\r\n    const i = originIndex * 2;\r\n    const j = targetAIndex * 2;\r\n    const k = targetBIndex * 2;\r\n    const data = this._data;\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYXY(\r\n        data[j] - data[i], data[j + 1] - data[i + 1],\r\n        data[k] - data[i], data[k + 1] - data[i + 1]);\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from origin to indexed targets i and j */\r\n  public crossProductXAndYIndexIndex(origin: XAndY, targetAIndex: number, targetBIndex: number): number | undefined {\r\n    const j = targetAIndex * 2;\r\n    const k = targetBIndex * 2;\r\n    const data = this._data;\r\n    if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYXY(\r\n        data[j] - origin.x, data[j + 1] - origin.y,\r\n        data[k] - origin.x, data[k + 1] - origin.y);\r\n    return undefined;\r\n  }\r\n\r\n  /** Return the distance between two points in the array. */\r\n  public distance(i: number, j: number): number | undefined {\r\n    if (this.isIndexValid(i) && this.isIndexValid(j)) {\r\n      const i0 = 2 * i;\r\n      const j0 = 2 * j;\r\n      return Geometry.hypotenuseXY(\r\n        this._data[j0] - this._data[i0],\r\n        this._data[j0 + 1] - this._data[i0 + 1]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the distance between an array point and the input point. */\r\n  public distanceIndexToPoint(i: number, spacePoint: Point2d): number | undefined {\r\n    if (this.isIndexValid(i)) {\r\n      const i0 = 2 * i;\r\n      return Geometry.hypotenuseXY(\r\n        spacePoint.x - this._data[i0],\r\n        spacePoint.y - this._data[i0 + 1]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Test for nearly equal arrays. */\r\n  public static isAlmostEqual(dataA: GrowableXYArray | undefined, dataB: GrowableXYArray | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (!dataA.getPoint2dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint2dAtUncheckedPointIndex(i)))\r\n          return false;\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (!dataA && !dataB);\r\n  }\r\n\r\n  /** Return an array of block indices sorted per compareLexicalBlock function */\r\n  public sortIndicesLexical(): Uint32Array {\r\n    const n = this._xyInUse;\r\n    // let numCompare = 0;\r\n    const result = new Uint32Array(n);\r\n    for (let i = 0; i < n; i++)result[i] = i;\r\n    result.sort(\r\n      (blockIndexA: number, blockIndexB: number) => {\r\n        // numCompare++;\r\n        return this.compareLexicalBlock(blockIndexA, blockIndexB);\r\n      });\r\n    // console.log (n, numCompare);\r\n    return result;\r\n  }\r\n\r\n  /** compare two blocks in simple lexical order. */\r\n  public compareLexicalBlock(ia: number, ib: number): number {\r\n    let ax = 0;\r\n    let bx = 0;\r\n    for (let i = 0; i < 2; i++) {\r\n      ax = this._data[ia * 2 + i];\r\n      bx = this._data[ib * 2 + i];\r\n      if (ax > bx) return 1;\r\n      if (ax < bx) return -1;\r\n    }\r\n    return ia - ib; // so original order is maintained among duplicates !!!!\r\n  }\r\n\r\n  /** Access a single double at offset within a block.  This has no index checking. */\r\n  public component(pointIndex: number, componentIndex: number): number {\r\n    return this._data[2 * pointIndex + componentIndex];\r\n  }\r\n  /** Toleranced equality test */\r\n  public isAlmostEqual(other: GrowableXYArray, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    const numXY = this._xyInUse;\r\n    if (other._xyInUse !== numXY)\r\n      return false;\r\n    const dataA = this._data;\r\n    const dataB = other._data;\r\n    for (let i = 0; i < 2 * numXY; i++) {\r\n      if (Math.abs(dataA[i] - dataB[i]) > tolerance)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Range3d, Range1d } from \"./Range\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\n\r\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\n\r\n/** `GrowableXYArray` manages a (possibly growing) Float64Array to pack xy coordinates.\r\n * @public\r\n */\r\nexport class GrowableXYZArray extends IndexedXYZCollection {\r\n  /**\r\n   * array of packed xyzxyzxyz components\r\n   */\r\n  private _data: Float64Array;\r\n  /**\r\n   * Number of xyz triples (not floats) in the array\r\n   */\r\n  private _xyzInUse: number;\r\n  /**\r\n   * capacity in xyz triples. (not floats)\r\n   */\r\n  private _xyzCapacity: number;\r\n  /** Construct a new GrowablePoint3d array.\r\n   * @param numPoints [in] initial capacity.\r\n   */\r\n  public constructor(numPoints: number = 8) {\r\n    super();\r\n    this._data = new Float64Array(numPoints * 3);   // 8 Points to start (3 values each)\r\n    this._xyzInUse = 0;\r\n    this._xyzCapacity = numPoints;\r\n  }\r\n  /** Return the number of points in use. */\r\n  public get length() { return this._xyzInUse; }\r\n\r\n  /** Return the number of float64 in use. */\r\n  public get float64Length() { return this._xyzInUse * 3; }\r\n  /** Return the raw packed data.\r\n   * * Note that the length of the returned Float64Array is a count of doubles, and includes the excess capacity\r\n   */\r\n  public float64Data(): Float64Array { return this._data; }\r\n\r\n  /** If necessary, increase the capacity to a new pointCount.  Current coordinates and point count (length) are unchanged. */\r\n  public ensureCapacity(pointCapacity: number) {\r\n    if (pointCapacity > this._xyzCapacity) {\r\n      const newData = new Float64Array(pointCapacity * 3);\r\n      const numCopy = this.length * 3;\r\n      for (let i = 0; i < numCopy; i++) newData[i] = this._data[i];\r\n      this._data = newData;\r\n      this._xyzCapacity = pointCapacity;\r\n    }\r\n  }\r\n  /** Resize the actual point count, preserving excess capacity. */\r\n  public resize(pointCount: number) {\r\n    if (pointCount < this.length) {\r\n      this._xyzInUse = pointCount >= 0 ? pointCount : 0;\r\n    } else if (pointCount > this._xyzCapacity) {\r\n      const newArray = new Float64Array(pointCount * 3);\r\n      // Copy contents\r\n      for (let i = 0; i < this._data.length; i += 3) {\r\n        newArray[i] = this._data[i];\r\n        newArray[i + 1] = this._data[i + 1];\r\n        newArray[i + 2] = this._data[i + 2];\r\n      }\r\n      this._data = newArray;\r\n      this._xyzCapacity = pointCount;\r\n      this._xyzInUse = pointCount;\r\n    }\r\n  }\r\n  /**\r\n   * Make a copy of the (active) points in this array.\r\n   * (The clone does NOT get excess capacity)\r\n   */\r\n  public clone(result?: GrowableXYZArray): GrowableXYZArray {\r\n    const numValue = this.length * 3;\r\n    if (!result)\r\n      result = new GrowableXYZArray(this.length);\r\n    else {\r\n      result.clear();\r\n      result.ensureCapacity(this.length);\r\n    }\r\n    const newData = result._data;\r\n    const data = this._data;\r\n    for (let i = 0; i < numValue; i++) newData[i] = data[i];\r\n    result._xyzInUse = this.length;\r\n    return result;\r\n  }\r\n  /** Create an array from various point data formats.\r\n   * Valid inputs are:\r\n   * * Point2d\r\n   * * point3d\r\n   * * An array of 2 doubles\r\n   * * An array of 3 doubles\r\n   * * A GrowableXYZArray\r\n   * * Any json object satisfying Point3d.isXYAndZ\r\n   * * Any json object satisfying Point3d.isXAndY\r\n   * * A Float64Array of doubles, interpreted as xyzxyz\r\n   * * An array of any of the above\r\n   * @param data source points.\r\n   * @param result optional pre-allocated GrowableXYZArray to clear and fill.\r\n   */\r\n  public static create(data: any, result?: GrowableXYZArray): GrowableXYZArray {\r\n    if (result)\r\n      result.clear();\r\n    else\r\n      result = new GrowableXYZArray(data.length);\r\n    result.pushFrom(data);\r\n    return result;\r\n  }\r\n\r\n  /** push a point to the end of the array */\r\n  public push(toPush: XYAndZ) {\r\n    this.pushXYZ(toPush.x, toPush.y, toPush.z);\r\n  }\r\n\r\n  /** push all points of an array */\r\n  public pushAll(points: Point3d[]) {\r\n    for (const p of points) this.push(p);\r\n  }\r\n  /** Push points from variant sources.\r\n   * Valid inputs are:\r\n   * * Point2d\r\n   * * point3d\r\n   * * An array of 2 doubles\r\n   * * An array of 3 doubles\r\n   * * A GrowableXYZArray\r\n   * * Any json object satisfying Point3d.isXYAndZ\r\n   * * Any json object satisfying Point3d.isXAndY\r\n   * * A Float64Array of doubles, interpreted as xyzxyz\r\n   * * An array of any of the above\r\n   * @returns the number of points added.\r\n   */\r\n  public pushFrom(p: any) {\r\n    if (p instanceof Point3d)\r\n      this.pushXYZ(p.x, p.y, p.z);\r\n    else if (p instanceof GrowableXYZArray)\r\n      this.pushFromGrowableXYZArray(p);\r\n    else if (p instanceof Point2d)\r\n      this.pushXYZ(p.x, p.y, 0.0);\r\n    else if (Geometry.isNumberArray(p, 4)) {\r\n      const n = p.length;\r\n      for (let i = 0; i + 2 < n; i += 3)\r\n        this.pushXYZ(p[i], p[i + 1], p[i + 2]);\r\n    } else if (Geometry.isNumberArray(p, 3))\r\n      this.pushXYZ(p[0], p[1], p[2]);\r\n    else if (Geometry.isNumberArray(p, 2))\r\n      this.pushXYZ(p[0], p[1], 0.0);\r\n    else if (Array.isArray(p)) {\r\n      // direct recursion re-wraps p and goes infinite.  unroll here .\r\n      for (const q of p)\r\n        this.pushFrom(q);\r\n    } else if (Point3d.isXYAndZ(p))\r\n      this.pushXYZ(p.x, p.y, p.z);\r\n    else if (Point3d.isXAndY(p))\r\n      this.pushXYZ(p.x, p.y, 0.0);\r\n    else if (p instanceof Float64Array) {\r\n      const n = p.length;\r\n      for (let i = 0; i + 2 < n; i += 3)\r\n        this.pushXYZ(p[i], p[i + 1], p[i + 2]);\r\n    }\r\n  }\r\n  /**\r\n   * Replicate numWrap xyz values from the front of the array as new values at the end.\r\n   * @param numWrap number of xyz values to replicate\r\n   */\r\n  public pushWrap(numWrap: number) {\r\n    if (this._xyzInUse > 0) {\r\n      let k;\r\n      for (let i = 0; i < numWrap; i++) {\r\n        k = 3 * i;\r\n        this.pushXYZ(this._data[k], this._data[k + 1], this._data[k + 2]);\r\n      }\r\n    }\r\n  }\r\n  /** append a new point with given x,y,z */\r\n  public pushXYZ(x: number, y: number, z: number) {\r\n    const index = this._xyzInUse * 3;\r\n    if (index >= this._data.length)\r\n      this.ensureCapacity(this.length === 0 ? 4 : this.length * 2);\r\n    this._data[index] = x;\r\n    this._data[index + 1] = y;\r\n    this._data[index + 2] = z;\r\n    this._xyzInUse++;\r\n  }\r\n\r\n  /** Remove one point from the back.\r\n   * * NOTE that (in the manner of std::vector native) this is \"just\" removing the point -- no point is NOT returned.\r\n   * * Use `back ()` to get the last x,y,z assembled into a `Point3d `\r\n   */\r\n  public pop() {\r\n    if (this._xyzInUse > 0)\r\n      this._xyzInUse--;\r\n  }\r\n  /**\r\n   * Test if index is valid for an xyz (point or vector) within this array\r\n   * @param index xyz index to test.\r\n   */\r\n  public isIndexValid(index: number): boolean {\r\n    if (index >= this._xyzInUse || index < 0)\r\n      return false;\r\n    return true;\r\n  }\r\n  /**\r\n   * Clear all xyz data, but leave capacity unchanged.\r\n   */\r\n  public clear() {\r\n    this._xyzInUse = 0;\r\n  }\r\n  /**\r\n   * Get a point by index, strongly typed as a Point3d.  This is unchecked.  Use getPoint3dAtCheckedPointIndex to have validity test.\r\n   * @param pointIndex index to access\r\n   * @param result optional result\r\n   */\r\n  public getPoint3dAtUncheckedPointIndex(pointIndex: number, result?: Point3d): Point3d {\r\n    const index = 3 * pointIndex;\r\n    return Point3d.create(this._data[index], this._data[index + 1], this._data[index + 2], result);\r\n  }\r\n\r\n  /**\r\n   * Get a point by index, strongly typed as a Point2d.  This is unchecked.  Use getPoint2dAtCheckedPointIndex to have validity test.\r\n   * @param pointIndex index to access\r\n   * @param result optional result\r\n   */\r\n  public getPoint2dAtUncheckedPointIndex(pointIndex: number, result?: Point2d): Point2d {\r\n    const index = 3 * pointIndex;\r\n    return Point2d.create(this._data[index], this._data[index + 1], result);\r\n  }\r\n\r\n  /** copy xyz into strongly typed Point3d */\r\n  public getPoint3dAtCheckedPointIndex(pointIndex: number, result?: Point3d): Point3d | undefined {\r\n    const index = 3 * pointIndex;\r\n    if (this.isIndexValid(pointIndex)) {\r\n      if (!result) result = Point3d.create();\r\n      result.x = this._data[index];\r\n      result.y = this._data[index + 1];\r\n      result.z = this._data[index + 2];\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** copy xy into strongly typed Point2d */\r\n  public getPoint2dAtCheckedPointIndex(pointIndex: number, result?: Point2d): Point2d | undefined {\r\n    const index = 3 * pointIndex;\r\n    if (this.isIndexValid(pointIndex)) {\r\n      if (!result) result = Point2d.create();\r\n      result.x = this._data[index];\r\n      result.y = this._data[index + 1];\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** copy xyz into strongly typed Vector3d */\r\n  public getVector3dAtCheckedVectorIndex(vectorIndex: number, result?: Vector3d): Vector3d | undefined {\r\n    const index = 3 * vectorIndex;\r\n    if (vectorIndex >= 0 && vectorIndex < this._xyzInUse) {\r\n      if (!result) result = Vector3d.create();\r\n      result.x = this._data[index];\r\n      result.y = this._data[index + 1];\r\n      result.z = this._data[index + 2];\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Read coordinates from source array, place them at index within this array.\r\n   * @param destIndex point index where coordinates are to be placed in this array\r\n   * @param source source array\r\n   * @param sourceIndex point index in source array\r\n   * @returns true if destIndex and sourceIndex are both valid.\r\n   */\r\n  public transferFromGrowableXYZArray(destIndex: number, source: GrowableXYZArray, sourceIndex: number): boolean {\r\n    if (this.isIndexValid(destIndex) && source.isIndexValid(sourceIndex)) {\r\n      const i = destIndex * 3;\r\n      const j = sourceIndex * 3;\r\n      this._data[i] = source._data[j];\r\n      this._data[i + 1] = source._data[j + 1];\r\n      this._data[i + 2] = source._data[j + 2];\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * push coordinates from the source array to the end of this array.\r\n   * @param source source array\r\n   * @param sourceIndex xyz index within the source.  If undefined, entire source is pushed.\r\n   * @returns number of points pushed.\r\n   */\r\n  public pushFromGrowableXYZArray(source: GrowableXYZArray, sourceIndex?: number): number {\r\n    // full array push  . . .\r\n    if (sourceIndex === undefined) {\r\n      const numXYZAdd = source.length;\r\n      this.ensureCapacity(this.length + numXYZAdd);\r\n      const nXAdd = source.length * 3;\r\n      const i0 = this._xyzInUse * 3;\r\n      for (let i = 0; i < nXAdd; i++)\r\n        this._data[i0 + i] = source._data[i];\r\n      this._xyzInUse += numXYZAdd;\r\n      return numXYZAdd;\r\n    }\r\n    // single point push . . .\r\n    if (source.isIndexValid(sourceIndex)) {\r\n      const j = sourceIndex * 3;\r\n      this.pushXYZ(source._data[j], source._data[j + 1], source._data[j + 2]);\r\n      return 1;\r\n    }\r\n    return 0;\r\n  }\r\n\r\n  /**\r\n   * Return the first point, or undefined if the array is empty.\r\n   */\r\n  public front(result?: Point3d): Point3d | undefined {\r\n    if (this._xyzInUse === 0) return undefined;\r\n    return this.getPoint3dAtUncheckedPointIndex(0, result);\r\n  }\r\n  /**\r\n   * Return the last point, or undefined if the array is empty.\r\n   */\r\n  public back(result?: Point3d): Point3d | undefined {\r\n    if (this._xyzInUse < 1) return undefined;\r\n    return this.getPoint3dAtUncheckedPointIndex(this._xyzInUse - 1, result);\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point.\r\n   * @param pointIndex index of point to set\r\n   * @param value coordinates to set\r\n   */\r\n  public setAtCheckedPointIndex(pointIndex: number, value: XYAndZ): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    let index = pointIndex * 3;\r\n    this._data[index++] = value.x;\r\n    this._data[index++] = value.y;\r\n    this._data[index] = value.z;\r\n    return true;\r\n  }\r\n  /**\r\n   * Set the coordinates of a single point given as coordinates\r\n   * @param pointIndex index of point to set\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   */\r\n  public setXYZAtCheckedPointIndex(pointIndex: number, x: number, y: number, z: number): boolean {\r\n    if (!this.isIndexValid(pointIndex))\r\n      return false;\r\n    let index = pointIndex * 3;\r\n    this._data[index++] = x;\r\n    this._data[index++] = y;\r\n    this._data[index] = z;\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Copy all points into a simple array of Point3d\r\n   */\r\n  public getPoint3dArray(): Point3d[] {\r\n    const result = [];\r\n    const data = this._data;\r\n    const n = this.length;\r\n    for (let i = 0; i < n; i++) {\r\n      result.push(Point3d.create(data[i * 3], data[i * 3 + 1], data[i * 3 + 2]));\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply each point by the transform, replace values. */\r\n  public multiplyTransformInPlace(transform: Transform) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = transform.matrix.coffs;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    const z0 = origin.z;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 3) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z + x0;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z + y0;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z + z0;\r\n    }\r\n  }\r\n\r\n  /** multiply each xyz (as a vector) by matrix, replace values. */\r\n  public multiplyMatrix3dInPlace(matrix: Matrix3d) {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const coffs = matrix.coffs;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 3) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;\r\n    }\r\n  }\r\n\r\n  /** multiply each xyz (as a vector) by matrix inverse transpose, renormalize the vector, replace values.\r\n   * * This is the way to apply a matrix (possibly with skew and scale) to a surface normal, and\r\n   *      have it end up perpendicular to the transformed in-surface vectors.\r\n   * * Return false if matrix is not invertible or if any normalization fails.\r\n   */\r\n  public multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(matrix: Matrix3d): boolean {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    if (!matrix.computeCachedInverse(true))\r\n      return false;\r\n    const coffs = matrix.inverseCoffs!;\r\n    const tol = 1.0e-15;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    let x1;\r\n    let y1;\r\n    let z1;\r\n    let q;\r\n    let a;\r\n    let numFail = 0;\r\n    for (let i = 0; i + 2 <= nDouble; i += 3) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      x1 = coffs[0] * x + coffs[3] * y + coffs[6] * z;\r\n      y1 = coffs[1] * x + coffs[4] * y + coffs[7] * z;\r\n      z1 = coffs[2] * x + coffs[5] * y + coffs[8] * z;\r\n      a = x1 * x1 + y1 * y1 + z1 * z1;\r\n      if (a < tol) {\r\n        // put the originals back ..\r\n        x1 = x; y1 = y; z1 = z;\r\n        numFail++;\r\n      } else if (Math.abs(a - 1.0) > tol) {\r\n        q = 1.0 / Math.sqrt(a);\r\n        x1 *= q;\r\n        y1 *= q;\r\n        z1 *= q;\r\n      } // else -- q is near 1, no need to do the division !!\r\n      data[i] = x1;\r\n      data[i + 1] = y1;\r\n      data[i + 2] = z1;\r\n    }\r\n    return numFail === 0;\r\n  }\r\n\r\n  /** multiply each point by the transform, replace values. */\r\n  public tryTransformInverseInPlace(transform: Transform): boolean {\r\n    const data = this._data;\r\n    const nDouble = this.float64Length;\r\n    const matrix = transform.matrix;\r\n    matrix.computeCachedInverse(true);\r\n    const coffs = matrix.inverseCoffs;\r\n    if (!coffs)\r\n      return false;\r\n    const origin = transform.origin;\r\n    const x0 = origin.x;\r\n    const y0 = origin.y;\r\n    const z0 = origin.z;\r\n    let x = 0;\r\n    let y = 0;\r\n    let z = 0;\r\n    for (let i = 0; i + 3 <= nDouble; i += 3) {\r\n      x = data[i] - x0;\r\n      y = data[i + 1] - y0;\r\n      z = data[i + 2] - z0;\r\n      data[i] = coffs[0] * x + coffs[1] * y + coffs[2] * z;\r\n      data[i + 1] = coffs[3] * x + coffs[4] * y + coffs[5] * z;\r\n      data[i + 2] = coffs[6] * x + coffs[7] * y + coffs[8] * z;\r\n    }\r\n    return true;\r\n  }\r\n  /** Extend `range` to extend by all points. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const numDouble = this.float64Length;\r\n    const data = this._data;\r\n    if (transform) {\r\n      for (let i = 0; i + 3 <= numDouble; i += 3)\r\n        rangeToExtend.extendTransformedXYZ(transform, data[i], data[i + 1], data[i + 2]);\r\n    } else {\r\n      for (let i = 0; i + 3 <= numDouble; i += 3)\r\n        rangeToExtend.extendXYZ(data[i], data[i + 1], data[i + 2]);\r\n\r\n    }\r\n  }\r\n  /** Sum the lengths of segments between points. */\r\n  public sumLengths(): number {\r\n    let sum = 0.0;\r\n    const n = 3 * (this._xyzInUse - 1);  // Length already takes into account what specifically is in use\r\n    const data = this._data;\r\n    for (let i = 0; i < n; i += 3) sum += Geometry.hypotenuseXYZ(\r\n      data[i + 3] - data[i],\r\n      data[i + 4] - data[i + 1],\r\n      data[i + 5] - data[i + 2]);\r\n    return sum;\r\n  }\r\n  /**\r\n   * Multiply each x,y,z by the scale factor.\r\n   * @param factor\r\n   */\r\n  public scaleInPlace(factor: number) {\r\n    if (this._data) {\r\n      const numFloat = this.float64Length;\r\n      for (let i = 0; i < numFloat; i++)\r\n        this._data[i] = this._data[i] * factor;\r\n    }\r\n  }\r\n  /** test if all points are within tolerance of a plane. */\r\n  public isCloseToPlane(plane: Plane3dByOriginAndUnitNormal, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    const numCoordinate = 3 * this._xyzInUse;\r\n    const data = this._data;\r\n    for (let i = 0; i < numCoordinate; i += 3)\r\n      if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)\r\n        return false;\r\n    return true;\r\n  }\r\n  /** Compute a point at fractional coordinate between points i and j */\r\n  public interpolate(i: number, fraction: number, j: number, result?: Point3d): Point3d | undefined {\r\n    if (this.isIndexValid(i) && this.isIndexValid(j)) {\r\n      const fraction0 = 1.0 - fraction;\r\n      const data = this._data;\r\n      i = 3 * i;\r\n      j = 3 * j;\r\n      return Point3d.create(\r\n        fraction0 * data[i] + fraction * data[j],\r\n        fraction0 * data[i + 1] + fraction * data[j + 1],\r\n        fraction0 * data[i + 2] + fraction * data[j + 2], result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * * Compute a point at fractional coordinate between points i and j of source\r\n   * * push onto this array.\r\n   */\r\n  public pushInterpolatedFromGrowableXYZArray(source: GrowableXYZArray, i: number, fraction: number, j: number) {\r\n    if (source.isIndexValid(i) && source.isIndexValid(j)) {\r\n      const fraction0 = 1.0 - fraction;\r\n      const data = source._data;\r\n      i = 3 * i;\r\n      j = 3 * j;\r\n      this.pushXYZ(\r\n        fraction0 * data[i] + fraction * data[j],\r\n        fraction0 * data[i + 1] + fraction * data[j + 1],\r\n        fraction0 * data[i + 2] + fraction * data[j + 2]);\r\n    }\r\n  }\r\n\r\n  /** Sum the signed areas of the projection to xy plane */\r\n  public areaXY(): number {\r\n    let area = 0.0;\r\n    const n = 3 * this._xyzInUse;    // float count !!\r\n    if (n > 6) {\r\n      const x0 = this._data[n - 3];\r\n      const y0 = this._data[n - 2];\r\n      let dx1 = this._data[0] - x0;\r\n      let dy1 = this._data[1] - y0;\r\n      let dx2 = 0;\r\n      let dy2 = 0;\r\n      for (let i = 3; i < n; i += 3, dx1 = dx2, dy1 = dy2) {\r\n        dx2 = this._data[i] - x0;\r\n        dy2 = this._data[i + 1] - y0;\r\n        area += Geometry.crossProductXYXY(dx1, dy1, dx2, dy2);\r\n      }\r\n    }\r\n    return 0.5 * area;\r\n  }\r\n\r\n  /** Compute a vector from index origin i to indexed target j  */\r\n  public vectorIndexIndex(i: number, j: number, result?: Vector3d): Vector3d | undefined {\r\n    if (!this.isIndexValid(i) || !this.isIndexValid(j))\r\n      return undefined;\r\n    if (!result) result = Vector3d.create();\r\n    const data = this._data;\r\n    i = 3 * i;\r\n    j = 3 * j;\r\n    result.x = data[j] - data[i];\r\n    result.y = data[j + 1] - data[i + 1];\r\n    result.z = data[j + 2] - data[i + 2];\r\n    return result;\r\n  }\r\n\r\n  /** Compute a vector from origin to indexed target j */\r\n  public vectorXYAndZIndex(origin: XYAndZ, j: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isIndexValid(j)) {\r\n      const data = this._data;\r\n      j = 3 * j;\r\n      return Vector3d.create(\r\n        data[j] - origin.x,\r\n        data[j + 1] - origin.y,\r\n        data[j + 2] - origin.z, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from indexed origin to indexed targets i and j */\r\n  public crossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number, result?: Vector3d): Vector3d | undefined {\r\n    const i = originIndex * 3;\r\n    const j = targetAIndex * 3;\r\n    const k = targetBIndex * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYZXYZ(\r\n        data[j] - data[i], data[j + 1] - data[i + 1], data[j + 2] - data[i + 2],\r\n        data[k] - data[i], data[k + 1] - data[i + 1], data[k + 2] - data[i + 2],\r\n        result);\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the dot product of pointIndex with [x,y,z] */\r\n  public evaluateUncheckedIndexDotProductXYZ(pointIndex: number, x: number, y: number, z: number): number {\r\n    const i = pointIndex * 3;\r\n    const data = this._data;\r\n    return data[i] * x + data[i + 1] * y + data[i + 2] * z;\r\n  }\r\n\r\n  /**\r\n   * * compute the cross product from indexed origin t indexed targets targetAIndex and targetB index.\r\n   * * accumulate it to the result.\r\n   */\r\n  public accumulateCrossProductIndexIndexIndex(originIndex: number, targetAIndex: number, targetBIndex: number, result: Vector3d): void {\r\n    const i = originIndex * 3;\r\n    const j = targetAIndex * 3;\r\n    const k = targetBIndex * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      result.addCrossProductToTargetsInPlace(\r\n        data[i], data[i + 1], data[i + 2],\r\n        data[j], data[j + 1], data[j + 2],\r\n        data[k], data[k + 1], data[k + 2]);\r\n    return undefined;\r\n  }\r\n\r\n  /** Compute the cross product of vectors from from origin to indexed targets i and j */\r\n  public crossProductXYAndZIndexIndex(origin: XYAndZ, targetAIndex: number, targetBIndex: number, result?: Vector3d): Vector3d | undefined {\r\n    const j = targetAIndex * 3;\r\n    const k = targetBIndex * 3;\r\n    const data = this._data;\r\n    if (this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex))\r\n      return Geometry.crossProductXYZXYZ(\r\n        data[j] - origin.x, data[j + 1] - origin.y, data[j + 2] - origin.z,\r\n        data[k] - origin.x, data[k + 1] - origin.y, data[k + 2] - origin.z,\r\n        result);\r\n    return undefined;\r\n  }\r\n\r\n  /** Return the distance between two points in the array. */\r\n  public distance(i: number, j: number): number | undefined {\r\n    if (i >= 0 && i < this._xyzInUse && j >= 0 && j <= this._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      const j0 = 3 * j;\r\n      return Geometry.hypotenuseXYZ(\r\n        this._data[j0] - this._data[i0],\r\n        this._data[j0 + 1] - this._data[i0 + 1],\r\n        this._data[j0 + 2] - this._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return the distance between an array point and the input point. */\r\n  public distanceIndexToPoint(i: number, spacePoint: XYAndZ): number | undefined {\r\n    if (i >= 0 && i < this._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      return Geometry.hypotenuseXYZ(\r\n        spacePoint.x - this._data[i0],\r\n        spacePoint.y - this._data[i0 + 1],\r\n        spacePoint.z - this._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Return the distance between points in distinct arrays. */\r\n  public static distanceBetweenPointsIn2Arrays(arrayA: GrowableXYZArray, i: number, arrayB: GrowableXYZArray, j: number): number | undefined {\r\n\r\n    if (i >= 0 && i < arrayA._xyzInUse && j >= 0 && j <= arrayB._xyzInUse) {\r\n      const i0 = 3 * i;\r\n      const j0 = 3 * j;\r\n      return Geometry.hypotenuseXYZ(\r\n        arrayB._data[j0] - arrayA._data[i0],\r\n        arrayB._data[j0 + 1] - arrayA._data[i0 + 1],\r\n        arrayB._data[j0 + 2] - arrayA._data[i0 + 2]);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** test for near equality between two `GrowableXYZArray`. */\r\n  public static isAlmostEqual(dataA: GrowableXYZArray | undefined, dataB: GrowableXYZArray | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (!dataA.getPoint3dAtUncheckedPointIndex(i).isAlmostEqual(dataB.getPoint3dAtUncheckedPointIndex(i)))\r\n          return false;\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (!dataA && !dataB);\r\n  }\r\n\r\n  /** Return an array of block indices sorted per compareLexicalBlock function */\r\n  public sortIndicesLexical(): Uint32Array {\r\n    const n = this._xyzInUse;\r\n    // let numCompare = 0;\r\n    const result = new Uint32Array(n);\r\n    for (let i = 0; i < n; i++)result[i] = i;\r\n    result.sort(\r\n      (blockIndexA: number, blockIndexB: number) => {\r\n        // numCompare++;\r\n        return this.compareLexicalBlock(blockIndexA, blockIndexB);\r\n      });\r\n    // console.log (n, numCompare);\r\n    return result;\r\n  }\r\n\r\n  /** compare two blocks in simple lexical order. */\r\n  public compareLexicalBlock(ia: number, ib: number): number {\r\n    let ax = 0;\r\n    let bx = 0;\r\n    for (let i = 0; i < 3; i++) {\r\n      ax = this._data[ia * 3 + i];\r\n      bx = this._data[ib * 3 + i];\r\n      if (ax > bx) return 1;\r\n      if (ax < bx) return -1;\r\n    }\r\n    return ia - ib; // so original order is maintained among duplicates !!!!\r\n  }\r\n\r\n  /** Access a single double at offset within a block.  This has no index checking. */\r\n  public component(pointIndex: number, componentIndex: number): number {\r\n    return this._data[3 * pointIndex + componentIndex];\r\n  }\r\n  /**\r\n   * add points at regular steps from `other`\r\n   * @param source\r\n   * @param pointIndex0\r\n   * @param step\r\n   * @param numAdd\r\n   */\r\n  public addSteppedPoints(other: GrowableXYZArray, pointIndex0: number, step: number, numAdd: number) {\r\n    const dataB = other._data;\r\n    let b0 = pointIndex0 * 3;\r\n    const nb = other.length * 3;\r\n    let numAdded = 0;\r\n    while (b0 >= 0 && b0 + 2 < nb && numAdded < numAdd) {\r\n      this.pushXYZ(dataB[b0], dataB[b0 + 1], dataB[b0 + 2]);\r\n      b0 += step * 3;\r\n      numAdded++;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * find the min and max distance between corresponding indexed points.   Excess points are ignored.\r\n   * @param arrayA first array\r\n   * @param arrayB second array\r\n   */\r\n  public static distanceRangeBetweenCorrespondingPoints(arrayA: GrowableXYZArray, arrayB: GrowableXYZArray): Range1d {\r\n    const dataA = arrayA._data;\r\n    const dataB = arrayB._data;\r\n    const n = Math.min(arrayA.length, arrayB.length);\r\n    let i = 0;\r\n    let k0;\r\n    const range = Range1d.createNull();\r\n    while (i < n) {\r\n      k0 = 3 * i;\r\n      range.extendX(Geometry.hypotenuseXYZ(dataA[k0] - dataB[k0], dataA[k0 + 1] - dataB[k0 + 1], dataA[k0 + 2] - dataB[k0 + 2]));\r\n      i++;\r\n    }\r\n    return range;\r\n  }\r\n  /**\r\n   * * Triangle for (unchecked!) for three points identified by index\r\n   * * z direction of frame is 001.\r\n   * * Transform axes from origin to targetX and targetY\r\n   * * in local coordinates (u,v,w) the xy interior of the triangle is `u>=0, v>= 0, w>= 0, u+v+w<1`\r\n   * * Return undefined if transform is invertible (i.e. points are not in a vertical plane.)\r\n   */\r\n  public fillLocalXYTriangleFrame(originIndex: number, targetAIndex: number, targetBIndex: number, result?: Transform): Transform | undefined {\r\n    if (this.isIndexValid(originIndex) && this.isIndexValid(targetAIndex) && this.isIndexValid(targetBIndex)) {\r\n      let i0 = originIndex * 3;\r\n      const data = this._data;\r\n      const ax = data[i0++];\r\n      const ay = data[i0++];\r\n      const az = data[i0++];\r\n      i0 = targetAIndex * 3;\r\n      const ux = data[i0++] - ax;\r\n      const uy = data[i0++] - ay;\r\n      const uz = data[i0++] - az;\r\n      i0 = targetBIndex * 3;\r\n      const vx = data[i0++] - ax;\r\n      const vy = data[i0++] - ay;\r\n      const vz = data[i0++] - az;\r\n      result = Transform.createRowValues(\r\n        ux, vx, 0, ax,\r\n        uy, vy, 0, ay,\r\n        uz, vz, 1, az, result);\r\n      return result.computeCachedInverse() ? result : undefined;\r\n    }\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { XAndY } from \"./XYZProps\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\n\r\n/**\r\n * abstract base class for access to XYZ data with indexed reference.\r\n * * This allows algorithms to work with Point2d[] or GrowableXYZ.\r\n * ** GrowableXYZArray implements these for its data.\r\n * ** Point2dArrayCarrier carries a (reference to) a Point2d[] and implements the methods with calls on that array reference.\r\n * * In addition to \"point by point\" accessors, there abstract members compute commonly useful vector data \"between points\".\r\n * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.\r\n * @public\r\n */\r\nexport abstract class IndexedXYCollection {\r\n  /**\r\n   * Get from `index` as a `Point2d`\r\n   * @param index index of point within the array\r\n   * @param result optional caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getPoint2dAtCheckedPointIndex(index: number, result?: Point2d): Point2d | undefined;\r\n  /**\r\n   * Get from `index` as a `Vector2d`\r\n   * @param index index of point within the array\r\n   * @param result optional caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getVector2dAtCheckedVectorIndex(index: number, result?: Vector2d): Vector2d | undefined;\r\n  /**\r\n   * Return a vector from the point at `indexA` to the point at `indexB`\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract vectorIndexIndex(indexA: number, indexB: number, result?: Vector2d): Vector2d | undefined;\r\n  /**\r\n   * Return a vector from given origin to the point at `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public abstract vectorXAndYIndex(origin: XAndY, indexB: number, result?: Vector2d): Vector2d | undefined;\r\n\r\n  /**\r\n   * Return the cross product of vectors from `origin` to points at `indexA` and `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract crossProductXAndYIndexIndex(origin: XAndY, indexA: number, indexB: number): number | undefined;\r\n  /**\r\n   * Return the cross product of vectors from origin point at `indexA` to target points at `indexB` and `indexC`\r\n   * @param origin index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result optional caller - allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n    public abstract crossProductIndexIndexIndex(origin: number, indexA: number, indexB: number): number | undefined;\r\n\r\n    /**\r\n     * read-only property for number of XYZ in the collection.\r\n     */\r\n  public abstract get length(): number;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module ArraysAndInterfaces */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\n\r\n/**\r\n * abstract base class for access to XYZ data with indexed reference.\r\n * * This allows algorithms to work with Point3d[] or GrowableXYZ.\r\n * ** GrowableXYZArray implements these for its data.\r\n * ** Point3dArrayCarrier carries a (reference to) a Point3d[] and implements the methods with calls on that array reference.\r\n * * In addition to \"point by point\" accessors, there abstract members compute commonly useful vector data \"between points\".\r\n * * Methods that create vectors among multiple indices allow callers to avoid creating temporaries.\r\n * @public\r\n */\r\nexport abstract class IndexedXYZCollection {\r\n  /**\r\n   * Return the point at `index` as a strongly typed Point3d.\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getPoint3dAtCheckedPointIndex(index: number, result?: Point3d): Point3d | undefined;\r\n  /**\r\n   * Get from `index` as a strongly typed Vector3d.\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public abstract getVector3dAtCheckedVectorIndex(index: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return a vector from the point at `indexA` to the point at `indexB`\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract vectorIndexIndex(indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return a vector from `origin` to the point at `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public abstract vectorXYAndZIndex(origin: XYAndZ, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n\r\n  /**\r\n   * Return the cross product of the vectors from `origin` to points at `indexA` and `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract crossProductXYAndZIndexIndex(origin: XYAndZ, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return the cross product of vectors from `origin` to points at `indexA` and `indexB`\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result optional caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public abstract crossProductIndexIndexIndex(origin: number, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined;\r\n  /**\r\n   * Return the cross product of vectors from origin point at `indexA` to target points at `indexB` and `indexC`\r\n   * @param origin index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n  public abstract accumulateCrossProductIndexIndexIndex(origin: number, indexA: number, indexB: number, result: Vector3d): void;\r\n\r\n  /**\r\n   * read-only property for number of XYZ in the collection.\r\n   */\r\n  public abstract get length(): number;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Geometry, AxisOrder, AxisIndex, BeJSONFunctions, StandardViewIndex } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\nimport { XYAndZ, XAndY, Matrix3dProps } from \"./XYZProps\";\r\nimport { XYZ, Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\n/* tslint:disable:prefer-get */\r\n/**\r\n * PackedMatrix3dOps contains static methods for matrix operations where the matrix is a Float64Array.\r\n * * The Float64Array contains the matrix entries in row-major order\r\n */\r\nclass PackedMatrix3dOps {\r\n  /**\r\n   * Load 9 doubles into the packed format.\r\n   * @param dest destination, allocated by caller\r\n   * @param a00 row 0, column 0 entry\r\n   * @param a01 row 0, column 1 entry\r\n   * @param a02 row 0, column 2 entry\r\n   * @param a10 row 1, column 0 entry\r\n   * @param a11 row 1, column 1 entry\r\n   * @param a12 row 1, column 2 entry\r\n   * @param a20 row 2, column 0 entry\r\n   * @param a21 row 2, column 1 entry\r\n   * @param a22 row 2, column 2 entry\r\n   */\r\n  public static loadMatrix(dest: Float64Array,\r\n    a00: number, a01: number, a02: number,\r\n    a10: number, a11: number, a12: number,\r\n    a20: number, a21: number, a22: number) {\r\n    dest[0] = a00; dest[1] = a01; dest[2] = a02;\r\n    dest[3] = a10; dest[4] = a11; dest[5] = a12;\r\n    dest[6] = a20; dest[7] = a21; dest[8] = a22;\r\n  }\r\n\r\n  /**\r\n   * * multiply 3x3 matrix `a*b`, store in c.\r\n   * * All params assumed length 9, allocated by caller.\r\n   * * c may alias either input.\r\n   */\r\n  public static multiplyMatrixMatrix(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(9);\r\n    PackedMatrix3dOps.loadMatrix(result,\r\n      (a[0] * b[0] + a[1] * b[3] + a[2] * b[6]),\r\n      (a[0] * b[1] + a[1] * b[4] + a[2] * b[7]),\r\n      (a[0] * b[2] + a[1] * b[5] + a[2] * b[8]),\r\n      (a[3] * b[0] + a[4] * b[3] + a[5] * b[6]),\r\n      (a[3] * b[1] + a[4] * b[4] + a[5] * b[7]),\r\n      (a[3] * b[2] + a[4] * b[5] + a[5] * b[8]),\r\n      (a[6] * b[0] + a[7] * b[3] + a[8] * b[6]),\r\n      (a[6] * b[1] + a[7] * b[4] + a[8] * b[7]),\r\n      (a[6] * b[2] + a[7] * b[5] + a[8] * b[8]));\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * multiply 3x3 matrix `a*bTranspose`, store in c.\r\n   * * All params assumed length 9, allocated by caller.\r\n   * * c may alias either input.\r\n   */\r\n  public static multiplyMatrixMatrixTranspose(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(9);\r\n    PackedMatrix3dOps.loadMatrix(result,\r\n      (a[0] * b[0] + a[1] * b[1] + a[2] * b[2]),\r\n      (a[0] * b[3] + a[1] * b[4] + a[2] * b[5]),\r\n      (a[0] * b[6] + a[1] * b[7] + a[2] * b[8]),\r\n      (a[3] * b[0] + a[4] * b[1] + a[5] * b[2]),\r\n      (a[3] * b[3] + a[4] * b[4] + a[5] * b[5]),\r\n      (a[3] * b[6] + a[4] * b[7] + a[5] * b[8]),\r\n      (a[6] * b[0] + a[7] * b[1] + a[8] * b[2]),\r\n      (a[6] * b[3] + a[7] * b[4] + a[8] * b[5]),\r\n      (a[6] * b[6] + a[7] * b[7] + a[8] * b[8]));\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * * multiply 3x3 matrix `a*bTranspose`, store in c.\r\n   * * All params assumed length 9, allocated by caller.\r\n   * * c may alias either input.\r\n   */\r\n  public static multiplyMatrixTransposeMatrix(a: Float64Array, b: Float64Array, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(9);\r\n    PackedMatrix3dOps.loadMatrix(result,\r\n      (a[0] * b[0] + a[3] * b[3] + a[6] * b[6]),\r\n      (a[0] * b[1] + a[3] * b[4] + a[6] * b[7]),\r\n      (a[0] * b[2] + a[3] * b[5] + a[6] * b[8]),\r\n      (a[1] * b[0] + a[4] * b[3] + a[7] * b[6]),\r\n      (a[1] * b[1] + a[4] * b[4] + a[7] * b[7]),\r\n      (a[1] * b[2] + a[4] * b[5] + a[7] * b[8]),\r\n      (a[2] * b[0] + a[5] * b[3] + a[8] * b[6]),\r\n      (a[2] * b[1] + a[5] * b[4] + a[8] * b[7]),\r\n      (a[2] * b[2] + a[5] * b[5] + a[8] * b[8]));\r\n    return result;\r\n  }\r\n  /** transpose 3x3 coefficients in place */\r\n  public static transposeInPlace(a: Float64Array) {\r\n    let q = a[1]; a[1] = a[3]; a[3] = q;\r\n    q = a[2]; a[2] = a[6]; a[6] = q;\r\n    q = a[5]; a[5] = a[7]; a[7] = q;\r\n  }\r\n  /** transpose 3x3 coefficients in place */\r\n  public static copyTransposed(a: Float64Array, dest?: Float64Array): Float64Array {\r\n    if (dest === a) {\r\n      PackedMatrix3dOps.transposeInPlace(a);\r\n    } else {\r\n      if (!dest)\r\n        dest = new Float64Array(9);\r\n      dest[0] = a[0]; dest[1] = a[3]; dest[2] = a[6];\r\n      dest[3] = a[1]; dest[4] = a[4]; dest[5] = a[7];\r\n      dest[6] = a[2]; dest[7] = a[5]; dest[8] = a[8];\r\n    }\r\n    return dest;\r\n  }\r\n\r\n}\r\n/** A Matrix3d is tagged indicating one of the following states:\r\n * * unknown: it is not know if the matrix is invertible.\r\n * * inverseStored: the matrix has its inverse stored\r\n * * singular: the matrix is known to be singular.\r\n * @public\r\n */\r\nexport enum InverseMatrixState {\r\n  /**\r\n   * * The invertibility of the  `coffs` array has not been determined.\r\n   * * Any `inverseCoffs` contents are random.\r\n   */\r\n  unknown,\r\n  /** An inverse was computed and stored as the `inverseCoffs` */\r\n  inverseStored,\r\n  /**\r\n   * * The `coffs` array is known to be singular.\r\n   * * Any `inverseCoffs` contents are random.\r\n   */\r\n  singular,\r\n}\r\n/** A Matrix3d is a 3x3 matrix.\r\n * * A very common use is to hold a rigid body rotation (which has no scaling or skew), but the 3x3 contents can\r\n * also hold scaling and skewing.\r\n * * The 9 entries are stored in row-major order in the coffs array.\r\n * * If the matrix inverse is known it is stored in the inverseCoffs array.\r\n * * The inverse status (unknown, inverseStored, singular) status is indicated by the inverseState property.\r\n * * constructions method that are able to determine the inverse store it immediately and\r\n *     note that in the inverseState.\r\n * * constructions (e.g. createRowValues) for which the inverse is not immediately known mark the\r\n *     inverseState as unknown.\r\n * * Later queries for the inverse trigger full computation if needed at that time.\r\n * * Most matrix queries are present with both \"column\" and \"row\" variants.\r\n * * Usage elsewhere in the library is typically \"column\" based.  For example, in a Transform\r\n *     that carries a coordinate frame the matrix columns are the unit vectors for the axes.\r\n * @public\r\n */\r\nexport class Matrix3d implements BeJSONFunctions {\r\n  /** Control flag for whether this class uses cached inverse of matrices. */\r\n  public static useCachedInverse = true;  // cached inverse can be suppressed for testing.\r\n  /** total number of times a cached inverse was used to avoid recompute */\r\n  public static numUseCache = 0;\r\n  /** total number of times a cached inverse was computed. */\r\n  public static numComputeCache = 0;\r\n  /** Matrix contents as a flat array of numbers in row-major order.\r\n   * * DO NOT directly modify this array.  It will destroy safety of the cached inverse state.\r\n   */\r\n  public coffs: Float64Array;\r\n  /** matrix inverse contents.\r\n   * * DO NOT directly modify this array.  It will destroy integrity of the cached inverse state.\r\n   *\r\n   */\r\n  public inverseCoffs: Float64Array | undefined;\r\n  /** indicates if inverse is unknown, available, or known singular */\r\n  public inverseState: InverseMatrixState;\r\n  private static _identity: Matrix3d;\r\n\r\n  /** The identity Matrix3d. Value is frozen and cannot be modified. */\r\n  public static get identity(): Matrix3d {\r\n    if (undefined === this._identity) {\r\n      this._identity = Matrix3d.createIdentity();\r\n      this._identity.freeze();\r\n    }\r\n\r\n    return this._identity;\r\n  }\r\n\r\n  /** Freeze this Matrix3d. */\r\n  public freeze() {\r\n    this.computeCachedInverse(true);\r\n    /* hm.. can't freeze the Float64Arrays . . .\r\n    Object.freeze(this.coffs);\r\n    if (this.inverseCoffs)\r\n      Object.freeze(this.inverseCoffs);\r\n    */\r\n    Object.freeze(this);\r\n  }\r\n  /**\r\n   *\r\n   * @param coffs optional coefficient array.  This is captured.\r\n   */\r\n  public constructor(coffs?: Float64Array) {\r\n    this.coffs = coffs ? coffs : new Float64Array(9);\r\n    this.inverseCoffs = undefined;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** Return a json object containing the 9 numeric entries as a single array in row major order,\r\n   * `[ [1, 2, 3],[ 4, 5, 6], [7, 8, 9] ]`\r\n   */\r\n  public toJSON(): Matrix3dProps {\r\n    return [[this.coffs[0], this.coffs[1], this.coffs[2]],\r\n    [this.coffs[3], this.coffs[4], this.coffs[5]],\r\n    [this.coffs[6], this.coffs[7], this.coffs[8]]];\r\n  }\r\n  /** copy data from various input forms to this matrix:\r\n   * * Another `Matrix3d`\r\n   * * An array of 3 arrays, each of which has the 3 numbers for a row of the matrix.\r\n   * * An array of 9 numbers in row major order.\r\n   */\r\n  public setFromJSON(json?: Matrix3dProps): void {\r\n    this.inverseCoffs = undefined;\r\n    if (!json) {\r\n      this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0);\r\n      return;\r\n    }\r\n    if (!Array.isArray(json)) {\r\n      if (json instanceof Matrix3d)\r\n        this.setFrom(json);\r\n      return;\r\n    }\r\n\r\n    if (Geometry.isArrayOfNumberArray(json, 3, 3)) {\r\n      const data = json as number[][];\r\n      this.setRowValues(\r\n        data[0][0], data[0][1], data[0][2],\r\n        data[1][0], data[1][1], data[1][2],\r\n        data[2][0], data[2][1], data[2][2]);\r\n      return;\r\n    }\r\n\r\n    if (json.length === 9) {\r\n      const data = json as number[];\r\n      this.setRowValues(\r\n        data[0], data[1], data[2],\r\n        data[3], data[4], data[5],\r\n        data[6], data[7], data[8]);\r\n    } else if (json.length === 4) {\r\n      const data = json as number[];\r\n      this.setRowValues(\r\n        data[0], data[1], 0,\r\n        data[2], data[3], 0,\r\n        0, 0, 1);\r\n    }\r\n  }\r\n  /** Return a new Matrix3d constructed from contents of the json value. Se `setFromJSON` for layout rules */\r\n  public static fromJSON(json?: Matrix3dProps): Matrix3d { const result = Matrix3d.createIdentity(); result.setFromJSON(json); return result; }\r\n  /** Test if this Matrix3d and other are within tolerance in all numeric entries.\r\n   * @param tol optional tolerance for comparisons by Geometry.isDistanceWithinTol\r\n   */\r\n  public isAlmostEqual(other: Matrix3d, tol?: number): boolean {\r\n    if (tol)\r\n      return Geometry.isDistanceWithinTol(this.maxDiff(other), tol);\r\n    return Geometry.isSmallMetricDistance(this.maxDiff(other));\r\n  }\r\n  /** Test for exact (bitwise) equality with other. */\r\n  public isExactEqual(other: Matrix3d): boolean { return this.maxDiff(other) === 0.0; }\r\n  /** test if all entries in the z row and column are exact 001, i.e. the matrix only acts in 2d */\r\n  public get isXY(): boolean {\r\n    return this.coffs[2] === 0.0\r\n      && this.coffs[5] === 0.0\r\n      && this.coffs[6] === 0.0\r\n      && this.coffs[7] === 0.0\r\n      && this.coffs[8] === 1.0;\r\n  }\r\n  // !! does not clear supplied result !!\r\n  private static _create(result?: Matrix3d): Matrix3d { return result ? result : new Matrix3d(); }\r\n\r\n  /** Returns a Matrix3d populated by numeric values given in row-major order.\r\n   *  set all entries in the matrix from call parameters appearing in row - major order.\r\n   * @param axx Row x, column x(0, 0) entry\r\n   * @param axy Row x, column y(0, 1) entry\r\n   * @param axz Row x, column z(0, 2) entry\r\n   * @param ayx Row y, column x(1, 0) entry\r\n   * @param ayy Row y, column y(1, 1) entry\r\n   * @param ayz Row y, column z(1, 2) entry\r\n   * @param azx Row z, column x(2, 0) entry\r\n   * @param azy Row z, column y(2, 2) entry\r\n   * @param azz row z, column z(2, 3) entry\r\n   */\r\n  public static createRowValues(\r\n    axx: number, axy: number, axz: number,\r\n    ayx: number, ayy: number, ayz: number,\r\n    azx: number, azy: number, azz: number,\r\n    result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    result.inverseState = InverseMatrixState.unknown;\r\n    result.coffs[0] = axx; result.coffs[1] = axy; result.coffs[2] = axz;\r\n    result.coffs[3] = ayx; result.coffs[4] = ayy; result.coffs[5] = ayz;\r\n    result.coffs[6] = azx; result.coffs[7] = azy; result.coffs[8] = azz;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a Matrix3d with caller-supplied coefficients and optional inverse coefficients.\r\n   * * The inputs are captured into the new Matrix3d.\r\n   * * The caller is responsible for validity of the inverse coefficients.\r\n   * @param coffs (required) array of 9 coefficients.\r\n   * @param inverseCoffs (optional) array of 9 coefficients.\r\n   * @returns a Matrix3d populated by a coffs array.\r\n   */\r\n  public static createCapture(coffs: Float64Array, inverseCoffs?: Float64Array): Matrix3d {\r\n    const result = new Matrix3d(coffs);\r\n    if (inverseCoffs) {\r\n      result.inverseCoffs = inverseCoffs;\r\n      result.inverseState = InverseMatrixState.inverseStored;\r\n    } else {\r\n      result.inverseState = InverseMatrixState.unknown;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * create a matrix by distributing vectors to columns in one of 6 orders.\r\n   * @param axisOrder identifies where the columns are placed.\r\n   * @param columnA vector to place in the first column named by the axis order.\r\n   * @param columnB vector to place in the second column named by the axis order.\r\n   * @param columnC vector to place in the third column named by the axis order.\r\n   * @param result\r\n   */\r\n  public static createColumnsInAxisOrder(axisOrder: AxisOrder, columnA: Vector3d, columnB: Vector3d, columnC: Vector3d | undefined, result?: Matrix3d) {\r\n    if (!result) result = new Matrix3d();\r\n    if (axisOrder === AxisOrder.YZX) {\r\n      result.setColumns(columnC, columnA, columnB);\r\n    } else if (axisOrder === AxisOrder.ZXY) {\r\n      result.setColumns(columnB, columnC, columnA);\r\n    } else if (axisOrder === AxisOrder.XZY) {\r\n      result.setColumns(columnA, columnC, columnB);\r\n    } else if (axisOrder === AxisOrder.YXZ) {\r\n      result.setColumns(columnB, columnA, columnC);\r\n    } else if (axisOrder === AxisOrder.ZYX) {\r\n      result.setColumns(columnC, columnB, columnA);\r\n    } else {  // fallthrough should only happen for AxisOrder.XYZ\r\n      result.setColumns(columnA, columnB, columnC);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   *  set all entries in the matrix from call parameters appearing in row-major order.\r\n   * @param axx Row x, column x (0,0) entry\r\n   * @param axy Row x, column y (0,1) entry\r\n   * @param axz Row x, column z (0,2) entry\r\n   * @param ayx Row y, column x (1,0) entry\r\n   * @param ayy Row y, column y (1,1) entry\r\n   * @param ayz Row y, column z (1,2) entry\r\n   * @param azx Row z, column x (2,0) entry\r\n   * @param azy Row z, column y (2,2) entry\r\n   * @param azz row z, column z (2,3) entry\r\n   */\r\n  public setRowValues(\r\n    axx: number, axy: number, axz: number,\r\n    ayx: number, ayy: number, ayz: number,\r\n    azx: number, azy: number, azz: number): void {\r\n    this.coffs[0] = axx; this.coffs[1] = axy; this.coffs[2] = axz;\r\n    this.coffs[3] = ayx; this.coffs[4] = ayy; this.coffs[5] = ayz;\r\n    this.coffs[6] = azx; this.coffs[7] = azy; this.coffs[8] = azz;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** Set the matrix to an identity. */\r\n  public setIdentity() { this.setRowValues(1, 0, 0, 0, 1, 0, 0, 0, 1); this.setupInverseTranspose(); }\r\n  /** Set the matrix to all zeros. */\r\n  public setZero() { this.setRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0); this.inverseState = InverseMatrixState.singular; }\r\n  /** copy contents from another matrix. */\r\n  public setFrom(other: Matrix3d) {\r\n    for (let i = 0; i < 9; i++)\r\n      this.coffs[i] = other.coffs[i];\r\n    this.inverseState = InverseMatrixState.unknown; // we don't trust the other .. . .\r\n  }\r\n\r\n  /** return a clone of this matrix.\r\n   * * coefficients are copied.\r\n   * * inverse coefficients are NOT copied.\r\n   * * inverse status is set to unknown\r\n   */\r\n  public clone(result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    result.setFrom(this);\r\n    return result;\r\n  }\r\n  /** create a matrix with all zeros.\r\n   * * Note that for geometry transformations \"all zeros\" is not a useful default state.\r\n   * * Hence almost always use `createIdentity` for graphics transformations.\r\n   * * \"all zeros\" is appropriate for summing moment data.\r\n   */\r\n  public static createZero(): Matrix3d {\r\n    const retVal = new Matrix3d();\r\n    retVal.inverseState = InverseMatrixState.singular;\r\n    return retVal;\r\n  }\r\n  /** create an identity matrix\r\n   * * all diagonal entries (xx,yy,zz) are one\r\n   * * all others are zero.\r\n   * * This (rather than all zeros) is the useful state for most graphics transformations.\r\n   */\r\n  public static createIdentity(result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    result.setIdentity();\r\n    return result;\r\n  }\r\n\r\n  /** Create a matrix with uniform scale factors */\r\n  public static createUniformScale(scaleFactor: number): Matrix3d {\r\n    return Matrix3d.createScale(scaleFactor, scaleFactor, scaleFactor);\r\n  }\r\n  /**\r\n   *\r\n   * *  use createHeadsUpPerpendicular to generate a vectorV perpendicular to vectorA\r\n   * *  construct a frame using createRigidFromColumns (vectorA, vectorB, axisOrder)\r\n   */\r\n  public static createRigidHeadsUp(vectorA: Vector3d, axisOrder: AxisOrder = AxisOrder.ZXY, result?: Matrix3d): Matrix3d {\r\n    const vectorB = Matrix3d.createPerpendicularVectorFavorXYPlane(vectorA);\r\n    const matrix = Matrix3d.createRigidFromColumns(vectorA, vectorB, axisOrder, result);\r\n    if (matrix) {\r\n      matrix.setupInverseTranspose();\r\n      return matrix;\r\n    }\r\n    return Matrix3d.createIdentity(result);\r\n  }\r\n  /**\r\n   *\r\n   * * return a vector that is perpendicular to the input direction.\r\n   * * Among the infinite number of perpendiculars possible, this method\r\n   * favors having one in the xy plane.\r\n   * * Hence, when vectorA is NOT close to the Z axis, the returned vector is Z cross vectorA.\r\n   * * But vectorA is close to the Z axis, the returned vector is unitY cross vectorA.\r\n   */\r\n  public static createPerpendicularVectorFavorXYPlane(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    const a = vector.magnitude();\r\n    const b = a / 64.0;   // A constant from the dawn of time in the CAD industry.\r\n    if (Math.abs(vector.x) < b && Math.abs(vector.y) < b) {\r\n      return Vector3d.createCrossProduct(vector.x, vector.y, vector.z, 0, -1, 0, result);\r\n    }\r\n    return Vector3d.createCrossProduct(0, 0, 1, vector.x, vector.y, vector.z, result);\r\n  }\r\n\r\n  /**\r\n   *\r\n   * * return a vector that is perpendicular to the input direction.\r\n   * * Among the infinite number of perpendiculars possible, this method\r\n   * favors having one near the Z.\r\n   * That is achieved by crossing \"this\" vector with the result of createHeadsUpPerpendicularFavorXYPlane.\r\n   */\r\n  public static createPerpendicularVectorFavorPlaneContainingZ(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    result = Matrix3d.createPerpendicularVectorFavorXYPlane(vector, result);\r\n    return vector.crossProduct(result, result);\r\n  }\r\n\r\n  /** Create a matrix with distinct x,y,z diagonal (scale) entries */\r\n  public static createScale(scaleFactorX: number, scaleFactorY: number, scaleFactorZ: number, result?: Matrix3d): Matrix3d {\r\n    if (result)\r\n      result.setZero();\r\n    else\r\n      result = new Matrix3d();\r\n\r\n    result.coffs[0] = scaleFactorX;\r\n    result.coffs[4] = scaleFactorY;\r\n    result.coffs[8] = scaleFactorZ;\r\n    if (scaleFactorX === 0 || scaleFactorY === 0 || scaleFactorZ === 0) {\r\n      result.inverseState = InverseMatrixState.singular;\r\n    } else {\r\n      result.inverseState = InverseMatrixState.inverseStored;\r\n      result.inverseCoffs = Float64Array.from([1 / scaleFactorX, 0, 0,\r\n        0, 1 / scaleFactorY, 0,\r\n        0, 0, 1 / scaleFactorZ]);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** return a rotation of specified angle around an axis */\r\n  public static createRotationAroundVector(axis: Vector3d, angle: Angle, result?: Matrix3d): Matrix3d | undefined {\r\n    const c = angle.cos();\r\n    const s = angle.sin();\r\n    const v = 1.0 - c;\r\n    const unit = axis.normalize();\r\n    if (unit) {\r\n      const retVal = Matrix3d.createRowValues(\r\n        unit.x * unit.x * v + c,\r\n        unit.x * unit.y * v - s * unit.z,\r\n        unit.x * unit.z * v + s * unit.y,\r\n        unit.y * unit.x * v + s * unit.z,\r\n        unit.y * unit.y * v + c,\r\n        unit.y * unit.z * v - s * unit.x,\r\n        unit.z * unit.x * v - s * unit.y,\r\n        unit.z * unit.y * v + s * unit.x,\r\n        unit.z * unit.z * v + c, result);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Returns a rotation of specified angle around an axis\r\n   * @param axisIndex index of axis (AxisIndex.X, AxisIndex.Y, AxisIndex.Z) kept fixed by the rotation.\r\n   * @param angle angle of rotation\r\n   * @param result optional result matrix.\r\n   */\r\n  public static createRotationAroundAxisIndex(axisIndex: AxisIndex, angle: Angle, result?: Matrix3d): Matrix3d {\r\n    const c = angle.cos();\r\n    const s = angle.sin();\r\n    let myResult;\r\n    if (axisIndex === AxisIndex.X) {\r\n      myResult = Matrix3d.createRowValues(\r\n        1, 0, 0,\r\n        0, c, -s,\r\n        0, s, c,\r\n        result);\r\n    } else if (axisIndex === AxisIndex.Y) {\r\n      myResult = Matrix3d.createRowValues(\r\n        c, 0, s,\r\n        0, 1, 0,\r\n        -s, 0, c,\r\n        result);\r\n    } else {\r\n      myResult = Matrix3d.createRowValues(\r\n        c, -s, 0,\r\n        s, c, 0,\r\n        0, 0, 1,\r\n        result);\r\n    }\r\n    myResult.setupInverseTranspose();\r\n    return myResult;\r\n  }\r\n\r\n  /** Create a matrix with\r\n   * * ColumnX points in the rightVector direction\r\n   * * ColumnY points in in the upVectorDirection\r\n   * * ColumnZ is a unit cross product.\r\n   * Optionally rotate the standard cube by 45 to bring its left or right vertical edge to center\r\n   * * leftNoneRight = [-1,0,1] respectively for left edge, no rotation, or right edge\r\n   * * bottomNoneTop = [-1,0,1] respectively for isometric rotation to view the bottom, no isometric rotation, and isometric rotation to view the top\r\n   * This is expected to be used with various principal unit vectors that are perpendicular to each other.\r\n   *  * STANDARD TOP VIEW: (Vector3d.UnitX (), Vector3d.UnitY (), 0, 0)\r\n   *  * STANDARD FRONT VIEW: (Vector3d.UnitX (), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD BACK VIEW: (Vector3d.UnitX (-1), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD RIGHT VIEW: (Vector3d.UnitY (1), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD LEFT VIEW: (Vector3d.UnitY (-1), Vector3d.UnitZ (), 0, 0)\r\n   *  * STANDARD BOTTOM VIEW: (Vector3d.UnitX (1), Vector3d.UnitY (-1), 0, 0)\r\n   * @param leftNoneRight Normally one of {-1,0,1}, where (-1) indicates the left vertical is rotated to center and (1) for right.  Other numbers are used as multiplier for this 45 degree rotation\r\n   * @returns undefined if columnX, columnY are coplanar.\r\n   */\r\n  public static createViewedAxes(rightVector: Vector3d, upVector: Vector3d, leftNoneRight: number = 0, topNoneBottom: number = 0): Matrix3d | undefined {\r\n    const columnZ = rightVector.crossProduct(upVector);\r\n    if (columnZ.normalizeInPlace()) {\r\n      const geometry = Matrix3d.createColumns(rightVector, upVector, columnZ);\r\n      if (leftNoneRight !== 0.0) {\r\n        let c = Math.sqrt(0.5);\r\n        let s = leftNoneRight < 0.0 ? -c : c;\r\n        if (Math.abs(leftNoneRight) !== 1.0) {\r\n          const radians = Angle.degreesToRadians(45.0 * leftNoneRight);\r\n          c = Math.cos(radians);\r\n          s = Math.sin(radians);\r\n        }\r\n        geometry.applyGivensColumnOp(2, 0, c, s);   // rotate around Y\r\n      }\r\n      if (topNoneBottom !== 0.0) {\r\n        const theta = topNoneBottom * Math.atan(Math.sqrt(0.5));\r\n        const c = Math.cos(theta);\r\n        const s = Math.sin(theta);\r\n        geometry.applyGivensColumnOp(1, 2, c, -s); // rotate around X\r\n      }\r\n      return geometry;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create a rotation matrix for one of the 8 standard views.\r\n   * * With `invert === false` the return is such that `matrix.multiply(worldVector)` returns the vector as seen in the xy (projected) coordinates of the view.\r\n   * * With invert === true the matrix is transposed so that `matrix.multiply(viewVector` maps the \"in view\" vector to a world vector.\r\n   *\r\n   * @param index standard view index `StandardViewIndex.Top, Bottom, LEft, Right, Front, Back, Iso, LeftIso`\r\n   * @param invert if false (default), the returned Matrix3d \"projects\" world vectors into XY view vectors.  If true, it is inverted to map view vectors to world.\r\n   * @param result optional result.\r\n   */\r\n  public static createStandardWorldToView(index: StandardViewIndex, invert: boolean = false, result?: Matrix3d): Matrix3d {\r\n    switch (index) {\r\n\r\n      case StandardViewIndex.Bottom:\r\n        result = Matrix3d.createRowValues(\r\n          1, 0, 0,\r\n          0, -1, 0,\r\n          0, 0, -1);\r\n        break;\r\n      case StandardViewIndex.Left:\r\n        result = Matrix3d.createRowValues(\r\n          0, -1, 0,\r\n          0, 0, 1,\r\n          -1, 0, 0);\r\n        break;\r\n      case StandardViewIndex.Right:\r\n        result = Matrix3d.createRowValues(\r\n          0, 1, 0,\r\n          0, 0, 1,\r\n          1, 0, 0);\r\n        break;\r\n      case StandardViewIndex.Front: // 0-based 4\r\n        result = Matrix3d.createRowValues(\r\n          1, 0, 0,\r\n          0, 0, 1,\r\n          0, -1, 0);\r\n        break;\r\n      case StandardViewIndex.Back: // 0-based 5\r\n        result = Matrix3d.createRowValues(\r\n          -1, 0, 0,\r\n          0, 0, 1,\r\n          0, 1, 0);\r\n        break;\r\n      case StandardViewIndex.Iso:\r\n        result = Matrix3d.createRowValues(\r\n          0.707106781186548, -0.70710678118654757, 0.00000000000000000,\r\n          0.408248290463863, 0.40824829046386302, 0.81649658092772603,\r\n          -0.577350269189626, -0.57735026918962573, 0.57735026918962573);\r\n        break;\r\n      case StandardViewIndex.RightIso:\r\n        result = Matrix3d.createRowValues(\r\n          0.707106781186548, 0.70710678118654757, 0.00000000000000000,\r\n          -0.408248290463863, 0.40824829046386302, 0.81649658092772603,\r\n          0.577350269189626, -0.57735026918962573, 0.57735026918962573);\r\n        break;\r\n      case StandardViewIndex.Top:\r\n      default:\r\n        result = Matrix3d.createIdentity(result);\r\n    }\r\n    if (invert)\r\n      result.transposeInPlace();\r\n    return result;\r\n  }\r\n  /*\r\n  // this implementation has problems distinguishing failure (normalize) from small angle.\r\n  public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, error: boolean } {\r\n\r\n    const result = { axis: Vector3d.unitZ(), angle: Angle.createRadians(0), error: true };\r\n    if (this.isIdentity()) {\r\n      result.error = false;\r\n      return result;\r\n    }\r\n    if (!this.isRigid())\r\n      return result;\r\n    const QminusI = this.clone();\r\n    QminusI.coffs[0] -= 1.0;\r\n    QminusI.coffs[4] -= 1.0;\r\n    QminusI.coffs[8] -= 1.0;\r\n    // Each column of (Q - I) is the motion of the corresponding axis vector\r\n    // during the rotation.\r\n    // Only one of the three axes can really be close to the rotation axis.\r\n    const delta0 = QminusI.columnX();\r\n    const delta1 = QminusI.columnY();\r\n    const delta2 = QminusI.columnZ();\r\n    const cross01 = delta0.crossProduct(delta1);\r\n    const cross12 = delta1.crossProduct(delta2);\r\n    const cross20 = delta2.crossProduct(delta0);\r\n\r\n    const aa01 = cross01.magnitudeSquared();\r\n    const aa12 = cross12.magnitudeSquared();\r\n    const aa20 = cross20.magnitudeSquared();\r\n\r\n    const cross = cross01.clone(); // This will end up as the biggest cross product\r\n    const v0 = delta0.clone();  // This will end up as one of the two largest delta vectors\r\n    let aaMax = aa01;\r\n    if (aa12 > aaMax) {\r\n      cross.setFrom(cross12);\r\n      aaMax = aa12;\r\n      v0.setFrom(delta1);\r\n    }\r\n    if (aa20 > aaMax) {\r\n      cross.setFrom(cross20);\r\n      aaMax = aa20;\r\n      v0.setFrom(delta2);\r\n    }\r\n\r\n    if (aaMax === 0.0) {\r\n      // The vectors did not move.  Just accept the zero rotation, with error flag set.\r\n      return result;\r\n    }\r\n\r\n    v0.normalizeInPlace();\r\n    // V0 is a unit vector perpendicular to the rotation axis.\r\n    // Rotate it.   Its image V1 is also a unit vector, and the angle from V0 to V1 is the quat angle.\r\n    // CrossProduct is axis vector times sine of angle.\r\n    // Dot Product is cosine of angle.\r\n    // V2 is zero in 180 degree case, so we use the Cross from the search as the axis\r\n    //   as direction, being careful to keep sine positive.\r\n    const v1 = this.multiplyVector(v0);\r\n    const v2 = v0.crossProduct(v1);\r\n    const sine = v2.magnitude();\r\n    if (v2.dotProduct(cross) < 0.0)\r\n      cross.scaleInPlace(-1.0);\r\n    const cosine = v0.dotProduct(v1);\r\n    result.angle.setRadians(Math.atan2(sine, cosine));\r\n    result.axis.setFrom(cross);\r\n    result.error = !result.axis.tryNormalizeInPlace();\r\n    return result\r\n  }\r\n*/\r\n  /**\r\n   * Compute the (unit vector) axis and angle of rotation.\r\n   * @returns Returns with result.ok === true when the conversion succeeded.\r\n   */\r\n  public getAxisAndAngleOfRotation(): { axis: Vector3d, angle: Angle, ok: boolean } {\r\n    const trace = this.coffs[0] + this.coffs[4] + this.coffs[8];\r\n    // trace = (xx + yy * zz) * (1-c) + 3 * c = 1 + 2c ==> c = (trace-1) / 2\r\n    const skewXY = this.coffs[3] - this.coffs[1];  // == 2sz\r\n    const skewYZ = this.coffs[7] - this.coffs[5]; // == 2sx\r\n    const skewZX = this.coffs[2] - this.coffs[6]; // == 2sy\r\n    const c = (trace - 1.0) / 2.0;\r\n    const s = Geometry.hypotenuseXYZ(skewXY, skewYZ, skewZX) / 2.0;\r\n    const e = c * c + s * s - 1.0;\r\n    if (Math.abs(e) > Geometry.smallAngleRadians) {\r\n      // the sine and cosine are not a unit circle point.   bad matrix . ..\r\n      return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\r\n    }\r\n    if (Math.abs(s) < Geometry.smallAngleRadians) {\r\n      // There is no significant skew.\r\n      // The matrix is symmetric\r\n      // So it has simple eigenvalues -- either (1,1,1) or (1,-1,-1).\r\n      if (c > 0)  // no rotation\r\n        return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: true };\r\n      // 180 degree flip around some axis ?\r\n      // Look for the simple case of a principal rotation ...\r\n      // look for a pair of (-1) entries on the diagonal ...\r\n      const axx = this.coffs[0];\r\n      const ayy = this.coffs[4];\r\n      const azz = this.coffs[8];\r\n      const theta180 = Angle.createDegrees(180);\r\n      // Look for principal axis flips as a special case . ..\r\n      if (Geometry.isAlmostEqualNumber(-1.0, ayy) && Geometry.isAlmostEqualNumber(-1, azz)) {\r\n        // rotate around\r\n        return { axis: Vector3d.create(1, 0, 0), angle: theta180, ok: true };\r\n      } else if (Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry.isAlmostEqualNumber(-1, azz)) {\r\n        return { axis: Vector3d.create(0, 1, 0), angle: theta180, ok: true };\r\n      } else if (Geometry.isAlmostEqualNumber(-1.0, axx) && Geometry.isAlmostEqualNumber(-1, ayy)) {\r\n        return { axis: Vector3d.create(0, 0, 1), angle: theta180, ok: true };\r\n      }\r\n\r\n      // 180 degree flip around some other axis ...\r\n      // eigenvalues will have 1.0 once, -1.0 twice.\r\n      // These cases look for each place (x,y,z) that the 1.0 might appear.\r\n      // But fastSymmetricEigenvalues reliably always seems to put the 1.0 as the x eigenvalue.\r\n      // so only the getColumn(0) return seems reachable in unit tests.\r\n      const eigenvectors = Matrix3d.createIdentity();\r\n      const eigenvalues = Vector3d.create(0, 0, 0);\r\n      if (this.fastSymmetricEigenvalues(eigenvectors, eigenvalues)) {\r\n        for (let axisIndex = 0; axisIndex < 2; axisIndex++) {\r\n          const lambda = eigenvalues.at(axisIndex);\r\n          if (Geometry.isAlmostEqualNumber(1, lambda))\r\n            return { axis: eigenvectors.getColumn(axisIndex), angle: theta180, ok: true };\r\n        }\r\n        // Don't know if this can be reached ....\r\n        return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\r\n      }\r\n      return { axis: Vector3d.create(0, 0, 1), angle: Angle.createRadians(0), ok: false };\r\n    }\r\n    const a = 1.0 / (2.0 * s);\r\n    const result = { axis: Vector3d.create(skewYZ * a, skewZX * a, skewXY * a), angle: Angle.createAtan2(s, c), ok: true };\r\n    return result;\r\n  }\r\n  /**\r\n   * Returns a matrix that rotates from vectorA to vectorB.\r\n   */\r\n  public static createRotationVectorToVector(vectorA: Vector3d, vectorB: Vector3d, result?: Matrix3d): Matrix3d | undefined {\r\n    return this.createPartialRotationVectorToVector(vectorA, 1.0, vectorB, result);\r\n  }\r\n  /**\r\n   * Return a matrix that rotates a fraction of the angular sweep from vectorA to vectorB.\r\n   * @param vectorA initial vector position\r\n   * @param fraction fractional rotation.  1.0 is \"all the way\"\r\n   * @param vectorB final vector position\r\n   * @param result optional result matrix.\r\n   */\r\n  public static createPartialRotationVectorToVector(vectorA: Vector3d, fraction: number, vectorB: Vector3d, result?: Matrix3d): Matrix3d | undefined {\r\n\r\n    let upVector = vectorA.unitCrossProduct(vectorB);\r\n    if (upVector) {  // the usual case --\r\n      return Matrix3d.createRotationAroundVector(upVector,\r\n        Angle.createRadians(fraction * vectorA.planarAngleTo(vectorB, upVector).radians));\r\n    }\r\n    // fail if either vector is zero ...\r\n    if (Geometry.isSmallMetricDistance(vectorA.magnitude())\r\n      || Geometry.isSmallMetricDistance(vectorB.magnitude()))\r\n      return undefined;\r\n    // nonzero but aligned vectors ...\r\n    if (vectorA.dotProduct(vectorB) > 0.0)\r\n      return Matrix3d.createIdentity(result);\r\n    // nonzero opposing vectors ..\r\n    upVector = Matrix3d.createPerpendicularVectorFavorPlaneContainingZ(vectorA, upVector);\r\n    return Matrix3d.createRotationAroundVector(upVector, Angle.createRadians(fraction * Math.PI));\r\n  }\r\n\r\n  /** Create a 90 degree rotation around a principal axis */\r\n  public static create90DegreeRotationAroundAxis(axisIndex: number): Matrix3d {\r\n    axisIndex = Geometry.cyclic3dAxis(axisIndex);\r\n    if (axisIndex === 0) {\r\n      const retVal = Matrix3d.createRowValues(\r\n        1, 0, 0,\r\n        0, 0, -1,\r\n        0, 1, 0);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    } else if (axisIndex === 1) {\r\n      const retVal = Matrix3d.createRowValues(\r\n        0, 0, 1,\r\n        0, 1, 0,\r\n        -1, 0, 0);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    } else {\r\n      const retVal = Matrix3d.createRowValues(\r\n        0, -1, 0,\r\n        1, 0, 0,\r\n        0, 0, 1);\r\n      retVal.setupInverseTranspose();\r\n      return retVal;\r\n    }\r\n  }\r\n\r\n  /** Return (a copy of) the X column */\r\n  public columnX(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[0], this.coffs[3], this.coffs[6], result); }\r\n  /** Return (a copy of)the Y column */\r\n  public columnY(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[1], this.coffs[4], this.coffs[7], result); }\r\n  /** Return (a copy of)the Z column */\r\n  public columnZ(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[2], this.coffs[5], this.coffs[8], result); }\r\n\r\n  /** Return the X column magnitude squared */\r\n  public columnXMagnitudeSquared(): number { return Geometry.hypotenuseSquaredXYZ(this.coffs[0], this.coffs[3], this.coffs[6]); }\r\n  /** Return the Y column magnitude squared */\r\n  public columnYMagnitudeSquared(): number { return Geometry.hypotenuseSquaredXYZ(this.coffs[1], this.coffs[4], this.coffs[7]); }\r\n  /** Return the Z column magnitude squared */\r\n  public columnZMagnitudeSquared(): number { return Geometry.hypotenuseSquaredXYZ(this.coffs[2], this.coffs[5], this.coffs[8]); }\r\n\r\n  /** Return the X column magnitude */\r\n  public columnXMagnitude(): number { return Math.hypot(this.coffs[0], this.coffs[3], this.coffs[6]); }\r\n  /** Return the Y column magnitude */\r\n  public columnYMagnitude(): number { return Math.hypot(this.coffs[1], this.coffs[4], this.coffs[7]); }\r\n  /** Return the Z column magnitude */\r\n  public columnZMagnitude(): number { return Math.hypot(this.coffs[2], this.coffs[5], this.coffs[8]); }\r\n\r\n  /** Return magnitude of columnX cross columnY. */\r\n  public columnXYCrossProductMagnitude(): number {\r\n    return Geometry.crossProductMagnitude(\r\n      this.coffs[0], this.coffs[3], this.coffs[6],\r\n      this.coffs[1], this.coffs[4], this.coffs[7]);\r\n  }\r\n\r\n  /** Return the X row magnitude d */\r\n  public rowXMagnitude(): number { return Math.hypot(this.coffs[0], this.coffs[1], this.coffs[2]); }\r\n  /** Return the Y row magnitude  */\r\n  public rowYMagnitude(): number { return Math.hypot(this.coffs[3], this.coffs[4], this.coffs[5]); }\r\n  /** Return the Z row magnitude  */\r\n  public rowZMagnitude(): number { return Math.hypot(this.coffs[6], this.coffs[7], this.coffs[8]); }\r\n  /** Return the dot product of column X with column Y */\r\n  /** Return the dot product of column X with column Y */\r\n  public columnXDotColumnY(): number {\r\n    return this.coffs[0] * this.coffs[1]\r\n      + this.coffs[3] * this.coffs[4]\r\n      + this.coffs[6] * this.coffs[7];\r\n  }\r\n  /** Return (a copy of) the X row */\r\n  public rowX(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[0], this.coffs[1], this.coffs[2], result); }\r\n  /** Return (a copy of) the Y row */\r\n  public rowY(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[3], this.coffs[4], this.coffs[5], result); }\r\n  /** Return (a copy of) the Z row */\r\n  public rowZ(result?: Vector3d): Vector3d { return Vector3d.create(this.coffs[6], this.coffs[7], this.coffs[8], result); }\r\n\r\n  /** Return the dot product of the vector parameter with the X column. */\r\n  public dotColumnX(vector: XYZ): number { return vector.x * this.coffs[0] + vector.y * this.coffs[3] + vector.z * this.coffs[6]; }\r\n  /** Return the dot product of the vector parameter with the Y column. */\r\n  public dotColumnY(vector: XYZ): number { return vector.x * this.coffs[1] + vector.y * this.coffs[4] + vector.z * this.coffs[7]; }\r\n  /** Return the dot product of the vector parameter with the Z column. */\r\n  public dotColumnZ(vector: XYZ): number { return vector.x * this.coffs[2] + vector.y * this.coffs[5] + vector.z * this.coffs[8]; }\r\n\r\n  /** Return the dot product of the vector parameter with the X row. */\r\n  public dotRowX(vector: XYZ): number { return vector.x * this.coffs[0] + vector.y * this.coffs[1] + vector.z * this.coffs[2]; }\r\n  /** Return the dot product of the vector parameter with the Y row. */\r\n  public dotRowY(vector: XYZ): number { return vector.x * this.coffs[3] + vector.y * this.coffs[4] + vector.z * this.coffs[5]; }\r\n  /** Return the dot product of the vector parameter with the Z row. */\r\n  public dotRowZ(vector: XYZ): number { return vector.x * this.coffs[6] + vector.y * this.coffs[7] + vector.z * this.coffs[8]; }\r\n\r\n  /** Return the dot product of the x,y,z with the X row. */\r\n  public dotRowXXYZ(x: number, y: number, z: number): number { return x * this.coffs[0] + y * this.coffs[1] + z * this.coffs[2]; }\r\n  /** Return the dot product of the x,y,z with the Y row. */\r\n  public dotRowYXYZ(x: number, y: number, z: number): number { return x * this.coffs[3] + y * this.coffs[4] + z * this.coffs[5]; }\r\n  /** Return the dot product of the x,y,z with the Z row. */\r\n  public dotRowZXYZ(x: number, y: number, z: number): number { return x * this.coffs[6] + y * this.coffs[7] + z * this.coffs[8]; }\r\n\r\n  /** Return the (vector) cross product of the Z column with the vector parameter. */\r\n  public columnZCrossVector(vector: XYZ, result?: Vector3d): Vector3d {\r\n    return Geometry.crossProductXYZXYZ(this.coffs[2], this.coffs[5], this.coffs[8], vector.x, vector.y, vector.z, result);\r\n  }\r\n  /**\r\n   * Replace current rows Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)\r\n   * @param i first row index.  must be 0,1,2 (unchecked)\r\n   * @param j second row index. must be 0,1,2 (unchecked)\r\n   * @param c fist coefficient\r\n   * @param s second coefficient\r\n   */\r\n  private applyGivensRowOp(i: number, j: number, c: number, s: number): void {\r\n    let ii = 3 * i;\r\n    let jj = 3 * j;\r\n    const limit = ii + 3;\r\n    for (; ii < limit; ii++ , jj++) {\r\n      const a = this.coffs[ii];\r\n      const b = this.coffs[jj];\r\n      this.coffs[ii] = a * c + b * s;\r\n      this.coffs[jj] = -a * s + b * c;\r\n    }\r\n  }\r\n  /**\r\n   * Replace current columns Ui Uj with (c*Ui - s*Uj) and (c*Uj + s*Ui)\r\n   * This is used in compute intensive inner loops -- there is no\r\n   * checking for i,j being 0,1,2\r\n   * @param i first row index.  must be 0,1,2 (unchecked)\r\n   * @param j second row index. must be 0,1,2 (unchecked)\r\n   * @param c fist coefficient\r\n   * @param s second coefficient\r\n   */\r\n  public applyGivensColumnOp(i: number, j: number, c: number, s: number): void {\r\n    const limit = i + 9;\r\n    for (; i < limit; i += 3, j += 3) {\r\n      const a = this.coffs[i];\r\n      const b = this.coffs[j];\r\n      this.coffs[i] = a * c + b * s;\r\n      this.coffs[j] = -a * s + b * c;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * create a rigid coordinate frame with:\r\n   * * column z points from origin to x,y,z\r\n   * * column x is perpendicular and in the xy plane\r\n   * * column y is perpendicular to both.  It is the \"up\" vector on the view plane.\r\n   * * Multiplying a world vector times the transpose of this matrix transforms into the view xy\r\n   * * Multiplying the matrix times the an in-view vector transforms the vector to world.\r\n   * @param x eye x coordinate\r\n   * @param y eye y coordinate\r\n   * @param z eye z coordinate\r\n   * @param result\r\n   */\r\n  public static createRigidViewAxesZTowardsEye(x: number, y: number, z: number, result?: Matrix3d): Matrix3d {\r\n    result = Matrix3d.createIdentity(result);\r\n    const rxy = Geometry.hypotenuseXY(x, y);\r\n    if (Geometry.isSmallMetricDistance(rxy)) {\r\n      // special case for top or bottom view.\r\n      if (z < 0.0)\r\n        result.scaleColumnsInPlace(1.0, -1, -1.0);\r\n    } else {\r\n      //      const d = Geometry.hypotenuseSquaredXYZ(x, y, z);\r\n      const c = x / rxy;\r\n      const s = y / rxy;\r\n      result.setRowValues(\r\n        -s, 0, c,\r\n        c, 0, s,\r\n        0, 1, 0);\r\n      if (z !== 0.0) {\r\n        const r = Geometry.hypotenuseXYZ(x, y, z);\r\n        const s1 = z / r;\r\n        const c1 = rxy / r;\r\n        result.applyGivensColumnOp(1, 2, c1, -s1);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Rotate so columns i and j become perpendicular */\r\n  private applyJacobiColumnRotation(i: number, j: number, matrixU: Matrix3d): number {\r\n    const uDotU = this.coffs[i] * this.coffs[i] + this.coffs[i + 3] * this.coffs[i + 3] + this.coffs[i + 6] * this.coffs[i + 6];\r\n    const vDotV = this.coffs[j] * this.coffs[j] + this.coffs[j + 3] * this.coffs[j + 3] + this.coffs[j + 6] * this.coffs[j + 6];\r\n    const uDotV = this.coffs[i] * this.coffs[j] + this.coffs[i + 3] * this.coffs[j + 3] + this.coffs[i + 6] * this.coffs[j + 6];\r\n    // const c2 = uDotU - vDotV;\r\n    // const s2 = 2.0 * uDotV;\r\n    const jacobi = Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);\r\n    // const h = Math.hypot(c2, s2);\r\n    // console.log(\" c2 s2\", c2 / h, s2 / h);\r\n    // console.log(\" C S \", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));\r\n    // console.log(\"i j uDotV\", i, j, uDotV);\r\n    if (Math.abs(jacobi.s) < 2.0e-15)\r\n      return 0.0;\r\n    this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);\r\n    matrixU.applyGivensRowOp(i, j, jacobi.c, jacobi.s);\r\n    // const BTB = this.multiplyMatrixTransposeMatrix(this);\r\n    // console.log(\"BTB\", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), \"       off\", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), \"  at(i,j)\", BTB.at(i, j));\r\n    return Math.abs(uDotV);\r\n  }\r\n  /**\r\n   * Factor this as a product C * U where C has mutually perpendicular columns and\r\n   * U is orthogonal.\r\n   * @param matrixC (allocate by caller, computed here)\r\n   * @param factor  (allocate by caller, computed here)\r\n   */\r\n  public factorPerpendicularColumns(matrixC: Matrix3d, matrixU: Matrix3d): boolean {\r\n    matrixC.setFrom(this);\r\n    matrixU.setIdentity();\r\n    const ss = this.sumSquares();\r\n    const tolerance = 1.0e-12 * ss;\r\n    for (let iteration = 0; iteration < 7; iteration++) {\r\n      const sum = matrixC.applyJacobiColumnRotation(0, 1, matrixU)\r\n        + matrixC.applyJacobiColumnRotation(0, 2, matrixU)\r\n        + matrixC.applyJacobiColumnRotation(1, 2, matrixU);\r\n      // console.log (\"   sum\", sum);\r\n      if (sum < tolerance) {\r\n        // console.log(\"jacobi iterations\", iteration);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Apply a jacobi step to lambda which evolves towards diagonal. */\r\n  private applySymmetricJacobi(i: number, j: number, lambda: Matrix3d): number {\r\n    const uDotU = lambda.at(i, i);\r\n    const vDotV = lambda.at(j, j);\r\n    const uDotV = lambda.at(i, j);\r\n    if (Math.abs(uDotV) < 1.0e-15 * (uDotU + vDotV))\r\n      return 0.0;\r\n    // const c2 = uDotU - vDotV;\r\n    // const s2 = 2.0 * uDotV;\r\n    const jacobi = Angle.trigValuesToHalfAngleTrigValues(uDotU - vDotV, 2.0 * uDotV);\r\n    // const h = Math.hypot(c2, s2);\r\n    // console.log(\" c2 s2\", c2 / h, s2 / h);\r\n    // console.log(\" C S \", Math.cos(2 * jacobi.radians), Math.sin(2 * jacobi.radians));\r\n    // console.log(\"i j uDotV\", i, j, uDotV);\r\n    if (Math.abs(jacobi.s) < 2.0e-15)\r\n      return 0.0;\r\n    // Factored form is this *lambda * thisTranspose\r\n    // Let Q be the rotation matrix.  Q*QT is inserted, viz\r\n    //          this*Q * QT * lambda * Q*thisTranspose\r\n    this.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);\r\n\r\n    lambda.applyGivensRowOp(i, j, jacobi.c, jacobi.s);\r\n    lambda.applyGivensColumnOp(i, j, jacobi.c, jacobi.s);\r\n    // const BTB = this.multiplyMatrixTransposeMatrix(this);\r\n    // console.log(\"BTB\", BTB.at(0, 0), BTB.at(1, 1), BTB.at(2, 2), \"       off\", BTB.at(0, 1), BTB.at(0, 2), BTB.at(1, 2), \"  at(i,j)\", BTB.at(i, j));\r\n    return Math.abs(uDotV);\r\n  }\r\n  /**\r\n   * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.\r\n   * The upper triangle is mirrored to lower triangle to enforce symmetry.\r\n   * @param matrixC (allocate by caller, computed here)\r\n   * @param factor  (allocate by caller, computed here)\r\n   */\r\n  public symmetricEigenvalues(leftEigenvectors: Matrix3d, lambda: Vector3d): boolean {\r\n    const matrix = this.clone();\r\n    leftEigenvectors.setIdentity();\r\n    matrix.coffs[3] = matrix.coffs[1];\r\n    matrix.coffs[6] = matrix.coffs[2];\r\n    matrix.coffs[7] = matrix.coffs[5];\r\n    const ss = this.sumSquares();\r\n    const tolerance = 1.0e-12 * ss;\r\n    for (let iteration = 0; iteration < 7; iteration++) {\r\n      const sum = leftEigenvectors.applySymmetricJacobi(0, 1, matrix)\r\n        + leftEigenvectors.applySymmetricJacobi(0, 2, matrix)\r\n        + leftEigenvectors.applySymmetricJacobi(1, 2, matrix);\r\n      // console.log(\"symmetric sum\", sum);\r\n      // console.log (\"   sum\", sum);\r\n      if (sum < tolerance) {\r\n        // console.log(\"symmetric iterations\", iteration);\r\n        lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Apply (in place a jacobi update that zeros out this.at(i,j).\r\n   *\r\n   */\r\n  private applyFastSymmetricJacobiUpdate(\r\n    i: number,  // row index of zeroed member\r\n    j: number,  // column index of zeroed member\r\n    k: number,  // other row/column index (different from i and j)\r\n    leftEigenVectors: Matrix3d): number {\r\n    const indexII = 4 * i;\r\n    const indexJJ = 4 * j;\r\n    const indexIJ = 3 * i + j;\r\n    const indexIK = 3 * i + k;\r\n    const indexJK = 3 * j + k;\r\n    const dotUU = this.coffs[indexII];\r\n    const dotVV = this.coffs[indexJJ];\r\n    const dotUV = this.coffs[indexIJ];\r\n    const jacobi = Angle.trigValuesToHalfAngleTrigValues(dotUU - dotVV, 2.0 * dotUV);\r\n    if (Math.abs(dotUV) < 1.0e-15 * (dotUU + dotVV))\r\n      return 0.0;\r\n    const c = jacobi.c;\r\n    const s = jacobi.s;\r\n    const cc = c * c;\r\n    const ss = s * s;\r\n    const sc2 = 2.0 * c * s;\r\n    this.coffs[indexII] = cc * dotUU + sc2 * dotUV + ss * dotVV;\r\n    this.coffs[indexJJ] = ss * dotUU - sc2 * dotUV + cc * dotVV;\r\n    this.coffs[indexIJ] = 0.0;\r\n    const a = this.coffs[indexIK];\r\n    const b = this.coffs[indexJK];\r\n    this.coffs[indexIK] = a * c + b * s;\r\n    this.coffs[indexJK] = -s * a + c * b;\r\n    this.coffs[3 * j + i] = 0.0;\r\n    this.coffs[3 * k + i] = this.coffs[indexIK];\r\n    this.coffs[3 * k + j] = this.coffs[indexJK];\r\n    leftEigenVectors.applyGivensColumnOp(i, j, c, s);\r\n    return Math.abs(dotUV);\r\n  }\r\n\r\n  /**\r\n   * Factor this (symmetrized) as a product U * lambda * UT where U is orthogonal, lambda is diagonal.\r\n   * The upper triangle is mirrored to lower triangle to enforce symmetry.\r\n   * @param matrixC (allocate by caller, computed here)\r\n   * @param factor  (allocate by caller, computed here)\r\n   */\r\n  public fastSymmetricEigenvalues(leftEigenvectors: Matrix3d, lambda: Vector3d): boolean {\r\n    const matrix = this.clone();\r\n    leftEigenvectors.setIdentity();\r\n    const ss = this.sumSquares();\r\n    const tolerance = 1.0e-12 * ss;\r\n    for (let iteration = 0; iteration < 7; iteration++) {\r\n      const sum = matrix.applyFastSymmetricJacobiUpdate(0, 1, 2, leftEigenvectors)\r\n        + matrix.applyFastSymmetricJacobiUpdate(0, 2, 1, leftEigenvectors)\r\n        + matrix.applyFastSymmetricJacobiUpdate(1, 2, 0, leftEigenvectors);\r\n      // console.log(\"symmetric sum\", sum);\r\n      // console.log (\"   sum\", sum);\r\n      if (sum < tolerance) {\r\n        // console.log(\"symmetric iterations\", iteration);\r\n        lambda.set(matrix.at(0, 0), matrix.at(1, 1), matrix.at(2, 2));\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Create a matrix from column vectors. */\r\n  public static createColumns(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        vectorU.x, vectorV.x, vectorW.x,\r\n        vectorU.y, vectorV.y, vectorW.y,\r\n        vectorU.z, vectorV.z, vectorW.z, result);\r\n  }\r\n\r\n  /** Create a matrix from column vectors.\r\n   * Each column gets x and y from given XAndY, and z from w.\r\n   */\r\n  public static createColumnsXYW(vectorU: XAndY, uz: number, vectorV: XAndY, vz: number, vectorW: XAndY, wz: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        vectorU.x, vectorV.x, vectorW.x,\r\n        vectorU.y, vectorV.y, vectorW.y,\r\n        uz, vz, wz, result);\r\n  }\r\n\r\n  /** Install data from xyz parts of Point4d  (w part of Point4d ignored) */\r\n  public setColumnsPoint4dXYZ(vectorU: Point4d, vectorV: Point4d, vectorW: Point4d) {\r\n    this.setRowValues(\r\n      vectorU.x, vectorV.x, vectorW.x,\r\n      vectorU.y, vectorV.y, vectorW.y,\r\n      vectorU.z, vectorV.z, vectorW.z);\r\n  }\r\n  /**\r\n   * set entries in one column of the matrix.\r\n   * @param columnIndex column index. this is interpreted cyclically.\r\n   * @param value x,yz, values for column.  If undefined, zeros are installed.\r\n   */\r\n  public setColumn(columnIndex: number, value: Vector3d | undefined) {\r\n    const index = Geometry.cyclic3dAxis(columnIndex);\r\n    if (value) {\r\n      this.coffs[index] = value.x;\r\n      this.coffs[index + 3] = value.y;\r\n      this.coffs[index + 6] = value.z;\r\n    } else {\r\n      this.coffs[index] = 0.0;\r\n      this.coffs[index + 3] = 0.0;\r\n      this.coffs[index + 6] = 0.0;\r\n    }\r\n  }\r\n  /** Set all columns of the matrix. Any undefined vector is zeros. */\r\n  public setColumns(vectorX: Vector3d | undefined, vectorY: Vector3d | undefined, vectorZ?: Vector3d | undefined) {\r\n    this.setColumn(0, vectorX);\r\n    this.setColumn(1, vectorY);\r\n    this.setColumn(2, vectorZ);\r\n  }\r\n  /**\r\n   * set entries in one row of the matrix.\r\n   * @param rowIndex row index. this is interpreted cyclically.\r\n   * @param value x,yz, values for row.  If undefined, zeros are installed.\r\n   */\r\n  public setRow(rowIndex: number, value: Vector3d) {\r\n    const index = 3 * Geometry.cyclic3dAxis(rowIndex);\r\n    this.coffs[index] = value.x;\r\n    this.coffs[index + 1] = value.y;\r\n    this.coffs[index + 2] = value.z;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** Return a (copy of) a column of the matrix.\r\n   * @param i column index.  This is corrected to 012 by Geometry.cyclic3dAxis.\r\n   */\r\n  public getColumn(columnIndex: number, result?: Vector3d): Vector3d {\r\n    const index = Geometry.cyclic3dAxis(columnIndex);\r\n    return Vector3d.create(\r\n      this.coffs[index],\r\n      this.coffs[index + 3],\r\n      this.coffs[index + 6], result);\r\n  }\r\n\r\n  /** Return a (copy of) a row of the matrix.\r\n   * @param i row index.  This is corrected to 012 by Geometry.cyclic3dAxis.\r\n   */\r\n  public getRow(columnIndex: number, result?: Vector3d): Vector3d {\r\n    const index = 3 * Geometry.cyclic3dAxis(columnIndex);\r\n    return Vector3d.create(\r\n      this.coffs[index],\r\n      this.coffs[index + 1],\r\n      this.coffs[index + 2], result);\r\n  }\r\n\r\n  /** Create a matrix from column vectors, shuffled into place per AxisTriple */\r\n  public static createShuffledColumns(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, axisOrder: AxisOrder, result?: Matrix3d): Matrix3d {\r\n    const target = Matrix3d._create(result);\r\n    target.setColumn(Geometry.axisOrderToAxis(axisOrder, 0), vectorU);\r\n    target.setColumn(Geometry.axisOrderToAxis(axisOrder, 1), vectorV);\r\n    target.setColumn(Geometry.axisOrderToAxis(axisOrder, 2), vectorW);\r\n    return target;\r\n  }\r\n\r\n  /** Create a matrix from row vectors. */\r\n  public static createRows(vectorU: Vector3d, vectorV: Vector3d, vectorW: Vector3d, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        vectorU.x, vectorU.y, vectorU.z,\r\n        vectorV.x, vectorV.y, vectorV.z,\r\n        vectorW.x, vectorW.y, vectorW.z, result);\r\n  }\r\n\r\n  /** Create a matrix that scales along a specified direction. The scale factor can be negative. for instance scale of -1.0 (negative one) is a mirror. */\r\n  public static createDirectionalScale(direction: Vector3d, scale: number, result?: Matrix3d): Matrix3d {\r\n    const unit = direction.normalize();\r\n    if (unit) {\r\n      const x = unit.x;\r\n      const y = unit.y;\r\n      const z = unit.z;\r\n      const a = (scale - 1);\r\n      return Matrix3d.createRowValues\r\n        (\r\n          1 + a * x * x, a * x * y, a * x * z,\r\n          a * y * x, 1 + a * y * y, a * y * z,\r\n          a * z * x, a * z * y, 1 + a * z * z, result);\r\n    }\r\n    return Matrix3d.createUniformScale(scale);\r\n  }\r\n\r\n  /* Create a matrix with the indicated column in the (normalized) direction, and the other two columns perpendicular. All columns are normalized.\r\n   * * The direction vector is normalized and appears in column axisIndex\r\n   * * If the direction vector is not close to Z, the \"next\" column ((axisIndex + 1) mod 3) will be in the XY plane in the direction of (direction cross Z)\r\n   * * If the direction vector is close to Z, the \"next\" column ((axisIndex + 1) mode 3) will be in the direction of (direction cross Y)\r\n  */\r\n  // static create1Vector(direction: Vector3d, axisIndex: number): Matrix3d;\r\n  // static createFromXYVectors(vectorX: Vector3d, vectorY: Vector3d, axisIndex: number): Matrix3d;\r\n\r\n  /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.\r\n   * @return the vector result\r\n   */\r\n  public multiplyVector(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    return Vector3d.create(\r\n      (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z),\r\n      (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z),\r\n      (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z),\r\n      result);\r\n  }\r\n\r\n  /** Multiply the matrix * vector, i.e. the vector is a column vector on the right.\r\n   * @return the vector result\r\n   */\r\n  public multiplyVectorArrayInPlace(data: XYZ[]): void {\r\n    for (const v of data) v.set(\r\n      (this.coffs[0] * v.x + this.coffs[1] * v.y + this.coffs[2] * v.z),\r\n      (this.coffs[3] * v.x + this.coffs[4] * v.y + this.coffs[5] * v.z),\r\n      (this.coffs[6] * v.x + this.coffs[7] * v.y + this.coffs[8] * v.z));\r\n  }\r\n\r\n  /** compute `origin - matrix * vector` */\r\n  public static xyzMinusMatrixTimesXYZ(origin: XYAndZ, matrix: Matrix3d, vector: XYAndZ, result?: Point3d): Point3d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    return Point3d.create(\r\n      origin.x - (matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z),\r\n      origin.y - (matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z),\r\n      origin.z - (matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z),\r\n      result);\r\n  }\r\n\r\n  /** compute  `origin + matrix * vector`  using only the xy parts of the inputs. */\r\n  public static xyPlusMatrixTimesXY(origin: XAndY, matrix: Matrix3d, vector: XAndY, result?: Point2d): Point2d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    return Point2d.create(\r\n      origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y,\r\n      origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y,\r\n      result);\r\n  }\r\n\r\n  /** compute  `origin + matrix * vector`  using all xyz parts of the inputs. */\r\n  public static xyzPlusMatrixTimesXYZ(origin: XYZ, matrix: Matrix3d, vector: XYAndZ, result?: Point3d): Point3d {\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    return Point3d.create(\r\n      origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z,\r\n      origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z,\r\n      origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z,\r\n      result);\r\n  }\r\n  /** compute `origin + matrix * vector` where the final vector is given as direct x,y,z coordinates */\r\n  public static xyzPlusMatrixTimesCoordinates(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, result?: Point3d): Point3d {\r\n    return Point3d.create(\r\n      origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z,\r\n      origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z,\r\n      origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z,\r\n      result);\r\n  }\r\n\r\n  /**\r\n   * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\r\n   * Multiply times point with coordinates `[x,y,z,w]`\r\n   * @param origin translation part (xyz in column 3)\r\n   * @param matrix matrix part (leading 3x3)\r\n   * @param x x part of multiplied point\r\n   * @param y y part of multiplied point\r\n   * @param z z part of multiplied point\r\n   * @param w w part of multiplied point\r\n   * @param result optional result.\r\n   */\r\n  public static xyzPlusMatrixTimesWeightedCoordinates(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    return Point4d.create(\r\n      w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z,\r\n      w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z,\r\n      w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z,\r\n      w,\r\n      result);\r\n  }\r\n  /**\r\n   * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\r\n   * Multiply times point with coordinates `[x,y,z,w]`\r\n   * @param origin translation part (xyz in column 3)\r\n   * @param matrix matrix part (leading 3x3)\r\n   * @param x x part of multiplied point\r\n   * @param y y part of multiplied point\r\n   * @param z z part of multiplied point\r\n   * @param w w part of multiplied point\r\n   * @param result optional result.\r\n   */\r\n  public static xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, w: number, result?: Float64Array): Float64Array {\r\n    if (!result)\r\n      result = new Float64Array(4);\r\n    result[0] = w * origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;\r\n    result[1] = w * origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;\r\n    result[2] = w * origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;\r\n    result[3] = w;\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Treat the 3x3 matrix and origin as upper 3x4 part of a 4x4 matrix, with 0001 as the final row.\r\n   * Multiply times point with coordinates `[x,y,z,w]`\r\n   * @param origin translation part (xyz in column 3)\r\n   * @param matrix matrix part (leading 3x3)\r\n   * @param x x part of multiplied point\r\n   * @param y y part of multiplied point\r\n   * @param z z part of multiplied point\r\n   * @param w w part of multiplied point\r\n   * @param result optional result.\r\n   */\r\n  public static xyzPlusMatrixTimesCoordinatesToFloat64Array(origin: XYZ, matrix: Matrix3d, x: number, y: number, z: number, result?: Float64Array): Float64Array {\r\n    if (!result)\r\n      result = new Float64Array(3);\r\n    result[0] = origin.x + matrix.coffs[0] * x + matrix.coffs[1] * y + matrix.coffs[2] * z;\r\n    result[1] = origin.y + matrix.coffs[3] * x + matrix.coffs[4] * y + matrix.coffs[5] * z;\r\n    result[2] = origin.z + matrix.coffs[6] * x + matrix.coffs[7] * y + matrix.coffs[8] * z;\r\n    return result;\r\n  }\r\n  /** Multiply transpose of this matrix times  avector. */\r\n  public multiplyTransposeVector(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    const x = vector.x;\r\n    const y = vector.y;\r\n    const z = vector.z;\r\n    result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);\r\n    result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);\r\n    result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the matrix * (x,y,z), i.e. the vector (x,y,z) is a column vector on the right.\r\n   * @return the vector result\r\n   */\r\n  public multiplyXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);\r\n    result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);\r\n    result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the matrix * xyz, place result in (required) return value.\r\n   *   @param xyz right side\r\n   *   @param result result.\r\n   */\r\n  public multiplyXYZtoXYZ(xyz: XYZ, result: XYZ) {\r\n    const x = xyz.x;\r\n    const y = xyz.y;\r\n    const z = xyz.z;\r\n    result.x = (this.coffs[0] * x + this.coffs[1] * y + this.coffs[2] * z);\r\n    result.y = (this.coffs[3] * x + this.coffs[4] * y + this.coffs[5] * z);\r\n    result.z = (this.coffs[6] * x + this.coffs[7] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the matrix * (x,y,0), i.e. the vector (x,y,z) is a column vector on the right.\r\n   *   @return the vector result\r\n   */\r\n  public multiplyXY(x: number, y: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = (this.coffs[0] * x + this.coffs[1] * y);\r\n    result.y = (this.coffs[3] * x + this.coffs[4] * y);\r\n    result.z = (this.coffs[6] * x + this.coffs[7] * y);\r\n    return result;\r\n  }\r\n\r\n  /** compute `origin + this*[x,y,0]`  */\r\n  public originPlusMatrixTimesXY(origin: XYZ, x: number, y: number, result?: Point3d): Point3d {\r\n    return Point3d.create(\r\n      origin.x + this.coffs[0] * x + this.coffs[1] * y,\r\n      origin.y + this.coffs[3] * x + this.coffs[4] * y,\r\n      origin.z + this.coffs[6] * x + this.coffs[7] * y,\r\n      result);\r\n  }\r\n\r\n  /** Multiply matrix * (x, y, z) using any 3d object given containing those members */\r\n  public multiplyVectorInPlace(xyzData: XYZ): void {\r\n    const x = xyzData.x;\r\n    const y = xyzData.y;\r\n    const z = xyzData.z;\r\n    const coffs = this.coffs;\r\n    xyzData.x = (coffs[0] * x + coffs[1] * y + coffs[2] * z);\r\n    xyzData.y = (coffs[3] * x + coffs[4] * y + coffs[5] * z);\r\n    xyzData.z = (coffs[6] * x + coffs[7] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** Multiply matrix * (x, y, z) using any 3d object given containing those members */\r\n  public multiplyTransposeVectorInPlace(xyzData: XYZ): void {\r\n    const x = xyzData.x;\r\n    const y = xyzData.y;\r\n    const z = xyzData.z;\r\n    const coffs = this.coffs;\r\n    xyzData.x = (coffs[0] * x + coffs[3] * y + coffs[6] * z);\r\n    xyzData.y = (coffs[1] * x + coffs[4] * y + coffs[7] * z);\r\n    xyzData.z = (coffs[2] * x + coffs[5] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** Multiply the (x,y,z) * matrix, i.e. the vector (x,y,z) is a row vector on the left.\r\n   *   @return the vector result\r\n   */\r\n  public multiplyTransposeXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = (this.coffs[0] * x + this.coffs[3] * y + this.coffs[6] * z);\r\n    result.y = (this.coffs[1] * x + this.coffs[4] * y + this.coffs[7] * z);\r\n    result.z = (this.coffs[2] * x + this.coffs[5] * y + this.coffs[8] * z);\r\n    return result;\r\n  }\r\n  /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */\r\n  public multiplyInverse(vector: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      const x = vector.x;\r\n      const y = vector.y;\r\n      const z = vector.z;\r\n      return Vector3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z),\r\n        (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z),\r\n        (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Solve matrix * result = vector, i.e. multiply result = matrixInverse * rightHandSide  */\r\n  public multiplyInverseTranspose(vector: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      const x = vector.x;\r\n      const y = vector.y;\r\n      const z = vector.z;\r\n      return Vector3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[3] * y + this.inverseCoffs[6] * z),\r\n        (this.inverseCoffs[1] * x + this.inverseCoffs[4] * y + this.inverseCoffs[7] * z),\r\n        (this.inverseCoffs[2] * x + this.inverseCoffs[5] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * *  multiply matrixInverse * [x,y,z]\r\n   * *  Equivalent to solving matrix * result = [x,y,z]\r\n   * *  return as a Vector3d.\r\n   */\r\n  public multiplyInverseXYZAsVector3d(x: number, y: number, z: number, result?: Vector3d): Vector3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      return Vector3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z),\r\n        (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z),\r\n        (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   *\r\n   * *  multiply matrixInverse * [x,y,z]\r\n   * *  Equivalent to solving matrix * result = [x,y,z]\r\n   * *  return as a Point3d.\r\n   */\r\n  public multiplyInverseXYZAsPoint3d(x: number, y: number, z: number, result?: Point3d): Point3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseCoffs) {\r\n      return Point3d.create(\r\n        (this.inverseCoffs[0] * x + this.inverseCoffs[1] * y + this.inverseCoffs[2] * z),\r\n        (this.inverseCoffs[3] * x + this.inverseCoffs[4] * y + this.inverseCoffs[5] * z),\r\n        (this.inverseCoffs[6] * x + this.inverseCoffs[7] * y + this.inverseCoffs[8] * z),\r\n        result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Multiply two matrices.\r\n   *   @return the matrix result\r\n   */\r\n  public multiplyMatrixMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.coffs, result.coffs);\r\n    return result;\r\n  }\r\n\r\n  /** Multiply this matrix times inverse of other\r\n   *   @return the matrix result\r\n   */\r\n  public multiplyMatrixMatrixInverse(other: Matrix3d, result?: Matrix3d): Matrix3d | undefined {\r\n    if (!other.computeCachedInverse(true))\r\n      return undefined;\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixMatrix(this.coffs, other.inverseCoffs!, result.coffs);\r\n    return result;\r\n  }\r\n  /** Matrix multiplication `this * otherTranspose`\r\n   * @return the matrix result\r\n   */\r\n  public multiplyMatrixMatrixTranspose(other: Matrix3d, result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixMatrixTranspose(this.coffs, other.coffs, result.coffs);\r\n    return result;\r\n  }\r\n\r\n  /** Matrix multiplication `thisTranspose * other`\r\n   *   @return the matrix result\r\n   */\r\n  public multiplyMatrixTransposeMatrix(other: Matrix3d, result?: Matrix3d): Matrix3d {\r\n    result = result ? result : new Matrix3d();\r\n    PackedMatrix3dOps.multiplyMatrixTransposeMatrix(this.coffs, other.coffs, result.coffs);\r\n    return result;\r\n  }\r\n  //   [Q 0][R A] = [QR QA]\r\n  //   [0 1][0 1]   [0  1]\r\n  /** multiply this Matrix3d (considered as a transform with 0 translation) times other Transform.\r\n   * @param other right hand Matrix3d for multiplication.\r\n   * @param result optional preallocated result to reuse.\r\n   */\r\n  public multiplyMatrixTransform(other: Transform, result?: Transform): Transform {\r\n    if (!result)\r\n      return Transform.createRefs(\r\n        this.multiplyXYZ(other.origin.x, other.origin.y, other.origin.z),\r\n        this.multiplyMatrixMatrix(other.matrix));\r\n    // be sure to do the point mulitplication first before aliasing changes the matrix ..\r\n    this.multiplyXYZtoXYZ(other.origin, result.origin);\r\n    this.multiplyMatrixMatrix(other.matrix, result.matrix);\r\n    return result;\r\n  }\r\n\r\n  /** return the transposed matrix */\r\n  public transpose(result?: Matrix3d): Matrix3d {\r\n    if (!result) result = new Matrix3d();\r\n    PackedMatrix3dOps.copyTransposed(this.coffs, result.coffs);\r\n    if (this.inverseCoffs !== undefined) {\r\n      result.inverseState = InverseMatrixState.inverseStored;\r\n      result.inverseCoffs = PackedMatrix3dOps.copyTransposed(this.inverseCoffs, result.inverseCoffs);\r\n    } else {\r\n      result.inverseState = this.inverseState;  // singular or unknown.\r\n      result.inverseCoffs = undefined;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** return the transposed matrix */\r\n  public transposeInPlace() {\r\n    PackedMatrix3dOps.transposeInPlace(this.coffs);\r\n    if (this.inverseCoffs)\r\n      PackedMatrix3dOps.transposeInPlace(this.inverseCoffs);\r\n  }\r\n\r\n  /** return the inverse matrix.  The return is  null if the matrix is singular (has columns that are coplanar or colinear) */\r\n  public inverse(result?: Matrix3d): Matrix3d | undefined {\r\n    this.computeCachedInverse(true);\r\n    if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs)\r\n      return Matrix3d.createRowValues(this.inverseCoffs[0], this.inverseCoffs[1], this.inverseCoffs[2],\r\n        this.inverseCoffs[3], this.inverseCoffs[4], this.inverseCoffs[5],\r\n        this.inverseCoffs[6], this.inverseCoffs[7], this.inverseCoffs[8], result);\r\n    return undefined;\r\n  }\r\n\r\n  /** copy the transpose of the coffs to the inverseCoffs.\r\n   * * mark the matrix as inverseStored.\r\n   */\r\n  private setupInverseTranspose() {\r\n    const coffs = this.coffs;\r\n    this.inverseState = InverseMatrixState.inverseStored;\r\n    this.inverseCoffs = Float64Array.from([coffs[0], coffs[3], coffs[6],\r\n    coffs[1], coffs[4], coffs[7],\r\n    coffs[2], coffs[5], coffs[8]]);\r\n  }\r\n\r\n  /* Alternate implementation of computedCachedInverse - more direct addressing of arrays.\r\n     This is indeed 10% faster than using static work areas. */\r\n\r\n  // take the cross product of two rows of source.\r\n  // store as a column of dest.\r\n  private static indexedRowCrossProduct(source: Float64Array, rowStart0: number, rowStart1: number, dest: Float64Array, columnStart: number) {\r\n    dest[columnStart] = source[rowStart0 + 1] * source[rowStart1 + 2] - source[rowStart0 + 2] * source[rowStart1 + 1];\r\n    dest[columnStart + 3] = source[rowStart0 + 2] * source[rowStart1] - source[rowStart0] * source[rowStart1 + 2];\r\n    dest[columnStart + 6] = source[rowStart0] * source[rowStart1 + 1] - source[rowStart0 + 1] * source[rowStart1];\r\n  }\r\n\r\n  // take the cross product of two columns of source.\r\n  // store as third column in same Matrix3d.\r\n  // This is private because the columnStart values are unchecked raw indices into the coffs\r\n  private indexedColumnCrossProductInPlace(colStart0: number, colStart1: number, colStart2: number) {\r\n    const coffs = this.coffs;\r\n    coffs[colStart2] = coffs[colStart0 + 3] * coffs[colStart1 + 6] - coffs[colStart0 + 6] * coffs[colStart1 + 3];\r\n    coffs[colStart2 + 3] = coffs[colStart0 + 6] * coffs[colStart1] - coffs[colStart0] * coffs[colStart1 + 6];\r\n    coffs[colStart2 + 6] = coffs[colStart0] * coffs[colStart1 + 3] - coffs[colStart0 + 3] * coffs[colStart1];\r\n  }\r\n  /** Form cross products among axes in axisOrder.\r\n   * For axis order ABC,\r\n   * * form cross product of column A and B, store in C\r\n   * * form cross product of column C and A, store in B.\r\n   * This means that in the final matrix:\r\n   * * column A is strictly parallel to original column A\r\n   * * column B is linear combination of only original A and B\r\n   * * column C is perpendicular to A and B of both the original and final.\r\n   * * original column C does not participate in the result.\r\n   */\r\n  public axisOrderCrossProductsInPlace(axisOrder: AxisOrder) {\r\n    switch (axisOrder) {\r\n      case AxisOrder.XYZ: {\r\n        this.indexedColumnCrossProductInPlace(0, 1, 2);\r\n        this.indexedColumnCrossProductInPlace(2, 0, 1);\r\n        break;\r\n      }\r\n      case AxisOrder.YZX: {\r\n        this.indexedColumnCrossProductInPlace(1, 2, 0);\r\n        this.indexedColumnCrossProductInPlace(0, 1, 2);\r\n        break;\r\n      }\r\n      case AxisOrder.ZXY: {\r\n        this.indexedColumnCrossProductInPlace(2, 0, 1);\r\n        this.indexedColumnCrossProductInPlace(1, 2, 0);\r\n        break;\r\n      }\r\n      case AxisOrder.XZY: {\r\n        this.indexedColumnCrossProductInPlace(0, 2, 1);\r\n        this.indexedColumnCrossProductInPlace(1, 0, 2);\r\n        break;\r\n      }\r\n      case AxisOrder.YXZ: {\r\n        this.indexedColumnCrossProductInPlace(1, 0, 2);\r\n        this.indexedColumnCrossProductInPlace(2, 1, 0);\r\n        break;\r\n      }\r\n      case AxisOrder.ZYX: {\r\n        this.indexedColumnCrossProductInPlace(2, 1, 0);\r\n        this.indexedColumnCrossProductInPlace(0, 2, 1);\r\n        break;\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Normalize each column in place.\r\n   * * For false return the magnitudes are stored in the originalMagnitudes vector but no columns are altered.\r\n   * @returns Return true if all columns had nonzero lengths.\r\n   * @param originalMagnitudes optional vector to receive original column magnitudes.\r\n   */\r\n  public normalizeColumnsInPlace(originalMagnitudes?: Vector3d): boolean {\r\n    const ax = this.columnXMagnitude();\r\n    const ay = this.columnYMagnitude();\r\n    const az = this.columnZMagnitude();\r\n    if (originalMagnitudes)\r\n      originalMagnitudes.set(ax, ay, az);\r\n    if (Geometry.isSmallMetricDistance(ax) || Geometry.isSmallMetricDistance(ay) || Geometry.isSmallMetricDistance(az))\r\n      return false;\r\n    this.scaleColumns(1.0 / ax, 1.0 / ay, 1.0 / az, this);\r\n    return true;\r\n  }\r\n  /** Normalize each row in place */\r\n  public normalizeRowsInPlace(originalMagnitudes?: Vector3d): boolean {\r\n    const ax = this.rowXMagnitude();\r\n    const ay = this.rowYMagnitude();\r\n    const az = this.rowZMagnitude();\r\n    if (originalMagnitudes)\r\n      originalMagnitudes.set(ax, ay, az);\r\n    if (Geometry.isSmallMetricDistance(ax) || Geometry.isSmallMetricDistance(ay) || Geometry.isSmallMetricDistance(az))\r\n      return false;\r\n    this.scaleRows(1.0 / ax, 1.0 / ay, 1.0 / az, this);\r\n    return true;\r\n  }\r\n  // take the cross product of two rows of source.\r\n  // store as a column of dest.\r\n  private static rowColumnDot(coffA: Float64Array, rowStartA: number, coffB: Float64Array, columnStartB: number): number {\r\n    return coffA[rowStartA] * coffB[columnStartB] + coffA[rowStartA + 1] * coffB[columnStartB + 3] + coffA[rowStartA + 2] * coffB[columnStartB + 6];\r\n  }\r\n  /**\r\n   * Returns true if the matrix is singular (i.e. collapses data to a plane, line, or point)\r\n   */\r\n  public isSingular(): boolean {\r\n    return !this.computeCachedInverse(true);\r\n  }\r\n  /** compute the inverse of this Matrix3d. The inverse is stored for later use.\r\n   * @returns Return true if the inverse computed.  (False if the columns collapse to a point, line or plane.)\r\n   */\r\n  public computeCachedInverse(useCacheIfAvailable: boolean): boolean {\r\n    if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {\r\n      Matrix3d.numUseCache++;\r\n      return this.inverseState === InverseMatrixState.inverseStored;\r\n    }\r\n    this.inverseState = InverseMatrixState.unknown;\r\n    if (this.inverseCoffs === undefined)\r\n      this.inverseCoffs = new Float64Array(9);\r\n    const coffs = this.coffs;\r\n    const inverseCoffs = this.inverseCoffs;\r\n    Matrix3d.indexedRowCrossProduct(coffs, 3, 6, inverseCoffs, 0);\r\n    Matrix3d.indexedRowCrossProduct(coffs, 6, 0, inverseCoffs, 1);\r\n    Matrix3d.indexedRowCrossProduct(coffs, 0, 3, inverseCoffs, 2);\r\n    Matrix3d.numComputeCache++;\r\n    const d = Matrix3d.rowColumnDot(coffs, 0, inverseCoffs, 0);\r\n    if (d === 0.0) {     // better test?\r\n      this.inverseState = InverseMatrixState.singular;\r\n      this.inverseCoffs = undefined;\r\n      return false;\r\n    }\r\n    const f = 1.0 / d;\r\n    for (let i = 0; i < 9; i++)inverseCoffs[i] *= f;\r\n    this.inverseState = InverseMatrixState.inverseStored;\r\n    // verify inverse\r\n    // const p = new Float64Array(9);\r\n    // for (let i = 0; i < 9; i += 3)\r\n    //   for (let j = 0; j < 3; j++)\r\n    //    p[i + j] = Matrix3d.rowColumnDot (coffs, i, inverseCoffs, j);\r\n    return true;\r\n  }\r\n\r\n  /* \"Classic\" inverse implementation with temporary vectors.\r\n    private static rowX: Vector3d = Vector3d.create();\r\n    private static rowY: Vector3d = Vector3d.create();\r\n    private static rowZ: Vector3d = Vector3d.create();\r\n    private static crossXY: Vector3d = Vector3d.create();\r\n    private static crossZX: Vector3d = Vector3d.create();\r\n    private static crossYZ: Vector3d = Vector3d.create();\r\n  private computeCachedInverse(useCacheIfAvailable: boolean) {\r\n      if (useCacheIfAvailable && Matrix3d.useCachedInverse && this.inverseState !== InverseMatrixState.unknown) {\r\n        Matrix3d.numUseCache++;\r\n        return this.inverseState === InverseMatrixState.inverseStored;\r\n      }\r\n      this.inverseState = InverseMatrixState.unknown;\r\n      Matrix3d.numComputeCache++;\r\n      const rowX = this.rowX(Matrix3d.rowX);\r\n      const rowY = this.rowY(Matrix3d.rowY);\r\n      const rowZ = this.rowZ(Matrix3d.rowZ);\r\n      const crossXY = rowX.crossProduct(rowY, Matrix3d.crossXY);\r\n      const crossYZ = rowY.crossProduct(rowZ, Matrix3d.crossYZ);\r\n      const crossZX = rowZ.crossProduct(rowX, Matrix3d.crossZX);\r\n      const d = rowX.dotProduct(crossYZ);  // that's the determinant\r\n      if (d === 0.0) {     // better test?\r\n        this.inverseState = InverseMatrixState.singular;\r\n        this.inverseCoffs = undefined;\r\n        return false;\r\n      }\r\n      const f = 1.0 / d;\r\n      this.inverseState = InverseMatrixState.inverseStored;   // Currently just lists that the inverse has been stored... singular case not handled\r\n      this.inverseCoffs = Float64Array.from([crossYZ.x * f, crossZX.x * f, crossXY.x * f,\r\n      crossYZ.y * f, crossZX.y * f, crossXY.y * f,\r\n      crossYZ.z * f, crossZX.z * f, crossXY.z * f]);\r\n      return true;\r\n    }\r\n  */\r\n  /** convert a (row,column) index pair to the single index within flattened array of 9 numbers in row-major-order  */\r\n  public static flatIndexOf(row: number, column: number): number {\r\n    return 3 * Geometry.cyclic3dAxis(row) + Geometry.cyclic3dAxis(column);\r\n  }\r\n\r\n  /** Get a column by index (0,1,2), packaged as a Point4d with given weight.   Out of range index is interpreted cyclically.  */\r\n  public indexedColumnWithWeight(index: number, weight: number, result?: Point4d): Point4d {\r\n    index = Geometry.cyclic3dAxis(index);\r\n    return Point4d.create(this.coffs[index], this.coffs[index + 3], this.coffs[index + 6], weight, result);\r\n  }\r\n\r\n  /** return the entry at specific row and column */\r\n  public at(row: number, column: number): number {\r\n    return this.coffs[Matrix3d.flatIndexOf(row, column)];\r\n  }\r\n\r\n  /** Set the entry at specific row and column */\r\n  public setAt(row: number, column: number, value: number): void {\r\n    this.coffs[Matrix3d.flatIndexOf(row, column)] = value;\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n\r\n  /** create a Matrix3d whose columns are scaled copies of this Matrix3d.\r\n   * @param scaleX scale factor for columns x\r\n   * @param scaleY scale factor for column y\r\n   * @param scaleZ scale factor for column z\r\n   * @param result optional result.\r\n   */\r\n  public scaleColumns(scaleX: number, scaleY: number, scaleZ: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        this.coffs[0] * scaleX, this.coffs[1] * scaleY, this.coffs[2] * scaleZ,\r\n        this.coffs[3] * scaleX, this.coffs[4] * scaleY, this.coffs[5] * scaleZ,\r\n        this.coffs[6] * scaleX, this.coffs[7] * scaleY, this.coffs[8] * scaleZ,\r\n        result);\r\n  }\r\n\r\n  /** create a Matrix3d whose columns are scaled copies of this Matrix3d.\r\n   * @param scaleX scale factor for columns x\r\n   * @param scaleY scale factor for column y\r\n   * @param scaleZ scale factor for column z\r\n   * @param result optional result.\r\n   */\r\n  public scaleColumnsInPlace(scaleX: number, scaleY: number, scaleZ: number) {\r\n\r\n    this.coffs[0] *= scaleX; this.coffs[1] *= scaleY; this.coffs[2] *= scaleZ;\r\n    this.coffs[3] *= scaleX; this.coffs[4] *= scaleY; this.coffs[5] *= scaleZ;\r\n    this.coffs[6] *= scaleX; this.coffs[7] *= scaleY; this.coffs[8] *= scaleZ;\r\n    if (this.inverseState === InverseMatrixState.inverseStored && this.inverseCoffs !== undefined) {\r\n      // apply reciprocal scales to the ROWS of the inverse .  . .\r\n      const divX = Geometry.conditionalDivideFraction(1.0, scaleX);\r\n      const divY = Geometry.conditionalDivideFraction(1.0, scaleY);\r\n      const divZ = Geometry.conditionalDivideFraction(1.0, scaleZ);\r\n      if (divX !== undefined && divY !== undefined && divZ !== undefined) {\r\n        this.inverseCoffs[0] *= divX; this.inverseCoffs[1] *= divX; this.inverseCoffs[2] *= divX;\r\n        this.inverseCoffs[3] *= divY; this.inverseCoffs[4] *= divY; this.inverseCoffs[5] *= divY;\r\n        this.inverseCoffs[6] *= divZ; this.inverseCoffs[7] *= divZ; this.inverseCoffs[8] *= divZ;\r\n      } else\r\n        this.inverseState = InverseMatrixState.singular;\r\n    }\r\n  }\r\n\r\n  /** create a Matrix3d whose rows are scaled copies of this Matrix3d.\r\n   * @param scaleX scale factor for row x\r\n   * @param scaleY scale factor for row y\r\n   * @param scaleZ scale factor for row z\r\n   * @param result optional result.\r\n   */\r\n  public scaleRows(scaleX: number, scaleY: number, scaleZ: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        this.coffs[0] * scaleX, this.coffs[1] * scaleX, this.coffs[2] * scaleX,\r\n        this.coffs[3] * scaleY, this.coffs[4] * scaleY, this.coffs[5] * scaleY,\r\n        this.coffs[6] * scaleZ, this.coffs[7] * scaleZ, this.coffs[8] * scaleZ,\r\n        result);\r\n  }\r\n  /**\r\n   * add scaled values from other Matrix3d to this Matrix3d\r\n   * @param other Matrix3d with values to be added\r\n   * @param scale scale factor to apply to th eadded values.\r\n   */\r\n  public addScaledInPlace(other: Matrix3d, scale: number): void {\r\n    for (let i = 0; i < 9; i++)\r\n      this.coffs[i] += scale * other.coffs[i];\r\n    this.inverseState = InverseMatrixState.unknown;\r\n  }\r\n  /** create a Matrix3d whose values are uniformly scaled from this.\r\n   * @param scale scale factor to apply.\r\n   * @param result optional result.\r\n   * @returns Return the new or repopulated matrix\r\n   */\r\n  public scale(scale: number, result?: Matrix3d): Matrix3d {\r\n    return Matrix3d.createRowValues\r\n      (\r\n        this.coffs[0] * scale, this.coffs[1] * scale, this.coffs[2] * scale,\r\n        this.coffs[3] * scale, this.coffs[4] * scale, this.coffs[5] * scale,\r\n        this.coffs[6] * scale, this.coffs[7] * scale, this.coffs[8] * scale,\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the determinant of this matrix. */\r\n  public determinant(): number {\r\n    return this.coffs[0] * this.coffs[4] * this.coffs[8]\r\n      - this.coffs[0] * this.coffs[7] * this.coffs[5]\r\n      + this.coffs[3] * this.coffs[7] * this.coffs[2]\r\n      - this.coffs[3] * this.coffs[1] * this.coffs[8]\r\n      + this.coffs[6] * this.coffs[1] * this.coffs[5]\r\n      - this.coffs[6] * this.coffs[4] * this.coffs[2];\r\n  }\r\n\r\n  /** Return an estimate of how independent the columns are.  Near zero is bad. Near 1 is good\r\n   */\r\n  public conditionNumber(): number {\r\n    const determinant = this.determinant();\r\n    const columnMagnitudeProduct =\r\n      Geometry.hypotenuseXYZ(this.coffs[0], this.coffs[3], this.coffs[6])\r\n      + Geometry.hypotenuseXYZ(this.coffs[1], this.coffs[4], this.coffs[7])\r\n      + Geometry.hypotenuseXYZ(this.coffs[2], this.coffs[5], this.coffs[8]);\r\n    return Geometry.safeDivideFraction(determinant, columnMagnitudeProduct, 0.0);\r\n  }\r\n  /** Return the sum of squares of all entries */\r\n  public sumSquares(): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i++)\r\n      a += this.coffs[i] * this.coffs[i];\r\n    return a;\r\n  }\r\n\r\n  /** Return the sum of squares of diagonal entries */\r\n  public sumDiagonalSquares(): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i += 4)\r\n      a += this.coffs[i] * this.coffs[i];\r\n    return a;\r\n  }\r\n\r\n  /** Return the sum of diagonal entries (also known as the trace) */\r\n  public sumDiagonal(): number {\r\n    return this.coffs[0] + this.coffs[4] + this.coffs[8];\r\n  }\r\n\r\n  /** Return the Maximum absolute value of any single entry */\r\n  public maxAbs(): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i++)\r\n      a = Math.max(a, Math.abs(this.coffs[i]));\r\n    return a;\r\n  }\r\n\r\n  /** Return the maximum absolute difference between corresponding entries */\r\n  public maxDiff(other: Matrix3d): number {\r\n    let i = 0;\r\n    let a = 0;\r\n    for (i = 0; i < 9; i++)\r\n      a = Math.max(a, Math.abs(this.coffs[i] - other.coffs[i]));\r\n    return a;\r\n  }\r\n\r\n  /** Test if the matrix is (very near to) an identity */\r\n  public get isIdentity(): boolean {\r\n    return this.maxDiff(Matrix3d.identity) < Geometry.smallAngleRadians;\r\n\r\n  }\r\n\r\n  /** Test if the off diagonal entries are all nearly zero */\r\n  public get isDiagonal(): boolean {\r\n    const sumAll = this.sumSquares();\r\n    const sumDiagonal = this.sumDiagonalSquares();\r\n    const sumOff = Math.abs(sumAll - sumDiagonal);\r\n    return Math.sqrt(sumOff) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\r\n  }\r\n\r\n  /** Test if the below diagonal entries are all nearly zero */\r\n  public get isUpperTriangular(): boolean {\r\n    const sumAll = this.sumSquares();\r\n    const sumLow = Geometry.hypotenuseSquaredXYZ(this.coffs[3], this.coffs[6], this.coffs[7]);\r\n    return Math.sqrt(sumLow) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll));\r\n  }\r\n\r\n  /** If the matrix is diagonal and all diagonals are within tolerance, return the first diagonal.  Otherwise return undefined.\r\n   */\r\n  public sameDiagonalScale(): number | undefined {\r\n    const sumAll = this.sumSquares();\r\n    const sumDiagonal = this.sumDiagonalSquares();\r\n    const sumOff = Math.abs(sumAll - sumDiagonal);\r\n    if (Math.sqrt(sumOff) <= Geometry.smallAngleRadians * (1.0 + Math.sqrt(sumAll))\r\n      && Geometry.isSameCoordinate(this.coffs[0], this.coffs[4]) && Geometry.isSameCoordinate(this.coffs[0], this.coffs[8]))\r\n      return this.coffs[0];\r\n    return undefined;\r\n  }\r\n\r\n  /** Sum of squared differences between symmetric pairs */\r\n  public sumSkewSquares(): number {\r\n    return Geometry.hypotenuseSquaredXYZ(\r\n      this.coffs[1] - this.coffs[3],\r\n      this.coffs[2] - this.coffs[6],\r\n      this.coffs[5] - this.coffs[7]);\r\n  }\r\n\r\n  /** Test if the matrix is a pure rotation. */\r\n  public isRigid(allowMirror: boolean = false): boolean {\r\n    return this.testPerpendicularUnitRowsAndColumns() && (allowMirror || this.determinant() > 0);\r\n  }\r\n  /** Test if all rows and columns are perpendicular to each other and have equal length.\r\n   * If so, the length (or its negative) is the scale factor from a set of rigid axes to these axes.\r\n   * * result.rigidAxes is the rigid axes (with the scale factor removed)\r\n   * * result.scale is the scale factor\r\n   */\r\n  public factorRigidWithSignedScale(): { rigidAxes: Matrix3d, scale: number } | undefined {\r\n    const product = this.multiplyMatrixMatrixTranspose(this);\r\n    const ss = product.sameDiagonalScale();\r\n    if (ss === undefined || ss <= 0.0) return undefined;\r\n    const s = this.determinant() > 0 ? Math.sqrt(ss) : -Math.sqrt(ss);\r\n    const divS = 1.0 / s;\r\n    const result = { rigidAxes: this.scaleColumns(divS, divS, divS), scale: s };\r\n    return result;\r\n  }\r\n\r\n  /** Test if the matrix is shuffles and negates columns. */\r\n  public get isSignedPermutation(): boolean {\r\n    let count = 0;\r\n    for (let row = 0; row < 3; row++)\r\n      for (let col = 0; col < 3; col++) {\r\n        const q = this.at(row, col);\r\n        if (q === 0) {// This comment makes the block non-empty\r\n        } else if (q === 1 || q === -1) {\r\n          // the rest of this row and column should be 0.\r\n          // \"at\" will apply cyclic indexing.\r\n          count++;\r\n          if (this.at(row + 1, col) !== 0)\r\n            return false;\r\n          if (this.at(row + 2, col) !== 0)\r\n            return false;\r\n          if (this.at(row, col + 1) !== 0)\r\n            return false;\r\n          if (this.at(row, col + 2) !== 0)\r\n            return false;\r\n        } else {// entry is not from 0,1,-1 . . .\r\n          return false;\r\n        }\r\n      }\r\n    return count === 3;\r\n  }\r\n\r\n  /** Test if all rows and columns are length 1 and are perpendicular to each other.  (I.e. the matrix is either a pure rotation with uniform scale factor of 1 or -1) */\r\n  public testPerpendicularUnitRowsAndColumns(): boolean {\r\n    const product = this.multiplyMatrixMatrixTranspose(this);\r\n    return product.isIdentity;\r\n  }\r\n  /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)\r\n   * vectorA is placed in the first column of the axis order.\r\n   * vectorB is projected perpendicular to vectorA within their plane and placed in the second column.\r\n   */\r\n  public static createRigidFromColumns(\r\n    vectorA: Vector3d,\r\n    vectorB: Vector3d,\r\n    axisOrder: AxisOrder,\r\n    result?: Matrix3d): Matrix3d | undefined {\r\n    const vectorA1 = vectorA.normalize();\r\n    if (vectorA1) {\r\n      const vectorC1 = vectorA1.unitCrossProduct(vectorB);\r\n      if (vectorC1) {\r\n        const vectorB1 = vectorC1.unitCrossProduct(vectorA);\r\n        if (vectorB1) {\r\n          const retVal = Matrix3d.createShuffledColumns(vectorA1, vectorB1, vectorC1, axisOrder, result);\r\n          retVal.setupInverseTranspose();\r\n          return retVal;\r\n        }\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** create a new orthogonal matrix (perpendicular columns, unit length, transpose is inverse)\r\n   * columns are taken from the source Matrix3d in order indicated by the axis order.\r\n   */\r\n  public static createRigidFromMatrix3d(\r\n    source: Matrix3d,\r\n    axisOrder: AxisOrder = AxisOrder.XYZ,\r\n    result?: Matrix3d): Matrix3d | undefined {\r\n    result = source.clone(result);\r\n    result.axisOrderCrossProductsInPlace(axisOrder);\r\n    if (result.normalizeColumnsInPlace())\r\n      return result;\r\n    return undefined;\r\n  }\r\n  private static computeQuatTerm(numerator: number, denomCoff: number, reciprocal: number, diagSum: number): number {\r\n    let coff: number;\r\n    const diagTol = 0.500;\r\n    if (diagSum > diagTol) {\r\n      coff = Math.sqrt(diagSum) * 0.5;\r\n      if (denomCoff * numerator < 0.0)\r\n        coff = - coff;\r\n    } else {\r\n      coff = numerator * reciprocal;\r\n    }\r\n    return coff;\r\n  }\r\n\r\n  /** create a matrix from a quaternion.\r\n   * WARNING: There is frequent confusion over whether a \"from quaternion\" matrix is organized by rows and columns.\r\n   * WARNING: If you find that the matrix seems to rotate by the opposite angle expect it, transpose it.\r\n   */\r\n  public static createFromQuaternion(quat: Point4d): Matrix3d {\r\n\r\n    const qqx = quat.x * quat.x;\r\n    const qqy = quat.y * quat.y;\r\n    const qqz = quat.z * quat.z;\r\n    const qqw = quat.w * quat.w;\r\n\r\n    const mag2 = qqx + qqy + qqz + qqw;\r\n\r\n    if (mag2 === 0.0) {\r\n      return Matrix3d.createIdentity();\r\n    } else {\r\n      const a = 1.0 / mag2;\r\n\r\n      const matrix = Matrix3d.createRowValues(\r\n        a * (qqw + qqx - qqy - qqz), 2.0 * a * (quat.w * quat.z + quat.x * quat.y), 2.0 * a * (quat.x * quat.z - quat.w * quat.y),\r\n        2.0 * a * (quat.x * quat.y - quat.w * quat.z), a * (qqw - qqx + qqy - qqz), 2.0 * a * (quat.w * quat.x + quat.y * quat.z),\r\n        2.0 * a * (quat.x * quat.z + quat.w * quat.y), 2.0 * a * (quat.y * quat.z - quat.w * quat.x), a * (qqw - qqx - qqy + qqz));\r\n      return matrix;\r\n    }\r\n  }\r\n  /** convert the matrix to a quaternion.\r\n   * WARNING: There is frequent confusion over whether a \"from quaternion\" matrix is organized by rows and columns.\r\n   * WARNING: If you find that the matrix seems to rotate by the opposite angle expect it, transpose it.\r\n   */\r\n  public toQuaternion(): Point4d {\r\n    const result = Point4d.createZero();\r\n    const props = [[this.coffs[0], this.coffs[3], this.coffs[6]],\r\n    [this.coffs[1], this.coffs[4], this.coffs[7]],\r\n    [this.coffs[2], this.coffs[5], this.coffs[8]]];\r\n\r\n    const xx = props[0][0];\r\n    const yy = props[1][1];\r\n    const zz = props[2][2];\r\n    const dSum: number[] = [];\r\n    let denom: number, maxIndex: number, i: number;\r\n\r\n    dSum[0] = 1.0 + xx - yy - zz;\r\n    dSum[1] = 1.0 - xx + yy - zz;\r\n    dSum[2] = 1.0 - xx - yy + zz;\r\n    dSum[3] = 1.0 + xx + yy + zz;\r\n\r\n    maxIndex = 0;\r\n    for (i = 1; i < 4; i++) {\r\n      if (dSum[i] > dSum[maxIndex])\r\n        maxIndex = i;\r\n    }\r\n\r\n    if (maxIndex === 0) {\r\n      result.x = 0.5 * Math.sqrt(dSum[0]);\r\n      denom = 1.0 / (4.0 * result.x);\r\n      result.y = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.x, denom, dSum[1]);\r\n      result.z = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.x, denom, dSum[2]);\r\n      result.w = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.x, denom, dSum[3]);\r\n    } else if (maxIndex === 1) {\r\n      result.y = 0.5 * Math.sqrt(dSum[1]);\r\n      denom = 1.0 / (4.0 * result.y);\r\n      result.x = Matrix3d.computeQuatTerm(props[0][1] + props[1][0], result.y, denom, dSum[0]);\r\n      result.z = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.y, denom, dSum[2]);\r\n      result.w = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.y, denom, dSum[3]);\r\n\r\n    } else if (maxIndex === 2) {\r\n      result.z = 0.5 * Math.sqrt(dSum[2]);\r\n      denom = 1.0 / (4.0 * result.z);\r\n      result.x = Matrix3d.computeQuatTerm(props[0][2] + props[2][0], result.z, denom, dSum[0]);\r\n      result.y = Matrix3d.computeQuatTerm(props[1][2] + props[2][1], result.z, denom, dSum[1]);\r\n      result.w = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.z, denom, dSum[3]);\r\n\r\n    } else {\r\n      result.w = 0.5 * Math.sqrt(dSum[3]);\r\n      denom = 1.0 / (4.0 * result.w);\r\n      result.x = Matrix3d.computeQuatTerm(props[2][1] - props[1][2], result.w, denom, dSum[0]);\r\n      result.y = Matrix3d.computeQuatTerm(props[0][2] - props[2][0], result.w, denom, dSum[1]);\r\n      result.z = Matrix3d.computeQuatTerm(props[1][0] - props[0][1], result.w, denom, dSum[2]);\r\n    }\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { AxisOrder } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\n\r\n/**\r\n * * OrderedRotationAngles represents a non-trivial rotation using three simple axis rotation angles, and an order in which to apply them.\r\n * * This class accommodates application-specific interpretation of \"Multiplying 3 rotation matrices\" with regard to\r\n *   * Whether a \"vector\" is a \"row\" or a \"column\"\r\n *   * The order in which the X,Y, Z rotations are applied.\r\n * * Within the imodel geometry library, the preferred rotation order is encapsulated in `YawPitchRollAngles`.\r\n * @alpha\r\n */\r\nexport class OrderedRotationAngles {\r\n  private _x: Angle;\r\n  private _y: Angle;\r\n  private _z: Angle;\r\n  private _order: AxisOrder;\r\n  private static _sTreatVectorsAsColumns: boolean = false;\r\n\r\n  private constructor(x: Angle, y: Angle, z: Angle, axisOrder: AxisOrder) {\r\n    this._x = x;\r\n    this._y = y;\r\n    this._z = z;\r\n    this._order = axisOrder;\r\n  }\r\n\r\n  /** (Property accessor) Return the `AxisOrder` controlling matrix multiplication order. */\r\n  public get order(): AxisOrder { return this._order; }\r\n  /** (Property accessor) Return the strongly typed angle of rotation around x. */\r\n  public get xAngle(): Angle { return this._x.clone(); }\r\n  /** (Property accessor) Return the strongly typed angle of rotation around y. */\r\n  public get yAngle(): Angle { return this._y.clone(); }\r\n  /** (Property accessor) Return the strongly typed angle of rotation around z. */\r\n  public get zAngle(): Angle { return this._z.clone(); }\r\n  /** (Property accessor) Return the angle of rotation around x, in degrees */\r\n  public get xDegrees(): number { return this._x.degrees; }\r\n  /** (Property accessor) Return the angle of rotation around y, in degrees */\r\n  public get xRadians(): number { return this._x.radians; }\r\n  /** (Property accessor) Return the angle of rotation around z, in degrees */\r\n  public get yDegrees(): number { return this._y.degrees; }\r\n  /** (Property accessor) Return the angle of rotation around x, in radians */\r\n  public get yRadians(): number { return this._y.radians; }\r\n  /** (Property accessor) Return the angle of rotation around y, in radians */\r\n  public get zDegrees(): number { return this._z.degrees; }\r\n  /** (Property accessor) Return the angle of rotation around z, in radians */\r\n  public get zRadians(): number { return this._z.radians; }\r\n  /** (Property accessor) flag controlling whether vectors are treated as rows or as columns */\r\n  public static get treatVectorsAsColumns(): boolean { return OrderedRotationAngles._sTreatVectorsAsColumns; }\r\n  /** (Property set) flag controlling whether vectors are treated as rows or as columns */\r\n  public static set treatVectorsAsColumns(value: boolean) { OrderedRotationAngles._sTreatVectorsAsColumns = value; }\r\n\r\n  /** Create an OrderedRotationAngles from three angles and an ordering in which to apply them when rotating.\r\n   * @param xRotation rotation around x\r\n   * @param yRotation rotation around y\r\n   * @param zRotation rotation around z\r\n   * @param axisOrder right to left order of axis names identifies the order that rotations are applied to xyz data.\r\n   */\r\n  public static createAngles(xRotation: Angle, yRotation: Angle, zRotation: Angle, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n    if (result) {\r\n      result._x.setFrom(xRotation);\r\n      result._y.setFrom(yRotation);\r\n      result._z.setFrom(zRotation);\r\n      result._order = order;\r\n      return result;\r\n    }\r\n    return new OrderedRotationAngles(xRotation.clone(), yRotation.clone(), zRotation.clone(), order);\r\n  }\r\n\r\n  /** Create an OrderedRotationAngles from three angles (in radians) and an ordering in which to apply them when rotating. */\r\n  public static createRadians(xRadians: number, yRadians: number, zRadians: number, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n    if (result) {\r\n      result._x.setRadians(xRadians);\r\n      result._y.setRadians(yRadians);\r\n      result._z.setRadians(zRadians);\r\n      result._order = order;\r\n      return result;\r\n    }\r\n    return new OrderedRotationAngles(Angle.createRadians(xRadians), Angle.createRadians(yRadians), Angle.createRadians(zRadians), order);\r\n  }\r\n\r\n  /** Create an OrderedRotationAngles from three angles (in degrees) and an ordering in which to apply them when rotating. */\r\n  public static createDegrees(xDegrees: number, yDegrees: number, zDegrees: number, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n    if (result) {\r\n      result._x.setDegrees(xDegrees);\r\n      result._y.setDegrees(yDegrees);\r\n      result._z.setDegrees(zDegrees);\r\n      result._order = order;\r\n      return result;\r\n    }\r\n    return new OrderedRotationAngles(Angle.createDegrees(xDegrees), Angle.createDegrees(yDegrees), Angle.createDegrees(zDegrees), order);\r\n  }\r\n\r\n  /** Create an OrderedRotationAngles from a 3x3 rotational matrix, given the ordering of axis rotations that the matrix derives from. */\r\n  public static createFromMatrix3d(matrix: Matrix3d, order: AxisOrder, result?: OrderedRotationAngles): OrderedRotationAngles {\r\n\r\n    let m11 = matrix.coffs[0], m12 = matrix.coffs[3], m13 = matrix.coffs[6];\r\n    let m21 = matrix.coffs[1], m22 = matrix.coffs[4], m23 = matrix.coffs[7];\r\n    let m31 = matrix.coffs[2], m32 = matrix.coffs[5], m33 = matrix.coffs[8];\r\n\r\n    if (OrderedRotationAngles.treatVectorsAsColumns) {\r\n      // the formulas are from row order .. flip the mIJ\r\n      m11 = matrix.coffs[0], m12 = matrix.coffs[1], m13 = matrix.coffs[2];\r\n      m21 = matrix.coffs[3], m22 = matrix.coffs[4], m23 = matrix.coffs[5];\r\n      m31 = matrix.coffs[6], m32 = matrix.coffs[7], m33 = matrix.coffs[8];\r\n\r\n    }\r\n\r\n    let xRad: number;\r\n    let yRad: number;\r\n    let zRad: number;\r\n\r\n    switch (order) {\r\n      case AxisOrder.XYZ: {\r\n        yRad = Math.asin(Math.max(-1, Math.min(1, m13)));\r\n\r\n        if (Math.abs(m13) < 0.99999) {\r\n          xRad = Math.atan2(- m23, m33);\r\n          zRad = Math.atan2(- m12, m11);\r\n        } else {\r\n          xRad = Math.atan2(m32, m22);\r\n          zRad = 0;\r\n        }\r\n        break;\r\n      } case AxisOrder.YXZ: {\r\n        xRad = Math.asin(-Math.max(-1, Math.min(1, m23)));\r\n\r\n        if (Math.abs(m23) < 0.99999) {\r\n          yRad = Math.atan2(m13, m33);\r\n          zRad = Math.atan2(m21, m22);\r\n        } else {\r\n          yRad = Math.atan2(-m31, m11);\r\n          zRad = 0;\r\n        }\r\n        break;\r\n      } case AxisOrder.ZXY: {\r\n        xRad = Math.asin(Math.max(-1, Math.min(1, m32)));\r\n\r\n        if (Math.abs(m32) < 0.99999) {\r\n          yRad = Math.atan2(-m31, m33);\r\n          zRad = Math.atan2(-m12, m22);\r\n        } else {\r\n          yRad = 0;\r\n          zRad = Math.atan2(m21, m11);\r\n        }\r\n        break;\r\n      } case AxisOrder.ZYX: {\r\n        yRad = -Math.asin(Math.max(-1, Math.min(1, m31)));\r\n\r\n        if (Math.abs(m31) < 0.99999) {\r\n          xRad = Math.atan2(m32, m33);\r\n          zRad = Math.atan2(m21, m11);\r\n        } else {\r\n          xRad = 0;\r\n          zRad = Math.atan2(-m12, m22);\r\n        }\r\n        break;\r\n      } case AxisOrder.YZX: {\r\n        zRad = Math.asin(Math.max(-1, Math.min(1, m21)));\r\n\r\n        if (Math.abs(m21) < 0.99999) {\r\n          xRad = Math.atan2(-m23, m22);\r\n          yRad = Math.atan2(-m31, m11);\r\n        } else {\r\n          xRad = 0;\r\n          yRad = Math.atan2(m13, m33);\r\n        }\r\n        break;\r\n      } case AxisOrder.XZY: {\r\n        zRad = -Math.asin(Math.max(-1, Math.min(1, m12)));\r\n\r\n        if (Math.abs(m12) < 0.99999) {\r\n          xRad = Math.atan2(m32, m22);\r\n          yRad = Math.atan2(m13, m11);\r\n        } else {\r\n          xRad = Math.atan2(-m23, m33);\r\n          yRad = 0;\r\n        }\r\n        break;\r\n      } default: {\r\n        xRad = yRad = zRad = 0;\r\n      }\r\n    }\r\n    if (OrderedRotationAngles.treatVectorsAsColumns)\r\n      return OrderedRotationAngles.createRadians(-xRad, -yRad, -zRad, order, result);\r\n\r\n    return OrderedRotationAngles.createRadians(xRad, yRad, zRad, order, result);\r\n  }\r\n\r\n  /** Create a 3x3 rotational matrix from this OrderedRotationAngles. */\r\n  public toMatrix3d(result?: Matrix3d): Matrix3d {\r\n    const rot = result !== undefined ? result : new Matrix3d();\r\n    const axisOrder = this.order;\r\n    const x = this.xAngle, y = this.yAngle, z = this.zAngle;\r\n    const a = x.cos(); let b = x.sin();\r\n    const c = y.cos(); let d = y.sin();\r\n    const e = z.cos(); let f = z.sin();\r\n    if (OrderedRotationAngles.treatVectorsAsColumns) {\r\n      b = -b;\r\n      d = -d;\r\n      f = -f;\r\n    }\r\n\r\n    if (axisOrder === AxisOrder.XYZ) {\r\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n      rot.setRowValues(\r\n        c * e, af + be * d, bf - ae * d,\r\n        -c * f, ae - bf * d, be + af * d,\r\n        d, -b * c, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.YXZ) {\r\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n      rot.setRowValues(\r\n        ce + df * b, a * f, cf * b - de,\r\n        de * b - cf, a * e, df + ce * b,\r\n        a * d, -b, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.ZXY) {\r\n      const ce = c * e, cf = c * f, de = d * e, df = d * f;\r\n      rot.setRowValues(\r\n        ce - df * b, cf + de * b, -a * d,\r\n        -a * f, a * e, b,\r\n        de + cf * b, df - ce * b, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.ZYX) {\r\n      const ae = a * e, af = a * f, be = b * e, bf = b * f;\r\n      rot.setRowValues(\r\n        c * e, c * f, -d,\r\n        be * d - af, bf * d + ae, b * c,\r\n        ae * d + bf, af * d - be, a * c,\r\n      );\r\n    } else if (axisOrder === AxisOrder.YZX) {\r\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n      rot.setRowValues(\r\n        c * e, f, -d * e,\r\n        bd - ac * f, a * e, ad * f + bc,\r\n        bc * f + ad, -b * e, ac - bd * f,\r\n      );\r\n    } else if (axisOrder === AxisOrder.XZY) {\r\n      const ac = a * c, ad = a * d, bc = b * c, bd = b * d;\r\n      rot.setRowValues(\r\n        c * e, ac * f + bd, bc * f - ad,\r\n        -f, a * e, b * e,\r\n        d * e, ad * f - bc, bd * f + ac,\r\n      );\r\n    }\r\n    if (OrderedRotationAngles.treatVectorsAsColumns)\r\n      rot.transposeInPlace();\r\n\r\n    return rot;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n/**\r\n * A plane defined by\r\n *\r\n * * Any point on the plane.\r\n * * a unit normal.\r\n * @public\r\n */\r\nexport class Plane3dByOriginAndUnitNormal implements BeJSONFunctions {\r\n  private _origin: Point3d;\r\n  private _normal: Vector3d;\r\n  // constructor captures references !!!\r\n  private constructor(origin: Point3d, normal: Vector3d) {\r\n    this._origin = origin;\r\n    this._normal = normal;\r\n  }\r\n  // This is private because it does not check validity of the unit vector.\r\n  private static _create(x: number, y: number, z: number, u: number, v: number, w: number) {\r\n    return new Plane3dByOriginAndUnitNormal(Point3d.create(x, y, z), Vector3d.create(u, v, w));\r\n  }\r\n  /**\r\n   * Create a plane parallel to the XY plane\r\n   * @param origin optional plane origin.  If omitted, the origin is placed at 000\r\n   */\r\n  public static createXYPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal {\r\n    if (origin)\r\n      return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 0, 1);\r\n    return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 0, 1);\r\n  }\r\n  /**\r\n   * Create a plane parallel to the YZ plane\r\n   * @param origin optional plane origin.  If omitted, the origin is placed at 000\r\n   */\r\n  public static createYZPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal {\r\n    if (origin)\r\n      return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 1, 0, 0);\r\n    return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 1, 0, 0);\r\n  }\r\n  /**\r\n   * Create a plane parallel to the ZX plane\r\n   * @param origin optional plane origin.  If omitted, the origin is placed at 000\r\n   */\r\n  public static createZXPlane(origin?: Point3d): Plane3dByOriginAndUnitNormal {\r\n    if (origin)\r\n      return Plane3dByOriginAndUnitNormal._create(origin.x, origin.y, origin.z, 0, 1, 0);\r\n    return Plane3dByOriginAndUnitNormal._create(0, 0, 0, 0, 1, 0);\r\n  }\r\n  /** create a new  Plane3dByOriginAndUnitNormal with given origin and normal.\r\n   * * Returns undefined if the normal vector is all zeros.\r\n   */\r\n  public static create(origin: Point3d, normal: Vector3d, result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined {\r\n    const normalized = normal.normalize();\r\n    if (!normalized)\r\n      return undefined;\r\n    if (result) {\r\n      result.set(origin, normalized);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndUnitNormal(origin.clone(), normalized);\r\n  }\r\n  /** Create a plane defined by two points and an in-plane vector.\r\n   * @param pointA any point in the plane\r\n   * @param pointB any other point in the plane\r\n   * @param vector any vector in the plane but not parallel to the vector from pointA to pointB\r\n   */\r\n  public static createPointPointVectorInPlane(pointA: Point3d, pointB: Point3d, vector: Vector3d): Plane3dByOriginAndUnitNormal | undefined {\r\n    const cross = vector.crossProductStartEnd(pointA, pointB);\r\n    if (cross.tryNormalizeInPlace())\r\n      return new Plane3dByOriginAndUnitNormal(pointA, cross);\r\n    return undefined;\r\n  }\r\n  /** test for (toleranced) equality with `other` */\r\n  public isAlmostEqual(other: Plane3dByOriginAndUnitNormal): boolean {\r\n    return this._origin.isAlmostEqual(other._origin) && this._normal.isAlmostEqual(other._normal);\r\n  }\r\n  /** Parse a json fragment `{origin: [x,y,z], normal: [ux,uy,uz]}`  */\r\n  public setFromJSON(json?: any) {\r\n    if (!json) {\r\n      this._origin.set(0, 0, 0);\r\n      this._normal.set(0, 0, 1);\r\n    } else {\r\n      this._origin.setFromJSON(json.origin);\r\n      this._normal.setFromJSON(json.normal);\r\n    }\r\n  }\r\n  /**\r\n   * Convert to a JSON object.\r\n   * @return {*} [origin,normal]\r\n   */\r\n  public toJSON(): any { return { origin: this._origin.toJSON(), normal: this._normal.toJSON() }; }\r\n  /**  create a new Plane3dByOriginAndUnitNormal from json fragment.\r\n   * * See `Plane3dByOriginAndUnitNormal.setFromJSON`\r\n   */\r\n  public static fromJSON(json?: any): Plane3dByOriginAndUnitNormal {\r\n    const result = Plane3dByOriginAndUnitNormal.createXYPlane();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Return a reference to the origin. */\r\n  public getOriginRef(): Point3d { return this._origin; }\r\n  /** Return a reference to the unit normal. */\r\n  public getNormalRef(): Vector3d { return this._normal; }\r\n  /** Copy coordinates from the given origin and normal. */\r\n  public set(origin: Point3d, normal: Vector3d): void {\r\n    this._origin.setFrom(origin);\r\n    this._normal.setFrom(normal);\r\n  }\r\n  /** return a deep clone (point and normal cloned) */\r\n  public clone(result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal {\r\n    if (result) {\r\n      result.set(this._origin, this._normal);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndUnitNormal(this._origin.clone(), this._normal.clone());\r\n  }\r\n  /** Create a clone and return the transform of the clone. */\r\n  public cloneTransformed(transform: Transform): Plane3dByOriginAndUnitNormal | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyPoint3d(result._origin, result._origin);\r\n    transform.matrix.multiplyInverseTranspose(result._normal, result._normal);\r\n    if (result._normal.normalizeInPlace())\r\n      return result;\r\n    return undefined;\r\n  }\r\n  /** Copy data from the given plane. */\r\n  public setFrom(source: Plane3dByOriginAndUnitNormal): void {\r\n    this.set(source._origin, source._normal);\r\n  }\r\n  /** Return the altitude of spacePoint above or below the plane.  (Below is negative) */\r\n  public altitude(spacePoint: Point3d): number { return this._normal.dotProductStartEnd(this._origin, spacePoint); }\r\n\r\n  /** Return the altitude of weighted spacePoint above or below the plane.  (Below is negative) */\r\n  public weightedAltitude(spacePoint: Point4d): number {\r\n    return this._normal.dotProductStart3dEnd4d(this._origin, spacePoint);\r\n  }\r\n\r\n  /** return a point at specified (signed) altitude */\r\n  public altitudeToPoint(altitude: number, result?: Point3d): Point3d {\r\n    return this._origin.plusScaled(this._normal, altitude, result);\r\n  }\r\n  /** Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude\r\n   * for a point moving at speed one along the spaceVector.\r\n   */\r\n  public velocityXYZ(x: number, y: number, z: number): number { return this._normal.dotProductXYZ(x, y, z); }\r\n  /** Return the dot product of spaceVector with the plane's unit normal.  This tells the rate of change of altitude\r\n   * for a point moving at speed one along the spaceVector.\r\n   */\r\n  public velocity(spaceVector: Vector3d): number { return this._normal.dotProduct(spaceVector); }\r\n  /** Return the altitude of a point given as separate x,y,z components. */\r\n  public altitudeXYZ(x: number, y: number, z: number): number {\r\n    return this._normal.dotProductStartEndXYZ(this._origin, x, y, z);\r\n  }\r\n  /** Return the altitude of a point given as separate x,y,z,w components. */\r\n  public altitudeXYZW(x: number, y: number, z: number, w: number): number {\r\n    return this._normal.dotProductStartEndXYZW(this._origin, x, y, z, w);\r\n  }\r\n  /** Return the projection of spacePoint onto the plane. */\r\n  public projectPointToPlane(spacePoint: Point3d, result?: Point3d): Point3d {\r\n    return spacePoint.plusScaled(this._normal, -this._normal.dotProductStartEnd(this._origin, spacePoint), result);\r\n  }\r\n  /** Returns true of spacePoint is within distance tolerance of the plane. */\r\n  public isPointInPlane(spacePoint: Point3d): boolean { return Geometry.isSmallMetricDistance(this.altitude(spacePoint)); }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Transform } from \"./Transform\";\r\n/**\r\n * A Point3dVector3dVector3d is an origin and a pair of vectors.\r\n * This defines a plane with a (possibly skewed) uv coordinate grid\r\n * * The grid directions (`vectorU` and `vectorV`)\r\n *   * are NOT required to be unit vectors.\r\n *   * are NOT required to be perpendicular vectors.\r\n * @public\r\n */\r\nexport class Plane3dByOriginAndVectors implements BeJSONFunctions {\r\n  /** origin of plane grid */\r\n  public origin: Point3d;\r\n  /** u direction in plane grid */\r\n  public vectorU: Vector3d;\r\n  /** v direction in plane grid */\r\n  public vectorV: Vector3d;\r\n  private constructor(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d) {\r\n    this.origin = origin;\r\n    this.vectorU = vectorU;\r\n    this.vectorV = vectorV;\r\n  }\r\n  /** create a new plane from origin and vectors. */\r\n  public static createOriginAndVectors(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (result) {\r\n      result.origin.setFrom(origin);\r\n      result.vectorU.setFrom(vectorU);\r\n      result.vectorV.setFrom(vectorV);\r\n      return result;\r\n    }\r\n    return new Plane3dByOriginAndVectors(origin.clone(), vectorU.clone(), vectorV.clone());\r\n  }\r\n  /**\r\n   * Return a Plane3dByOriginAndVectors, with\r\n   * * origin is the translation (aka origin) from the Transform\r\n   * * vectorU is the X column of the transform\r\n   * * vectorV is the Y column of the transform.\r\n   * @param transform source transform\r\n   * @param xLength optional length to impose on vectorU.\r\n   * @param yLength optional length to impose on vectorV.\r\n   * @param result optional preexisting result\r\n   */\r\n  public static createFromTransformColumnsXYAndLengths(transform: Transform,\r\n    xLength: number | undefined, yLength: number | undefined,\r\n    result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (result) {\r\n      result.origin.setFrom(transform.getOrigin());\r\n      transform.matrix.columnX(result.vectorU);\r\n      transform.matrix.columnY(result.vectorV);\r\n    } else {\r\n      result = new Plane3dByOriginAndVectors(\r\n        transform.getOrigin(),\r\n        transform.matrix.columnX(),\r\n        transform.matrix.columnY());\r\n    }\r\n    if (xLength !== undefined)\r\n      result.vectorU.scaleToLength(xLength, result.vectorU);\r\n    if (yLength !== undefined)\r\n      result.vectorV.scaleToLength(yLength, result.vectorV);\r\n    return result;\r\n  }\r\n  /** Capture origin and directions in a new planed. */\r\n  public static createCapture(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (!result)\r\n      return new Plane3dByOriginAndVectors(origin, vectorU, vectorV);\r\n    result.origin = origin;\r\n    result.vectorU = vectorU;\r\n    result.vectorV = vectorV;\r\n    return result;\r\n  }\r\n  /** Set all origin and both vectors from direct numeric parameters */\r\n  public setOriginAndVectorsXYZ(x0: number, y0: number, z0: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number): Plane3dByOriginAndVectors {\r\n    this.origin.set(x0, y0, z0);\r\n    this.vectorU.set(ux, uy, uz);\r\n    this.vectorV.set(vx, vy, vz);\r\n    return this;\r\n  }\r\n  /** Set all origin and both vectors from coordinates in given origin and vectors.\r\n   * * Note that coordinates are copied out of the parameters -- the given parameters are NOT retained by reference.\r\n   */\r\n  public setOriginAndVectors(origin: Point3d, vectorU: Vector3d, vectorV: Vector3d): Plane3dByOriginAndVectors {\r\n    this.origin.setFrom(origin);\r\n    this.vectorU.setFrom(vectorU);\r\n    this.vectorV.setFrom(vectorV);\r\n    return this;\r\n  }\r\n  /** Create a new plane from direct numeric parameters */\r\n  public static createOriginAndVectorsXYZ(x0: number, y0: number, z0: number, ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    if (result)\r\n      return result.setOriginAndVectorsXYZ(x0, y0, z0, ux, uy, uz, vx, vy, vz);\r\n    return new Plane3dByOriginAndVectors(Point3d.create(x0, y0, z0), Vector3d.create(ux, uy, uz), Vector3d.create(vx, vy, vz));\r\n  }\r\n  /** Define a plane by three points in the plane.\r\n   * @param origin origin for the parameterization.\r\n   * @param targetU target point for the vectorU starting at the origin.\r\n   * @param targetV target point for the vectorV originating at the origin.\r\n   * @param result optional result.\r\n   */\r\n  public static createOriginAndTargets(origin: Point3d, targetU: Point3d, targetV: Point3d, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin.x, origin.y, origin.z, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, result);\r\n  }\r\n  /** Create a plane with origin at 000, unit vectorU in x direction, and unit vectorV in the y direction. */\r\n  public static createXYPlane(result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(0, 0, 0, 1, 0, 0, 0, 1, 0, result);\r\n  }\r\n  /** create a plane from data presented as Float64Arrays.\r\n   * @param origin x,y,z of origin.\r\n   * @param vectorU x,y,z of vectorU\r\n   * @param vectorV x,y,z of vectorV\r\n   */\r\n  public static createOriginAndVectorsArrays(origin: Float64Array, vectorU: Float64Array, vectorV: Float64Array, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(origin[0], origin[1], origin[2], vectorU[0], vectorU[1], vectorU[2], vectorV[0], vectorV[1], vectorV[2], result);\r\n  }\r\n  /** create a plane from data presented as Float64Array with weights\r\n   * @param origin x,y,z,w of origin.\r\n   * @param vectorU x,y,z,w of vectorU\r\n   * @param vectorV x,y,z,w of vectorV\r\n   */\r\n  public static createOriginAndVectorsWeightedArrays(originw: Float64Array, vectorUw: Float64Array, vectorVw: Float64Array, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const w = originw[3];\r\n    result = Plane3dByOriginAndVectors.createXYPlane(result);\r\n    if (Geometry.isSmallMetricDistance(w))\r\n      return result;\r\n    const dw = 1.0 / w;\r\n    const au = vectorUw[3] * dw * dw;\r\n    const av = vectorVw[3] * dw * dw;\r\n    // for homogeneous function X, with w its weight:\r\n    // (X/w) is the cartesian point.\r\n    // (X/w)' = (X' w - X w')/(w*w)\r\n    //        = X'/w  - (X/w)(w'/w)\r\n    //        = X'/w  - X w'/w^2)\r\n    // The w parts of the formal xyzw sums are identically 0.\r\n    // Here the X' and its w' are taken from each vectorUw and vectorVw\r\n    result.origin.set(originw[0] * dw, originw[1] * dw, originw[2] * dw);\r\n    Vector3d.createAdd2ScaledXYZ(vectorUw[0], vectorUw[1], vectorUw[2], dw, originw[0], originw[1], originw[2], -au, result.vectorU);\r\n    Vector3d.createAdd2ScaledXYZ(vectorVw[0], vectorVw[1], vectorVw[2], dw, originw[0], originw[1], originw[2], -av, result.vectorV);\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate a point a grid coordinates on the plane.\r\n   * * The computed point is `origin + vectorU * u + vectorV * v`\r\n   * @param u coordinate along vectorU\r\n   * @param v coordinate along vectorV\r\n   * @param result optional result destination.\r\n   * @returns Return the computed coordinate.\r\n   */\r\n  public fractionToPoint(u: number, v: number, result?: Point3d): Point3d {\r\n    return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);\r\n  }\r\n  /** Return the vector from the plane origin to parametric coordinate (u.v) */\r\n  public fractionToVector(u: number, v: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.createAdd2Scaled(this.vectorU, u, this.vectorV, v, result);\r\n  }\r\n  /** Set coordinates from a json object such as `{origin: [1,2,3], vectorU:[4,5,6], vectorV[3,2,1]}` */\r\n  public setFromJSON(json?: any) {\r\n    if (!json || !json.origin || !json.vectorV) {\r\n      this.origin.set(0, 0, 0);\r\n      this.vectorU.set(1, 0, 0);\r\n      this.vectorV.set(0, 1, 0);\r\n    } else {\r\n      this.origin.setFromJSON(json.origin);\r\n      this.vectorU.setFromJSON(json.vectorU);\r\n      this.vectorV.setFromJSON(json.vectorV);\r\n    }\r\n  }\r\n  /**\r\n   * Convert an Angle to a JSON object.\r\n   * @return {*} [origin,normal]\r\n   */\r\n  public toJSON(): any {\r\n    return {\r\n      origin: this.origin.toJSON(),\r\n      vectorU: this.vectorU.toJSON(),\r\n      vectorV: this.vectorV.toJSON(),\r\n    };\r\n  }\r\n  /** create a new plane.   See `setFromJSON` for layout example. */\r\n  public static fromJSON(json?: any): Plane3dByOriginAndVectors {\r\n    const result = Plane3dByOriginAndVectors.createXYPlane();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Test origin and vectors for isAlmostEqual with `other` */\r\n  public isAlmostEqual(other: Plane3dByOriginAndVectors): boolean {\r\n    return this.origin.isAlmostEqual(other.origin)\r\n      && this.vectorU.isAlmostEqual(other.vectorU)\r\n      && this.vectorV.isAlmostEqual(other.vectorV);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module CartesianGeometry */\r\n\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Point2d, Vector2d, XY } from \"./Point2dVector2d\";\r\nimport { XAndY } from \"./XYZProps\";\r\nimport { IndexedXYCollection } from \"./IndexedXYCollection\";\r\n\r\n/**\r\n * Helper object to access members of a Point2d[] in geometric calculations.\r\n * * The collection holds only a reference to the actual array.\r\n * * The actual array may be replaced by the user as needed.\r\n * * When replaced, there is no cached data to be updated.\r\n * @public\r\n*/\r\nexport class Point2dArrayCarrier extends IndexedXYCollection {\r\n  /** reference to array being queried. */\r\n  public data: Point2d[];\r\n  /** CAPTURE caller supplied array ... */\r\n  public constructor(data: Point2d[]) {\r\n    super();\r\n    this.data = data;\r\n  }\r\n  /** test if index is valid  */\r\n  public isValidIndex(index: number): boolean {\r\n    return index >= 0 && index < this.data.length;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Point2d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getPoint2dAtCheckedPointIndex(index: number, result?: Point2d): Point2d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Point2d.create(source.x, source.y, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Vector2d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getVector2dAtCheckedVectorIndex(index: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Vector2d.create(source.x, source.y, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from the point at indexA to the point at indexB\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public vectorIndexIndex(indexA: number, indexB: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector2d.createStartEnd(this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from given origin to point at indexB\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public vectorXAndYIndex(origin: XAndY, indexB: number, result?: Vector2d): Vector2d | undefined {\r\n    if (this.isValidIndex(indexB))\r\n      return Vector2d.createStartEnd(origin, this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return the cross product of vectors from origin to points at indexA and indexB\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public crossProductXAndYIndexIndex(origin: XAndY, indexA: number, indexB: number): number | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return XY.crossProductToPoints(origin, this.data[indexA], this.data[indexB]);\r\n    return undefined;\r\n  }\r\n  /**\r\n * Return the cross product of vectors from point at originIndex to points at indexA and indexB\r\n * @param originIndex index of origin\r\n * @param indexA index of first target within the array\r\n * @param indexB index of second target within the array\r\n * @param result caller-allocated vector.\r\n * @returns return true if indexA, indexB both valid\r\n */\r\n  public crossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number): number | undefined {\r\n    if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return XY.crossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB]);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * read-only property for number of XYZ in the collection.\r\n   */\r\n  public get length(): number {\r\n    return this.data.length;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { XAndY, XYProps } from \"./XYZProps\";\r\n\r\n/** Minimal object containing x,y and operations that are meaningful without change in both point and vector.\r\n *  * `XY` is not instantiable.\r\n *  * The derived (instantiable) classes are\r\n *    * `Point2d`\r\n *    * `Vector2d`\r\n * @public\r\n */\r\nexport class XY implements XAndY {\r\n  /** x component */\r\n  public x: number;\r\n  /** y component */\r\n  public y: number;\r\n  /** Set both x and y. */\r\n  public set(x: number = 0, y: number = 0) { this.x = x; this.y = y; }\r\n  /** Set both x and y to zero */\r\n  public setZero() { this.x = 0; this.y = 0; }\r\n  protected constructor(x: number = 0, y: number = 0) { this.x = x; this.y = y; }\r\n  /** Set both x and y from other. */\r\n  public setFrom(other?: XAndY) {\r\n    if (other) {\r\n      this.x = other.x; this.y = other.y;\r\n    } else {\r\n      this.x = 0; this.y = 0;\r\n    }\r\n  }\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this); }\r\n\r\n  /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqual(other: XAndY, tol?: number): boolean { return Geometry.isSameCoordinate(this.x, other.x, tol) && Geometry.isSameCoordinate(this.y, other.y, tol); }\r\n\r\n  /** Returns true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqualXY(x: number, y: number, tol?: number): boolean { return Geometry.isSameCoordinate(this.x, x, tol) && Geometry.isSameCoordinate(this.y, y, tol); }\r\n\r\n  /** return a json array  `[x,y]`   */\r\n  public toJSON(): XYProps { return [this.x, this.y]; }\r\n  /** return a json object `{x: 1, y:2}`  */\r\n  public toJSONXY(): XYProps { return { x: this.x, y: this.y }; }\r\n\r\n  /** Set x and y from a JSON source such as `[1,2]` or `{x:1, y:2}` */\r\n  public setFromJSON(json?: XYProps): void {\r\n    if (Array.isArray(json)) {\r\n      this.set(json[0] || 0, json[1] || 0);\r\n      return;\r\n    }\r\n    if (json) {\r\n      this.set(json.x || 0, json.y || 0);\r\n      return;\r\n    }\r\n    this.set(0, 0);\r\n  }\r\n\r\n  /** Return the distance from this point to other */\r\n  public distance(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (Math.sqrt(xDist * xDist + yDist * yDist));\r\n  }\r\n\r\n  /** Return squared distance from this point to other */\r\n  public distanceSquared(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (xDist * xDist + yDist * yDist);\r\n  }\r\n\r\n  /** Return the largest absolute distance between corresponding components */\r\n  public maxDiff(other: XAndY): number {\r\n    return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y));\r\n  }\r\n  /** returns true if the x,y components are both small by metric metric tolerance */\r\n  public get isAlmostZero(): boolean {\r\n    return Geometry.isSmallMetricDistance(this.x) && Geometry.isSmallMetricDistance(this.y);\r\n  }\r\n\r\n  /** Return the largest absolute value of any component */\r\n  public maxAbs(): number { return Math.max(Math.abs(this.x), Math.abs(this.y)); }\r\n  /** Return the magnitude of the vector */\r\n  public magnitude(): number { return Math.sqrt(this.x * this.x + this.y * this.y); }\r\n  /** Return the squared magnitude of the vector.  */\r\n  public magnitudeSquared(): number { return this.x * this.x + this.y * this.y; }\r\n\r\n  /** returns true if the x,y components are exactly equal. */\r\n  public isExactEqual(other: XAndY): boolean { return this.x === other.x && this.y === other.y; }\r\n  /** returns true if x,y match `other` within metric tolerance */\r\n  public isAlmostEqualMetric(other: XAndY): boolean { return this.maxDiff(other) <= Geometry.smallMetricDistance; }\r\n\r\n  /** Return a (full length) vector from this point to other */\r\n  public vectorTo(other: XAndY, result?: Vector2d): Vector2d {\r\n    return Vector2d.create(\r\n      other.x - this.x,\r\n      other.y - this.y,\r\n      result);\r\n  }\r\n  /** Return a unit vector from this point to other */\r\n  public unitVectorTo(target: XAndY, result?: Vector2d): Vector2d | undefined {\r\n    return this.vectorTo(target, result).normalize(result);\r\n  }\r\n  /** cross product of vectors from origin to targets */\r\n  public static crossProductToPoints(origin: XAndY, targetA: XAndY, targetB: XAndY): number {\r\n    return Geometry.crossProductXYXY(\r\n      targetA.x - origin.x, targetA.y - origin.y, targetB.x - origin.x, targetB.y - origin.y);\r\n  }\r\n}\r\n/** 2D point with `x`,`y` as properties\r\n * @public\r\n */\r\nexport class Point2d extends XY implements BeJSONFunctions {\r\n  /** Constructor for Point2d */\r\n  constructor(x: number = 0, y: number = 0) { super(x, y); }\r\n  /** return a new Point2d with x,y coordinates from this. */\r\n  public clone(): Point2d { return new Point2d(this.x, this.y); }\r\n\r\n  /**\r\n   * Return a point (newly created unless result provided) with given x,y coordinates\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param result optional result\r\n   */\r\n  public static create(x: number = 0, y: number = 0, result?: Point2d): Point2d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      return result;\r\n    }\r\n    return new Point2d(x, y);\r\n  }\r\n  /** Convert JSON `[1,2]` or `{x:1, y:2}` to a Point2d instance */\r\n  public static fromJSON(json?: XYProps): Point2d { const val = new Point2d(); val.setFromJSON(json); return val; }\r\n  /** Create (or optionally reuse) a Point2d from another object with fields x and y */\r\n  public static createFrom(xy: XAndY | undefined, result?: Point2d): Point2d {\r\n    if (xy)\r\n      return Point2d.create(xy.x, xy.y, result);\r\n    return Point2d.create(0, 0, result);\r\n  }\r\n  /** Create a Point2d with both coordinates zero. */\r\n  public static createZero(result?: Point2d): Point2d { return Point2d.create(0, 0, result); }\r\n  /** Starting at this point, move along vector by tangentFraction of the vector length, and to the left by leftFraction of\r\n   * the perpendicular vector length.\r\n   * @param tangentFraction distance to move along the vector, as a fraction of vector\r\n   * @param leftfraction distance to move perpendicular to the vector, as a fraction of the rotated vector\r\n   */\r\n  public addForwardLeft(tangentFraction: number, leftFraction: number, vector: Vector2d): Point2d {\r\n    const dx = vector.x;\r\n    const dy = vector.y;\r\n    return Point2d.create(this.x + tangentFraction * dx - leftFraction * dy,\r\n      this.y + tangentFraction * dy + leftFraction * dx);\r\n  }\r\n  /** Interpolate at tangentFraction between this instance and point.   Move by leftFraction along the xy perpendicular\r\n   * of the vector between the points.\r\n   */\r\n  public forwardLeftInterpolate(tangentFraction: number, leftFraction: number, point: XAndY): Point2d {\r\n    const dx = point.x - this.x;\r\n    const dy = point.y - this.y;\r\n    return Point2d.create(\r\n      this.x + tangentFraction * dx - leftFraction * dy,\r\n      this.y + tangentFraction * dy + leftFraction * dx);\r\n  }\r\n\r\n  /** Return a point interpolated between this point and the right param. */\r\n  public interpolate(fraction: number, other: XAndY, result?: Point2d): Point2d {\r\n    if (fraction <= 0.5)\r\n      return Point2d.create(\r\n        this.x + fraction * (other.x - this.x),\r\n        this.y + fraction * (other.y - this.y),\r\n        result);\r\n    const t: number = fraction - 1.0;\r\n    return Point2d.create(\r\n      other.x + t * (other.x - this.x),\r\n      other.y + t * (other.y - this.y),\r\n      result);\r\n  }\r\n\r\n  /** Return a point with independent x,y fractional interpolation. */\r\n  public interpolateXY(fractionX: number, fractionY: number, other: XAndY, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      Geometry.interpolate(this.x, fractionX, other.x),\r\n      Geometry.interpolate(this.y, fractionY, other.y),\r\n      result);\r\n  }\r\n\r\n  /** Return this point minus vector */\r\n  public minus(vector: XAndY, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x - vector.x,\r\n      this.y - vector.y,\r\n      result);\r\n  }\r\n\r\n  /** Return point plus vector */\r\n  public plus(vector: XAndY, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vector.x,\r\n      this.y + vector.y,\r\n      result);\r\n  }\r\n  /** Return point plus vector */\r\n  public plusXY(dx: number = 0, dy: number = 0, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + dx,\r\n      this.y + dy, result);\r\n  }\r\n\r\n  /** Return point + vector * scalar */\r\n  public plusScaled(vector: XAndY, scaleFactor: number, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vector.x * scaleFactor,\r\n      this.y + vector.y * scaleFactor,\r\n      result);\r\n  }\r\n\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB */\r\n  public plus2Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vectorA.x * scalarA + vectorB.x * scalarB,\r\n      this.y + vectorA.y * scalarA + vectorB.y * scalarB,\r\n      result);\r\n  }\r\n\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */\r\n  public plus3Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, vectorC: XAndY, scalarC: number, result?: Point2d): Point2d {\r\n    return Point2d.create(\r\n      this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC,\r\n      this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC,\r\n      result);\r\n  }\r\n  /**\r\n   * Return the dot product of vector from this to targetA and vector from this to targetB\r\n   * @param targetA target of first vector\r\n   * @param targetB target of second vector\r\n   */\r\n  public dotVectorsToTargets(targetA: XAndY, targetB: XAndY): number {\r\n    return (targetA.x - this.x) * (targetB.x - this.x) +\r\n      (targetA.y - this.y) * (targetB.y - this.y);\r\n  }\r\n\r\n  /** Returns the (scalar) cross product of two points/vectors, computed from origin to target1 and target2 */\r\n  public crossProductToPoints(target1: XAndY, target2: XAndY): number {\r\n    const x1 = target1.x - this.x;\r\n    const y1 = target1.y - this.y;\r\n    const x2 = target2.x - this.x;\r\n    const y2 = target2.y - this.y;\r\n    return x1 * y2 - y1 * x2;\r\n  }\r\n  /** Return the fractional coordinate of the projection of this instance x,y onto the line from startPoint to endPoint.\r\n   * @param startPoint start point of line\r\n   * @param endPoint end point of line\r\n   * @param defaultFraction fraction to return if startPoint and endPoint are equal.\r\n   */\r\n  public fractionOfProjectionToLine(startPoint: Point2d, endPoint: Point2d, defaultFraction?: number): number {\r\n    const denominator = startPoint.distanceSquared(endPoint);\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction ? defaultFraction : 0;\r\n    return startPoint.dotVectorsToTargets(endPoint, this) / denominator;\r\n  }\r\n}\r\n/** 2D vector with `x`,`y` as properties\r\n * @public\r\n */\r\nexport class Vector2d extends XY implements BeJSONFunctions {\r\n  constructor(x: number = 0, y: number = 0) { super(x, y); }\r\n  /** Return a new Vector2d with the same x,y */\r\n  public clone(): Vector2d { return new Vector2d(this.x, this.y); }\r\n  /** Return a new Vector2d with given x and y */\r\n  public static create(x: number = 0, y: number = 0, result?: Vector2d): Vector2d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      return result;\r\n    }\r\n    return new Vector2d(x, y);\r\n  }\r\n\r\n  /** Return a (new) Vector2d with components 1,0 */\r\n  public static unitX(scale: number = 1): Vector2d { return new Vector2d(scale, 0); }\r\n\r\n  /** Return a (new) Vector2d with components 0,1 */\r\n  public static unitY(scale: number = 1): Vector2d { return new Vector2d(0, scale); }\r\n\r\n  /** Return a Vector2d with components 0,0 */\r\n  public static createZero(result?: Vector2d): Vector2d { return Vector2d.create(0, 0, result); }\r\n\r\n  /** copy contents from another Point3d, Point2d, Vector2d, or Vector3d, or leading entries of Float64Array */\r\n  public static createFrom(data: XAndY | Float64Array, result?: Vector2d): Vector2d {\r\n    if (data instanceof Float64Array) {\r\n      if (data.length >= 2)\r\n        return Vector2d.create(data[0], data[1]);\r\n      if (data.length >= 1)\r\n        return Vector2d.create(data[0], 0);\r\n      return Vector2d.create(0, 0);\r\n    }\r\n    return Vector2d.create(data.x, data.y, result);\r\n  }\r\n  /** Return a new Vector2d from json structured as `[1,2]` or `{x:1,y:2}` */\r\n  public static fromJSON(json?: XYProps): Vector2d { const val = new Vector2d(); val.setFromJSON(json); return val; }\r\n  /** Return a new Vector2d from polar coordinates for radius and Angle from x axis */\r\n  public static createPolar(r: number, theta: Angle): Vector2d {\r\n    return Vector2d.create(r * theta.cos(), r * theta.sin());\r\n  }\r\n  /** Return a new Vector2d extending from point0 to point1 */\r\n  public static createStartEnd(point0: XAndY, point1: XAndY, result?: Vector2d): Vector2d {\r\n    if (result) {\r\n      result.set(point1.x - point0.x, point1.y - point0.y);\r\n      return result;\r\n    }\r\n    return new Vector2d(point1.x - point0.x, point1.y - point0.y);\r\n  }\r\n  /**\r\n   * Return a vector that bisects the angle between two normals and extends to the intersection of two offset lines\r\n   * @param unitPerpA unit perpendicular to incoming direction\r\n   * @param unitPerpB  unit perpendicular to outgoing direction\r\n   * @param offset offset distance\r\n   */\r\n  public static createOffsetBisector(unitPerpA: Vector2d, unitPerpB: Vector2d, offset: number): Vector2d | undefined {\r\n    let bisector: Vector2d | undefined = unitPerpA.plus(unitPerpB);\r\n    bisector = bisector.normalize();\r\n    if (bisector) {\r\n      const c = offset * bisector.dotProduct(unitPerpA);\r\n      return bisector.safeDivideOrNull(c);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Return a (new or optionally reused) vector which is `this` divided by denominator\r\n   * * return undefined if denominator is zero.\r\n   */\r\n  public safeDivideOrNull(denominator: number, result?: Vector2d): Vector2d | undefined {\r\n    if (denominator !== 0.0) {\r\n      return this.scale(1.0 / denominator, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return a unit vector in direction of this instance (undefined if this instance has near zero length) */\r\n  public normalize(result?: Vector2d): Vector2d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    result = result ? result : new Vector2d();\r\n    return this.safeDivideOrNull(mag, result);\r\n  }\r\n\r\n  /** return the fractional projection of spaceVector onto this */\r\n  public fractionOfProjectionToVector(target: Vector2d, defaultFraction?: number): number {\r\n    const numerator = this.dotProduct(target);\r\n    const denominator = target.magnitudeSquared();\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction ? defaultFraction : 0;\r\n    return numerator / denominator;\r\n  }\r\n\r\n  /** Return a new vector with components negated from this instance. */\r\n  public negate(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = -this.x;\r\n    result.y = -this.y;\r\n    return result;\r\n  }\r\n\r\n  /** Return a vector same length as this but rotated 90 degrees counter clockwise */\r\n  public rotate90CCWXY(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    // save x,y to allow aliasing ..\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    return result;\r\n  }\r\n\r\n  /** Return a vector same length as this but rotated 90 degrees clockwise */\r\n  public rotate90CWXY(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    // save x,y to allow aliasing ..\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = yy;\r\n    result.y = -xx;\r\n    return result;\r\n  }\r\n  /** Return a unit vector perpendicular to this instance. */\r\n  public unitPerpendicularXY(result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    const d2: number = xx * xx + yy * yy;\r\n    if (d2 !== 0.0) {\r\n      const a = 1.0 / Math.sqrt(d2);\r\n      result.x *= a;\r\n      result.y *= a;\r\n    }\r\n    return result;\r\n  }\r\n  /** return a new Vector2d rotated CCW by given angle */\r\n  public rotateXY(angle: Angle, result?: Vector2d): Vector2d {\r\n    const s = angle.sin();\r\n    const c = angle.cos();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result = result ? result : new Vector2d();\r\n    result.x = xx * c - yy * s;\r\n    result.y = xx * s + yy * c;\r\n    return result;\r\n  }\r\n\r\n  /** return the interpolation {this + fraction * (right - this)} */\r\n  public interpolate(fraction: number, right: Vector2d, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    /* For best last-bit behavior, if fraction is below 0.5, use this as base point.   If above 0.5, use right as base point.   */\r\n    if (fraction <= 0.5) {\r\n      result.x = this.x + fraction * (right.x - this.x);\r\n      result.y = this.y + fraction * (right.y - this.y);\r\n    } else {\r\n      const t: number = fraction - 1.0;\r\n      result.x = right.x + t * (right.x - this.x);\r\n      result.y = right.y + t * (right.y - this.y);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** return {this + vector}. */\r\n  public plus(vector: XAndY, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vector.x;\r\n    result.y = this.y + vector.y;\r\n    return result;\r\n  }\r\n  /** return {this - vector}. */\r\n  public minus(vector: XAndY, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x - vector.x;\r\n    result.y = this.y - vector.y;\r\n    return result;\r\n  }\r\n\r\n  /** Return {point + vector \\* scalar} */\r\n  public plusScaled(vector: XAndY, scaleFactor: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vector.x * scaleFactor;\r\n    result.y = this.y + vector.y * scaleFactor;\r\n    return result;\r\n  }\r\n\r\n  /** Return {point + vectorA \\* scalarA + vectorB \\* scalarB} */\r\n  public plus2Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;\r\n    return result;\r\n  }\r\n\r\n  /** Return {this + vectorA \\* scalarA + vectorB \\* scalarB + vectorC \\* scalarC} */\r\n  public plus3Scaled(vectorA: XAndY, scalarA: number, vectorB: XAndY, scalarB: number, vectorC: XAndY, scalarC: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;\r\n    return result;\r\n  }\r\n  /** Return {this * scale} */\r\n  public scale(scale: number, result?: Vector2d): Vector2d {\r\n    result = result ? result : new Vector2d();\r\n    result.x = this.x * scale;\r\n    result.y = this.y * scale;\r\n    return result;\r\n  }\r\n  /** return a vector parallel to this but with specified length */\r\n  public scaleToLength(length: number, result?: Vector2d): Vector2d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    if (mag === 0)\r\n      return undefined;\r\n    return this.scale(length / mag, result);\r\n  }\r\n  /** return the dot product of this with vectorB */\r\n  public dotProduct(vectorB: XAndY): number { return this.x * vectorB.x + this.y * vectorB.y; }\r\n\r\n  /** dot product with vector from pointA to pointB */\r\n  public dotProductStartEnd(pointA: XAndY, pointB: XAndY): number {\r\n    return this.x * (pointB.x - pointA.x)\r\n      + this.y * (pointB.y - pointA.y);\r\n  }\r\n\r\n  /** vector cross product {this CROSS vectorB} */\r\n  public crossProduct(vectorB: XAndY): number { return this.x * vectorB.y - this.y * vectorB.x; }\r\n  /** return the (signed) angle from this to vectorB.   This is positive if the shortest turn is counterclockwise, negative if clockwise. */\r\n  public angleTo(vectorB: XAndY): Angle {\r\n    return Angle.createAtan2(this.crossProduct(vectorB), this.dotProduct(vectorB));\r\n  }\r\n\r\n  /*  smallerUnorientedAngleTo(vectorB: Vector2d): Angle { }\r\n    signedAngleTo(vectorB: Vector2d, upVector: Vector2d): Angle { }\r\n    planarAngleTo(vectorB: Vector2d, planeNormal: Vector2d): Angle { }\r\n    // sectors\r\n    isInSmallerSector(vectorA: Vector2d, vectorB: Vector2d): boolean { }\r\n    isInCCWSector(vectorA: Vector2d, vectorB: Vector2d, upVector: Vector2d): boolean { }\r\n    */\r\n  /**\r\n   * Test if `this` and `other` area parallel, with angle tolerance `Geometry.smallAngleRadiansSquared`.\r\n   * @param other second vector for comparison.\r\n   * @param oppositeIsParallel if true, treat vectors 180 opposite as parallel.  If false, treat those as non-parallel.\r\n   */\r\n  public isParallelTo(other: Vector2d, oppositeIsParallel: boolean = false): boolean {\r\n    const a2 = this.magnitudeSquared();\r\n    const b2 = other.magnitudeSquared();\r\n    // we know both are 0 or positive -- no need for\r\n    if (a2 < Geometry.smallMetricDistanceSquared || b2 < Geometry.smallMetricDistanceSquared)\r\n      return false;\r\n\r\n    const dot = this.dotProduct(other);\r\n    if (dot < 0.0 && !oppositeIsParallel)\r\n      return false;\r\n\r\n    const cross = this.crossProduct(other);\r\n\r\n    /* a2,b2,cross2 are squared lengths of respective vectors */\r\n    /* cross2 = sin^2(theta) * a2 * b2 */\r\n    /* For small theta, sin^2(theta)~~theta^2 */\r\n    return cross * cross <= Geometry.smallAngleRadiansSquared * a2 * b2;\r\n  }\r\n  /**\r\n   * Returns `true` if `this` vector is perpendicular to `other`.\r\n   * @param other second vector.\r\n   */\r\n  public isPerpendicularTo(other: Vector2d): boolean {\r\n    return Angle.isPerpendicularDotSet(this.magnitudeSquared(), other.magnitudeSquared(), this.dotProduct(other));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Ray3d } from \"./Ray3d\";\r\nimport { XYAndZ, XAndY, HasZ, XYZProps } from \"./XYZProps\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n/**\r\n *  * `XYZ` is a minimal object containing x,y,z and operations that are meaningful without change in both point and vector.\r\n *  * `XYZ` is not instantiable.\r\n *  * The derived (instantiable) classes are\r\n *    * `Point3d`\r\n *    * `Vector3d`\r\n * @public\r\n */\r\nexport class XYZ implements XYAndZ {\r\n  /** x coordinate */\r\n  public x: number;\r\n  /** y coordinate */\r\n  public y: number;\r\n  /** z coordinate */\r\n  public z: number;\r\n  /**\r\n   * Set the x,y,z  parts.\r\n   * @param x (optional) x part\r\n   * @param y (optional) y part\r\n   * @param z (optional) z part\r\n   */\r\n  public set(x: number = 0, y: number = 0, z: number = 0) { this.x = x; this.y = y; this.z = z; }\r\n\r\n  /** Set the x,y,z parts to zero. */\r\n  public setZero() { this.x = 0; this.y = 0; this.z = 0; }\r\n  protected constructor(x: number = 0, y: number = 0, z: number = 0) { this.x = x; this.y = y; this.z = z; }\r\n  /** Type guard for XAndY.\r\n   * @note this will return true for an XYAndZ. If you wish to distinguish between the two, call isXYAndZ first.\r\n   */\r\n  public static isXAndY(arg: any): arg is XAndY { return arg.x !== undefined && arg.y !== undefined; }\r\n  /** Type guard to determine whether an object has a member called \"z\" */\r\n  public static hasZ(arg: any): arg is HasZ { return arg.z !== undefined; }\r\n  /** Type guard for XYAndZ.  */\r\n  public static isXYAndZ(arg: any): arg is XYAndZ { return this.isXAndY(arg) && this.hasZ(arg); }\r\n  /**\r\n   * Set the x,y,z parts from one of these input types\r\n   *\r\n   * * XYZ -- copy the x,y,z parts\r\n   * * Float64Array -- Copy from indices 0,1,2 to x,y,z\r\n   * * XY -- copy the x, y parts and set z=0\r\n   */\r\n  public setFrom(other: Float64Array | XAndY | XYAndZ) {\r\n    if (XYZ.isXAndY(other)) {\r\n      this.x = other.x;\r\n      this.y = other.y;\r\n      this.z = XYZ.hasZ(other) ? other.z : 0;\r\n    } else {\r\n      this.x = other[0];\r\n      this.y = other[1];\r\n      this.z = other[2];\r\n    }\r\n  }\r\n  /**\r\n   * Set the x,y,z parts from a Point3d.\r\n   * This is the same effect as `setFrom(other)` with no pretesting of variant input type\r\n   */\r\n  public setFromPoint3d(other: Point3d) {\r\n    this.x = other.x;\r\n    this.y = other.y;\r\n    this.z = other.z;\r\n  }\r\n  /**\r\n   * Set the x,y,z parts from a Vector3d\r\n   * This is the same effect as `setFrom(other)` with no pretesting of variant input type\r\n   */\r\n  public setFromVector3d(other: Vector3d) {\r\n    this.x = other.x;\r\n    this.y = other.y;\r\n    this.z = other.z;\r\n  }\r\n\r\n  /** Returns true if this and other have equal x,y,z parts within Geometry.smallMetricDistance.\r\n   * @param other The other XYAndZ to compare\r\n   * @param tol The tolerance for the comparison. If undefined, use [[Geometry.smallMetricDistance]]\r\n   */\r\n  public isAlmostEqual(other: XYAndZ, tol?: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, other.x, tol)\r\n      && Geometry.isSameCoordinate(this.y, other.y, tol)\r\n      && Geometry.isSameCoordinate(this.z, other.z, tol);\r\n  }\r\n  /** Return true if this and other have equal x,y,z parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqualXYZ(x: number, y: number, z: number, tol?: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, x, tol)\r\n      && Geometry.isSameCoordinate(this.y, y, tol)\r\n      && Geometry.isSameCoordinate(this.z, z, tol);\r\n  }\r\n  /** Return true if this and other have equal x,y parts within Geometry.smallMetricDistance. */\r\n  public isAlmostEqualXY(other: XAndY, tol?: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, other.x, tol)\r\n      && Geometry.isSameCoordinate(this.y, other.y, tol);\r\n  }\r\n  /** Return a JSON object as array `[x,y,z]` */\r\n  public toJSON(): XYZProps { return [this.x, this.y, this.z]; }\r\n  /** Return a JSON object as key value pairs `{x: value, y: value, z: value}` */\r\n  public toJSONXYZ(): XYZProps { return { x: this.x, y: this.y, z: this.z }; }\r\n  /** Pack the x,y,z values in a Float64Array. */\r\n  public toFloat64Array(): Float64Array { return Float64Array.of(this.x, this.y, this.z); }\r\n  /**\r\n   * Set the x,y,z properties from one of several json forms:\r\n   *\r\n   * *  array of numbers: [x,y,z]\r\n   * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\r\n   */\r\n  public setFromJSON(json?: XYZProps): void {\r\n    if (Array.isArray(json)) {\r\n      this.set(json[0] || 0, json[1] || 0, json[2] || 0);\r\n      return;\r\n    }\r\n    if (json) {\r\n      this.set(json.x || 0, json.y || 0, json.z || 0);\r\n      return;\r\n    }\r\n    this.set(0, 0, 0);\r\n  }\r\n  /** Return the distance from this point to other */\r\n  public distance(other: XYAndZ): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    const zDist = other.z - this.z;\r\n    return (Math.sqrt(xDist * xDist + yDist * yDist + zDist * zDist));\r\n  }\r\n  /** Return squared distance from this point to other */\r\n  public distanceSquared(other: XYAndZ): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    const zDist = other.z - this.z;\r\n    return (xDist * xDist + yDist * yDist + zDist * zDist);\r\n  }\r\n  /** Return the XY distance from this point to other */\r\n  public distanceXY(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (Math.sqrt(xDist * xDist + yDist * yDist));\r\n  }\r\n  /** Return squared XY distance from this point to other */\r\n  public distanceSquaredXY(other: XAndY): number {\r\n    const xDist = other.x - this.x;\r\n    const yDist = other.y - this.y;\r\n    return (xDist * xDist + yDist * yDist);\r\n  }\r\n  /** Return the largest absolute distance between corresponding components */\r\n  public maxDiff(other: XYAndZ): number {\r\n    return Math.max(Math.abs(this.x - other.x), Math.abs(this.y - other.y), Math.abs(this.z - other.z));\r\n  }\r\n  /**\r\n   * Return the x,y, z component corresponding to 0,1,2.\r\n   */\r\n  public at(index: number): number {\r\n    if (index < 0.5)\r\n      return this.x;\r\n    if (index > 1.5)\r\n      return this.z;\r\n    return this.y;\r\n  }\r\n  /** Return the index (0,1,2) of the x,y,z component with largest absolute value */\r\n  public indexOfMaxAbs(): number {\r\n    let index = 0;\r\n    let a = Math.abs(this.x);\r\n    let b = Math.abs(this.y);\r\n    if (b > a) {\r\n      index = 1;\r\n      a = b;\r\n    }\r\n    b = Math.abs(this.z);\r\n    if (b > a) {\r\n      index = 2;\r\n      a = b;\r\n    }\r\n    return index;\r\n  }\r\n  /** Return true if the if x,y,z components are all nearly zero to tolerance Geometry.smallMetricDistance */\r\n  public get isAlmostZero(): boolean {\r\n    return Geometry.isSmallMetricDistance(this.x) && Geometry.isSmallMetricDistance(this.y) && Geometry.isSmallMetricDistance(this.z);\r\n  }\r\n  /** Return the largest absolute value of any component */\r\n  public maxAbs(): number { return Math.max(Math.abs(this.x), Math.abs(this.y), Math.abs(this.z)); }\r\n  /** Return the sqrt of the sum of squared x,y,z parts */\r\n  public magnitude(): number { return Math.hypot(this.x, this.y, this.z); }\r\n  /** Return the sum of squared x,y,z parts */\r\n  public magnitudeSquared(): number { return this.x * this.x + this.y * this.y + this.z * this.z; }\r\n  /** Return sqrt of the sum of squared x,y parts */\r\n  public magnitudeXY(): number { return Math.hypot(this.x, this.y); }\r\n  /** Return the sum of squared x,y parts */\r\n  public magnitudeSquaredXY(): number { return this.x * this.x + this.y * this.y; }\r\n  /** exact equality test. */\r\n  public isExactEqual(other: XYAndZ): boolean { return this.x === other.x && this.y === other.y && this.z === other.z; }\r\n  /** equality test with Geometry.smallMetricDistance tolerance */\r\n  public isAlmostEqualMetric(other: XYAndZ): boolean { return this.maxDiff(other) <= Geometry.smallMetricDistance; }\r\n  /** add x,y,z from other in place. */\r\n  public addInPlace(other: XYAndZ): void { this.x += other.x; this.y += other.y; this.z += other.z; }\r\n  /** add (in place) the scaled x,y,z of other */\r\n  public addScaledInPlace(other: XYAndZ, scale: number): void {\r\n    this.x += scale * other.x;\r\n    this.y += scale * other.y;\r\n    this.z += scale * other.z;\r\n  }\r\n  /** Multiply the x, y, z parts by scale. */\r\n  public scaleInPlace(scale: number) { this.x *= scale; this.y *= scale; this.z *= scale; }\r\n  /** Clone strongly typed as Point3d */\r\n  public cloneAsPoint3d() { return Point3d.create(this.x, this.y, this.z); }\r\n  /** Return a (full length) vector from this point to other */\r\n  public vectorTo(other: XYAndZ, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(other.x - this.x, other.y - this.y, other.z - this.z, result);\r\n  }\r\n  /** Return a multiple of a the (full length) vector from this point to other */\r\n  public scaledVectorTo(other: XYAndZ, scale: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(scale * (other.x - this.x), scale * (other.y - this.y), scale * (other.z - this.z), result);\r\n  }\r\n  /** Return a unit vector from this vector to other. Return a 000 vector if the input is too small to normalize.\r\n   * @param other target of created vector.\r\n   * @param result optional result vector.\r\n   */\r\n  public unitVectorTo(target: XYAndZ, result?: Vector3d): Vector3d | undefined { return this.vectorTo(target, result).normalize(result); }\r\n  /** Freeze this XYZ */\r\n  public freeze() { Object.freeze(this); }\r\n}\r\n/** 3D point with `x`,`y`,`z` as properties\r\n * @public\r\n */\r\nexport class Point3d extends XYZ {\r\n  /** Constructor for Point3d */\r\n  constructor(x: number = 0, y: number = 0, z: number = 0) { super(x, y, z); }\r\n  /**\r\n   * Convert json to Point3d.  Accepted forms are:\r\n   * * `[1,2,3]` --- array of numbers\r\n   * *  array of numbers: [x,y,z]\r\n   * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\r\n   * @param json json value.\r\n   */\r\n  public static fromJSON(json?: XYZProps): Point3d { const val = new Point3d(); val.setFromJSON(json); return val; }\r\n  /** Return a new Point3d with the same coordinates */\r\n  public clone(result?: Point3d): Point3d { return Point3d.create(this.x, this.y, this.z, result); }\r\n  /** Create a new Point3d with given coordinates\r\n   * @param x x part\r\n   * @param y y part\r\n   * @param z z part\r\n   */\r\n  public static create(x: number = 0, y: number = 0, z: number = 0, result?: Point3d): Point3d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      result.z = z;\r\n      return result;\r\n    }\r\n    return new Point3d(x, y, z);\r\n  }\r\n  /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */\r\n  public static createFrom(data: XYAndZ | XAndY | Float64Array, result?: Point3d): Point3d {\r\n    if (data instanceof Float64Array) {\r\n      let x = 0;\r\n      let y = 0;\r\n      let z = 0;\r\n      if (data.length > 0)\r\n        x = data[0];\r\n      if (data.length > 1)\r\n        y = data[1];\r\n      if (data.length > 2)\r\n        z = data[2];\r\n      return Point3d.create(x, y, z, result);\r\n    }\r\n    return Point3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0, result);\r\n  }\r\n  /**\r\n   * Copy x,y,z from\r\n   * @param xyzData flat array of xyzxyz for multiple points\r\n   * @param pointIndex index of point to extract.   This index is multiplied by 3 to obtain starting index in the array.\r\n   * @param result optional result point.\r\n   */\r\n  public static createFromPacked(xyzData: Float64Array, pointIndex: number, result?: Point3d): Point3d | undefined {\r\n    const indexX = pointIndex * 3;\r\n    if (indexX >= 0 && indexX + 2 < xyzData.length)\r\n      return Point3d.create(xyzData[indexX], xyzData[indexX + 1], xyzData[indexX + 2], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Copy and unweight xyzw.\r\n   * @param xyzData flat array of xyzwxyzw for multiple points\r\n   * @param pointIndex index of point to extract.   This index is multiplied by 4 to obtain starting index in the array.\r\n   * @param result optional result point.\r\n   */\r\n  public static createFromPackedXYZW(xyzData: Float64Array, pointIndex: number, result?: Point3d): Point3d | undefined {\r\n    const indexX = pointIndex * 4;\r\n    if (indexX >= 0 && indexX + 3 < xyzData.length) {\r\n      const w = xyzData[indexX + 3];\r\n      if (!Geometry.isSmallMetricDistance(w)) {\r\n        const divW = 1.0 / w;\r\n        return Point3d.create(divW * xyzData[indexX], divW * xyzData[indexX + 1], divW * xyzData[indexX + 2], result);\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Create a new point with 000 xyz */\r\n  public static createZero(result?: Point3d): Point3d { return Point3d.create(0, 0, 0, result); }\r\n  /** Return the cross product of the vectors from this to pointA and pointB\r\n   *\r\n   * *  the result is a vector\r\n   * *  the result is perpendicular to both vectors, with right hand orientation\r\n   * *  the magnitude of the vector is twice the area of the triangle.\r\n   */\r\n  public crossProductToPoints(pointA: Point3d, pointB: Point3d, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, result);\r\n  }\r\n  /** Return the triple product of the vectors from this to pointA, pointB, pointC\r\n   *\r\n   * * This is a scalar (number)\r\n   * *  This is 6 times the (signed) volume of the tetrahedron on the 4 points.\r\n   */\r\n  public tripleProductToPoints(pointA: Point3d, pointB: Point3d, pointC: Point3d): number {\r\n    return Geometry.tripleProduct(pointA.x - this.x, pointA.y - this.y, pointA.z - this.z, pointB.x - this.x, pointB.y - this.y, pointB.z - this.z, pointC.x - this.x, pointC.y - this.y, pointC.z - this.z);\r\n  }\r\n  /** Return the cross product of the vectors from this to pointA and pointB\r\n   *\r\n   * *  the result is a scalar\r\n   * *  the magnitude of the vector is twice the signed area of the triangle.\r\n   * *  this is positive for counter-clockwise order of the points, negative for clockwise.\r\n   */\r\n  public crossProductToPointsXY(pointA: Point3d, pointB: Point3d): number {\r\n    return Geometry.crossProductXYXY(pointA.x - this.x, pointA.y - this.y, pointB.x - this.x, pointB.y - this.y);\r\n  }\r\n  /** Return a point interpolated between this point and the right param. */\r\n  public interpolate(fraction: number, other: XYAndZ, result?: Point3d): Point3d {\r\n    if (fraction <= 0.5)\r\n      return Point3d.create(this.x + fraction * (other.x - this.x), this.y + fraction * (other.y - this.y), this.z + fraction * (other.z - this.z), result);\r\n    const t: number = fraction - 1.0;\r\n    return Point3d.create(other.x + t * (other.x - this.x), other.y + t * (other.y - this.y), other.z + t * (other.z - this.z), result);\r\n  }\r\n  /**\r\n   * Return a ray whose ray.origin is interpolated, and ray.direction is the vector between points with a\r\n   * scale factor applied.\r\n   * @param fraction fractional position between points.\r\n   * @param other endpoint of interpolation\r\n   * @param tangentScale scale factor to apply to the startToEnd vector\r\n   * @param result  optional receiver.\r\n   */\r\n  public interpolatePointAndTangent(fraction: number, other: Point3d, tangentScale: number, result?: Ray3d): Ray3d {\r\n    result = result ? result : Ray3d.createZero();\r\n    const dx = other.x - this.x;\r\n    const dy = other.y - this.y;\r\n    const dz = other.z - this.z;\r\n    result.direction.set(tangentScale * dx, tangentScale * dy, tangentScale * dz);\r\n    if (fraction <= 0.5)\r\n      result.origin.set(this.x + fraction * dx, this.y + fraction * dy, this.z + fraction * dz);\r\n    else {\r\n      const t: number = fraction - 1.0;\r\n      result.origin.set(other.x + t * dx, other.y + t * dy, other.z + t * dz);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a point with independent x,y,z fractional interpolation. */\r\n  public interpolateXYZ(fractionX: number, fractionY: number, fractionZ: number, other: Point3d, result?: Point3d): Point3d {\r\n    return Point3d.create(Geometry.interpolate(this.x, fractionX, other.x), Geometry.interpolate(this.y, fractionY, other.y), Geometry.interpolate(this.z, fractionZ, other.z), result);\r\n  }\r\n  /** Interpolate between points, then add a shift in the xy plane by a fraction of the XY projection perpendicular. */\r\n  public interpolatePerpendicularXY(fraction: number, pointB: Point3d, fractionXYPerp: number, result?: Point3d): Point3d {\r\n    result = result ? result : new Point3d();\r\n    const vector = pointB.minus(this);\r\n    this.interpolate(fraction, pointB, result);\r\n    result.x -= fractionXYPerp * vector.y;\r\n    result.y += fractionXYPerp * vector.x;\r\n    return result;\r\n  }\r\n  /** Return point minus vector */\r\n  public minus(vector: XYAndZ, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x - vector.x, this.y - vector.y, this.z - vector.z, result);\r\n  }\r\n  /** Return point plus vector */\r\n  public plus(vector: XYAndZ, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + vector.x, this.y + vector.y, this.z + vector.z, result);\r\n  }\r\n  /** Return point plus vector */\r\n  public plusXYZ(dx: number = 0, dy: number = 0, dz: number = 0, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + dx, this.y + dy, this.z + dz, result);\r\n  }\r\n  /** Return point + vector * scalar */\r\n  public plusScaled(vector: XYAndZ, scaleFactor: number, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + vector.x * scaleFactor, this.y + vector.y * scaleFactor, this.z + vector.z * scaleFactor, result);\r\n  }\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB */\r\n  public plus2Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYZ, scalarB: number, result?: Point3d): Point3d {\r\n    return Point3d.create(this.x + vectorA.x * scalarA + vectorB.x * scalarB, this.y + vectorA.y * scalarA + vectorB.y * scalarB, this.z + vectorA.z * scalarA + vectorB.z * scalarB, result);\r\n  }\r\n  /** Return point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC */\r\n  public plus3Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, vectorC: XYAndZ, scalarC: number, result?: Point3d): Point3d {\r\n    return Point3d.create(\r\n      this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC,\r\n      this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC,\r\n      this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC, result);\r\n  }\r\n  /**\r\n   * Return a point that is scaled from the source point.\r\n   * @param source existing point\r\n   * @param scale scale factor to apply to its x,y,z parts\r\n   * @param result optional point to receive coordinates\r\n   */\r\n  public static createScale(source: XYAndZ, scale: number, result?: Point3d): Point3d {\r\n    return Point3d.create(source.x * scale, source.y * scale, source.z * scale, result);\r\n  }\r\n  /** create a point that is a linear combination (weighted sum) of 2 input points.\r\n   * @param pointA first input point\r\n   * @param scaleA scale factor for pointA\r\n   * @param pointB second input point\r\n   * @param scaleB scale factor for pointB\r\n   */\r\n  public static createAdd2Scaled(pointA: XYAndZ, scaleA: number, pointB: XYAndZ, scaleB: number, result?: Point3d): Point3d {\r\n    return Point3d.create(pointA.x * scaleA + pointB.x * scaleB, pointA.y * scaleA + pointB.y * scaleB, pointA.z * scaleA + pointB.z * scaleB, result);\r\n  }\r\n  /** Create a point that is a linear combination (weighted sum) of 3 input points.\r\n   * @param pointA first input point\r\n   * @param scaleA scale factor for pointA\r\n   * @param pointB second input point\r\n   * @param scaleB scale factor for pointB\r\n   * @param pointC third input point.\r\n   * @param scaleC scale factor for pointC\r\n   */\r\n  public static createAdd3Scaled(pointA: XYAndZ, scaleA: number, pointB: XYAndZ, scaleB: number, pointC: XYAndZ, scaleC: number, result?: Point3d): Point3d {\r\n    return Point3d.create(pointA.x * scaleA + pointB.x * scaleB + pointC.x * scaleC, pointA.y * scaleA + pointB.y * scaleB + pointC.y * scaleC, pointA.z * scaleA + pointB.z * scaleB + pointC.z * scaleC, result);\r\n  }\r\n  /**\r\n   * Return the dot product of vectors from this to pointA and this to pointB.\r\n   * @param targetA target point for first vector\r\n   * @param targetB target point for second vector\r\n   */\r\n  public dotVectorsToTargets(targetA: Point3d, targetB: Point3d): number {\r\n    return (targetA.x - this.x) * (targetB.x - this.x) +\r\n      (targetA.y - this.y) * (targetB.y - this.y) +\r\n      (targetA.z - this.z) * (targetB.z - this.z);\r\n  }\r\n  /** Return the fractional projection of this onto a line between points.\r\n   *\r\n   */\r\n  public fractionOfProjectionToLine(startPoint: Point3d, endPoint: Point3d, defaultFraction: number = 0): number {\r\n    const denominator = startPoint.distanceSquared(endPoint);\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction;\r\n    return startPoint.dotVectorsToTargets(endPoint, this) / denominator;\r\n  }\r\n}\r\n/** 3D vector with `x`,`y`,`z` as properties\r\n * @public\r\n */\r\nexport class Vector3d extends XYZ {\r\n  constructor(x: number = 0, y: number = 0, z: number = 0) { super(x, y, z); }\r\n  /**\r\n   * Copy xyz from this instance to a new (or optionally resused) Vector3d\r\n   * @param result optional instance to reuse.\r\n   */\r\n  public clone(result?: Vector3d): Vector3d { return Vector3d.create(this.x, this.y, this.z, result); }\r\n  /**\r\n   * return a Vector3d (new or reused from optional result)\r\n   * @param x x component\r\n   * @param y y component\r\n   * @param z z component\r\n   * @param result optional instance to reuse\r\n   */\r\n  public static create(x: number = 0, y: number = 0, z: number = 0, result?: Vector3d): Vector3d {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      result.z = z;\r\n      return result;\r\n    }\r\n    return new Vector3d(x, y, z);\r\n  }\r\n  /**\r\n   * Create a vector which is cross product of two vectors supplied as separate arguments\r\n   * @param ux x coordinate of vector u\r\n   * @param uy y coordinate of vector u\r\n   * @param uz z coordinate of vector u\r\n   * @param vx x coordinate of vector v\r\n   * @param vy y coordinate of vector v\r\n   * @param vz z coordinate of vector v\r\n   * @param result optional result vector.\r\n   */\r\n  public static createCrossProduct(ux: number, uy: number, uz: number, vx: number, vy: number, vz: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(uy * vz - uz * vy, uz * vx - ux * vz, ux * vy - uy * vx, result);\r\n  }\r\n  /**\r\n   * Accumulate a vector which is cross product vectors from origin (ax,ay,az) to targets (bx,by,bz) and (cx,cy,cz)\r\n   * @param ax x coordinate of origin\r\n   * @param ay y coordinate of origin\r\n   * @param az z coordinate of origin\r\n   * @param bx x coordinate of target point b\r\n   * @param by y coordinate of target point b\r\n   * @param bz z coordinate of target point b\r\n   * @param cx x coordinate of target point c\r\n   * @param cy y coordinate of target point c\r\n   * @param cz z coordinate of target point c\r\n   */\r\n  public addCrossProductToTargetsInPlace(ax: number, ay: number, az: number, bx: number, by: number, bz: number, cx: number, cy: number, cz: number) {\r\n    const ux = bx - ax;\r\n    const uy = by - ay;\r\n    const uz = bz - az;\r\n    const vx = cx - ax;\r\n    const vy = cy - ay;\r\n    const vz = cz - az;\r\n    this.x += uy * vz - uz * vy;\r\n    this.y += uz * vx - ux * vz;\r\n    this.z += ux * vy - uy * vx;\r\n  }\r\n  /**\r\n   * Return the cross product of the vectors from origin to pointA and pointB.\r\n   *\r\n   * * the result is a vector\r\n   * * the result is perpendicular to both vectors, with right hand orientation\r\n   * * the magnitude of the vector is twice the area of the triangle.\r\n   */\r\n  public static createCrossProductToPoints(origin: XYAndZ, pointA: XYAndZ, pointB: XYAndZ, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(pointA.x - origin.x, pointA.y - origin.y, pointA.z - origin.z, pointB.x - origin.x, pointB.y - origin.y, pointB.z - origin.z, result);\r\n  }\r\n  /**\r\n   * Return a vector defined by polar coordinates distance and angle from x axis\r\n   * @param r distance measured from origin\r\n   * @param theta angle from x axis to the vector (in xy plane)\r\n   * @param z optional z coordinate\r\n   */\r\n  public static createPolar(r: number, theta: Angle, z?: number): Vector3d {\r\n    return Vector3d.create(r * theta.cos(), r * theta.sin(), z);\r\n  }\r\n  /**\r\n   * Return a vector defined in spherical coordinates.\r\n   * @param r sphere radius\r\n   * @param theta angle in xy plane\r\n   * @param phi angle from xy plane to the vector\r\n   */\r\n  public static createSpherical(r: number, theta: Angle, phi: Angle): Vector3d {\r\n    const cosPhi = phi.cos();\r\n    return Vector3d.create(cosPhi * r * theta.cos(), cosPhi * r * theta.sin(), phi.sin());\r\n  }\r\n  /**\r\n   * Convert json to Vector3d.  Accepted forms are:\r\n   * * `[1,2,3]` --- array of numbers\r\n   * *  array of numbers: [x,y,z]\r\n   * *  object with x,y, and (optional) z as numeric properties {x: xValue, y: yValue, z: zValue}\r\n   * @param json json value.\r\n   */\r\n\r\n  public static fromJSON(json?: XYZProps): Vector3d { const val = new Vector3d(); val.setFromJSON(json); return val; }\r\n  /** Copy contents from another Point3d, Point2d, Vector2d, or Vector3d */\r\n  public static createFrom(data: XYAndZ | XAndY | Float64Array, result?: Vector3d): Vector3d {\r\n    if (data instanceof Float64Array) {\r\n      let x = 0;\r\n      let y = 0;\r\n      let z = 0;\r\n      if (data.length > 0)\r\n        x = data[0];\r\n      if (data.length > 1)\r\n        y = data[1];\r\n      if (data.length > 2)\r\n        z = data[2];\r\n      return Vector3d.create(x, y, z, result);\r\n    }\r\n    return Vector3d.create(data.x, data.y, XYZ.hasZ(data) ? data.z : 0.0, result);\r\n  }\r\n  /**\r\n   * Return a vector defined by start and end points (end - start).\r\n   * @param start start point for vector\r\n   * @param end end point for vector\r\n   * @param result optional result\r\n   */\r\n  public static createStartEnd(start: XYAndZ, end: XYAndZ, result?: Vector3d): Vector3d {\r\n    if (result) {\r\n      result.set(end.x - start.x, end.y - start.y, end.z - start.z);\r\n      return result;\r\n    }\r\n    return new Vector3d(end.x - start.x, end.y - start.y, end.z - start.z);\r\n  }\r\n  /**\r\n   * Return a vector (optionally in preallocated result, otherwise newly created) from [x0,y0,z0] to [x1,y1,z1]\r\n   * @param x0 start point x coordinate\r\n   * @param y0 start point y coordinate\r\n   * @param z0 start point z coordinate\r\n   * @param x1 end point x coordinate\r\n   * @param y1 end point y coordinate\r\n   * @param z1 end point z coordinate\r\n   * @param result optional result vector\r\n   */\r\n  public static createStartEndXYZXYZ(x0: number, y0: number, z0: number, x1: number, y1: number, z1: number, result?: Vector3d): Vector3d {\r\n    return this.create(x1 - x0, y1 - y0, z1 - z0, result);\r\n  }\r\n  /**\r\n   * Return a vector which is the input vector rotated around the axis vector.\r\n   * @param vector initial vector\r\n   * @param axis axis of rotation\r\n   * @param angle angle of rotation.  If undefined, 90 degrees is implied\r\n   * @param result optional result vector\r\n   * @returns undefined if axis has no length.\r\n   */\r\n  public static createRotateVectorAroundVector(vector: Vector3d, axis: Vector3d, angle?: Angle): Vector3d | undefined {\r\n    // Rodriguez formula, https://en.wikipedia.org/wiki/Rodrigues'_rotation_formula\r\n    const unitAxis = axis.normalize();\r\n    if (unitAxis) {\r\n      const xProduct = unitAxis.crossProduct(vector);\r\n      let c, s;\r\n      if (angle) {\r\n        c = angle.cos();\r\n        s = angle.sin();\r\n      } else {\r\n        c = 0.0;\r\n        s = 1.0;\r\n      }\r\n      return Vector3d.createAdd3Scaled(vector, c, xProduct, s, unitAxis, unitAxis.dotProduct(vector) * (1.0 - c));\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Set (replace) xzz components so they are a vector from point0 to point1\r\n   * @param point0 start point of computed vector\r\n   * @param point1 end point of computed vector.\r\n   */\r\n  public setStartEnd(point0: XYAndZ, point1: XYAndZ) {\r\n    this.x = point1.x - point0.x;\r\n    this.y = point1.y - point0.y;\r\n    this.z = point1.z - point0.z;\r\n  }\r\n  /** Return a vector with 000 xyz parts. */\r\n  public static createZero(result?: Vector3d): Vector3d { return Vector3d.create(0, 0, 0, result); }\r\n  /** Return a unit X vector optionally multiplied by a scale  */\r\n  public static unitX(scale: number = 1): Vector3d { return new Vector3d(scale, 0, 0); }\r\n  /** Return a unit Y vector  */\r\n  public static unitY(scale: number = 1): Vector3d { return new Vector3d(0, scale, 0); }\r\n  /** Return a unit Z vector  */\r\n  public static unitZ(scale: number = 1): Vector3d { return new Vector3d(0, 0, scale); }\r\n  /** Divide by denominator, but return undefined if denominator is zero. */\r\n  public safeDivideOrNull(denominator: number, result?: Vector3d): Vector3d | undefined {\r\n    if (denominator !== 0.0) {\r\n      return this.scale(1.0 / denominator, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a pair object containing (a) property `v` which is a unit vector in the direction\r\n   * of the input and (b) property mag which is the magnitude (length) of the input (instance) prior to normalization.\r\n   * If the instance (input) is a near zero length the `v` property of the output is undefined.\r\n   * @param result optional result.\r\n   */\r\n  public normalizeWithLength(result?: Vector3d): {\r\n    v: Vector3d | undefined;\r\n    mag: number;\r\n  } {\r\n    const magnitude = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    result = result ? result : new Vector3d();\r\n    return { v: this.safeDivideOrNull(magnitude, result), mag: magnitude };\r\n  }\r\n  /**\r\n   * Return a unit vector parallel with this.  Return undefined if this.magnitude is near zero.\r\n   * @param result optional result.\r\n   */\r\n  public normalize(result?: Vector3d): Vector3d | undefined { return this.normalizeWithLength(result).v; }\r\n  /**\r\n   * If this vector has nonzero length, divide by the length to change to a unit vector.\r\n   * @returns true if normalization completed.\r\n   */\r\n  public normalizeInPlace(): boolean {\r\n    const a = Geometry.inverseMetricDistance(this.magnitude());\r\n    if (!a)\r\n      return false;\r\n    this.x *= a;\r\n    this.y *= a;\r\n    this.z *= a;\r\n    return true;\r\n  }\r\n  /** Return the fractional projection of spaceVector onto this */\r\n  public fractionOfProjectionToVector(target: Vector3d, defaultFraction: number = 0): number {\r\n    const numerator = this.dotProduct(target);\r\n    const denominator = target.magnitudeSquared();\r\n    if (denominator < Geometry.smallMetricDistanceSquared)\r\n      return defaultFraction;\r\n    return numerator / denominator;\r\n  }\r\n  /** Return a new vector with components negated from the calling instance.\r\n   * @param result optional result vector.\r\n   */\r\n  public negate(result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = -this.x;\r\n    result.y = -this.y;\r\n    result.z = -this.z;\r\n    return result;\r\n  }\r\n  /** Return a vector same length as this but rotate 90 degrees CCW */\r\n  public rotate90CCWXY(result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    // save x,y to allow aliasing ..\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    result.z = this.z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a vector which is in the xy plane, perpendicular ot the xy part of this vector, and of unit length.\r\n   * * If the xy part is 00, the return is the rotated (but not normalized) xy parts of this vector.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public unitPerpendicularXY(result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result.x = -yy;\r\n    result.y = xx;\r\n    result.z = 0.0;\r\n    const d2: number = xx * xx + yy * yy;\r\n    if (d2 !== 0.0) {\r\n      const a = 1.0 / Math.sqrt(d2);\r\n      result.x *= a;\r\n      result.y *= a;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Rotate the xy parts of this vector around the z axis.\r\n   * * z is taken unchanged to the result.\r\n   * @param angle angle to rotate\r\n   * @param result optional preallocated result\r\n   */\r\n  public rotateXY(angle: Angle, result?: Vector3d): Vector3d {\r\n    const s = angle.sin();\r\n    const c = angle.cos();\r\n    const xx: number = this.x;\r\n    const yy: number = this.y;\r\n    result = result ? result : new Vector3d();\r\n    result.x = xx * c - yy * s;\r\n    result.y = xx * s + yy * c;\r\n    result.z = this.z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a (new or optionally preallocated) vector that is rotated 90 degrees in the plane of this vector and the target vector.\r\n   * @param target Second vector which deifnes the plane of rotation.\r\n   * @param result optional preallocated vector for result.\r\n   * @returns rotated vector, or undefined if the crossproduct of this and the the target cannot be normalized (i.e. if the target and this are colinear)\r\n   */\r\n  public rotate90Towards(target: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    const normal = this.crossProduct(target).normalize();\r\n    return normal ? normal.crossProduct(this, result) : undefined;\r\n  }\r\n  /** Rotate this vector 90 degrees around an axis vector.\r\n   * @returns the (new or optionally reused result) rotated vector, or undefined if the axis vector cannot be normalized.\r\n   */\r\n  public rotate90Around(axis: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    const unitNormal = axis.normalize();\r\n    return unitNormal ? unitNormal.crossProduct(this).plusScaled(unitNormal, unitNormal.dotProduct(this), result) : undefined;\r\n  }\r\n  /**\r\n   * Return a vector computed at fractional position between this vector and vectorB\r\n   * @param fraction fractional position.  0 is at `this`.  1 is at `vectorB`.  True fractions are \"between\", negatives are \"before this\", beyond 1 is \"beyond vectorB\".\r\n   * @param vectorB second vector\r\n   * @param result optional preallocated result.\r\n   */\r\n  public interpolate(fraction: number, vectorB: Vector3d, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    if (fraction <= 0.5) {\r\n      result.x = this.x + fraction * (vectorB.x - this.x);\r\n      result.y = this.y + fraction * (vectorB.y - this.y);\r\n      result.z = this.z + fraction * (vectorB.z - this.z);\r\n    } else {\r\n      const t: number = fraction - 1.0;\r\n      result.x = vectorB.x + t * (vectorB.x - this.x);\r\n      result.y = vectorB.y + t * (vectorB.y - this.y);\r\n      result.z = vectorB.z + t * (vectorB.z - this.z);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the vector sum `this - vector`\r\n   * @param vector right side of addition.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public plus(vector: XYAndZ, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vector.x;\r\n    result.y = this.y + vector.y;\r\n    result.z = this.z + vector.z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the vector difference `this - vector`\r\n   * @param vector right side of subtraction.\r\n   * @param result optional preallocated result.\r\n   */\r\n  public minus(vector: XYAndZ, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x - vector.x;\r\n    result.y = this.y - vector.y;\r\n    result.z = this.z - vector.z;\r\n    return result;\r\n  }\r\n  /** Return vector + vector * scalar */\r\n  public plusScaled(vector: XYAndZ, scaleFactor: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vector.x * scaleFactor;\r\n    result.y = this.y + vector.y * scaleFactor;\r\n    result.z = this.z + vector.z * scaleFactor;\r\n    return result;\r\n  }\r\n\r\n  /** Return the (strongly typed Vector3d) `this Vector3d + vectorA * scalarA + vectorB * scalarB` */\r\n  public plus2Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB;\r\n    result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB;\r\n    return result;\r\n  }\r\n\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */\r\n  public plus3Scaled(vectorA: XYAndZ, scalarA: number, vectorB: XYAndZ, scalarB: number, vectorC: XYAndZ, scalarC: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x + vectorA.x * scalarA + vectorB.x * scalarB + vectorC.x * scalarC;\r\n    result.y = this.y + vectorA.y * scalarA + vectorB.y * scalarB + vectorC.y * scalarC;\r\n    result.z = this.z + vectorA.z * scalarA + vectorB.z * scalarB + vectorC.z * scalarC;\r\n    return result;\r\n  }\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` */\r\n  public static createAdd2Scaled(vectorA: XYAndZ, scaleA: number, vectorB: XYAndZ, scaleB: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB, vectorA.y * scaleA + vectorB.y * scaleB, vectorA.z * scaleA + vectorB.z * scaleB, result);\r\n  }\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scalarA + vectorB * scalarB` with all components presented as numbers */\r\n  public static createAdd2ScaledXYZ(ax: number, ay: number, az: number, scaleA: number, bx: number, by: number, bz: number, scaleB: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(ax * scaleA + bx * scaleB, ay * scaleA + by * scaleB, az * scaleA + bz * scaleB, result);\r\n  }\r\n  /** Return the (strongly typed Vector3d) `thisVector3d + vectorA * scaleA + vectorB * scaleB + vectorC * scaleC` */\r\n  public static createAdd3Scaled(vectorA: XYAndZ, scaleA: number, vectorB: XYAndZ, scaleB: number, vectorC: XYAndZ, scaleC: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.create(vectorA.x * scaleA + vectorB.x * scaleB + vectorC.x * scaleC, vectorA.y * scaleA + vectorB.y * scaleB + vectorC.y * scaleC, vectorA.z * scaleA + vectorB.z * scaleB + vectorC.z * scaleC, result);\r\n  }\r\n  /** Return vector * scalar */\r\n  public scale(scale: number, result?: Vector3d): Vector3d {\r\n    result = result ? result : new Vector3d();\r\n    result.x = this.x * scale;\r\n    result.y = this.y * scale;\r\n    result.z = this.z * scale;\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a (optionally new or reused) vector in the direction of `this` but with specified length.\r\n   * @param length desired length of vector\r\n   * @param result optional preallocated result\r\n   */\r\n  public scaleToLength(length: number, result?: Vector3d): Vector3d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitude());\r\n    if (mag === 0)\r\n      return undefined;\r\n    return this.scale(length / mag, result);\r\n  }\r\n  /** Compute the cross product of this vector with `vectorB`.   Immediately pass it to `normalize`.\r\n   * @param vectorB second vector for cross product.\r\n   * @returns see `Vector3d` method `normalize()` for error condition.\r\n   */\r\n  public unitCrossProduct(vectorB: Vector3d, result?: Vector3d): Vector3d | undefined {\r\n    return this.crossProduct(vectorB, result).normalize(result);\r\n  }\r\n  /**\r\n   * Compute the cross product of this vector with `vectorB`.   Normalize it, using given xyz as default if length is zero.\r\n   * @param vectorB second vector of cross product\r\n   * @param x x value for default result\r\n   * @param y y value for default result\r\n   * @param z z value for default result\r\n   * @param result optional pre-allocated result.\r\n   */\r\n  public unitCrossProductWithDefault(vectorB: Vector3d, x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    const unit = this.crossProduct(vectorB, result).normalize(result);\r\n    if (unit === undefined)\r\n      return Vector3d.create(x, y, z, result);\r\n    return unit;\r\n  }\r\n  /**\r\n   * Normalize this vector, using given xyz as default if length is zero.\r\n   * @param x x value for default result\r\n   * @param y y value for default result\r\n   * @param z z value for default result\r\n   * @param result optional pre-allocated result.\r\n   */\r\n  public normalizeWithDefault(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    const unit = this.normalize(result);\r\n    if (unit)\r\n      return unit;\r\n    return Vector3d.create(x, y, z, result);\r\n  }\r\n  /**\r\n   * Try to normalize (divide by magnitude), storing the result in place.\r\n   * @param smallestMagnitude smallest magnitude allowed as divisor.\r\n   * @returns false if magnitude is too small.  In this case the vector is unchanged.\r\n   */\r\n  public tryNormalizeInPlace(smallestMagnitude: number = Geometry.smallMetricDistance): boolean {\r\n    const a = this.magnitude();\r\n    if (a < smallestMagnitude || a === 0.0)\r\n      return false;\r\n    this.scaleInPlace(1.0 / a);\r\n    return true;\r\n  }\r\n  /**\r\n   * Compute cross product with `vectorB`.\r\n   * @param vectorB second vector for cross product.\r\n   * @param productLength desired length of result vector.\r\n   * @param result optional preallocated vector\r\n   * @return undefined if the cross product is near zero length.\r\n   */\r\n  public sizedCrossProduct(vectorB: Vector3d, productLength: number, result?: Vector3d): Vector3d | undefined {\r\n    result = this.crossProduct(vectorB, result);\r\n    if (result.tryNormalizeInPlace()) {\r\n      result.scaleInPlace(productLength);\r\n      return result;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Compute the squared magnitude of a cross product (without allocating a temporary vector object)\r\n   * @param vectorB second vector of cross product\r\n   * @returns the squared magnitude of the cross product of this instance with vectorB.\r\n   */\r\n  public crossProductMagnitudeSquared(vectorB: XYAndZ): number {\r\n    const xx = this.y * vectorB.z - this.z * vectorB.y;\r\n    const yy = this.z * vectorB.x - this.x * vectorB.z;\r\n    const zz = this.x * vectorB.y - this.y * vectorB.x;\r\n    return xx * xx + yy * yy + zz * zz;\r\n  }\r\n  /**\r\n   * Compute the  magnitude of a cross product (without allocating a temporary vector object)\r\n   * @param vectorB second vector of cross product\r\n   * @returns the  magnitude of the cross product of this instance with vectorB.\r\n   */\r\n  public crossProductMagnitude(vectorB: XYAndZ): number {\r\n    return Math.sqrt(this.crossProductMagnitudeSquared(vectorB));\r\n  }\r\n  /** Return the dot product of this vector with vectorB.\r\n   * @param vectorB second vector of cross product\r\n   * @returns the dot product of this instance with vectorB\r\n   */\r\n  public dotProduct(vectorB: XYAndZ): number {\r\n    return this.x * vectorB.x + this.y * vectorB.y + this.z * vectorB.z;\r\n  }\r\n  /**\r\n   * Returns the dot product of this vector with the with vector from pointA to pointB\r\n   * @param pointA start point of second vector of dot product\r\n   * @param pointB end point of second vector of dot product\r\n   */\r\n  public dotProductStartEnd(pointA: XYAndZ, pointB: XYAndZ): number {\r\n    return this.x * (pointB.x - pointA.x)\r\n      + this.y * (pointB.y - pointA.y)\r\n      + this.z * (pointB.z - pointA.z);\r\n  }\r\n\r\n  /**\r\n   * Returns the dot product with vector (pointB - pointA * pointB.w)\r\n   * * That is, pointA is weighted to weight of pointB.\r\n   * * If pointB.w is zero, the homogeneous pointB is a simple vector\r\n   * * If pointB.w is nonzero, the vector \"from A to B\" is not physical length.\r\n   */\r\n  public dotProductStart3dEnd4d(pointA: Point3d, pointB: Point4d): number {\r\n    const w = pointB.w;\r\n    return this.x * (pointB.x - pointA.x * w)\r\n      + this.y * (pointB.y - pointA.y * w)\r\n      + this.z * (pointB.z - pointA.z * w);\r\n  }\r\n\r\n  /** Cross product with vector from pointA to pointB */\r\n  public crossProductStartEnd(pointA: Point3d, pointB: Point3d, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(this.x, this.y, this.z, pointB.x - pointA.x, pointB.y - pointA.y, pointB.z - pointA.z, result);\r\n  }\r\n  /** Cross product (xy parts only) with vector from pointA to pointB */\r\n  public crossProductStartEndXY(pointA: Point3d, pointB: Point3d): number {\r\n    return Geometry.crossProductXYXY(this.x, this.y, pointB.x - pointA.x, pointB.y - pointA.y);\r\n  }\r\n  /** Dot product with vector from pointA to pointB, with pointB given as x,y,z */\r\n  public dotProductStartEndXYZ(pointA: Point3d, x: number, y: number, z: number): number {\r\n    return this.x * (x - pointA.x)\r\n      + this.y * (y - pointA.y)\r\n      + this.z * (z - pointA.z);\r\n  }\r\n  /** Dot product with vector from pointA to pointB, with pointB given as (weighted) x,y,z,w\r\n   * * pointB is a homogeneous point that has to be unweighted\r\n   * * if the weight is near zero metric, the return is zero.\r\n   */\r\n  public dotProductStartEndXYZW(pointA: Point3d, x: number, y: number, z: number, w: number): number {\r\n    if (Geometry.isSmallMetricDistance(w))\r\n      return 0.0;\r\n    const dw = 1.0 / w;\r\n    return this.x * (dw * x - pointA.x)\r\n      + this.y * (dw * y - pointA.y)\r\n      + this.z * (dw * z - pointA.z);\r\n  }\r\n  /** Return the dot product of the instance and vectorB, using only the x and y parts. */\r\n  public dotProductXY(vectorB: Vector3d): number {\r\n    return this.x * vectorB.x + this.y * vectorB.y;\r\n  }\r\n  /**\r\n   * Dot product with vector (x,y,z)\r\n   * @param x x component for dot product\r\n   * @param y y component for dot product\r\n   * @param z z component for dot product\r\n   */\r\n  public dotProductXYZ(x: number, y: number, z: number = 0): number {\r\n    return this.x * x + this.y * y + this.z * z;\r\n  }\r\n  /** Return the triple product of the instance, vectorB, and vectorC  */\r\n  public tripleProduct(vectorB: Vector3d, vectorC: Vector3d): number {\r\n    return Geometry.tripleProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, vectorC.x, vectorC.y, vectorC.z);\r\n  }\r\n  /** Return the cross product of the instance and vectorB, using only the x and y parts. */\r\n  public crossProductXY(vectorB: Vector3d): number {\r\n    return this.x * vectorB.y - this.y * vectorB.x;\r\n  }\r\n  /**\r\n   * Return the cross product of this vector and vectorB.\r\n   * @param vectorB second vector of cross product\r\n   * @param result optional preallocated result.\r\n   */\r\n  public crossProduct(vectorB: Vector3d, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(this.x, this.y, this.z, vectorB.x, vectorB.y, vectorB.z, result);\r\n  }\r\n  /**\r\n   * return cross product of `this` with the vector `(x, y, z)`\r\n   * @param x x component of second vector\r\n   * @param y y component of second vector\r\n   * @param z z component of second vector\r\n   * @param result computed cross product (new Vector3d).\r\n   */\r\n  public crossProductXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    return Vector3d.createCrossProduct(this.x, this.y, this.z, x, y, z, result);\r\n  }\r\n\r\n  /**\r\n   * Return the (Strongly typed) angle from this vector to vectorB.\r\n   * * The returned angle is always positive and no larger than 180 degrees (PI radians)\r\n   * * The returned angle is \"in the plane containing the two vectors\"\r\n   * * Use `planarAngleTo`, `signedAngleTo`, `angleToXY` to take have angle measured in specific plane.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public angleTo(vectorB: Vector3d): Angle {\r\n    return Angle.createAtan2(this.crossProductMagnitude(vectorB), this.dotProduct(vectorB));\r\n  }\r\n  /**\r\n   * Return the (Strongly typed) angle from this vector to vectorB,using only the xy parts.\r\n   * * The returned angle can range from negative 180 degrees (negative PI radians) to positive 180 degrees (positive PI radians), not closed on the negative side.\r\n   * * Use `planarAngleTo`, `signedAngleTo`, `angleToXY` to take have angle measured in other planes.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public angleToXY(vectorB: Vector3d): Angle {\r\n    return Angle.createAtan2(this.crossProductXY(vectorB), this.dotProductXY(vectorB));\r\n  }\r\n  /**\r\n   * Return the (radians as a simple number, not strongly typed Angle) radians from this vector to vectorB.\r\n   * * The returned angle can be positive or negative, with magnitude no larger than PI radians\r\n   * * Use signedRadiansTo` to take have angle measured in other planes.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public planarRadiansTo(vector: Vector3d, planeNormal: Vector3d): number {\r\n    const square = planeNormal.dotProduct(planeNormal);\r\n    if (square === 0.0)\r\n      return 0.0;\r\n    const factor = 1.0 / square;\r\n    const projection0: Vector3d = this.plusScaled(planeNormal, -this.dotProduct(planeNormal) * factor);\r\n    const projection1: Vector3d = vector.plusScaled(planeNormal, -vector.dotProduct(planeNormal) * factor);\r\n    return projection0.signedRadiansTo(projection1, planeNormal);\r\n  }\r\n  /**\r\n   * Return the (as strongly typed Angle) Angle from this vector to vectorB.\r\n   * * The returned angle can range from negative PI to positive PI (not closed on negative side)\r\n   * * Use signedRadiansTo` to take have angle measured in other planes.\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public planarAngleTo(vector: Vector3d, planeNormal: Vector3d): Angle {\r\n    return Angle.createRadians(this.planarRadiansTo(vector, planeNormal));\r\n  }\r\n\r\n  /**\r\n   * Return the (simple number of radians, not Strongly typed Angle) angle from this vector to vectorB, measured in the plane containing both, with vectorW indicating which side to view to control sign of the angle.\r\n   * * The returned angle can range from negative PI to positive PI (not closed on negative side)\r\n   * * The returned angle is \"in the plane containing the two vectors\"\r\n   * * `vectorW` distinguishes between the sides of the plane, but does not have to be perpendicular.\r\n   * * The returned angle has the same sign as vectorW dot product (thisVector cross vectorB)\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public signedRadiansTo(vector1: Vector3d, vectorW: Vector3d): number {\r\n    const p = this.crossProduct(vector1);\r\n    const theta = Math.atan2(p.magnitude(), this.dotProduct(vector1));\r\n    if (vectorW.dotProduct(p) < 0.0)\r\n      return -theta;\r\n    else\r\n      return theta;\r\n  }\r\n  /**\r\n   * Return the (strongly typed Angle) angle from this vector to vectorB, measured in the plane containing both, with vectorW indicating which side to view to control sign of the angle.\r\n   * * The returned angle can range from negative 180 degrees (negative PI radians) to positive 180 degrees (positive PI radians), not closed on the negative side.\r\n   * * The returned angle is \"in the plane containing the two vectors\"\r\n   * * `vectorW` distinguishes between the sides of the plane, but does not have to be perpendicular.\r\n   * * The returned angle has the same sign as vectorW dot product (thisVector cross vectorB)\r\n   * @param vectorB target vector of rotation.\r\n   */\r\n  public signedAngleTo(vector1: Vector3d, vectorW: Vector3d): Angle { return Angle.createRadians(this.signedRadiansTo(vector1, vectorW)); }\r\n  /*  smallerUnorientedAngleTo(vectorB: Vector3d): Angle { }\r\n    signedAngleTo(vectorB: Vector3d, upVector: Vector3d): Angle { }\r\n    // sectors\r\n    isInSmallerSector(vectorA: Vector3d, vectorB: Vector3d): boolean { }\r\n    isInCCWSector(vectorA: Vector3d, vectorB: Vector3d, upVector: Vector3d): boolean { }\r\n    */\r\n  /**\r\n   * Test if this vector is parallel to other.\r\n   * @param other second vector in comparison\r\n   * @param oppositeIsParallel if the vectors are on the same line but in opposite directions, return this value.\r\n   * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\r\n   */\r\n  public isParallelTo(other: Vector3d, oppositeIsParallel: boolean = false, returnValueIfAnInputIsZeroLength: boolean = false): boolean {\r\n    const a2 = this.magnitudeSquared();\r\n    const b2 = other.magnitudeSquared();\r\n    // we know both are 0 or positive -- no need for\r\n    if (a2 < Geometry.smallMetricDistanceSquared || b2 < Geometry.smallMetricDistanceSquared)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const dot = this.dotProduct(other);\r\n    if (dot < 0.0 && !oppositeIsParallel)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const cross2 = this.crossProductMagnitudeSquared(other);\r\n    /* a2,b2,cross2 are squared lengths of respective vectors */\r\n    /* cross2 = sin^2(theta) * a2 * b2 */\r\n    /* For small theta, sin^2(theta)~~theta^2 */\r\n    return cross2 <= Geometry.smallAngleRadiansSquared * a2 * b2;\r\n  }\r\n  /**\r\n   * Test if this vector is perpendicular to other.\r\n   * @param other second vector in comparison\r\n   * @param returnValueIfAnInputIsZeroLength if either vector is near zero length, return this value.\r\n   */\r\n  public isPerpendicularTo(other: Vector3d, returnValueIfAnInputIsZeroLength: boolean = false): boolean {\r\n    const aa = this.magnitudeSquared();\r\n    if (aa < Geometry.smallMetricDistanceSquared)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const bb = other.magnitudeSquared();\r\n    if (bb < Geometry.smallMetricDistanceSquared)\r\n      return returnValueIfAnInputIsZeroLength;\r\n    const ab = this.dotProduct(other);\r\n    return ab * ab <= Geometry.smallAngleRadiansSquared * aa * bb;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\n/* tslint:disable:variable-name jsdoc-format no-empty */\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\nimport { XYAndZ, XAndY } from \"./XYZProps\";\r\nimport { Point3d, Vector3d, XYZ } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\n\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\r\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\n/**\r\n * The `NumberArray` class contains static methods that act on arrays of numbers.\r\n * @public\r\n */\r\nexport class NumberArray {\r\n  /** return the sum of values in an array,   The summation is done with correction terms which\r\n   * improves last-bit numeric accuracy.\r\n   */\r\n  public static preciseSum(data: number[]) {\r\n    const n = data.length;\r\n    if (n === 0)\r\n      return 0.0;\r\n    let sum = data[0];\r\n    let c = 0.0;\r\n    let y: number;\r\n    let t: number;\r\n    for (let i = 1; i < n; i++) {\r\n      y = data[i] - c;\r\n      t = sum + y;\r\n      c = (t - sum) - y;\r\n      sum = t;\r\n    }\r\n    return sum;\r\n  }\r\n  /** Return true if arrays have identical counts and equal entries (using `!==` comparison) */\r\n  public static isExactEqual(dataA: any[] | Float64Array | undefined, dataB: any[] | Float64Array | undefined) {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (dataA[i] !== dataB[i])\r\n          return false;\r\n      return true;\r\n    }\r\n    return (!dataA && !dataB);\r\n  }\r\n  /** Return true if arrays have identical counts and entries equal within tolerance */\r\n  public static isAlmostEqual(\r\n    dataA: number[] | Float64Array | undefined,\r\n    dataB: number[] | Float64Array | undefined,\r\n    tolerance: number) {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (Math.abs(dataA[i] - dataB[i]) >= tolerance) return false;\r\n      return true;\r\n    }\r\n    return (!dataA && !dataB);\r\n  }\r\n\r\n  /** return the sum of numbers in an array.  Note that \"PreciseSum\" may be more accurate. */\r\n  public static sum(data: number[] | Float64Array) {\r\n    let sum = 0;\r\n    for (const x of data) { sum += x; }\r\n    return sum;\r\n  }\r\n  /** test if coordinate x appears (to tolerance by `Geometry.isSameCoordinate`) in this array of numbers */\r\n  public static isCoordinateInArray(x: number, data: number[] | undefined): boolean {\r\n    if (data) {\r\n      for (const y of data) { if (Geometry.isSameCoordinate(x, y)) return true; }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the max absolute value in a array of numbers. */\r\n  public static maxAbsArray(values: number[]) {\r\n    const arrLen = values.length;\r\n    if (arrLen === 0) {\r\n      return 0.0;\r\n    }\r\n    let a = Math.abs(values[0]);\r\n    for (let i = 1; i < arrLen; i++) {\r\n      const b = Math.abs(values[i]);\r\n      if (a < b) {\r\n        a = b;\r\n      }\r\n    }\r\n    return a;\r\n  }\r\n  /** return the max abssolute value of a pair of numbers */\r\n  public static maxAbsTwo(a1: number, a2: number) {\r\n    a1 = Math.abs(a1);\r\n    a2 = Math.abs(a2);\r\n    return (a1 > a2) ? a1 : a2;\r\n  }\r\n  /** Return the max absolute difference between corresponding entries in two arrays of numbers\r\n   * * If sizes are mismatched, only the smaller length is tested.\r\n   */\r\n  public static maxAbsDiff(dataA: number[], dataB: number[]): number {\r\n    let a = 0.0;\r\n    const n = Math.min(dataA.length, dataB.length);\r\n    for (let i = 0; i < n; i++) { a = Math.max(a, Math.abs(dataA[i] - dataB[i])); }\r\n    return a;\r\n  }\r\n\r\n  /** Return the max absolute difference between corresponding entries in two Float64Array\r\n   * * If sizes are mismatched, only the smaller length is tested.\r\n   */\r\n  public static maxAbsDiffFloat64(dataA: Float64Array, dataB: Float64Array): number {\r\n    let a = 0.0;\r\n    const n = Math.min(dataA.length, dataB.length);\r\n    for (let i = 0; i < n; i++) { a = Math.max(a, Math.abs(dataA[i] - dataB[i])); }\r\n    return a;\r\n  }\r\n\r\n}\r\n/**\r\n * The `Point2dArray` class contains static methods that act on arrays of 2d points.\r\n * @public\r\n */\r\nexport class Point2dArray {\r\n  /** Return true if arrays have same length and matching coordinates. */\r\n  public static isAlmostEqual(dataA: undefined | Point2d[], dataB: undefined | Point2d[]): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++) {\r\n        if (!dataA[i].isAlmostEqual(dataB[i]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return (!dataA && !dataB);\r\n  }\r\n  /**\r\n   * Return an array containing clones of the Point3d data[]\r\n   * @param data source data\r\n   */\r\n  public static clonePoint2dArray(data: Point2d[]): Point2d[] {\r\n    return data.map((p: Point2d) => p.clone());\r\n  }\r\n  /**\r\n   * Return the number of points when trailing points that match point 0 are excluded.\r\n   * @param data array of XAndY points.\r\n   */\r\n  public static pointCountExcludingTrailingWraparound(data: XAndY[]): number {\r\n    let n = data.length;\r\n    if (n < 2)\r\n      return n;\r\n    const x0 = data[0].x;\r\n    const y0 = data[0].y;\r\n    while (n > 1) {\r\n      if (!Geometry.isSameCoordinate(data[n - 1].x, x0) || !Geometry.isSameCoordinate(data[n - 1].y, y0))\r\n        return n;\r\n      n--;\r\n    }\r\n    return n;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * The `Vector3ddArray` class contains static methods that act on arrays of 2d vectors.\r\n * @public\r\n */\r\nexport class Vector3dArray {\r\n  /** Return true if arrays have same length and matching coordinates. */\r\n  public static isAlmostEqual(dataA: undefined | Vector3d[], dataB: undefined | Vector3d[]): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      for (let i = 0; i < dataA.length; i++)\r\n        if (!dataA[i].isAlmostEqual(dataB[i]))\r\n          return false;\r\n      return true;\r\n    }\r\n    return (!dataA && !dataB);\r\n  }\r\n  /**\r\n   * Return an array containing clones of the Vector3d data[]\r\n   * @param data source data\r\n   */\r\n  public static cloneVector3dArray(data: XYAndZ[]): Vector3d[] {\r\n    return data.map((p: XYAndZ) => Vector3d.create(p.x, p.y, p.z));\r\n  }\r\n}\r\n\r\n/**\r\n * The `Point4dArray` class contains static methods that act on arrays of 4d points.\r\n * @public\r\n */\r\nexport class Point4dArray {\r\n  /** pack each point and its corresponding weight into a buffer of xyzwxyzw... */\r\n  public static packPointsAndWeightsToFloat64Array(points: Point3d[], weights: number[], result?: Float64Array): Float64Array {\r\n    result = result ? result : new Float64Array(4 * points.length);\r\n    let i = 0;\r\n    let k = 0;\r\n    for (k = 0; k < points.length; k++) {\r\n      result[i++] = points[k].x;\r\n      result[i++] = points[k].y;\r\n      result[i++] = points[k].z;\r\n      result[i++] = weights[k];\r\n    }\r\n    return result;\r\n  }\r\n  /** pack x,y,z,w in Float64Array. */\r\n  public static packToFloat64Array(data: Point4d[], result?: Float64Array): Float64Array {\r\n    result = result ? result : new Float64Array(4 * data.length);\r\n    let i = 0;\r\n    for (const p of data) {\r\n      result[i++] = p.x;\r\n      result[i++] = p.y;\r\n      result[i++] = p.z;\r\n      result[i++] = p.w;\r\n    }\r\n    return result;\r\n  }\r\n  /** unpack from xyzwxyzw... to array of Point4d */\r\n  public static unpackToPoint4dArray(data: Float64Array): Point4d[] {\r\n    const result = [];\r\n    for (let i = 0; i + 3 < data.length; i += 4) {\r\n      result.push(Point4d.create(data[i], data[i + 1], data[i + 2], data[i + 3]));\r\n    }\r\n    return result;\r\n  }\r\n  /** unpack from xyzwxyzw... array to array of Point3d and array of weight.\r\n   */\r\n  public static unpackFloat64ArrayToPointsAndWeights(data: Float64Array, points: Point3d[], weights: number[],\r\n    pointFormatter: (x: number, y: number, z: number) => any = Point3d.create) {\r\n    points.length = 0;\r\n    weights.length = 0;\r\n    for (let i = 0; i + 3 < data.length; i += 4) {\r\n      points.push(pointFormatter(data[i], data[i + 1], data[i + 2]));\r\n      weights.push(data[i + 3]);\r\n    }\r\n  }\r\n  private static _workPoint4d = Point4d.create();\r\n  /**\r\n   * Multiply (and replace) each block of 4 values as a Point4d.\r\n   * @param transform transform to apply\r\n   * @param xyzw array of x,y,z,w points.\r\n   */\r\n  public static multiplyInPlace(transform: Transform, xyzw: Float64Array): void {\r\n    const numXYZW = xyzw.length;\r\n    const xyzw1 = Point4dArray._workPoint4d;\r\n    for (let i = 0; i + 3 < numXYZW; i += 4) {\r\n      transform.multiplyXYZW(xyzw[i], xyzw[i + 1], xyzw[i + 2], xyzw[i + 3], xyzw1);\r\n      xyzw[i] = xyzw1.x;\r\n      xyzw[i + 1] = xyzw1.y;\r\n      xyzw[i + 2] = xyzw1.z;\r\n      xyzw[i + 3] = xyzw1.w;\r\n    }\r\n  }\r\n  /** test for near equality of all corresponding numeric values, treated as coordinates. */\r\n  public static isAlmostEqual(dataA: Point4d[] | Float64Array | undefined, dataB: Point4d[] | Float64Array | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      if (dataA instanceof Float64Array && dataB instanceof Float64Array) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!Geometry.isSameCoordinate(dataA[i], dataB[i]))\r\n            return false;\r\n      } else if (Array.isArray(dataA) && Array.isArray(dataB)) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!dataA[i].isAlmostEqual(dataB[i]))\r\n            return false;\r\n      }\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (!dataA && !dataB);\r\n  }\r\n  /** return true iff all xyzw points' altitudes are within tolerance of the plane.*/\r\n  public static isCloseToPlane(data: Point4d[] | Float64Array, plane: Plane3dByOriginAndUnitNormal, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    if (Array.isArray(data)) {\r\n      for (const xyzw of data) {\r\n        if (Math.abs(plane.altitudeXYZW(xyzw.x, xyzw.y, xyzw.z, xyzw.w)) > tolerance)\r\n          return false;\r\n      }\r\n    } else if (data instanceof Float64Array) {\r\n      const numXYZ = data.length;\r\n      for (let i = 0; i + 2 < numXYZ; i += 4) {\r\n        if (Math.abs(plane.altitudeXYZW(data[i], data[i + 1], data[i + 2], data[i + 3])) > tolerance)\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n}\r\n/**\r\n * The `Point3dArray` class contains static methods that act on arrays of 3d points.\r\n * @public\r\n */\r\n\r\nexport class Point3dArray {\r\n  /** pack x,y,z to `Float64Array` */\r\n  public static packToFloat64Array(data: Point3d[]): Float64Array {\r\n    const result = new Float64Array(3 * data.length);\r\n    let i = 0;\r\n    for (const p of data) {\r\n      result[i++] = p.x;\r\n      result[i++] = p.y;\r\n      result[i++] = p.z;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Compute the 8 weights of trilinear mapping\r\n   * By appropriate choice of weights, this can be used for both point and derivative mappints.\r\n   * @param weights preallocated array to receive weights.\r\n   * @param u0 low u weight\r\n   * @param u1 high u weight\r\n   * @param v0 low v weight\r\n   * @param v1 high v weight\r\n   * @param w0 low w weight\r\n   * @param w1 high w weight\r\n   */\r\n  public static evaluateTrilinearWeights(weights: Float64Array, u0: number, u1: number, v0: number, v1: number, w0: number, w1: number) {\r\n\r\n    weights[0] = u0 * v0 * w0;\r\n    weights[1] = u1 * v0 * w0;\r\n    weights[2] = u0 * v1 * w0;\r\n    weights[3] = u1 * v1 * w0;\r\n    weights[4] = u0 * v0 * w1;\r\n    weights[5] = u1 * v0 * w1;\r\n    weights[6] = u0 * v1 * w1;\r\n    weights[7] = u1 * v1 * w1;\r\n  }\r\n  /**\r\n   * sum the weighted x components from a point array.\r\n   * * weights.length is the number of summed terms\r\n   * * points must have at least that length\r\n   * @param weights\r\n   * @param points\r\n   */\r\n  public static sumWeightedX(weights: Float64Array, points: Point3d[]): number {\r\n    let sum = 0.0;\r\n    const n = weights.length;\r\n    for (let i = 0; i < n; i++)\r\n      sum += weights[i] * points[i].x;\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * sum the weighted x components from a point array.\r\n   * * weights.length is the number of summed terms\r\n   * * points must have at least that length\r\n   * @param weights\r\n   * @param points\r\n   */\r\n  public static sumWeightedY(weights: Float64Array, points: Point3d[]): number {\r\n    let sum = 0.0;\r\n    const n = weights.length;\r\n    for (let i = 0; i < n; i++)\r\n      sum += weights[i] * points[i].y;\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * sum the weighted x components from a point array.\r\n   * * weights.length is the number of summed terms\r\n   * * points must have at least that length\r\n   * @param weights\r\n   * @param points\r\n   */\r\n  public static sumWeightedZ(weights: Float64Array, points: Point3d[]): number {\r\n    let sum = 0.0;\r\n    const n = weights.length;\r\n    for (let i = 0; i < n; i++)\r\n      sum += weights[i] * points[i].z;\r\n    return sum;\r\n  }\r\n\r\n  private static _weightUVW = new Float64Array(8);\r\n  private static _weightDU = new Float64Array(8);\r\n  private static _weightDV = new Float64Array(8);\r\n  private static _weightDW = new Float64Array(8);\r\n  /**\r\n   * Compute a point by trilinear mapping.\r\n   * @param points array of 8 points at corners, with x index varying fastest.\r\n   * @param result optional result point\r\n   */\r\n  public static evaluateTrilinearPoint(points: Point3d[], u: number, v: number, w: number, result?: Point3d): Point3d {\r\n    if (!result) result = Point3d.create(0, 0, 0);\r\n    this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);\r\n    let a;\r\n    for (let i = 0; i < 8; i++) {\r\n      a = this._weightUVW[i];\r\n      result.x += a * points[i].x;\r\n      result.y += a * points[i].y;\r\n      result.z += a * points[i].z;\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Compute a point and derivatives wrt uvw by trilinear mapping.\r\n   * * evaluated point is the point part of the transform\r\n   * * u,v,w derivatives are the respective columns of the matrix part of the transform.\r\n   * @param points array of 8 points at corners, with x index varying fastest.\r\n   * @param result optional result transform\r\n   */\r\n  public static evaluateTrilinearDerivativeTransform(points: Point3d[], u: number, v: number, w: number, result?: Transform): Transform {\r\n    this.evaluateTrilinearWeights(this._weightUVW, 1 - u, u, 1 - v, v, 1 - w, w);\r\n    this.evaluateTrilinearWeights(this._weightDU, -1, 1, 1 - v, v, 1 - w, w);\r\n    this.evaluateTrilinearWeights(this._weightDV, 1 - u, u, -1, 1, 1 - w, w);\r\n    this.evaluateTrilinearWeights(this._weightDW, 1 - u, u, 1 - v, v, -1, 1);\r\n    return Transform.createRowValues(\r\n      this.sumWeightedX(this._weightDU, points), this.sumWeightedX(this._weightDV, points), this.sumWeightedX(this._weightDW, points), this.sumWeightedX(this._weightUVW, points),\r\n      this.sumWeightedY(this._weightDU, points), this.sumWeightedY(this._weightDV, points), this.sumWeightedY(this._weightDW, points), this.sumWeightedY(this._weightUVW, points),\r\n      this.sumWeightedZ(this._weightDU, points), this.sumWeightedZ(this._weightDV, points), this.sumWeightedZ(this._weightDW, points), this.sumWeightedZ(this._weightUVW, points),\r\n      result);\r\n  }\r\n  /** unpack from a number array or Float64Array to an array of `Point3d` */\r\n  public static unpackNumbersToPoint3dArray(data: Float64Array | number[]): Point3d[] {\r\n    const result = [];\r\n    for (let i = 0; i + 2 < data.length; i += 3) {\r\n      result.push(Point3d.create(data[i], data[i + 1], data[i + 2]));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * return an 2-dimensional array containing all the values of `data` in arrays of numPerBlock\r\n   * @param data simple array of numbers\r\n   * @param numPerBlock number of values in each block at first level down\r\n   */\r\n  public static unpackNumbersToNestedArrays(data: Float64Array, numPerBlock: number): any[] {\r\n    const result = [];\r\n    const n = data.length;\r\n    let i = 0;\r\n    let i1 = 0;\r\n    while (i < n) {\r\n      // there is at least one more value for a block\r\n      const row = [];\r\n      i1 = i + numPerBlock;\r\n      if (i1 > n)\r\n        i1 = n;\r\n      for (; i < i1; i++) {\r\n        row.push(data[i]);\r\n      }\r\n      result.push(row);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * return an 3-dimensional array containing all the values of `data` in arrays numPerRow blocks of numPerBlock\r\n   * @param data simple array of numbers\r\n   * @param numPerBlock number of values in each block at first level down\r\n   */\r\n  public static unpackNumbersToNestedArraysIJK(data: Float64Array, numPerBlock: number, numPerRow: number): any[] {\r\n    const result = [];\r\n    const n = data.length;\r\n    let i = 0;\r\n    let i1 = 0;\r\n    let i2;\r\n    while (i < n) {\r\n      const row = [];\r\n      i2 = i + numPerBlock * numPerRow;\r\n      while (i < i2) {\r\n        const block = [];\r\n        i1 = i + numPerBlock;\r\n        if (i1 > n)\r\n          i1 = n;\r\n        for (; i < i1; i++) {\r\n          block.push(data[i]);\r\n        }\r\n        row.push(block);\r\n      }\r\n      result.push(row);\r\n    }\r\n    return result;\r\n  }\r\n  /**  multiply a transform times each x,y,z triple and replace the x,y,z in the packed array */\r\n  public static multiplyInPlace(transform: Transform, xyz: Float64Array): void {\r\n    const xyz1 = Point3d.create();\r\n    const numXYZ = xyz.length;\r\n    for (let i = 0; i + 2 < numXYZ; i += 3) {\r\n      transform.multiplyXYZ(xyz[i], xyz[i + 1], xyz[i + 2], xyz1);\r\n      xyz[i] = xyz1.x;\r\n      xyz[i + 1] = xyz1.y;\r\n      xyz[i + 2] = xyz1.z;\r\n    }\r\n  }\r\n  /** Apply Geometry.isAlmostEqual to corresponding coordinates */\r\n  public static isAlmostEqual(dataA: Point3d[] | Float64Array | undefined, dataB: Point3d[] | Float64Array | undefined): boolean {\r\n    if (dataA && dataB) {\r\n      if (dataA.length !== dataB.length)\r\n        return false;\r\n      if (dataA instanceof Float64Array && dataB instanceof Float64Array) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!Geometry.isSameCoordinate(dataA[i], dataB[i]))\r\n            return false;\r\n      } else if (Array.isArray(dataA) && Array.isArray(dataB)) {\r\n        for (let i = 0; i < dataA.length; i++)\r\n          if (!dataA[i].isAlmostEqual(dataB[i]))\r\n            return false;\r\n      }\r\n      return true;\r\n    }\r\n    // if both are null it is equal, otherwise unequal\r\n    return (!dataA && !dataB);\r\n  }\r\n\r\n  /** return simple average of all coordinates.   (000 if empty array) */\r\n  public static centroid(points: IndexedXYZCollection, result?: Point3d): Point3d {\r\n    result = Point3d.create(0, 0, 0, result);\r\n    const p = Point3d.create();\r\n    if (points.length > 0) {\r\n      for (let i = 0; i < points.length; i++) {\r\n        points.getPoint3dAtCheckedPointIndex(i, p);\r\n        result.x += p.x; result.y += p.y; result.z += p.z;\r\n      }\r\n      result.scaleInPlace(1.0 / points.length);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return the index of the point most distant from spacePoint */\r\n  public static indexOfMostDistantPoint(points: Point3d[], spacePoint: XYZ, farVector: Vector3d): number | undefined {\r\n    if (points.length === 0)\r\n      return undefined;\r\n    let dMax = -1;\r\n    let d;\r\n    let result = -1;\r\n    for (let i = 0; i < points.length; i++) {\r\n      d = spacePoint.distance(points[i]);\r\n      if (d > dMax) {\r\n        spacePoint.vectorTo(points[i], farVector);\r\n        dMax = d;\r\n        result = i;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** return the index of the point whose vector from space point has the largest magnitude of cross product with given vector. */\r\n  public static indexOfPointWithMaxCrossProductMagnitude(points: Point3d[], spacePoint: Point3d, vector: Vector3d, farVector: Vector3d): number | undefined {\r\n    if (points.length === 0)\r\n      return undefined;\r\n    let dMax = -1;\r\n    let d;\r\n    let result = -1;\r\n    let vectorAB; // to be reused in loop !!!\r\n    for (let i = 0; i < points.length; i++) {\r\n      vectorAB = spacePoint.vectorTo(points[i], vectorAB);\r\n      d = vectorAB.crossProductMagnitude(vector);\r\n      if (d > dMax) {\r\n        farVector.setFrom(vectorAB);\r\n        dMax = d;\r\n        result = i;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return the index of the closest point in the array (full xyz) */\r\n  public static closestPointIndex(data: XYAndZ[], spacePoint: XYAndZ): number {\r\n    let index = -1;\r\n    let dMin = Number.MAX_VALUE;\r\n    let d;\r\n    const x0 = spacePoint.x;\r\n    const y0 = spacePoint.y;\r\n    const z0 = spacePoint.z;\r\n    for (let i = 0; i < data.length; i++) {\r\n      d = Geometry.distanceXYZXYZ(x0, y0, z0, data[i].x, data[i].y, data[i].z);\r\n      if (d < dMin) {\r\n        index = i;\r\n        dMin = d;\r\n      }\r\n    }\r\n    return index;\r\n  }\r\n  /** return true iff all points' altitudes are within tolerance of the plane.*/\r\n  public static isCloseToPlane(data: Point3d[] | Float64Array, plane: Plane3dByOriginAndUnitNormal, tolerance: number = Geometry.smallMetricDistance): boolean {\r\n    if (Array.isArray(data)) {\r\n      let xyz;\r\n      for (xyz of data) {\r\n        if (Math.abs(plane.altitude(xyz)) > tolerance)\r\n          return false;\r\n      }\r\n    } else if (data instanceof Float64Array) {\r\n      const numXYZ = data.length;\r\n      for (let i = 0; i + 2 < numXYZ; i += 3) {\r\n        if (Math.abs(plane.altitudeXYZ(data[i], data[i + 1], data[i + 2])) > tolerance)\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Sum lengths of edges.\r\n   * @param data points.\r\n   */\r\n  public static sumEdgeLengths(data: Point3d[] | Float64Array, addClosureEdge: boolean = false): number {\r\n    let sum = 0.0;\r\n    if (Array.isArray(data)) {\r\n      const n = data.length - 1;\r\n      for (let i = 0; i < n; i++) sum += data[i].distance(data[i + 1]);\r\n      if (addClosureEdge && n > 0)\r\n        sum += data[0].distance(data[n]);\r\n\r\n    } else if (data instanceof Float64Array) {\r\n      const numXYZ = data.length;\r\n      let i = 0;\r\n      for (; i + 5 < numXYZ; i += 3) {  // final i points at final point x\r\n        sum += Geometry.hypotenuseXYZ(data[i + 3] - data[i],\r\n          data[i + 4] - data[i + 1],\r\n          data[i + 5] - data[i + 2]);\r\n      }\r\n      if (addClosureEdge && i >= 3) {\r\n        sum += Geometry.hypotenuseXYZ(data[0] - data[i],\r\n          data[1] - data[i + 1],\r\n          data[2] - data[i + 2]);\r\n      }\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Return an array containing clones of the Point3d data[]\r\n   * @param data source data\r\n   */\r\n  public static clonePoint3dArray(data: XYAndZ[]): Point3d[] {\r\n    return data.map((p: XYAndZ) => Point3d.create(p.x, p.y, p.z));\r\n  }\r\n\r\n  /**\r\n   * Return an array containing Point2d with xy parts of each Point3d\r\n   * @param data source data\r\n   */\r\n  public static clonePoint2dArray(data: XYAndZ[]): Point2d[] {\r\n    return data.map((p: XYAndZ) => Point2d.create(p.x, p.y));\r\n  }\r\n  /**\r\n   * clone points in the input array, inserting points within each edge to limit edge length.\r\n   * @param points array of points\r\n   * @param maxEdgeLength max length of an edge\r\n   */\r\n  public static cloneWithMaxEdgeLength(points: Point3d[], maxEdgeLength: number): Point3d[] {\r\n    if (points.length === 0)\r\n      return [];\r\n    const result = [points[0]];\r\n    for (let i = 1; i < points.length; i++) {\r\n      const a = points[i - 1].distance(points[i]);\r\n      const n = Geometry.stepCount(maxEdgeLength, a, 1);\r\n      for (let k = 1; k < n; k++)\r\n        result.push(points[i - 1].interpolate(k / n, points[i]));\r\n      result.push(points[i]);\r\n\r\n    }\r\n    return result;\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Helper object to access members of a Point3d[] in geometric calculations.\r\n * * The collection holds only a reference to the actual array.\r\n * * The actual array may be replaced by the user as needed.\r\n * * When replaced, there is no cached data to be updated.\r\n * @public\r\n*/\r\nexport class Point3dArrayCarrier extends IndexedXYZCollection {\r\n  /** reference to array being queried. */\r\n  public data: Point3d[];\r\n  /** CAPTURE caller supplied array ... */\r\n  public constructor(data: Point3d[]) {\r\n    super();\r\n    this.data = data;\r\n  }\r\n  /** test if `index` is a valid index into the array. */\r\n  public isValidIndex(index: number): boolean {\r\n    return index >= 0 && index < this.data.length;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Point3d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getPoint3dAtCheckedPointIndex(index: number, result?: Point3d): Point3d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Point3d.create(source.x, source.y, source.z, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Access by index, returning strongly typed Vector3d\r\n   * @param index index of point within the array\r\n   * @param result caller-allocated destination\r\n   * @returns undefined if the index is out of bounds\r\n   */\r\n  public getVector3dAtCheckedVectorIndex(index: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(index)) {\r\n      const source = this.data[index];\r\n      return Vector3d.create(source.x, source.y, source.z, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from the point at indexA to the point at indexB\r\n   * @param indexA index of point within the array\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public vectorIndexIndex(indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector3d.createStartEnd(this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a vector from given origin to point at indexB\r\n   * @param origin origin for vector\r\n   * @param indexB index of point within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if index is out of bounds\r\n   */\r\n  public vectorXYAndZIndex(origin: XYAndZ, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(indexB))\r\n      return Vector3d.createStartEnd(origin, this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return the cross product of vectors from origin to points at indexA and indexB\r\n   * @param origin origin for vector\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns undefined if either index is out of bounds\r\n   */\r\n  public crossProductXYAndZIndexIndex(origin: XYAndZ, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector3d.createCrossProductToPoints(origin, this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return the cross product of vectors from point at originIndex to points at indexA and indexB\r\n   * @param originIndex index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n  public crossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number, result?: Vector3d): Vector3d | undefined {\r\n    if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      return Vector3d.createCrossProductToPoints(this.data[originIndex], this.data[indexA], this.data[indexB], result);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Compute the cross product of vectors from point at originIndex to points at indexA and indexB, and accumulate it to the result.\r\n   * @param origin index of origin\r\n   * @param indexA index of first target within the array\r\n   * @param indexB index of second target within the array\r\n   * @param result caller-allocated vector.\r\n   * @returns return true if indexA, indexB both valid\r\n   */\r\n  public accumulateCrossProductIndexIndexIndex(originIndex: number, indexA: number, indexB: number, result: Vector3d): void {\r\n    const data = this.data;\r\n    if (this.isValidIndex(originIndex) && this.isValidIndex(indexA) && this.isValidIndex(indexB))\r\n      result.addCrossProductToTargetsInPlace(\r\n        data[originIndex].x, data[originIndex].y, data[originIndex].z,\r\n        data[indexA].x, data[indexA].y, data[indexA].z,\r\n        data[indexB].x, data[indexB].y, data[indexB].z);\r\n  }\r\n\r\n  /**\r\n   * read-only property for number of XYZ in the collection.\r\n   */\r\n  public get length(): number {\r\n    return this.data.length;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\nimport { XAndY } from \"./XYZProps\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Ray3d } from \"./Ray3d\";\r\nimport { IndexedXYZCollection } from \"./IndexedXYZCollection\";\r\nimport { Point3dArrayCarrier, Point3dArray } from \"./PointHelpers\";\r\nimport { XYParitySearchContext } from \"../topology/XYParitySearchContext\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\n/** Static class for operations that treat an array of points as a polygon (with area!) */\r\n/**\r\n * Various (static method) computations for arrays of points interpreted as a polygon.\r\n * @public\r\n */\r\nexport class PolygonOps {\r\n  /** Sum areas of triangles from points[0] to each far edge.\r\n   * * Consider triangles from points[0] to each edge.\r\n   * * Sum the areas(absolute, without regard to orientation) all these triangles.\r\n   * @returns sum of absolute triangle areas.\r\n   */\r\n  public static sumTriangleAreas(points: Point3d[] | GrowableXYZArray): number {\r\n    let s = 0;\r\n    const n = points.length;\r\n    if (Array.isArray(points)) {\r\n      if (n >= 3) {\r\n        const origin = points[0];\r\n        const vector0 = origin.vectorTo(points[1]);\r\n        let vector1 = Vector3d.create();\r\n        // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n        for (let i = 2; i < n; i++) {\r\n          vector1 = origin.vectorTo(points[i], vector1);\r\n          s += vector0.crossProductMagnitude(vector1);\r\n          vector0.setFrom(vector1);\r\n        }\r\n      }\r\n      return s * 0.5;\r\n    }\r\n    const crossVector = Vector3d.create();\r\n    for (let i = 2; i < n; i++) {\r\n      points.crossProductIndexIndexIndex(0, i - 1, i, crossVector);\r\n      s += crossVector.magnitude();\r\n    }\r\n    return s * 0.5;\r\n  }\r\n  /** Sum areas of triangles from points[0] to each far edge.\r\n   * * Consider triangles from points[0] to each edge.\r\n   * * Sum the areas(absolute, without regard to orientation) all these triangles.\r\n   * @returns sum of absolute triangle areas.\r\n   */\r\n  public static sumTriangleAreasXY(points: Point3d[]): number {\r\n    let s = 0.0;\r\n    const n = points.length;\r\n    if (n >= 3) {\r\n      const origin = points[0];\r\n      const vector0 = origin.vectorTo(points[1]);\r\n      let vector1 = Vector3d.create();\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        vector1 = origin.vectorTo(points[i], vector1);\r\n        s += vector0.crossProductXY(vector1);\r\n        vector0.setFrom(vector1);\r\n      }\r\n    }\r\n    s *= 0.5;\r\n    // console.log (\"polygon area \", s, points);\r\n    return s;\r\n  }\r\n  /** These values are the integrated area moment products [xx,xy,xz, x]\r\n   * for a right triangle in the first quadrant at the origin -- (0,0),(1,0),(0,1)\r\n   */\r\n  private static readonly _triangleMomentWeights = Matrix4d.createRowValues(2.0 / 24.0, 1.0 / 24.0, 0, 4.0 / 24.0, 1.0 / 24.0, 2.0 / 24.0, 0, 4.0 / 24.0, 0, 0, 0, 0, 4.0 / 24.0, 4.0 / 24.0, 0, 12.0 / 24.0);\r\n  // statics for shared reuse.\r\n  // many methods use these.\r\n  // only use them in \"leaf\" methods that are certain not to call other users . . .\r\n  private static _vector0 = Vector3d.create();\r\n  private static _vector1 = Vector3d.create();\r\n  private static _vectorOrigin = Vector3d.create();\r\n  private static _normal = Vector3d.create();\r\n  private static _matrixA = Matrix4d.createIdentity();\r\n  private static _matrixB = Matrix4d.createIdentity();\r\n  private static _matrixC = Matrix4d.createIdentity();\r\n  /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */\r\n  public static areaNormalGo(points: IndexedXYZCollection, result?: Vector3d): Vector3d | undefined {\r\n    if (!result)\r\n      result = new Vector3d();\r\n    const n = points.length;\r\n    if (n === 3) {\r\n      points.crossProductIndexIndexIndex(0, 1, 2, result);\r\n    } else if (n >= 3) {\r\n      result.setZero();\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        points.accumulateCrossProductIndexIndexIndex(0, i - 1, i, result);\r\n      }\r\n    }\r\n    // ALL BRANCHES SUM FULL CROSS PRODUCTS AND EXPECT SCALE HERE\r\n    result.scaleInPlace(0.5);\r\n    return result;\r\n  }\r\n  /** return a vector which is perpendicular to the polygon and has magnitude equal to the polygon area. */\r\n  public static areaNormal(points: Point3d[], result?: Vector3d): Vector3d {\r\n    if (!result)\r\n      result = Vector3d.create();\r\n    PolygonOps.areaNormalGo(new Point3dArrayCarrier(points), result);\r\n    return result;\r\n  }\r\n  /** return the area of the polygon (assuming planar) */\r\n  public static area(points: Point3d[]): number {\r\n    return PolygonOps.areaNormal(points).magnitude();\r\n  }\r\n  /** return the projected XY area of the polygon (assuming planar) */\r\n  public static areaXY(points: Point3d[]): number {\r\n    let area = 0.0;\r\n    for (let i = 1; i + 1 < points.length; i++)\r\n      area += points[0].crossProductToPointsXY(points[i], points[i + 1]);\r\n    return 0.5 * area;\r\n  }\r\n  /**\r\n   * Return a Ray3d with (assuming the polygon is planar and not self-intersecting)\r\n   * * origin at the centroid of the (3D) polygon\r\n   * * normal is a unit vector perpendicular to the plane\r\n   * * 'a' member is the area.\r\n   * @param points\r\n   */\r\n  public static centroidAreaNormal(points: Point3d[]): Ray3d | undefined {\r\n    const n = points.length;\r\n    if (n === 3) {\r\n      const normal = points[0].crossProductToPoints(points[1], points[2]);\r\n      const a = 0.5 * normal.magnitude();\r\n      const result = Ray3d.createCapture(Point3dArray.centroid(new Point3dArrayCarrier(points)), normal);\r\n      if (result.tryNormalizeInPlaceWithAreaWeight(a))\r\n        return result;\r\n      return undefined;\r\n    }\r\n    if (n >= 3) {\r\n      const origin = points[0].clone();\r\n      const normal = PolygonOps.areaNormal(points);\r\n      normal.normalizeInPlace();\r\n      const vector0 = origin.vectorTo(points[1]);\r\n      let vector1 = Vector3d.create();\r\n      let cross = Vector3d.create();\r\n      const centroidSum = Vector3d.createZero();\r\n      const normalSum = Vector3d.createZero();\r\n      let signedTriangleArea;\r\n      // This will work with or without closure edge.  If closure is given, the last vector is 000.\r\n      for (let i = 2; i < n; i++) {\r\n        vector1 = origin.vectorTo(points[i], vector1);\r\n        cross = vector0.crossProduct(vector1, cross);\r\n        signedTriangleArea = normal.dotProduct(cross);    // well, actually twice the area.\r\n        normalSum.addInPlace(cross); // this grows to twice the area\r\n        const b = signedTriangleArea / 6.0;\r\n        centroidSum.plus2Scaled(vector0, b, vector1, b, centroidSum);\r\n        vector0.setFrom(vector1);\r\n      }\r\n      const area = 0.5 * normalSum.magnitude();\r\n      const inverseArea = Geometry.conditionalDivideFraction(1, area);\r\n      if (inverseArea !== undefined) {\r\n        const result = Ray3d.createCapture(origin.plusScaled(centroidSum, inverseArea), normalSum);\r\n        result.tryNormalizeInPlaceWithAreaWeight(area);\r\n        return result;\r\n      }\r\n    }\r\n    return undefined;\r\n  }\r\n  // Has the potential to be combined with centroidAreaNormal for point3d array and Ray3d return listed above...\r\n  // Returns undefined if given point array less than 3 or if not safe to divide at any point\r\n  /**\r\n   * * Return (in caller-allocated centroid) the centroid of the xy polygon.\r\n   * * Return (as function value)  the area\r\n   */\r\n  public static centroidAndAreaXY(points: Point2d[], centroid: Point2d): number | undefined {\r\n    let area = 0.0;\r\n    centroid.set(0, 0);\r\n    if (points.length < 3)\r\n      return undefined;\r\n    const origin = points[0];\r\n    let vectorSum = Vector2d.create(0, 0); // == sum ((U+V)/3) * (U CROSS V)/2 -- but leave out divisions\r\n    let areaSum = 0.0; // == sum (U CROSS V) / 2 -- but leave out divisions\r\n    for (let i = 1; i + 1 < points.length; i++) {\r\n      const vector0 = origin.vectorTo(points[i]);\r\n      const vector1 = origin.vectorTo(points[i + 1]);\r\n      const tempArea = vector0.crossProduct(vector1);\r\n      vectorSum = vectorSum.plus(vector0.plus(vector1).scale(tempArea));\r\n      areaSum += tempArea;\r\n    }\r\n    area = areaSum * 0.5;\r\n    const a = Geometry.conditionalDivideFraction(1.0, 6.0 * area);\r\n    if (a === undefined) {\r\n      centroid.setFrom(origin);\r\n      return undefined;\r\n    }\r\n    centroid.setFrom(origin.plusScaled(vectorSum, a));\r\n    return area;\r\n  }\r\n  /**\r\n   * Return a unit normal to the plane of the polygon.\r\n   * @param points array of points around the polygon.  This is assumed to NOT have closure edge.\r\n   * @param result caller-allocated result vector.\r\n   */\r\n  public static unitNormal(points: IndexedXYZCollection, result: Vector3d): boolean {\r\n    const n = points.length;\r\n    if (n === 3) {\r\n      points.crossProductIndexIndexIndex(0, 1, 2, result);\r\n      return result.normalizeInPlace();\r\n    }\r\n    if (n === 4) {\r\n      // cross product of diagonals is more stable than from single of the points . . .\r\n      points.vectorIndexIndex(0, 2, PolygonOps._vector0);\r\n      points.vectorIndexIndex(1, 3, PolygonOps._vector1);\r\n      PolygonOps._vector0.crossProduct(PolygonOps._vector1, result);\r\n      return result.normalizeInPlace();\r\n    }\r\n    // more than 4 points  ... no shortcuts ...\r\n    PolygonOps.areaNormalGo(points, result);\r\n    return result.normalizeInPlace();\r\n  }\r\n  /** Return the matrix of area products of a polygon with respect to an origin.\r\n   * The polygon is assumed to be planar and non-self-intersecting.\r\n   */\r\n  public static addSecondMomentAreaProducts(points: IndexedXYZCollection, origin: Point3d, moments: Matrix4d) {\r\n    const unitNormal = PolygonOps._normal;\r\n    if (PolygonOps.unitNormal(points, unitNormal)) {\r\n      // The direction of the normal makes the various detJ values positive or negative so that non-convex polygons\r\n      // sum correctly.\r\n      const vector01 = PolygonOps._vector0;\r\n      const vector02 = PolygonOps._vector1;\r\n      const placement = PolygonOps._matrixA;\r\n      const matrixAB = PolygonOps._matrixB;\r\n      const matrixABC = PolygonOps._matrixC;\r\n      const vectorOrigin = points.vectorXYAndZIndex(origin, 0, PolygonOps._vectorOrigin)!;\r\n      const numPoints = points.length;\r\n      let detJ = 0;\r\n      for (let i2 = 2; i2 < numPoints; i2++) {\r\n        points.vectorIndexIndex(0, i2 - 1, vector01);\r\n        points.vectorIndexIndex(0, i2, vector02);\r\n        detJ = unitNormal.tripleProduct(vector01, vector02);\r\n        placement.setOriginAndVectors(vectorOrigin, vector01, vector02, unitNormal);\r\n        placement.multiplyMatrixMatrix(PolygonOps._triangleMomentWeights, matrixAB);\r\n        matrixAB.multiplyMatrixMatrixTranspose(placement, matrixABC);\r\n        moments.addScaledInPlace(matrixABC, detJ);\r\n      }\r\n    }\r\n  }\r\n  /** Test the direction of turn at the vertices of the polygon, ignoring z-coordinates.\r\n   *\r\n   * *  For a polygon without self intersections, this is a convexity and orientation test: all positive is convex and counterclockwise,\r\n   * all negative is convex and clockwise\r\n   * *  Beware that a polygon which turns through more than a full turn can cross itself and close, but is not convex\r\n   * *  Returns 1 if all turns are to the left, -1 if all to the right, and 0 if there are any zero turns\r\n   */\r\n  public static testXYPolygonTurningDirections(pPointArray: Point2d[] | Point3d[]): number {\r\n    // Reduce count by trailing duplicates; leaves iLast at final index\r\n    let numPoint = pPointArray.length;\r\n    let iLast = numPoint - 1;\r\n    while (iLast > 1 && pPointArray[iLast].x === pPointArray[0].x && pPointArray[iLast].y === pPointArray[0].y) {\r\n      numPoint = iLast--;\r\n    }\r\n    if (numPoint > 2) {\r\n      let vector0 = Point2d.create(pPointArray[iLast].x - pPointArray[iLast - 1].x, pPointArray[iLast].y - pPointArray[iLast - 1].y);\r\n      const vector1 = Point2d.create(pPointArray[0].x - pPointArray[iLast].x, pPointArray[0].y - pPointArray[iLast].y);\r\n      const baseArea = vector0.x * vector1.y - vector0.y * vector1.x;\r\n      // In a convex polygon, all successive-vector cross products will\r\n      // have the same sign as the base area, hence all products will be\r\n      // positive.\r\n      for (let i1 = 1; i1 < numPoint; i1++) {\r\n        vector0 = vector1.clone();\r\n        Point2d.create(pPointArray[i1].x - pPointArray[i1 - 1].x, pPointArray[i1].y - pPointArray[i1 - 1].y, vector1);\r\n        const currArea = vector0.x * vector1.y - vector0.y * vector1.x;\r\n        if (currArea * baseArea <= 0.0)\r\n          return 0;\r\n      }\r\n      // Fall out with all signs same as base area\r\n      return baseArea > 0.0 ? 1 : -1;\r\n    }\r\n    return 0;\r\n  }\r\n  /**\r\n   * Test if point (x,y) is IN, OUT or ON a polygon.\r\n   * @return (1) for in, (-1) for OUT, (0) for ON\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param points array of xy coordinates.\r\n   */\r\n  public static classifyPointInPolygon(x: number, y: number, points: XAndY[]): number | undefined {\r\n    const context = new XYParitySearchContext(x, y);\r\n    let i0 = 0;\r\n    const n = points.length;\r\n    let i1;\r\n    let iLast = -1;\r\n    // walk to an acceptable start index ...\r\n    for (i0 = 0; i0 < n; i0 = i1) {\r\n      i1 = i0 + 1;\r\n      if (i1 >= n)\r\n        i1 = 0;\r\n      if (context.tryStartEdge(points[i0].x, points[i0].y, points[i1].x, points[i1].y)) {\r\n        iLast = i1;\r\n        break;\r\n      }\r\n    }\r\n    if (iLast < 0)\r\n      return undefined;\r\n    for (let i = 1; i <= n; i++) {\r\n      i1 = iLast + i;\r\n      if (i1 >= n)\r\n        i1 -= n;\r\n      if (!context.advance(points[i1].x, points[i1].y))\r\n        return context.classifyCounts();\r\n    }\r\n    return context.classifyCounts();\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { GrowableXYZArray } from \"./GrowableXYZArray\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { Point2d, Vector2d } from \"./Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { LowAndHighXY, LowAndHighXYZ, Range1dProps, Range2dProps, Range3dProps, XAndY, XYAndZ } from \"./XYZProps\";\r\n/**\r\n * Base class for Range1d, Range2d, Range3d.\r\n * @public\r\n */\r\nexport abstract class RangeBase {\r\n  /** Number considered impossibly large possibly for a coordinate in a range. */\r\n  protected static readonly _EXTREME_POSITIVE: number = 1.0e200;\r\n  /** Number considered to be impossibly negative for a coordinate in a range. */\r\n  protected static readonly _EXTREME_NEGATIVE: number = -1.0e200;\r\n  /** Return 0 if high<= low, otherwise `1/(high-low)` for use in fractionalizing */\r\n  protected static npcScaleFactor(low: number, high: number): number { return (high <= low) ? 0.0 : 1.0 / (high - low); }\r\n  /** Return true if x is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\r\n  public static isExtremeValue(x: number): boolean { return Math.abs(x) >= RangeBase._EXTREME_POSITIVE; }\r\n  /** Return true if any x or y or z is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\r\n  public static isExtremePoint3d(xyz: Point3d) { return RangeBase.isExtremeValue(xyz.x) || RangeBase.isExtremeValue(xyz.y) || RangeBase.isExtremeValue(xyz.z); }\r\n  /** Return true if either of x,y is outside the range `[_EXTREME_NEGATIVE, _EXTREME_POSITIVE]' */\r\n  public static isExtremePoint2d(xy: Point2d) { return RangeBase.isExtremeValue(xy.x) || RangeBase.isExtremeValue(xy.y); }\r\n  /**\r\n   * Return the min absolute distance from any point of `[lowA,highA]' to any point of `[lowB,highB]'.\r\n   * * Both low,high pairs have order expectations:  The condition `high < low` means null interval.\r\n   * * If there is interval overlap, the distance is zero.\r\n   * @param lowA low of interval A\r\n   * @param highA high of interval A\r\n   * @param lowB low of interval B\r\n   * @param highB high of interval B\r\n   */\r\n  public static rangeToRangeAbsoluteDistance(lowA: number, highA: number, lowB: number, highB: number): number {\r\n    if (highA < lowA)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    if (highB < lowB)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    if (highB < lowA)\r\n      return lowA - highB;\r\n    if (highB <= highA)\r\n      return 0.0;\r\n    if (lowB <= highA)\r\n      return 0.0;\r\n    return lowB - highA;\r\n  }\r\n  /** Given a coordinate and pair of range limits, return the smallest distance to the range.\r\n   * * This is zero for any point inside the range\r\n   * * This is _EXTREME_POSITIVE if the range limits are inverted\r\n   * * Otherwise (i.e. x is outside a finite range) the distance to the near endpoint.\r\n   */\r\n  public static coordinateToRangeAbsoluteDistance(x: number, low: number, high: number): number {\r\n    if (high < low)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    if (x < low)\r\n      return low - x;\r\n    if (x > high)\r\n      return x - high;\r\n    return 0.0;\r\n  }\r\n}\r\n/**\r\n * Axis aligned range in 3D.\r\n * * member `low` contains minimum coordinate of range box\r\n * * member  `high` contains maximum coordinate of range box\r\n * * The range is considered null (empty) if any low member is larger than its high counterpart.\r\n * @public\r\n */\r\nexport class Range3d extends RangeBase implements LowAndHighXYZ, BeJSONFunctions {\r\n  // low and high are always non-null objects\r\n  // any direction of low.q > high.q is considered a null range.\r\n  // private ctor and setXYZXYZ_direct set the low and high explicitly (without further tests of low.q.<= high.q)\r\n  /** low point coordinates */\r\n  public low: Point3d;\r\n  /** high point coordinates */\r\n  public high: Point3d;\r\n  /** Set this transform to values that indicate it has no geometric contents. */\r\n  public setNull() {\r\n    this.low.x = RangeBase._EXTREME_POSITIVE;\r\n    this.low.y = RangeBase._EXTREME_POSITIVE;\r\n    this.low.z = RangeBase._EXTREME_POSITIVE;\r\n    this.high.x = RangeBase._EXTREME_NEGATIVE;\r\n    this.high.y = RangeBase._EXTREME_NEGATIVE;\r\n    this.high.z = RangeBase._EXTREME_NEGATIVE;\r\n  }\r\n\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this); Object.freeze(this.low); Object.freeze(this.high); }\r\n  /** Flatten the low and high coordinates of any json object with low.x .. high.z into an array of 6 doubles */\r\n  public static toFloat64Array(val: LowAndHighXYZ): Float64Array { return Float64Array.of(val.low.x, val.low.y, val.low.z, val.high.x, val.high.y, val.high.z); }\r\n  /** Flatten the low and high coordinates of this into an array of 6 doubles */\r\n  public toFloat64Array(): Float64Array { return Range3d.toFloat64Array(this); }\r\n  /**\r\n   * Construct a Range3d from an array of double-precision values\r\n   * @param f64 the array, which should contain exactly 6 values in this order: lowx, lowy, lowz, highx, highy, highz\r\n   * @return a new Range3d object\r\n   */\r\n  public static fromFloat64Array<T extends Range3d>(f64: Float64Array): T {\r\n    if (f64.length !== 6)\r\n      throw new Error(\"invalid array\");\r\n    return new this(f64[0], f64[1], f64[2], f64[3], f64[4], f64[5]) as T;\r\n  }\r\n  /**\r\n   * Construct a Range3d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.\r\n   * @param buffer untyped array\r\n   * @return a new Range3d object\r\n   */\r\n  public static fromArrayBuffer<T extends Range3d>(buffer: ArrayBuffer): T { return this.fromFloat64Array(new Float64Array(buffer)); }\r\n\r\n  // explicit ctor - no enforcement of value relationships\r\n  public constructor(lowx: number = RangeBase._EXTREME_POSITIVE, lowy: number = RangeBase._EXTREME_POSITIVE, lowz: number = RangeBase._EXTREME_POSITIVE,\r\n    highx: number = RangeBase._EXTREME_NEGATIVE, highy: number = RangeBase._EXTREME_NEGATIVE, highz: number = RangeBase._EXTREME_NEGATIVE) {\r\n    super();\r\n    this.low = Point3d.create(lowx, lowy, lowz);\r\n    this.high = Point3d.create(highx, highy, highz);\r\n  }\r\n\r\n  /** Returns true if this and other have equal low and high parts, or both are null ranges. */\r\n  public isAlmostEqual(other: Range3d): boolean {\r\n    return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))\r\n      || (this.isNull && other.isNull);\r\n  }\r\n  /** copy low and high values from other. */\r\n  public setFrom(other: Range3d) { this.low.setFrom(other.low); this.high.setFrom(other.high); }\r\n  /** Return a new Range3d copied from a range or derived type */\r\n  public static createFrom<T extends Range3d>(other: Range3d, result?: T): T {\r\n    if (result) { result.setFrom(other); return result; }\r\n    return this.createXYZXYZOrCorrectToNull<T>(other.low.x, other.low.y, other.low.z,\r\n      other.high.x, other.high.y, other.high.z, result);\r\n  }\r\n  /** set this range (in place) from json such as\r\n   * * key-value pairs: `{low:[1,2,3], high:[4,5,6]}`\r\n   * * array of points: `[[1,2,3],[9,3,4],[-2,1,3] ...]`\r\n   * * Lowest level points can be `[1,2,3]` or `{x:1,y:2,z:3}`\r\n   */\r\n  public setFromJSON(json?: Range3dProps) {\r\n    if (!json)\r\n      return;\r\n    this.setNull();\r\n    if (Array.isArray(json)) {\r\n      const point = Point3d.create();\r\n      for (const value of json) {\r\n        point.setFromJSON(value);\r\n        this.extendPoint(point);\r\n      }\r\n      return;\r\n    }\r\n    const low = Point3d.fromJSON(json.low);\r\n    const high = Point3d.fromJSON(json.high);\r\n    if (!RangeBase.isExtremePoint3d(low) && !RangeBase.isExtremePoint3d(high)) {\r\n      this.extendPoint(low);\r\n      this.extendPoint(high);\r\n    }\r\n  }\r\n  /** Return a JSON object `{low: ... , high: ...}`\r\n   * with points formatted by `Point3d.toJSON()`\r\n   */\r\n  public toJSON(): Range3dProps { return { low: this.low.toJSON(), high: this.high.toJSON() }; }\r\n  /** Use `setFromJSON` to parse `json` into a new Range3d instance. */\r\n  public static fromJSON<T extends Range3d>(json?: Range3dProps): T {\r\n    const result = new this() as T;\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  // internal use only -- directly set all coordinates, test only if directed.\r\n  private setDirect(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, correctToNull: boolean) {\r\n    this.low.x = xA;\r\n    this.low.y = yA;\r\n    this.low.z = zA;\r\n\r\n    this.high.x = xB;\r\n    this.high.y = yB;\r\n    this.high.z = zB;\r\n    if (correctToNull) {\r\n      if (this.low.x > this.high.x\r\n        || this.low.y > this.high.y\r\n        || this.low.z > this.high.z)\r\n        this.setNull();\r\n    }\r\n  }\r\n  /** Return a copy */\r\n  public clone(result?: this): this {\r\n    result = result ? result : new (this.constructor as any)() as this;\r\n    result.setDirect(this.low.x, this.low.y, this.low.z, this.high.x, this.high.y, this.high.z, false);\r\n    return result;\r\n  }\r\n  /** Return a range initialized to have no content. */\r\n  public static createNull<T extends Range3d>(result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    return result;\r\n  }\r\n\r\n  /** Extend (modify in place) so that the range is large enough to include the supplied points. */\r\n  public extend(...point: Point3d[]) {\r\n    let p;\r\n    for (p of point)\r\n      this.extendPoint(p);\r\n  }\r\n  /** Return a range large enough to include the supplied points. If no points are given, the range is a null range */\r\n  public static create(...point: Point3d[]) {\r\n    const result = Range3d.createNull();\r\n    let p;\r\n    for (p of point)\r\n      result.extendPoint(p);\r\n    return result;\r\n  }\r\n  /** create a Range3d enclosing the transformed points. */\r\n  public static createTransformed<T extends Range3d>(transform: Transform, ...point: Point3d[]): T {\r\n    const result = this.createNull<T>();\r\n    let p;\r\n    for (p of point)\r\n      result.extendTransformedXYZ(transform, p.x, p.y, p.z);\r\n    return result;\r\n  }\r\n  /** create a Range3d enclosing the transformed points. */\r\n  public static createTransformedArray<T extends Range3d>(transform: Transform, points: Point3d[]): T {\r\n    const result = this.createNull<T>();\r\n    result.extendArray(points, transform);\r\n    return result;\r\n  }\r\n\r\n  /** create a Range3d enclosing the points after inverse transform. */\r\n  public static createInverseTransformedArray<T extends Range3d>(transform: Transform, points: Point3d[]): T {\r\n    const result = this.createNull<T>();\r\n    result.extendInverseTransformedArray(points, transform);\r\n    return result;\r\n  }\r\n  /** Set the range to be a single point supplied as x,y,z values */\r\n  public setXYZ(x: number, y: number, z: number) {\r\n    this.low.x = this.high.x = x;\r\n    this.low.y = this.high.y = y;\r\n    this.low.z = this.high.z = z;\r\n  }\r\n\r\n  /** Create a single point range */\r\n  public static createXYZ<T extends Range3d>(x: number, y: number, z: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(x, y, z, x, y, z, false);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box with 2 pairs of xyz candidates. Theses are compared and shuffled as needed for the box. */\r\n  public static createXYZXYZ<T extends Range3d>(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB),\r\n      Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), false);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box with 2 pairs of xyz candidates. If any direction has order flip, create null. */\r\n  public static createXYZXYZOrCorrectToNull<T extends Range3d>(xA: number, yA: number, zA: number, xB: number, yB: number, zB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB), Math.min(zA, zB),\r\n      Math.max(xA, xB), Math.max(yA, yB), Math.max(zA, zB), true);\r\n    return result;\r\n  }\r\n\r\n  /** Creates a 3d range from a 2d range's low and high members, setting the corresponding z values to the value given. */\r\n  public static createRange2d<T extends Range3d>(range: Range2d, z: number = 0, result?: T): T {\r\n    const retVal = result ? result : new this() as T;\r\n    retVal.setNull();\r\n\r\n    retVal.extendXYZ(range.low.x, range.low.y, z);\r\n    retVal.extendXYZ(range.high.x, range.high.y, z);\r\n    return retVal;\r\n  }\r\n\r\n  /** Create a range around an array of points. */\r\n  public static createArray<T extends Range3d>(points: Point3d[], result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    let point;\r\n    for (point of points)\r\n      result.extendPoint(point);\r\n    return result;\r\n  }\r\n\r\n  /** extend a range around an array of points (optionally transformed) */\r\n  public extendArray(points: Point3d[] | GrowableXYZArray, transform?: Transform) {\r\n    if (Array.isArray(points))\r\n      if (transform)\r\n        for (const point of points)\r\n          this.extendTransformedXYZ(transform, point.x, point.y, point.z);\r\n      else\r\n        for (const point of points)\r\n          this.extendXYZ(point.x, point.y, point.z);\r\n    else  // growable array -- this should be implemented without point extraction !!!\r\n      if (transform)\r\n        for (let i = 0; i < points.length; i++)\r\n          this.extendTransformedXYZ(transform, points.getPoint3dAtUncheckedPointIndex(i).x, points.getPoint3dAtUncheckedPointIndex(i).y, points.getPoint3dAtUncheckedPointIndex(i).z);\r\n      else\r\n        for (let i = 0; i < points.length; i++)\r\n          this.extendXYZ(points.getPoint3dAtUncheckedPointIndex(i).x, points.getPoint3dAtUncheckedPointIndex(i).y, points.getPoint3dAtUncheckedPointIndex(i).z);\r\n  }\r\n\r\n  /** extend a range around an array of points (optionally transformed) */\r\n  public extendInverseTransformedArray(points: Point3d[] | GrowableXYZArray, transform: Transform) {\r\n    if (Array.isArray(points))\r\n      for (const point of points)\r\n        this.extendInverseTransformedXYZ(transform, point.x, point.y, point.z);\r\n    else  // growable array -- this should be implemented without point extraction !!!\r\n      for (let i = 0; i < points.length; i++)\r\n        this.extendInverseTransformedXYZ(transform, points.getPoint3dAtUncheckedPointIndex(i).x, points.getPoint3dAtUncheckedPointIndex(i).y, points.getPoint3dAtUncheckedPointIndex(i).z);\r\n  }\r\n\r\n  /** multiply the point x,y,z by transform and use the coordinate to extend this range.\r\n   */\r\n  public extendTransformedXYZ(transform: Transform, x: number, y: number, z: number) {\r\n    const origin = transform.origin;\r\n    const coffs = transform.matrix.coffs;\r\n    this.extendXYZ(\r\n      origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z,\r\n      origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z,\r\n      origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** multiply the point x,y,z,w by transform and use the coordinate to extend this range.\r\n   */\r\n  public extendTransformedXYZW(transform: Transform, x: number, y: number, z: number, w: number) {\r\n    const origin = transform.origin;\r\n    const coffs = transform.matrix.coffs;\r\n    this.extendXYZW(\r\n      origin.x * w + coffs[0] * x + coffs[1] * y + coffs[2] * z,\r\n      origin.y * w + coffs[3] * x + coffs[4] * y + coffs[5] * z,\r\n      origin.z * w + coffs[6] * x + coffs[7] * y + coffs[8] * z,\r\n      w);\r\n  }\r\n\r\n  /** multiply the point x,y,z by transform and use the coordinate to extend this range.\r\n   */\r\n  public extendInverseTransformedXYZ(transform: Transform, x: number, y: number, z: number): boolean {\r\n    const origin = transform.origin;\r\n    if (!transform.matrix.computeCachedInverse(true))\r\n      return false;\r\n    const coffs = transform.matrix.inverseCoffs!;\r\n    const xx = x - origin.x;\r\n    const yy = y - origin.y;\r\n    const zz = z - origin.z;\r\n    this.extendXYZ(\r\n      coffs[0] * xx + coffs[3] * yy + coffs[6] * zz,\r\n      coffs[1] * xx + coffs[4] * yy + coffs[7] * zz,\r\n      coffs[2] * xx + coffs[5] * yy + coffs[8] * zz);\r\n    return true;\r\n  }\r\n\r\n  /** Extend the range by the two transforms applied to xyz */\r\n  public extendTransformTransformedXYZ(transformA: Transform, transformB: Transform, x: number, y: number, z: number) {\r\n    const origin = transformB.origin;\r\n    const coffs = transformB.matrix.coffs;\r\n    this.extendTransformedXYZ(transformA,\r\n      origin.x + coffs[0] * x + coffs[1] * y + coffs[2] * z,\r\n      origin.y + coffs[3] * x + coffs[4] * y + coffs[5] * z,\r\n      origin.z + coffs[6] * x + coffs[7] * y + coffs[8] * z);\r\n  }\r\n\r\n  /** Test if the box has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */\r\n  public get isNull(): boolean {\r\n    return this.high.x < this.low.x\r\n      || this.high.y < this.low.y\r\n      || this.high.z < this.low.z;\r\n  }\r\n\r\n  /** Test if  data has high<low for any of x,y,z, condition. Note that a range around a single point is NOT null. */\r\n  public static isNull(data: LowAndHighXYZ): boolean {\r\n    return data.high.x < data.low.x\r\n      || data.high.y < data.low.y\r\n      || data.high.z < data.low.z;\r\n  }\r\n\r\n  /** Test of the range contains a single point. */\r\n  public get isSinglePoint(): boolean {\r\n    return this.high.x === this.low.x\r\n      && this.high.y === this.low.y\r\n      && this.high.z === this.low.z;\r\n  }\r\n\r\n  /** Return the midpoint of the diagonal.  No test for null range. */\r\n  public get center(): Point3d { return this.low.interpolate(.5, this.high); }\r\n  /** return the low x coordinate */\r\n  public get xLow(): number { return this.low.x; }\r\n  /** return the low y coordinate */\r\n  public get yLow(): number { return this.low.y; }\r\n  /** return the low z coordinate */\r\n  public get zLow(): number { return this.low.z; }\r\n  /** return the high x coordinate */\r\n  public get xHigh(): number { return this.high.x; }\r\n  /** return the high y coordinate */\r\n  public get yHigh(): number { return this.high.y; }\r\n  /** return the high z coordinate */\r\n  public get zHigh(): number { return this.high.z; }\r\n\r\n  /**  Return the length of the box in the x direction */\r\n  public xLength(): number { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }\r\n\r\n  /**  Return the length of the box in the y direction */\r\n  public yLength(): number { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }\r\n\r\n  /**  Return the length of the box in the z direction */\r\n  public zLength(): number { const a = this.high.z - this.low.z; return a > 0.0 ? a : 0.0; }\r\n\r\n  /**  Return the largest of the x,y, z lengths of the range. */\r\n  public maxLength(): number { return Math.max(this.xLength(), this.yLength(), this.zLength()); }\r\n  /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonal(result?: Vector3d): Vector3d { return this.low.vectorTo(this.high, result); }\r\n\r\n  /**  Return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonalFractionToPoint(fraction: number, result?: Point3d): Point3d { return this.low.interpolate(fraction, this.high, result); }\r\n\r\n  /**  Return a point given by fractional positions on the XYZ axes. This is done with no check for isNull !!! */\r\n  public fractionToPoint(fractionX: number, fractionY: number, fractionZ: number, result?: Point3d): Point3d {\r\n    return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);\r\n  }\r\n\r\n  /**  Return a point given by fractional positions on the XYZ axes.\r\n   *  Returns undefined if the range is null.\r\n   */\r\n  public localXYZToWorld(fractionX: number, fractionY: number, fractionZ: number, result?: Point3d): Point3d | undefined {\r\n    if (this.isNull) return undefined;\r\n    return this.low.interpolateXYZ(fractionX, fractionY, fractionZ, this.high, result);\r\n  }\r\n\r\n  /** Return a point given by fractional positions on the XYZ axes.\r\n   * * Returns undefined if the range is null.\r\n   */\r\n  public localToWorld(xyz: XYAndZ, result?: Point3d): Point3d | undefined {\r\n    return this.localXYZToWorld(xyz.x, xyz.y, xyz.z, result);\r\n  }\r\n  /** Replace fractional coordinates by world coordinates.\r\n   * @returns false if null range.\r\n   */\r\n  public localToWorldArrayInPlace(points: Point3d[]): boolean {\r\n    if (this.isNull) return false;\r\n    for (const p of points)\r\n      this.low.interpolateXYZ(p.x, p.y, p.z, this.high, p);\r\n    return false;\r\n  }\r\n  /** Return fractional coordinates of point within the range.\r\n   * * returns undefined if the range is null.\r\n   * * returns undefined if any direction (x,y,z) has zero length\r\n   */\r\n  public worldToLocal(point: Point3d, result?: Point3d): Point3d | undefined {\r\n    const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\r\n    const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\r\n    const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);\r\n    if (ax === 0.0 || ay === 0.0 || az === 0.0)\r\n      return undefined;\r\n    return Point3d.create((point.x - this.low.x) * ax, (point.y - this.low.y) * ay, (point.z - this.low.z) * az, result);\r\n  }\r\n\r\n  /** Return fractional coordinates of point within the range.\r\n   * * returns undefined if the range is null.\r\n   * * returns undefined if any direction (x,y,z) has zero length\r\n   */\r\n  public worldToLocalArrayInPlace(point: Point3d[]): boolean {\r\n    const ax = RangeBase.npcScaleFactor(this.low.x, this.high.x);\r\n    const ay = RangeBase.npcScaleFactor(this.low.y, this.high.y);\r\n    const az = RangeBase.npcScaleFactor(this.low.z, this.high.z);\r\n    if (ax === 0.0 || ay === 0.0 || az === 0.0)\r\n      return false;\r\n    for (const p of point)\r\n      Point3d.create((p.x - this.low.x) * ax, (p.y - this.low.y) * ay, (p.z - this.low.z) * az, p);\r\n    return true;\r\n  }\r\n\r\n  /** Return an array with the 8 corners on order wth \"x varies fastest, then y, then z\" */\r\n  public corners(): Point3d[] {\r\n    return [\r\n      Point3d.create(this.low.x, this.low.y, this.low.z),\r\n      Point3d.create(this.high.x, this.low.y, this.low.z),\r\n      Point3d.create(this.low.x, this.high.y, this.low.z),\r\n      Point3d.create(this.high.x, this.high.y, this.low.z),\r\n      Point3d.create(this.low.x, this.low.y, this.high.z),\r\n      Point3d.create(this.high.x, this.low.y, this.high.z),\r\n      Point3d.create(this.low.x, this.high.y, this.high.z),\r\n      Point3d.create(this.high.x, this.high.y, this.high.z)];\r\n  }\r\n\r\n  /** Return an array with indices of the corners of a face\r\n   * * face 0 has negative x normal\r\n   * * face 1 has positive x normal\r\n   * * face 2 has negative y normal\r\n   * * face 3 has positive y normal\r\n   * * face 4 has negative z normal\r\n   * * face 5 has positive z normal\r\n   * * Any other value returns face 5\r\n   * * faces are CCW as viewed from outside.\r\n   */\r\n  public static faceCornerIndices(index: number): number[] {\r\n    if (index === 0)\r\n      return [0, 4, 6, 2];\r\n    if (index === 1)\r\n      return [1, 3, 7, 5];\r\n    if (index === 2)\r\n      return [0, 1, 5, 4];\r\n    if (index === 3)\r\n      return [3, 2, 6, 7];\r\n    if (index === 4)\r\n      return [0, 2, 3, 1];\r\n    return [4, 5, 7, 6];\r\n  }\r\n\r\n  /** Return the largest absolute value among any coordinates in the box corners. */\r\n  public maxAbs(): number {\r\n    if (this.isNull)\r\n      return 0.0;\r\n    return Math.max(this.low.maxAbs(), this.high.maxAbs());\r\n  }\r\n\r\n  /** returns true if the x direction size is nearly zero */\r\n  public get isAlmostZeroX(): boolean { return Geometry.isSmallMetricDistance(this.xLength()); }\r\n  /** returns true if the y direction size is nearly zero */\r\n  public get isAlmostZeroY(): boolean { return Geometry.isSmallMetricDistance(this.yLength()); }\r\n  /** returns true if the z direction size is nearly zero */\r\n  public get isAlmostZeroZ(): boolean { return Geometry.isSmallMetricDistance(this.zLength()); }\r\n\r\n  /** Test if a point given as x,y,z is within the range. */\r\n  public containsXYZ(x: number, y: number, z: number): boolean {\r\n    return x >= this.low.x\r\n      && y >= this.low.y\r\n      && z >= this.low.z\r\n      && x <= this.high.x\r\n      && y <= this.high.y\r\n      && z <= this.high.z;\r\n  }\r\n\r\n  /** Test if a point is within the range. */\r\n  public containsPoint(point: Point3d): boolean { return this.containsXYZ(point.x, point.y, point.z); }\r\n\r\n  /** Test if the x,y coordinates of a point are within the range. */\r\n  public containsPointXY(point: Point3d): boolean {\r\n    return point.x >= this.low.x\r\n      && point.y >= this.low.y\r\n      && point.x <= this.high.x\r\n      && point.y <= this.high.y;\r\n  }\r\n\r\n  /** Test of other range is within this range */\r\n  public containsRange(other: Range3d): boolean {\r\n    return other.low.x >= this.low.x\r\n      && other.low.y >= this.low.y\r\n      && other.low.z >= this.low.z\r\n      && other.high.x <= this.high.x\r\n      && other.high.y <= this.high.y\r\n      && other.high.z <= this.high.z;\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRange(other: Range3d): boolean {\r\n    return !(this.low.x > other.high.x\r\n      || this.low.y > other.high.y\r\n      || this.low.z > other.high.z\r\n      || other.low.x > this.high.x\r\n      || other.low.y > this.high.y\r\n      || other.low.z > this.high.z);\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRangeXY(other: Range3d): boolean {\r\n    return !(this.low.x > other.high.x\r\n      || this.low.y > other.high.y\r\n      || other.low.x > this.high.x\r\n      || other.low.y > this.high.y);\r\n  }\r\n  /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\r\n  public distanceToPoint(point: XYAndZ): number {\r\n    if (this.isNull)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    return Math.min(\r\n      Geometry.hypotenuseXYZ(\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x),\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y),\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.z, this.low.z, this.high.z)),\r\n      RangeBase._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */\r\n  public distanceToRange(other: Range3d): number {\r\n    return Math.min(\r\n      Geometry.hypotenuseXYZ(\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x),\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y),\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.z, this.high.z, other.low.z, other.high.z)),\r\n      RangeBase._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** Expand this range by distances a (possibly signed) in all directions */\r\n  public extendXYZ(x: number, y: number, z: number): void {\r\n    if (x < this.low.x) this.low.x = x;\r\n    if (x > this.high.x) this.high.x = x;\r\n\r\n    if (y < this.low.y) this.low.y = y;\r\n    if (y > this.high.y) this.high.y = y;\r\n\r\n    if (z < this.low.z) this.low.z = z;\r\n    if (z > this.high.z) this.high.z = z;\r\n  }\r\n\r\n  /** Expand this range by distances a (weighted and possibly signed) in all directions */\r\n  public extendXYZW(x: number, y: number, z: number, w: number): void {\r\n    if (!Geometry.isSmallMetricDistance(w))\r\n      this.extendXYZ(x / w, y / w, z / w);\r\n  }\r\n  /** Expand this range to include a point. */\r\n  public extendPoint(point: Point3d): void { this.extendXYZ(point.x, point.y, point.z); }\r\n\r\n  /** Expand this range to include a transformed point. */\r\n  public extendTransformedPoint(transform: Transform, point: Point3d): void {\r\n    this.extendTransformedXYZ(transform, point.x, point.y, point.z);\r\n  }\r\n\r\n  /** Expand this range to include a range. */\r\n  public extendRange(other: LowAndHighXYZ): void {\r\n    if (!Range3d.isNull(other)) {\r\n      this.extendXYZ(other.low.x, other.low.y, other.low.z);\r\n      this.extendXYZ(other.high.x, other.high.y, other.high.z);\r\n    }\r\n  }\r\n\r\n  /** Return the intersection of ranges. */\r\n  public intersect(other: Range3d, result?: Range3d): Range3d {\r\n    if (!this.intersectsRange(other))\r\n      return Range3d.createNull(result);\r\n    return Range3d.createXYZXYZOrCorrectToNull\r\n      (\r\n        Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y), Math.max(this.low.z, other.low.z),\r\n        Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y), Math.min(this.high.z, other.high.z),\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the union of ranges. */\r\n  public union(other: Range3d, result?: Range3d): Range3d {\r\n    if (this.isNull)\r\n      return other.clone(result);\r\n    if (other.isNull)\r\n      return this.clone(result as this);\r\n    // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\r\n    return Range3d.createXYZXYZOrCorrectToNull\r\n      (\r\n        Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y), Math.min(this.low.z, other.low.z),\r\n        Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y), Math.max(this.high.z, other.high.z),\r\n        result);\r\n  }\r\n  /**\r\n   * move low and high points by scaleFactor around the center point.\r\n   * @param scaleFactor scale factor applied to low, high distance from center.\r\n   */\r\n  public scaleAboutCenterInPlace(scaleFactor: number) {\r\n    if (!this.isNull) {\r\n      scaleFactor = Math.abs(scaleFactor);\r\n      // do the scalar stuff to avoid making a temporary object ....\r\n      const xMid = 0.5 * (this.low.x + this.high.x);\r\n      const yMid = 0.5 * (this.low.y + this.high.y);\r\n      const zMid = 0.5 * (this.low.z + this.high.z);\r\n      this.high.x = Geometry.interpolate(xMid, scaleFactor, this.high.x);\r\n      this.high.y = Geometry.interpolate(yMid, scaleFactor, this.high.y);\r\n      this.high.z = Geometry.interpolate(zMid, scaleFactor, this.high.z);\r\n      this.low.x = Geometry.interpolate(xMid, scaleFactor, this.low.x);\r\n      this.low.y = Geometry.interpolate(yMid, scaleFactor, this.low.y);\r\n      this.low.z = Geometry.interpolate(zMid, scaleFactor, this.low.z);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * move all limits by a fixed amount.\r\n   * * positive delta expands the range size\r\n   * * negative delta reduces the range size\r\n   * * if any dimension reduces below zero size, the whole range becomes null\r\n   * @param delta shift to apply.\r\n   */\r\n  public expandInPlace(delta: number): void {\r\n    this.setDirect(\r\n      this.low.x - delta, this.low.y - delta, this.low.z - delta,\r\n      this.high.x + delta, this.high.y + delta, this.high.z + delta, true);\r\n  }\r\n\r\n  /** Create a local to world transform from this range. */\r\n  public getLocalToWorldTransform(result?: Transform): Transform {\r\n    return Transform.createOriginAndMatrix(Point3d.create(this.low.x, this.low.y, this.low.z), Matrix3d.createRowValues(\r\n      this.high.x - this.low.x, 0, 0,\r\n      0, this.high.y - this.low.y, 0,\r\n      0, 0, this.high.z - this.low.z,\r\n    ), result);\r\n  }\r\n\r\n  /**\r\n   * Creates an NPC to world transformation to go from 000...111 to the globally aligned cube with diagonally opposite corners that are the\r\n   * min and max of this range. The diagonal component for any degenerate direction is 1.\r\n   */\r\n  public getNpcToWorldRangeTransform(result?: Transform): Transform {\r\n    const transform = this.getLocalToWorldTransform(result);\r\n    const matrix = transform.matrix;\r\n    if (matrix.coffs[0] === 0)\r\n      matrix.coffs[0] = 1;\r\n    if (matrix.coffs[4] === 0)\r\n      matrix.coffs[4] = 1;\r\n    if (matrix.coffs[8] === 0)\r\n      matrix.coffs[8] = 1;\r\n    return transform;\r\n  }\r\n\r\n  /** Ensure that the length of each dimension of this AxisAlignedBox3d is at least a minimum size. If not, expand to minimum about the center.\r\n   * @param min The minimum length for each dimension.\r\n   */\r\n  public ensureMinLengths(min: number = .001) {\r\n    let size = (min - this.xLength()) / 2.0;\r\n    if (size > 0) {\r\n      this.low.x -= size;\r\n      this.high.x += size;\r\n    }\r\n    size = (min - this.yLength()) / 2.0;\r\n    if (size > 0) {\r\n      this.low.y -= size;\r\n      this.high.y += size;\r\n    }\r\n    size = (min - this.zLength()) / 2.0;\r\n    if (size > 0) {\r\n      this.low.z -= size;\r\n      this.high.z += size;\r\n    }\r\n  }\r\n}\r\n/**\r\n * Range on a 1d axis\r\n * * `low` and `high` members are always non-null objects\r\n * * having `low > high` indicates an empty range.\r\n * * the range contains x values for which `low <= x <= high`\r\n * @public\r\n */\r\nexport class Range1d extends RangeBase {\r\n  /** low point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public low: number;\r\n  /** high point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public high: number;\r\n  /** reset the low and high to null range state. */\r\n  public setNull() {\r\n    this.low = RangeBase._EXTREME_POSITIVE;\r\n    this.high = RangeBase._EXTREME_NEGATIVE;\r\n  }\r\n  // internal use only -- directly set all coordinates, test only if directed.\r\n  private setDirect(low: number, high: number, correctToNull: boolean = false) {\r\n    this.low = low;\r\n    this.high = high;\r\n    if (correctToNull && low > high)\r\n      this.setNull();\r\n  }\r\n  // explicit ctor - no enforcement of value relationships\r\n  private constructor(\r\n    low: number = RangeBase._EXTREME_POSITIVE,\r\n    high: number = RangeBase._EXTREME_NEGATIVE) {\r\n    super();\r\n    this.low = low; this.high = high; // duplicates set_direct, but compiler is not convinced they are set.\r\n    this.setDirect(low, high);\r\n  }\r\n  /** Returns true if this and other have equal low and high parts, or both are null ranges. */\r\n  public isAlmostEqual(other: Range1d): boolean {\r\n    return (Geometry.isSameCoordinate(this.low, other.low) && Geometry.isSameCoordinate(this.high, other.high))\r\n      || (this.isNull && other.isNull);\r\n  }\r\n  /** copy contents from other Range1d. */\r\n  public setFrom(other: Range1d) { this.low = other.low; this.high = other.high; }\r\n  /** Convert from a JSON object of one of these forms:\r\n   *\r\n   * *  Any array of numbers: `[value,value, value]`\r\n   * *  An object with low and high as properties: `{low:lowValue, high: highValue}`\r\n   */\r\n  public setFromJSON(json: Range1dProps): void {\r\n    this.setNull();\r\n    if (Array.isArray(json)) {\r\n      let value;\r\n      for (value of json) {\r\n        if (Number.isFinite(value))\r\n          this.extendX(value);\r\n      }\r\n    } else if (json.low && json.low && json.high && json.high) {\r\n      this.setNull();\r\n      this.extendX(json.low);\r\n      this.extendX(json.high);\r\n    }\r\n  }\r\n  /** Use `setFromJSON` to parse `json` into a new Range1d instance. */\r\n  public static fromJSON<T extends Range1d>(json?: Range1dProps): T {\r\n    const result = new this() as T;\r\n    if (json)\r\n      result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Convert to a JSON object of form\r\n   * ```\r\n   *    [lowValue,highValue]\r\n   * ```\r\n   */\r\n  public toJSON(): Range1dProps { if (this.isNull) return new Array<number>(); else return [this.low, this.high]; }\r\n\r\n  /** return a new Range1d with contents of this.\r\n   * @param result optional result.\r\n   */\r\n  public clone(result?: this): this {\r\n    result = result ? result : new (this.constructor as any)() as this;\r\n    result.setDirect(this.low, this.high);\r\n    return result;\r\n  }\r\n\r\n  /** return a new Range1d with contents of this.\r\n   * @param result optional result.\r\n   */\r\n  public static createFrom<T extends Range1d>(other: T, result?: T) {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(other.low, other.high);\r\n    return result;\r\n  }\r\n\r\n  /** Create a range with no content.\r\n   * @param result optional result.\r\n   */\r\n  public static createNull<T extends Range1d>(result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Set this range to be a single value.\r\n   * @param x value to use as both low and high.\r\n   */\r\n  public setX(x: number) { this.low = this.high = x; }\r\n\r\n  /** Create a single point box */\r\n  public static createX<T extends Range1d>(x: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(x, x);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box from two values. Values are reversed if needed\r\n   * @param xA first value\r\n   * @param xB second value\r\n   */\r\n  public static createXX<T extends Range1d>(xA: number, xB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB),\r\n      Math.max(xA, xB));\r\n    return result;\r\n  }\r\n\r\n  /** Create a box from two values, but null range if the values are reversed\r\n   * @param xA first value\r\n   * @param xB second value\r\n   */\r\n  public static createXXOrCorrectToNull<T extends Range1d>(xA: number, xB: number, result?: T): T {\r\n    if (xB < xA)\r\n      return Range1d.createNull(result);\r\n\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB),\r\n      Math.max(xA, xB));\r\n    return result;\r\n  }\r\n\r\n  /** Create a range containing all the values in an array.\r\n   * @param values array of points to be contained in the range.\r\n   * @param result optional result.\r\n   */\r\n  public static createArray<T extends Range1d>(values: Float64Array | number[], result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    let x;\r\n    for (x of values)\r\n      result.extendX(x);\r\n    return result;\r\n  }\r\n  /** extend to include an array of values */\r\n  public extendArray(values: Float64Array | number[]) {\r\n    let x;\r\n    for (x of values)\r\n      this.extendX(x);\r\n  }\r\n\r\n  /** extend to include `values` at indices `beginIndex <= i < endIndex]`\r\n   * @param values array of values\r\n   * @param beginIndex first index to include\r\n   * @param numValue number of values to access\r\n   */\r\n  public extendArraySubset(values: Float64Array | number[], beginIndex: number, numValue: number) {\r\n    const endIndex = beginIndex + numValue;\r\n    for (let i = beginIndex; i < endIndex; i++)\r\n      this.extendX(values[i]);\r\n  }\r\n\r\n  /** Test if the box has high<low Note that a range around a single point is NOT null. */\r\n  public get isNull(): boolean {\r\n    return this.high < this.low;\r\n  }\r\n\r\n  /** Test of the range contains a single point. */\r\n  public get isSinglePoint(): boolean {\r\n    return this.high === this.low;\r\n  }\r\n\r\n  /** Return the length of the range in the x direction */\r\n  public length(): number { const a = this.high - this.low; return a > 0.0 ? a : 0.0; }\r\n\r\n  /** return a point given by fractional positions within the range. This is done with no check for isNull !!! */\r\n  public fractionToPoint(fraction: number): number {\r\n    return Geometry.interpolate(this.low, fraction, this.high);\r\n  }\r\n\r\n  /** Return the largest absolute value among the box limits. */\r\n  public maxAbs(): number {\r\n    if (this.isNull)\r\n      return 0.0;\r\n    return Math.max(Math.abs(this.low), Math.abs(this.high));\r\n  }\r\n\r\n  /** Test if the x direction size is nearly zero */\r\n  public get isAlmostZeroLength(): boolean { return Geometry.isSmallMetricDistance(this.length()); }\r\n\r\n  /** Test if a number is within the range. */\r\n  public containsX(x: number): boolean {\r\n    return x >= this.low\r\n      && x <= this.high;\r\n  }\r\n\r\n  /** Test of other range is within this range */\r\n  public containsRange(other: Range1d): boolean {\r\n    return other.low >= this.low\r\n      && other.high <= this.high;\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRange(other: Range1d): boolean {\r\n    return !(this.low > other.high || other.low > this.high);\r\n  }\r\n\r\n  /** returns 0 if the ranges have any overlap, otherwise the shortest absolute distance from one to the other. */\r\n  public distanceToRange(other: Range1d): number {\r\n    return RangeBase.rangeToRangeAbsoluteDistance(this.low, this.high, other.low, other.high);\r\n  }\r\n\r\n  /** Return 0 if the point is within the range, otherwise the (unsigned) distance to the closest face or corner */\r\n  public distanceToX(x: number): number {\r\n    if (this.isNull)\r\n      return RangeBase._EXTREME_POSITIVE;\r\n    return RangeBase.coordinateToRangeAbsoluteDistance(x, this.low, this.high);\r\n  }\r\n\r\n  /** Expand this range by a single coordinate */\r\n  public extendX(x: number): void {\r\n    if (x < this.low) this.low = x;\r\n    if (x > this.high) this.high = x;\r\n  }\r\n\r\n  /** Expand this range to include a range. */\r\n  public extendRange(other: Range1d): void {\r\n    if (!other.isNull) {\r\n      this.extendX(other.low);\r\n      this.extendX(other.high);\r\n    }\r\n  }\r\n\r\n  /** Return the intersection of ranges. */\r\n  public intersect(other: Range1d, result?: Range1d): Range1d {\r\n    if (!this.intersectsRange(other))\r\n      return Range1d.createNull(result);\r\n\r\n    return Range1d.createXXOrCorrectToNull\r\n      (\r\n        Math.max(this.low, other.low),\r\n        Math.min(this.high, other.high),\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the union of ranges. */\r\n  /** Return the intersection of ranges. */\r\n  public union(other: Range1d, result?: Range1d): Range1d {\r\n    // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\r\n    return Range1d.createXX\r\n      (\r\n        Math.min(this.low, other.low),\r\n        Math.max(this.high, other.high),\r\n        result);\r\n  }\r\n  /**\r\n   * move low and high points by scaleFactor around the center point.\r\n   * @param scaleFactor scale factor applied to low, high distance from center.\r\n   */\r\n  public scaleAboutCenterInPlace(scaleFactor: number) {\r\n    if (!this.isNull) {\r\n      scaleFactor = Math.abs(scaleFactor);\r\n      // do the scalar stuff to avoid making a temporary object ....\r\n      const xMid = 0.5 * (this.low + this.high);\r\n      this.high = Geometry.interpolate(xMid, scaleFactor, this.high);\r\n      this.low = Geometry.interpolate(xMid, scaleFactor, this.low);\r\n    }\r\n  }\r\n  /**\r\n   * move all limits by a fixed amount.\r\n   * * positive delta expands the range size\r\n   * * negative delta reduces the range size\r\n   * * if any dimension reduces below zero size, the whole range becomes null\r\n   * @param delta shift to apply.\r\n   */\r\n  public expandInPlace(delta: number): void {\r\n    this.setDirect(\r\n      this.low - delta,\r\n      this.high + delta, true);\r\n  }\r\n}\r\n\r\n/**\r\n * Range box in xy plane\r\n * @public\r\n */\r\nexport class Range2d extends RangeBase implements LowAndHighXY {\r\n  // low and high are always non-null objects\r\n  // any direction of low.q > high.q is considered a null range.\r\n  /** low point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public low: Point2d;\r\n  /** low point coordinates.  DO NOT MODIFY FROM OUTSIDE THIS CLASS */\r\n  public high: Point2d;\r\n\r\n  /** reset the low and high to null range state. */\r\n  public setNull() {\r\n    this.low.x = RangeBase._EXTREME_POSITIVE;\r\n    this.low.y = RangeBase._EXTREME_POSITIVE;\r\n    this.high.x = RangeBase._EXTREME_NEGATIVE;\r\n    this.high.y = RangeBase._EXTREME_NEGATIVE;\r\n  }\r\n  /** Flatten the low and high coordinates of any json object with low.x .. high.y into an array of 4 doubles */\r\n  public static toFloat64Array(val: LowAndHighXY): Float64Array { return Float64Array.of(val.low.x, val.low.y, val.high.x, val.high.y); }\r\n  /** Flatten the low and high coordinates of this instance into an array of 4 doubles */\r\n  public toFloat64Array(): Float64Array { return Range2d.toFloat64Array(this); }\r\n  /**\r\n   * Construct a Range2d from an array of double-precision values\r\n   * @param f64 the array, which should contain exactly 4 values in this order: lowx, lowy, highx, highy\r\n   * @return a new Range2d object\r\n   */\r\n  public static fromFloat64Array<T extends Range2d>(f64: Float64Array): T {\r\n    if (f64.length !== 4)\r\n      throw new Error(\"invalid array\");\r\n    return new this(f64[0], f64[1], f64[2], f64[3]) as T;\r\n  }\r\n  /**\r\n   * Construct a Range2d from an un-typed array. This mostly useful when interpreting ECSQL query results of the 'blob' type, where you know that that result is a Range3d.\r\n   * @param buffer untyped array\r\n   * @return a new Range2d object\r\n   */\r\n  public static fromArrayBuffer<T extends Range2d>(buffer: ArrayBuffer): T { return this.fromFloat64Array(new Float64Array(buffer)); }\r\n\r\n  // explicit ctor - no enforcement of value relationships\r\n  public constructor(lowx = Range2d._EXTREME_POSITIVE, lowy = Range2d._EXTREME_POSITIVE, highx = Range2d._EXTREME_NEGATIVE, highy = Range2d._EXTREME_NEGATIVE) {\r\n    super();\r\n    this.low = Point2d.create(lowx, lowy);\r\n    this.high = Point2d.create(highx, highy);\r\n  }\r\n  /** Returns true if this and other have equal low and high parts, or both are null ranges. */\r\n  public isAlmostEqual(other: Range2d): boolean {\r\n    return (this.low.isAlmostEqual(other.low) && this.high.isAlmostEqual(other.high))\r\n      || (this.isNull && other.isNull);\r\n  }\r\n  /** copy all content from any `other` that has low and high xy data. */\r\n  public setFrom(other: LowAndHighXY) {\r\n    this.low.set(other.low.x, other.low.y);\r\n    this.high.set(other.high.x, other.high.y);\r\n  }\r\n  /** create a new Range2d from any `other` that has low and high xy data. */\r\n  public static createFrom<T extends Range2d>(other: LowAndHighXY, result?: T): T {\r\n    if (result) { result.setFrom(other); return result; }\r\n    return this.createXYXYOrCorrectToNull(other.low.x, other.low.y, other.high.x, other.high.y, result) as T;\r\n  }\r\n  /** treat any array of numbers as numbers to be inserted !!! */\r\n  public setFromJSON(json: Range2dProps): void {\r\n    this.setNull();\r\n    if (Array.isArray(json)) {\r\n      const point = Point2d.create();\r\n      for (const value of json) {\r\n        point.setFromJSON(value);\r\n        this.extendPoint(point);\r\n      }\r\n      return;\r\n    }\r\n    const low = Point2d.fromJSON(json.low);\r\n    const high = Point2d.fromJSON(json.high);\r\n    if (!RangeBase.isExtremePoint2d(low) && !RangeBase.isExtremePoint2d(high)) {\r\n      this.extendPoint(low);\r\n      this.extendPoint(high);\r\n    }\r\n  }\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this.low); Object.freeze(this.high); }\r\n  /** return json array with two points as produced by `Point2d.toJSON` */\r\n  public toJSON(): Range2dProps { return this.isNull ? [] : [this.low.toJSON(), this.high.toJSON()]; }\r\n  /** Use `setFromJSON` to parse `json` into a new Range2d instance. */\r\n  public static fromJSON<T extends Range2d>(json?: Range2dProps): T {\r\n    const result = new this() as T;\r\n    if (json)\r\n      result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  // internal use only -- directly set all coordinates, without tests.\r\n  private setDirect(xA: number, yA: number, xB: number, yB: number, correctToNull: boolean) {\r\n    this.low.x = xA;\r\n    this.low.y = yA;\r\n\r\n    this.high.x = xB;\r\n    this.high.y = yB;\r\n    if (correctToNull) {\r\n      if (this.low.x > this.high.x || this.low.y > this.high.y)\r\n        this.setNull();\r\n    }\r\n  }\r\n  /** return a clone of this range (or copy to optional result) */\r\n  public clone(result?: this): this {\r\n    result = result ? result : new (this.constructor as any)() as this;\r\n    result.setDirect(this.low.x, this.low.y, this.high.x, this.high.y, false);\r\n    return result;\r\n  }\r\n  /** create a range with no content. */\r\n  public static createNull<T extends Range2d>(result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setNull();\r\n    return result;\r\n  }\r\n  /** Set low and hight to a single xy value. */\r\n  public setXY(x: number, y: number) {\r\n    this.low.x = this.high.x = x;\r\n    this.low.y = this.high.y = y;\r\n  }\r\n\r\n  /** Create a single point box */\r\n  public static createXY<T extends Range2d>(x: number, y: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(x, y, x, y, false);\r\n    return result;\r\n  }\r\n\r\n  /** Create a box with 2 pairs of xy candidates. Theses are compared and shuffled as needed for the box. */\r\n  public static createXYXY<T extends Range2d>(xA: number, yA: number, xB: number, yB: number, result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB),\r\n      Math.max(xA, xB), Math.max(yA, yB), false);\r\n    return result;\r\n  }\r\n  /** Create a box with 2 pairs of xy candidates. If any direction has order flip, create null. */\r\n  public static createXYXYOrCorrectToNull<T extends Range2d>(xA: number, yA: number, xB: number, yB: number, result?: T): T {\r\n    if (xA > xB || yA > yB)\r\n      return this.createNull(result);\r\n    result = result ? result : new this() as T;\r\n    result.setDirect(\r\n      Math.min(xA, xB), Math.min(yA, yB),\r\n      Math.max(xA, xB), Math.max(yA, yB), true);\r\n    return result;\r\n  }\r\n\r\n  /** Create a range around an array of points. */\r\n  public static createArray<T extends Range2d>(points: Point2d[], result?: T): T {\r\n    result = result ? result : new this() as T;\r\n    let point;\r\n    for (point of points)\r\n      result.extendPoint(point);\r\n    return result;\r\n  }\r\n\r\n  /** Test if the box has high<low for any of x,y, condition. Note that a range around a single point is NOT null. */\r\n  public get isNull(): boolean {\r\n    return this.high.x < this.low.x\r\n      || this.high.y < this.low.y;\r\n  }\r\n\r\n  /** Test if the box has high strictly less than low for any of x,y, condition. Note that a range around a single point is NOT null. */\r\n  public static isNull(range: LowAndHighXY): boolean {\r\n    return range.high.x < range.low.x\r\n      || range.high.y < range.low.y;\r\n  }\r\n\r\n  /** Test of the range contains a single point. */\r\n  public get isSinglePoint(): boolean {\r\n    return this.high.x === this.low.x\r\n      && this.high.y === this.low.y;\r\n  }\r\n  /** Return the midpoint of the diagonal.  No test for null range. */\r\n  public get center(): Point2d { return this.low.interpolate(.5, this.high); }\r\n  /** return the low x coordinate */\r\n  public get xLow(): number { return this.low.x; }\r\n  /** return the low y coordinate */\r\n  public get yLow(): number { return this.low.y; }\r\n  /** return the high x coordinate */\r\n  public get xHigh(): number { return this.high.x; }\r\n  /** return the high y coordinate */\r\n  public get yHigh(): number { return this.high.y; }\r\n\r\n  /** Length of the box in the x direction */\r\n  public xLength(): number { const a = this.high.x - this.low.x; return a > 0.0 ? a : 0.0; }\r\n\r\n  /** Length of the box in the y direction */\r\n  public yLength(): number { const a = this.high.y - this.low.y; return a > 0.0 ? a : 0.0; }\r\n\r\n  /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonal(result?: Vector2d): Vector2d { return this.low.vectorTo(this.high, result); }\r\n\r\n  /** return the diagonal vector. There is no check for isNull -- if the range isNull(), the vector will have very large negative coordinates. */\r\n  public diagonalFractionToPoint(fraction: number, result?: Point2d): Point2d { return this.low.interpolate(fraction, this.high, result); }\r\n\r\n  /** return a point given by fractional positions on the XY axes. This is done with no check for isNull !!! */\r\n  public fractionToPoint(fractionX: number, fractionY: number, result?: Point2d): Point2d {\r\n    return this.low.interpolateXY(fractionX, fractionY, this.high, result);\r\n  }\r\n  /** Largest absolute value among any coordinates in the box corners. */\r\n  public maxAbs(): number {\r\n    if (this.isNull)\r\n      return 0.0;\r\n    return Math.max(this.low.maxAbs(), this.high.maxAbs());\r\n  }\r\n\r\n  /** Test if the x direction size is nearly zero */\r\n  public get isAlmostZeroX(): boolean { return Geometry.isSmallMetricDistance(this.xLength()); }\r\n  /** Test if the y direction size is nearly zero */\r\n  public get isAlmostZeroY(): boolean { return Geometry.isSmallMetricDistance(this.yLength()); }\r\n\r\n  /** Test if a point given as x,y is within the range. */\r\n  public containsXY(x: number, y: number): boolean {\r\n    return x >= this.low.x\r\n      && y >= this.low.y\r\n      && x <= this.high.x\r\n      && y <= this.high.y;\r\n  }\r\n\r\n  /** Test if a point is within the range. */\r\n  public containsPoint(point: XAndY): boolean { return this.containsXY(point.x, point.y); }\r\n\r\n  /** Test of other range is within this range */\r\n  public containsRange(other: LowAndHighXY): boolean {\r\n    return other.low.x >= this.low.x\r\n      && other.low.y >= this.low.y\r\n      && other.high.x <= this.high.x\r\n      && other.high.y <= this.high.y;\r\n  }\r\n\r\n  /** Test if there is any intersection with other range */\r\n  public intersectsRange(other: LowAndHighXY): boolean {\r\n    return !(this.low.x > other.high.x\r\n      || this.low.y > other.high.y\r\n      || other.low.x > this.high.x\r\n      || other.low.y > this.high.y);\r\n  }\r\n\r\n  /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\r\n  public distanceToPoint(point: XAndY): number {\r\n    if (this.isNull)\r\n      return Range2d._EXTREME_POSITIVE;\r\n    return Math.min(\r\n      Geometry.hypotenuseXY(\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.x, this.low.x, this.high.x),\r\n        RangeBase.coordinateToRangeAbsoluteDistance(point.y, this.low.y, this.high.y)),\r\n      Range2d._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** Return 0 if the point is within the range, otherwise the distance to the closest face or corner */\r\n  public distanceToRange(other: LowAndHighXY): number {\r\n    return Math.min(\r\n      Geometry.hypotenuseXY(\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.x, this.high.x, other.low.x, other.high.x),\r\n        RangeBase.rangeToRangeAbsoluteDistance(this.low.y, this.high.y, other.low.y, other.high.y)),\r\n      Range2d._EXTREME_POSITIVE);\r\n  }\r\n\r\n  /** Expand this range to include a point given by x,y */\r\n  public extendXY(x: number, y: number): void {\r\n    if (x < this.low.x) this.low.x = x;\r\n    if (x > this.high.x) this.high.x = x;\r\n\r\n    if (y < this.low.y) this.low.y = y;\r\n    if (y > this.high.y) this.high.y = y;\r\n  }\r\n\r\n  /** Expand this range to include a point given by x,y */\r\n  public extendTransformedXY(transform: Transform, x: number, y: number): void {\r\n    const x1 = transform.multiplyComponentXYZ(0, x, y, 0);\r\n    const y1 = transform.multiplyComponentXYZ(1, x, y, 0);\r\n    this.extendXY(x1, y1);\r\n  }\r\n  /** Expand this range to include a point. */\r\n  public extendPoint(point: XAndY): void { this.extendXY(point.x, point.y); }\r\n\r\n  /** Expand this range to include a range. */\r\n  public extendRange(other: LowAndHighXY): void {\r\n    if (!Range2d.isNull(other)) {\r\n      this.extendXY(other.low.x, other.low.y);\r\n      this.extendXY(other.high.x, other.high.y);\r\n    }\r\n  }\r\n\r\n  /** Return the intersection of ranges. */\r\n  public intersect(other: LowAndHighXY, result?: Range2d): Range2d {\r\n    if (!this.intersectsRange(other))\r\n      return Range2d.createNull(result);\r\n    return Range2d.createXYXY\r\n      (\r\n        Math.max(this.low.x, other.low.x), Math.max(this.low.y, other.low.y),\r\n        Math.min(this.high.x, other.high.x), Math.min(this.high.y, other.high.y),\r\n        result);\r\n\r\n  }\r\n\r\n  /** Return the union of ranges. */\r\n  public union(other: LowAndHighXY, result?: Range2d): Range2d {\r\n    if (this.isNull)\r\n      return Range2d.createFrom(other, result);\r\n    if (Range2d.isNull(other))\r\n      return this.clone(result as this);\r\n    // we trust null ranges have EXTREME values, so a null in either input leads to expected results.\r\n    return Range2d.createXYXY\r\n      (\r\n        Math.min(this.low.x, other.low.x), Math.min(this.low.y, other.low.y),\r\n        Math.max(this.high.x, other.high.x), Math.max(this.high.y, other.high.y),\r\n        result);\r\n  }\r\n\r\n  /**\r\n   * move low and high points by scaleFactor around the center point.\r\n   * @param scaleFactor scale factor applied to low, high distance from center.\r\n   */\r\n  public scaleAboutCenterInPlace(scaleFactor: number) {\r\n    if (!this.isNull) {\r\n      scaleFactor = Math.abs(scaleFactor);\r\n      // do the scalar stuff to avoid making a temporary object ....\r\n      const xMid = 0.5 * (this.low.x + this.high.x);\r\n      const yMid = 0.5 * (this.low.y + this.high.y);\r\n      this.high.x = Geometry.interpolate(xMid, scaleFactor, this.high.x);\r\n      this.high.y = Geometry.interpolate(yMid, scaleFactor, this.high.y);\r\n      this.low.x = Geometry.interpolate(xMid, scaleFactor, this.low.x);\r\n      this.low.y = Geometry.interpolate(yMid, scaleFactor, this.low.y);\r\n    }\r\n  }\r\n  /**\r\n   * move all limits by a fixed amount.\r\n   * * positive delta expands the range size\r\n   * * negative delta reduces the range size\r\n   * * if any dimension reduces below zero size, the whole range becomes null\r\n   * @param delta shift to apply.\r\n   */\r\n  public expandInPlace(delta: number): void {\r\n    this.setDirect(\r\n      this.low.x - delta, this.low.y - delta,\r\n      this.high.x + delta, this.high.y + delta, true);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\nimport { Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { AxisOrder, BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"./Plane3dByOriginAndUnitNormal\";\r\nimport { XYAndZ } from \"./XYZProps\";\r\nimport { CurveLocationDetail, CurveLocationDetailPair, CurveCurveApproachType } from \"../curve/CurveLocationDetail\";\r\nimport { SmallSystem } from \"../numerics/Polynomials\";\r\nimport { Vector2d } from \"./Point2dVector2d\";\r\n/** A Ray3d contains\r\n * * an origin point.\r\n * * a direction vector.  The vector is NOT required to be normalized.\r\n *  * an optional weight (number).\r\n * @public\r\n */\r\nexport class Ray3d implements BeJSONFunctions {\r\n  /** The ray origin */\r\n  public origin: Point3d;\r\n  /** The ray direction.  This is commonly (but not always) a unit vector. */\r\n  public direction: Vector3d;\r\n  /** Numeric annotation. */\r\n  public a?: number; // optional, e.g. weight.\r\n  // constructor captures references !!!\r\n  private constructor(origin: Point3d, direction: Vector3d) {\r\n    this.origin = origin;\r\n    this.direction = direction;\r\n  }\r\n  private static _create(x: number, y: number, z: number, u: number, v: number, w: number) {\r\n    return new Ray3d(Point3d.create(x, y, z), Vector3d.create(u, v, w));\r\n  }\r\n  /** Create a ray on the x axis. */\r\n  public static createXAxis(): Ray3d { return Ray3d._create(0, 0, 0, 1, 0, 0); }\r\n  /** Create a ray on the y axis. */\r\n  public static createYAxis(): Ray3d { return Ray3d._create(0, 0, 0, 0, 1, 0); }\r\n  /** Create a ray on the z axis. */\r\n  public static createZAxis(): Ray3d { return Ray3d._create(0, 0, 0, 0, 0, 1); }\r\n  /** Create a ray with all zeros. */\r\n  public static createZero(result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.origin.setZero();\r\n      result.direction.setZero();\r\n      return result;\r\n    }\r\n    return new Ray3d(Point3d.createZero(), Vector3d.createZero());\r\n  }\r\n  /** Test for nearly equal rays. */\r\n  public isAlmostEqual(other: Ray3d): boolean {\r\n    return this.origin.isAlmostEqual(other.origin) && this.direction.isAlmostEqual(other.direction);\r\n  }\r\n  /** Create a ray from origin and direction. */\r\n  public static create(origin: Point3d, direction: Vector3d, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.set(origin, direction);\r\n      return result;\r\n    }\r\n    return new Ray3d(origin.clone(), direction.clone());\r\n  }\r\n  /**\r\n   * Given a homogeneous point and its derivative components, construct a Ray3d with cartesian coordinates and derivatives.\r\n   * @param weightedPoint `[x,y,z,w]` parts of weighted point.\r\n   * @param weightedDerivative `[x,y,z,w]` derivatives\r\n   * @param result\r\n   */\r\n  public static createWeightedDerivative(weightedPoint: Float64Array, weightedDerivative: Float64Array, result?: Ray3d): Ray3d | undefined {\r\n    const w = weightedPoint[3];\r\n    const dw = weightedDerivative[3];\r\n    const x = weightedPoint[0];\r\n    const y = weightedPoint[1];\r\n    const z = weightedPoint[2];\r\n    const dx = weightedDerivative[0] * w - weightedPoint[0] * dw;\r\n    const dy = weightedDerivative[1] * w - weightedPoint[1] * dw;\r\n    const dz = weightedDerivative[2] * w - weightedPoint[2] * dw;\r\n    if (Geometry.isSmallMetricDistance(w))\r\n      return undefined;\r\n    const divW = 1.0 / w;\r\n    const divWW = divW * divW;\r\n    return Ray3d.createXYZUVW(x * divW, y * divW, z * divW, dx * divWW, dy * divWW, dz * divWW, result);\r\n  }\r\n  /** Create from coordinates of the origin and direction. */\r\n  public static createXYZUVW(originX: number, originY: number, originZ: number, directionX: number, directionY: number, directionZ: number, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.getOriginRef().set(originX, originY, originZ);\r\n      result.getDirectionRef().set(directionX, directionY, directionZ);\r\n      return result;\r\n    }\r\n    return new Ray3d(Point3d.create(originX, originY, originZ), Vector3d.create(directionX, directionY, directionZ));\r\n  }\r\n  /** Capture origin and direction in a new Ray3d. */\r\n  public static createCapture(origin: Point3d, direction: Vector3d): Ray3d {\r\n    return new Ray3d(origin, direction);\r\n  }\r\n  /** Create from (clones of) origin, direction, and numeric weight. */\r\n  public static createPointVectorNumber(origin: Point3d, direction: Vector3d, a: number, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.origin.setFrom(origin);\r\n      result.direction.setFrom(direction);\r\n      result.a = a;\r\n      return result;\r\n    }\r\n    result = new Ray3d(origin.clone(), direction.clone());\r\n    result.a = a;\r\n    return result;\r\n  }\r\n  /** Create from origin and target.  The direction vector is the full length (non-unit) vector from origin to target. */\r\n  public static createStartEnd(origin: Point3d, target: Point3d, result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.origin.setFrom(origin);\r\n      result.direction.setStartEnd(origin, target);\r\n      return result;\r\n    }\r\n    return new Ray3d(origin, Vector3d.createStartEnd(origin, target));\r\n  }\r\n  /** Return a reference to the ray's origin. */\r\n  public getOriginRef(): Point3d { return this.origin; }\r\n  /** Return a reference to the ray's direction vector. */\r\n  public getDirectionRef(): Vector3d { return this.direction; }\r\n  /** copy coordinates from origin and direction. */\r\n  public set(origin: Point3d, direction: Vector3d): void {\r\n    this.origin.setFrom(origin);\r\n    this.direction.setFrom(direction);\r\n  }\r\n  /** Clone the ray. */\r\n  public clone(result?: Ray3d): Ray3d {\r\n    if (result) {\r\n      result.set(this.origin.clone(), this.direction.clone());\r\n      return result;\r\n    }\r\n    return new Ray3d(this.origin.clone(), this.direction.clone());\r\n  }\r\n  /** Create a clone and return the transform of the clone. */\r\n  public cloneTransformed(transform: Transform): Ray3d {\r\n    return new Ray3d(transform.multiplyPoint3d(this.origin), transform.multiplyVector(this.direction));\r\n  }\r\n  /** Apply a transform in place. */\r\n  public transformInPlace(transform: Transform) {\r\n    transform.multiplyPoint3d(this.origin, this.origin);\r\n    transform.multiplyVector(this.direction, this.direction);\r\n  }\r\n  /** Copy data from another ray. */\r\n  public setFrom(source: Ray3d): void { this.set(source.origin, source.direction); }\r\n  /** * fraction 0 is the ray origin.\r\n   * * fraction 1 is at the end of the direction vector when placed at the origin.\r\n   * @returns Return a point at fractional position along the ray.\r\n   */\r\n  public fractionToPoint(fraction: number): Point3d { return this.origin.plusScaled(this.direction, fraction); }\r\n  /** Return the dot product of the ray's direction vector with a vector from the ray origin to the space point. */\r\n  public dotProductToPoint(spacePoint: Point3d): number { return this.direction.dotProductStartEnd(this.origin, spacePoint); }\r\n  /**\r\n   * Return the fractional coordinate (along the direction vector) of the spacePoint projected to the ray.\r\n   */\r\n  public pointToFraction(spacePoint: Point3d): number {\r\n    return Geometry.safeDivideFraction(this.direction.dotProductStartEnd(this.origin, spacePoint), this.direction.magnitudeSquared(), 0);\r\n  }\r\n  /**\r\n   *\r\n   * Return the spacePoint projected onto the ray.\r\n   */\r\n  public projectPointToRay(spacePoint: Point3d): Point3d {\r\n    return this.origin.plusScaled(this.direction, this.pointToFraction(spacePoint));\r\n  }\r\n  /** Return a transform for rigid axes\r\n   * at ray origin with z in ray direction.  If the direction vector is zero, axes default to identity (from createHeadsUpTriad)\r\n   */\r\n  public toRigidZFrame(): Transform | undefined {\r\n    const axes = Matrix3d.createRigidHeadsUp(this.direction, AxisOrder.ZXY);\r\n    return Transform.createOriginAndMatrix(this.origin, axes);\r\n  }\r\n  /**\r\n   * Convert {origin:[x,y,z], direction:[u,v,w]} to a Ray3d.\r\n   */\r\n  public setFromJSON(json?: any) {\r\n    if (!json) {\r\n      this.origin.set(0, 0, 0);\r\n      this.direction.set(0, 0, 1);\r\n      return;\r\n    }\r\n    this.origin.setFromJSON(json.origin);\r\n    this.direction.setFromJSON(json.direction);\r\n  }\r\n  /**\r\n   * try to scale the direction vector to a given magnitude.\r\n   * @returns Returns false if ray direction is a zero vector.\r\n   */\r\n  public trySetDirectionMagnitudeInPlace(magnitude: number = 1.0): boolean {\r\n    if (this.direction.tryNormalizeInPlace()) {\r\n      this.direction.scaleInPlace(magnitude);\r\n      return true;\r\n    }\r\n    this.direction.setZero();\r\n    this.a = 0.0;\r\n    return false;\r\n  }\r\n  /**\r\n   * If parameter `a` is clearly nonzero and the direction vector can be normalized,\r\n   * * save the parameter `a` as the optional `a` member of the ray.\r\n   * * normalize the ray's direction vector\r\n   * If parameter `a` is nearly zero,\r\n   * * Set the `a` member to zero\r\n   * * Set the ray's direction vector to zero.\r\n   * @param a area to be saved.\r\n   */\r\n  // input a ray and \"a\" understood as an area.\r\n  // if a is clearly nonzero metric squared and the vector can be normalized, install those and return true.\r\n  // otherwise set ray.z to zero and zero the vector of the ray and return false.\r\n  public tryNormalizeInPlaceWithAreaWeight(a: number): boolean {\r\n    const tolerance = Geometry.smallMetricDistanceSquared;\r\n    this.a = a;\r\n    if (Math.abs(a) > tolerance && this.direction.tryNormalizeInPlace(tolerance))\r\n      return true;\r\n    this.direction.setZero();\r\n    this.a = 0.0;\r\n    return false;\r\n  }\r\n  /**\r\n   * Convert an Angle to a JSON object.\r\n   * @return {*} [origin,normal]\r\n   */\r\n  public toJSON(): any { return { origin: this.origin.toJSON(), direction: this.direction.toJSON() }; }\r\n  /** Create a new ray from json object.  See `setFromJSON` for json structure; */\r\n  public static fromJSON(json?: any) {\r\n    const result = Ray3d.createXAxis();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** return distance from the ray to point in space */\r\n  public distance(spacePoint: Point3d): number {\r\n    const uu = this.direction.magnitudeSquared();\r\n    const uv = this.dotProductToPoint(spacePoint);\r\n    const aa = Geometry.inverseMetricDistanceSquared(uu);\r\n    if (aa)\r\n      return Math.sqrt(this.origin.distanceSquared(spacePoint) - uv * uv * aa);\r\n    else\r\n      return Math.sqrt(this.origin.distanceSquared(spacePoint));\r\n  }\r\n  /**\r\n   * Return the intersection of the unbounded ray with a plane.\r\n   * Stores the point of intersection in the result point given as a parameter,\r\n   * and returns the parameter along the ray where the intersection occurs.\r\n   * Returns undefined if the ray and plane are parallel.\r\n   */\r\n  public intersectionWithPlane(plane: Plane3dByOriginAndUnitNormal, result?: Point3d): number | undefined {\r\n    const vectorA = Vector3d.createStartEnd(plane.getOriginRef(), this.origin);\r\n    const uDotN = this.direction.dotProduct(plane.getNormalRef());\r\n    const aDotN = vectorA.dotProduct(plane.getNormalRef());\r\n    const division = Geometry.conditionalDivideFraction(-aDotN, uDotN);\r\n    if (undefined === division)\r\n      return undefined;\r\n    if (result) {\r\n      this.origin.plusScaled(this.direction, division, result);\r\n    }\r\n    return division;\r\n  }\r\n\r\n  /** Construct a vector from `ray.origin` to target point.\r\n   * * return the part of the vector that is perpendicular to `ray.direction`.\r\n   *  * i.e. return the shortest vector from the ray to the point.\r\n   */\r\n  public perpendicularPartOfVectorToTarget(targetPoint: XYAndZ, result?: Vector3d): Vector3d {\r\n    const vectorV = Vector3d.createStartEnd(this.origin, targetPoint);\r\n    const uu = this.direction.magnitudeSquared();\r\n    const uv = this.direction.dotProductStartEnd(this.origin, targetPoint);\r\n    const fraction = Geometry.safeDivideFraction(uv, uu, 0.0);\r\n    return vectorV.plusScaled(this.direction, -fraction, result);\r\n  }\r\n  /** Determine if two rays intersect, are fully overlapped, parallel but no coincident, or skew\r\n   * * Return a CurveLocationDetailPair which\r\n   * * contains fraction and point on each ray.\r\n   * * has (in the CurveLocationDetailPair structure, as member approachType) annotation indicating one of these relationships\r\n   *   * CurveCurveApproachType.Intersection -- the rays have a simple intersection, at fractions indicated in detailA and detailB\r\n   *   * CurveCurveApproachType.PerpendicularChord -- there is pair of where the rays have closest approach.  The rays are skew in space.\r\n   *   * CurveCurveApproachType.CoincidentGeometry -- the rays are the same unbounded line in space. The fractions and points are a representative single common point.\r\n   *   * CurveCurveApproachType.Parallel -- the rays are parallel (and not coincident).   The two points are at the minimum distance\r\n   */\r\n  public static closestApproachRay3dRay3d(rayA: Ray3d, rayB: Ray3d): CurveLocationDetailPair {\r\n    const intersectionFractions = Vector2d.create();\r\n    let fractionA, fractionB;\r\n    let pointA, pointB;\r\n    let pairType;\r\n    if (SmallSystem.ray3dXYZUVWClosestApproachUnbounded(\r\n      rayA.origin.x, rayA.origin.y, rayA.origin.z, rayA.direction.x, rayA.direction.y, rayA.direction.z,\r\n      rayB.origin.x, rayB.origin.y, rayB.origin.z, rayB.direction.x, rayB.direction.y, rayB.direction.z, intersectionFractions)) {\r\n      fractionA = intersectionFractions.x;\r\n      fractionB = intersectionFractions.y;\r\n      pointA = rayA.fractionToPoint(fractionA);\r\n      pointB = rayB.fractionToPoint(fractionB);\r\n      pairType = pointA.isAlmostEqualMetric(pointB) ? CurveCurveApproachType.Intersection : CurveCurveApproachType.PerpendicularChord;\r\n    } else {\r\n      fractionB = 0.0;\r\n      fractionA = rayA.pointToFraction(rayB.origin);\r\n      pointA = rayA.fractionToPoint(fractionA);\r\n      pointB = rayB.fractionToPoint(fractionB);\r\n      pairType = pointA.isAlmostEqualMetric(pointB) ? CurveCurveApproachType.CoincidentGeometry : CurveCurveApproachType.ParallelGeometry;\r\n    }\r\n    const pair = CurveLocationDetailPair.createCapture(\r\n      CurveLocationDetail.createRayFractionPoint(rayA, fractionA, rayA.fractionToPoint(fractionA)),\r\n      CurveLocationDetail.createRayFractionPoint(rayB, fractionB, rayB.fractionToPoint(fractionB)));\r\n    pair.approachType = pairType;\r\n    return pair;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * * A Segment1d is an interval of an axis named x.\r\n * * The interval is defined by two values x0 and x1.\r\n * * The x0 and x1 values can be in either order.\r\n *   * if `x0 < x1` fractional coordinates within the segment move from left to right.\r\n *   * if `x0 > x1` fractional coordinates within the segment move from right to left.\r\n * * This differs from a Range1d in that:\r\n * * For a Range1d the reversed ordering of its limit values means \"empty interval\".\r\n * * For a Segment1d the reversed ordering is a real interval but fractional positions move backwards.\r\n * * The segment is parameterized with a fraction\r\n * * * Fraction 0 is the start (`x0`)\r\n * * * Fraction 1 is the end (`x1`)\r\n * * * The fraction equation is `x = x0 + fraction * (x1-x0)` or (equivalently) `x = (1-fraction) * x0 + fraction * x1`\r\n * @public\r\n */\r\nexport class Segment1d {\r\n  /** start coordinate */\r\n  public x0: number;\r\n  /** end coordinate */\r\n  public x1: number;\r\n  private constructor(x0: number, x1: number) {\r\n    this.x0 = x0;\r\n    this.x1 = x1;\r\n  }\r\n  /**\r\n   * replace both end values.\r\n   * @param x0 new x0 value\r\n   * @param x1 new y0 value\r\n   */\r\n  public set(x0: number, x1: number) { this.x0 = x0, this.x1 = x1; }\r\n  /**\r\n   * shift (translate) the segment along its axis by adding `dx` to both `x0` and `x1`.\r\n   * @param dx value to add to both x0 and x1\r\n   */\r\n  public shift(dx: number) { this.x0 += dx, this.x1 += dx; }\r\n  /**\r\n   * create segment1d with given end values\r\n   * @param x0 start value\r\n   * @param x1 end value\r\n   * @param result optional pre-existing result to be reinitialized.\r\n   */\r\n  public static create(x0: number = 0, x1: number = 1, result?: Segment1d): Segment1d {\r\n    if (!result)\r\n      return new Segment1d(x0, x1);\r\n    result.set(x0, x1);\r\n    return result;\r\n  }\r\n  /**\r\n   * Copy both end values from other Segment1d\r\n   * @param other source Segment1d\r\n   */\r\n  public setFrom(other: Segment1d) { this.x0 = other.x0; this.x1 = other.x1; }\r\n  /**\r\n   * clone this Segment1d, return as a separate object.\r\n   */\r\n  public clone(): Segment1d { return new Segment1d(this.x0, this.x1); }\r\n  /**\r\n   * Returns true if both coordinates (`x0` and `x1`) are in the 0..1 range.\r\n   */\r\n  public get isIn01() {\r\n    return Geometry.isIn01(this.x0) && Geometry.isIn01(this.x1);\r\n\r\n  }\r\n  /**\r\n   * Evaluate the segment at fractional position\r\n   * @returns position within the segment\r\n   * @param fraction fractional position within this segment\r\n   */\r\n  public fractionToPoint(fraction: number): number { return Geometry.interpolate(this.x0, fraction, this.x1); }\r\n  /**\r\n   * * swap the x0 and x1 member values.\r\n   * * This makes the fractionToPoint evaluates reverse direction.\r\n   */\r\n  public reverseInPlace(): void { const x = this.x0; this.x0 = this.x1; this.x1 = x; }\r\n  /**\r\n   * Near equality test, using Geometry.isSameCoordinate for tolerances.\r\n   */\r\n  public isAlmostEqual(other: Segment1d): boolean {\r\n    return Geometry.isSameCoordinate(this.x0, other.x0) && Geometry.isSameCoordinate(this.x1, other.x1);\r\n  }\r\n  /**\r\n   * Return true if the segment limits are (exactly) 0 and 1\r\n   */\r\n  public get isExact01(): boolean { return this.x0 === 0.0 && this.x1 === 1.0; }\r\n\r\n  /** On input, `this` is an interval of a line.  On output, the interval has been clipped to positive parts of a linear function\r\n   * * f0 and f1 are values at parameter values 0 and 1 (which are in general NOT x0 and x1)\r\n   * * From that determine where the segment crosses function value 0.\r\n   * * The segment contains some interval in the same parameter space.\r\n   * * Clip the segment to the positive part of the space.\r\n   * * Return true (and modify the segment) if any of the segment remains.\r\n   * * Return false (but without modifying the segment) if the active part is entirely out.\r\n   */\r\n  public clipBy01FunctionValuesPositive(f0: number, f1: number): boolean {\r\n    const df01 = f1 - f0;\r\n    const fA = f0 + this.x0 * df01;\r\n    const fB = f0 + this.x1 * df01;\r\n    const dfAB = fB - fA;\r\n    if (fA > 0) {\r\n      if (fB >= 0) return true; // inside at both ends\r\n      /** There is an inside to outside crossing. The division is safe ... (and value between 0 and 1) */\r\n      const u = -fA / dfAB;\r\n      this.x1 = this.x0 + u * (this.x1 - this.x0);\r\n      return true;\r\n    } else if (fA < 0) {\r\n      if (fB < 0) return false;   // outside at both ends.\r\n      /** There is an outside to inside crossing crossing. The division is safe ... (and value between 0 and 1) */\r\n      const u = -fA / dfAB;\r\n      this.x0 = this.x0 + u * (this.x1 - this.x0);\r\n      return true;\r\n    }\r\n    /** fA is on the cut.   fB determines the entire segment. */\r\n    return fB > 0;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { Geometry, AxisOrder, BeJSONFunctions } from \"../Geometry\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { Range3d } from \"./Range\";\r\nimport { Point2d } from \"./Point2dVector2d\";\r\nimport { XAndY, XYAndZ, TransformProps } from \"./XYZProps\";\r\nimport { XYZ, Point3d, Vector3d } from \"./Point3dVector3d\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\n\r\n/** A transform is an origin and a Matrix3d.\r\n *\r\n * * This describes a coordinate frame with\r\n * this origin, with the columns of the Matrix3d being the\r\n * local x,y,z axis directions.\r\n * *  Beware that for common transformations (e.g. scale about point,\r\n * rotate around line, mirror across a plane) the \"fixed point\" that is used\r\n * when describing the transform is NOT the \"origin\" stored in the transform.\r\n * Setup methods (e.g createFixedPointAndMatrix, createScaleAboutPoint)\r\n * take care of determining the appropriate origin coordinates.\r\n * @public\r\n */\r\nexport class Transform implements BeJSONFunctions {\r\n  // static (one per class) vars for temporaries in computation.\r\n  // ASSUME any user of these vars needs them only within its own scope\r\n  // ASSUME no calls to other methods that use the same scratch.\r\n  // When Transform was in the same file with Point3d, this was initialized right here.\r\n  // But when split, there is a load order issue, so it has to be initialized at point-of-use\r\n  private static _scratchPoint: Point3d;\r\n  private _origin: XYZ;\r\n  private _matrix: Matrix3d;\r\n  // Constructor accepts and uses POINTER to content .. no copy here.\r\n  private constructor(origin: XYZ, matrix: Matrix3d) { this._origin = origin; this._matrix = matrix; }\r\n\r\n  private static _identity?: Transform;\r\n  /** The identity Transform. Value is frozen and cannot be modified. */\r\n  public static get identity(): Transform {\r\n    if (undefined === this._identity) {\r\n      this._identity = Transform.createIdentity();\r\n      this._identity.freeze();\r\n    }\r\n\r\n    return this._identity;\r\n  }\r\n  /** Freeze this instance (and its deep content) so it can be considered read-only */\r\n  public freeze() { Object.freeze(this); Object.freeze(this._origin); this._matrix.freeze(); }\r\n  /**\r\n   * Copy contents from other Transform into this Transform\r\n   * @param other source transform\r\n   */\r\n  public setFrom(other: Transform) { this._origin.setFrom(other._origin), this._matrix.setFrom(other._matrix); }\r\n  /** Set this Transform to be an identity. */\r\n  public setIdentity() { this._origin.setZero(); this._matrix.setIdentity(); }\r\n  /** Set this Transform instance from flexible inputs:\r\n   * * Any object (such as another Transform) that has `origin` and `matrix` members accepted by Point3d.setFromJSON and Matrix3d.setFromJSON\r\n   * * An array of 3 number arrays, each with 4 entries which are rows in a 3x4 matrix.\r\n   */\r\n  public setFromJSON(json?: TransformProps): void {\r\n    if (json) {\r\n      if (json instanceof Object && (json as any).origin && (json as any).matrix) {\r\n        this._origin.setFromJSON((json as any).origin);\r\n        this._matrix.setFromJSON((json as any).matrix);\r\n        return;\r\n      }\r\n      if (Geometry.isArrayOfNumberArray(json, 3, 4)) {\r\n        const data = json as number[][];\r\n        this._matrix.setRowValues(\r\n          data[0][0], data[0][1], data[0][2],\r\n          data[1][0], data[1][1], data[1][2],\r\n          data[2][0], data[2][1], data[2][2]);\r\n        this._origin.set(data[0][3], data[1][3], data[2][3]);\r\n        return;\r\n      }\r\n\r\n    }\r\n    this.setIdentity();\r\n  }\r\n  /**\r\n   * Test for near equality with other Transform.  Comparison uses the isAlmostEqual methods on\r\n   * the origin and matrix parts.\r\n   * @param other Transform to compare to.\r\n   */\r\n  public isAlmostEqual(other: Transform): boolean { return this._origin.isAlmostEqual(other._origin) && this._matrix.isAlmostEqual(other._matrix); }\r\n  /** Return a 3 by 4 matrix containing the rows of this Transform\r\n   * * This transform's origin is the [3] entry of the json arrays\r\n   */\r\n  public toJSON(): TransformProps {\r\n    // return { origin: this._origin.toJSON(), matrix: this._matrix.toJSON() };\r\n    return [\r\n      [this._matrix.coffs[0], this._matrix.coffs[1], this._matrix.coffs[2], this._origin.x],\r\n      [this._matrix.coffs[3], this._matrix.coffs[4], this._matrix.coffs[5], this._origin.y],\r\n      [this._matrix.coffs[6], this._matrix.coffs[7], this._matrix.coffs[8], this._origin.z],\r\n    ];\r\n  }\r\n  /** Return a new Transform initialized by `setFromJSON (json)` */\r\n  public static fromJSON(json?: TransformProps): Transform {\r\n    const result = Transform.createIdentity();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Copy the contents of this transform into a new Transform (or to the result, if specified). */\r\n  public clone(result?: Transform): Transform {\r\n    if (result) {\r\n      result._matrix.setFrom(this._matrix);\r\n      result._origin.setFrom(this._origin);\r\n      return result;\r\n    }\r\n    return new Transform(\r\n      Point3d.createFrom(this._origin),\r\n      this._matrix.clone());\r\n  }\r\n  /** Return a copy of this Transform, modified so that its axes are rigid\r\n   * * The first axis direction named in axisOrder is preserved\r\n   * * The plane of the first and second directions is preserved, and its vector in the rigid matrix has positive dot product with the corresponding vector if the instance\r\n   * * The third named column is the cross product of the first and second.\r\n   */\r\n  public cloneRigid(axisOrder: AxisOrder = AxisOrder.XYZ): Transform | undefined {\r\n    const axes0 = Matrix3d.createRigidFromMatrix3d(this.matrix, axisOrder);\r\n    if (!axes0)\r\n      return undefined;\r\n    return new Transform(this.origin.cloneAsPoint3d(), axes0);\r\n  }\r\n  /** Create a copy with the given origin and matrix captured as the Transform origin and Matrix3d. */\r\n  public static createRefs(origin: XYZ, matrix: Matrix3d, result?: Transform): Transform {\r\n    if (result) {\r\n      result._origin = origin;\r\n      result._matrix = matrix;\r\n      return result;\r\n    }\r\n    return new Transform(origin, matrix);\r\n  }\r\n  /** Create a transform with complete contents given */\r\n  public static createRowValues(\r\n    qxx: number, qxy: number, qxz: number, ax: number,\r\n    qyx: number, qyy: number, qyz: number, ay: number,\r\n    qzx: number, qzy: number, qzz: number, az: number,\r\n    result?: Transform): Transform {\r\n    if (result) {\r\n      result._origin.set(ax, ay, az);\r\n      result._matrix.setRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz);\r\n      return result;\r\n    }\r\n    return new Transform(Point3d.create(ax, ay, az), Matrix3d.createRowValues(qxx, qxy, qxz, qyx, qyy, qyz, qzx, qzy, qzz));\r\n  }\r\n  /** Create a transform with all zeros.\r\n   */\r\n  public static createZero(result?: Transform): Transform {\r\n    return Transform.createRowValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, result);\r\n  }\r\n\r\n  /**\r\n   * create a Transform with translation provided by x,y,z parts.\r\n   * @param x x part of translation\r\n   * @param y y part of translation\r\n   * @param z z part of translation\r\n   * @param result optional result\r\n   * @returns new or updated transform.\r\n   */\r\n  public static createTranslationXYZ(x: number = 0, y: number = 0, z: number = 0, result?: Transform): Transform {\r\n    return Transform.createRefs(Vector3d.create(x, y, z), Matrix3d.createIdentity(), result);\r\n  }\r\n  /** Create a matrix with specified translation part.\r\n   * @param XYZ x,y,z parts of the translation.\r\n   * @returns new or updated transform.\r\n   */\r\n  public static createTranslation(translation: XYZ, result?: Transform): Transform {\r\n    return Transform.createRefs(translation, Matrix3d.createIdentity(), result);\r\n  }\r\n\r\n  /** Return a reference to the matrix within the transform.  (NOT a copy) */\r\n  public get matrix(): Matrix3d { return this._matrix; }\r\n  /** Return a reference to the origin within the transform.  (NOT a copy) */\r\n  public get origin(): XYZ { return this._origin; }\r\n\r\n  /** return a (clone of) the origin part of the transform, as a Point3d */\r\n  public getOrigin(): Point3d { return Point3d.createFrom(this._origin); }\r\n\r\n  /** return a (clone of) the origin part of the transform, as a Vector3d */\r\n  public getTranslation(): Vector3d { return Vector3d.createFrom(this._origin); }\r\n\r\n  /** test if the transform has 000 origin and identity Matrix3d */\r\n  public get isIdentity(): boolean {\r\n    return this._matrix.isIdentity && this._origin.isAlmostZero;\r\n  }\r\n  /** Return an identity transform, optionally filling existing transform.  */\r\n  public static createIdentity(result?: Transform): Transform {\r\n    if (result) {\r\n      result._origin.setZero();\r\n      result._matrix.setIdentity();\r\n      return result;\r\n    }\r\n    return Transform.createRefs(Point3d.createZero(), Matrix3d.createIdentity());\r\n  }\r\n  /** Create by directly installing origin and matrix\r\n   * this is a the appropriate construction when the columns of the matrix are coordinate axes of a local-to-global mapping\r\n   * Note there is a closely related createFixedPointAndMatrix whose point input is the fixed point of the global-to-global transformation.\r\n   */\r\n  public static createOriginAndMatrix(origin: XYZ | undefined, matrix: Matrix3d | undefined, result?: Transform): Transform {\r\n    return Transform.createRefs(\r\n      origin ? origin.cloneAsPoint3d() : Point3d.createZero(),\r\n      matrix === undefined ? Matrix3d.createIdentity() : matrix.clone(), result);\r\n  }\r\n  /** Create by directly installing origin and columns of the matrix\r\n   */\r\n  public static createOriginAndMatrixColumns(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d, result?: Transform): Transform {\r\n    if (result)\r\n      result.setOriginAndMatrixColumns(origin, vectorX, vectorY, vectorZ);\r\n    else\r\n      result = Transform.createRefs(Vector3d.createFrom(origin), Matrix3d.createColumns(vectorX, vectorY, vectorZ));\r\n    return result;\r\n  }\r\n  /** Reinitialize by directly installing origin and columns of the matrix\r\n   */\r\n  public setOriginAndMatrixColumns(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d) {\r\n    this._origin.setFrom(origin);\r\n    this._matrix.setColumns(vectorX, vectorY, vectorZ);\r\n  }\r\n\r\n  /** Create a transform with the specified matrix. Compute an origin (different from the given fixedPoint)\r\n   * so that the fixedPoint maps back to itself.\r\n   */\r\n  public static createFixedPointAndMatrix(fixedPoint: XYAndZ, matrix: Matrix3d, result?: Transform): Transform {\r\n    const origin = Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);\r\n    return Transform.createRefs(origin, matrix.clone(), result);\r\n  }\r\n  /** Create a transform with the specified matrix, acting on any `pointX `via\r\n   * `pointY = matrix * (pointX - pointA) + pointB`\r\n   * so that the fixedPoint maps back to itself.\r\n   */\r\n  public static createMatrixPickupPutdown(matrix: Matrix3d, pointA: Point3d, pointB: Point3d, result?: Transform): Transform {\r\n    const origin = Matrix3d.xyzMinusMatrixTimesXYZ(pointB, matrix, pointA);\r\n    return Transform.createRefs(origin, matrix.clone(), result);\r\n  }\r\n\r\n  /** Create a Transform which leaves the fixedPoint unchanged and\r\n   * scales everything else around it by a single scale factor.\r\n   */\r\n  public static createScaleAboutPoint(fixedPoint: Point3d, scale: number, result?: Transform): Transform {\r\n    const matrix = Matrix3d.createScale(scale, scale, scale);\r\n    const origin = Matrix3d.xyzMinusMatrixTimesXYZ(fixedPoint, matrix, fixedPoint);\r\n    return Transform.createRefs(origin, matrix, result);\r\n  }\r\n\r\n  /** Transform the input 2d point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyPoint2d(source: XAndY, result?: Point2d): Point2d {\r\n    return Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, source, result);\r\n  }\r\n\r\n  /** Transform the input 3d point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyPoint3d(point: XYAndZ, result?: Point3d): Point3d {\r\n    return Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, result);\r\n  }\r\n\r\n  /** Transform the input point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZ(x: number, y: number, z: number, result?: Point3d): Point3d {\r\n    return Matrix3d.xyzPlusMatrixTimesCoordinates(this._origin, this._matrix, x, y, z, result);\r\n  }\r\n  /** Multiply a specific row of the transform times xyz. Return the (number). */\r\n  public multiplyComponentXYZ(componentIndex: number, x: number, y: number, z: number): number {\r\n    const coffs = this._matrix.coffs;\r\n    const i0 = 3 * componentIndex;\r\n    return this.origin.at(componentIndex) + coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;\r\n  }\r\n  /** Multiply a specific row of the transform times (weighted!) xyzw. Return the (number). */\r\n  public multiplyComponentXYZW(componentIndex: number, x: number, y: number, z: number, w: number): number {\r\n    const coffs = this._matrix.coffs;\r\n    const i0 = 3 * componentIndex;\r\n    return this.origin.at(componentIndex) * w +\r\n      coffs[i0] * x + coffs[i0 + 1] * y + coffs[i0 + 2] * z;\r\n  }\r\n\r\n  /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    return Matrix3d.xyzPlusMatrixTimesWeightedCoordinates(this._origin, this._matrix, x, y, z, w, result);\r\n  }\r\n  /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZWToFloat64Array(x: number, y: number, z: number, w: number, result?: Float64Array): Float64Array {\r\n    return Matrix3d.xyzPlusMatrixTimesWeightedCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, w, result);\r\n  }\r\n\r\n  /** Transform the input homogeneous point.  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyXYZToFloat64Array(x: number, y: number, z: number, result?: Float64Array): Float64Array {\r\n    return Matrix3d.xyzPlusMatrixTimesCoordinatesToFloat64Array(this._origin, this._matrix, x, y, z, result);\r\n  }\r\n  /** Multiply the transposed transform (as 4x4 with 0001 row) by Point4d given as xyzw..  Return as a new point or in the pre-allocated result (if result is given) */\r\n  public multiplyTransposeXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    const coffs = this._matrix.coffs;\r\n    const origin = this._origin;\r\n    return Point4d.create(\r\n      x * coffs[0] + y * coffs[3] + z * coffs[6],\r\n      x * coffs[1] + y * coffs[4] + z * coffs[7],\r\n      x * coffs[2] + y * coffs[5] + z * coffs[8],\r\n      x * origin.x + y * origin.y + z * origin.z + w,\r\n      result);\r\n  }\r\n\r\n  /** for each point:  replace point by Transform*point */\r\n  public multiplyPoint3dArrayInPlace(points: Point3d[]) {\r\n    let point;\r\n    for (point of points)\r\n      Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, point, point);\r\n  }\r\n\r\n  /** Return product of the transform's inverse times a point. */\r\n  public multiplyInversePoint3d(point: XYAndZ, result?: Point3d): Point3d | undefined {\r\n    return this._matrix.multiplyInverseXYZAsPoint3d(\r\n      point.x - this._origin.x,\r\n      point.y - this._origin.y,\r\n      point.z - this._origin.z,\r\n      result);\r\n  }\r\n  /** Return product of the transform's inverse times a point (point given as x,y,z) */\r\n  public multiplyInverseXYZ(x: number, y: number, z: number, result?: Point3d): Point3d | undefined {\r\n    return this._matrix.multiplyInverseXYZAsPoint3d(\r\n      x - this._origin.x,\r\n      y - this._origin.y,\r\n      z - this._origin.z,\r\n      result);\r\n  }\r\n\r\n  /**\r\n   * *  for each point:   multiply    transform * point\r\n   * *  if result is given, resize to match source and replace each corresponding pi\r\n   * *  if result is not given, return a new array.\r\n   */\r\n  public multiplyInversePoint3dArray(source: Point3d[], result?: Point3d[]): Point3d[] | undefined {\r\n    if (!this._matrix.computeCachedInverse(true))\r\n      return undefined;\r\n    const originX = this.origin.x;\r\n    const originY = this.origin.y;\r\n    const originZ = this.origin.z;\r\n    if (result) {\r\n      const n = Transform.matchArrayLengths(source, result, Point3d.createZero);\r\n      for (let i = 0; i < n; i++)\r\n        this._matrix.multiplyInverseXYZAsPoint3d(\r\n          source[i].x - originX,\r\n          source[i].y - originY,\r\n          source[i].z - originZ,\r\n          result[i]);\r\n    }\r\n    result = [];\r\n    for (const p of source)\r\n      result.push(this._matrix.multiplyInverseXYZAsPoint3d(\r\n        p.x - originX,\r\n        p.y - originY,\r\n        p.z - originZ)!);\r\n\r\n    return result;\r\n  }\r\n  /**\r\n   * * for each point in source: multiply transformInverse * point in place in the point.\r\n   * * return false if not invertible.\r\n   */\r\n  public multiplyInversePoint3dArrayInPlace(source: Point3d[]): boolean {\r\n    if (!this._matrix.computeCachedInverse(true))\r\n      return false;\r\n    const originX = this.origin.x;\r\n    const originY = this.origin.y;\r\n    const originZ = this.origin.z;\r\n    const n = source.length;\r\n    for (let i = 0; i < n; i++)\r\n      this._matrix.multiplyInverseXYZAsPoint3d(\r\n        source[i].x - originX,\r\n        source[i].y - originY,\r\n        source[i].z - originZ,\r\n        source[i]);\r\n    return true;\r\n  }\r\n  /**\r\n   * * Compute (if needed) the inverse of the matrix part, thereby ensuring inverse operations can complete.\r\n   * * Return true if matrix inverse completes.\r\n   * @param useCached If true, accept prior cached inverse if available.\r\n   */\r\n  public computeCachedInverse(useCached: boolean = true): boolean {\r\n    return this._matrix.computeCachedInverse(useCached);\r\n  }\r\n  /**\r\n   * * If destination has more values than source, remove the extras.\r\n   * * If destination has fewer values, use the constructionFunction to create new ones.\r\n   * @param source array\r\n   * @param dest destination array, to  be modified to match source length\r\n   * @param constructionFunction function to call to create new entries.\r\n   */\r\n  // modify destination so it has non-null points for the same length as the source.\r\n  // (ASSUME existing elements of dest are non-null, and that parameters are given as either Point2d or Point3d arrays)\r\n  public static matchArrayLengths(source: any[], dest: any[], constructionFunction: () => any): number {\r\n    const numSource = source.length;\r\n    const numDest = dest.length;\r\n    if (numSource > numDest) {\r\n      for (let i = numDest; i < numSource; i++) {\r\n        dest.push(constructionFunction());\r\n      }\r\n    } else if (numDest > numSource) {\r\n      dest.length = numSource;\r\n    }\r\n    return numSource;\r\n  }\r\n\r\n  /**\r\n   * *  for each point:   multiply    transform * point\r\n   * *  if result is given, resize to match source and replace each corresponding pi\r\n   * *  if result is not given, return a new array.\r\n   */\r\n  public multiplyPoint2dArray(source: Point2d[], result?: Point2d[]): Point2d[] {\r\n    if (result) {\r\n      const n = Transform.matchArrayLengths(source, result, Point2d.createZero);\r\n      for (let i = 0; i < n; i++)\r\n        Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, source[i], result[i]);\r\n      return result;\r\n    }\r\n    result = [];\r\n    for (const p of source)\r\n      result.push(Matrix3d.xyPlusMatrixTimesXY(this._origin, this._matrix, p));\r\n\r\n    return result;\r\n  }\r\n  /**\r\n   * *  for each point:   multiply    transform * point\r\n   * *  if result is given, resize to match source and replace each corresponding pi\r\n   * *  if result is not given, return a new array.\r\n   */\r\n  public multiplyPoint3dArray(source: Point3d[], result?: Point3d[]): Point3d[] {\r\n    if (result) {\r\n      const n = Transform.matchArrayLengths(source, result, Point3d.createZero);\r\n      for (let i = 0; i < n; i++)\r\n        Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, source[i], result[i]);\r\n      return result;\r\n    }\r\n    result = [];\r\n    for (const p of source)\r\n      result.push(Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, p));\r\n\r\n    return result;\r\n  }\r\n\r\n  /** Multiply the vector by the Matrix3d part of the transform.\r\n   *\r\n   * *  The transform's origin is not used.\r\n   * *  Return as new or result by usual optional result convention\r\n   */\r\n  public multiplyVector(vector: Vector3d, result?: Vector3d): Vector3d {\r\n    return this._matrix.multiplyVector(vector, result);\r\n  }\r\n  /** Multiply the vector (x,y,z) by the Matrix3d part of the transform.\r\n   *\r\n   * *  The transform's origin is not used.\r\n   * *  Return as new or result by usual optional result convention\r\n   */\r\n  public multiplyVectorXYZ(x: number, y: number, z: number, result?: Vector3d): Vector3d {\r\n    return this._matrix.multiplyXYZ(x, y, z, result);\r\n  }\r\n  /** multiply this Transform times other Transform.\r\n   * @param other right hand transform for multiplication.\r\n   * @param result optional preallocated result to reuse.\r\n   */\r\n  public multiplyTransformTransform(other: Transform, result?: Transform) {\r\n    if (!result)\r\n      return Transform.createRefs(\r\n        Matrix3d.xyzPlusMatrixTimesXYZ(this._origin, this._matrix, other._origin),\r\n        this._matrix.multiplyMatrixMatrix(other._matrix));\r\n    result.setMultiplyTransformTransform(this, other);\r\n    return result;\r\n  }\r\n  /**\r\n   * multiply transformA * transformB, store to calling instance.\r\n   * @param transformA left operand\r\n   * @param transformB right operand\r\n   */\r\n  public setMultiplyTransformTransform(transformA: Transform, transformB: Transform): void {\r\n    if (Transform._scratchPoint === undefined)\r\n      Transform._scratchPoint = Point3d.create();\r\n    Matrix3d.xyzPlusMatrixTimesXYZ(transformA._origin, transformA._matrix, transformB._origin, Transform._scratchPoint);\r\n    this._origin.setFrom(Transform._scratchPoint);\r\n    transformA._matrix.multiplyMatrixMatrix(transformB._matrix, this._matrix);\r\n  }\r\n  //   [Q A][R 0] = [QR A]\r\n  //   [0 1][0 1]   [0  1]\r\n  /** multiply this Transform times other Matrix3d, with other considered to be a Transform with 0 translation.\r\n   * @param other right hand Matrix3d for multiplication.\r\n   * @param result optional preallocated result to reuse.\r\n   */\r\n  public multiplyTransformMatrix3d(other: Matrix3d, result?: Transform): Transform {\r\n    if (!result)\r\n      return Transform.createRefs(\r\n        this._origin.cloneAsPoint3d(),\r\n        this._matrix.multiplyMatrixMatrix(other));\r\n    this._matrix.multiplyMatrixMatrix(other, result._matrix);\r\n    result._origin.setFrom(this._origin);\r\n    return result;\r\n  }\r\n\r\n  /** transform each of the 8 corners of a range. Return the range of the transformed corers */\r\n  public multiplyRange(range: Range3d, result?: Range3d): Range3d {\r\n    // snag current values to allow aliasing.\r\n    const lowx = range.low.x;\r\n    const lowy = range.low.y;\r\n    const lowz = range.low.z;\r\n    const highx = range.high.x;\r\n    const highy = range.high.y;\r\n    const highz = range.high.z;\r\n    result = Range3d.createNull(result);\r\n    result.extendTransformedXYZ(this, lowx, lowy, lowz);\r\n    result.extendTransformedXYZ(this, highx, lowy, lowz);\r\n    result.extendTransformedXYZ(this, lowx, highy, lowz);\r\n    result.extendTransformedXYZ(this, highx, highy, lowz);\r\n\r\n    result.extendTransformedXYZ(this, lowx, lowy, highz);\r\n    result.extendTransformedXYZ(this, highx, lowy, highz);\r\n    result.extendTransformedXYZ(this, lowx, highy, highz);\r\n    result.extendTransformedXYZ(this, highx, highy, highz);\r\n    return result;\r\n  }\r\n  /**\r\n   * * Return a Transform which is the inverse of this transform.\r\n   * * Return undefined if this Transform's matrix is singular.\r\n   */\r\n  public inverse(): Transform | undefined {\r\n    const matrixInverse = this._matrix.inverse();\r\n    if (!matrixInverse)\r\n      return undefined;\r\n    return Transform.createRefs(\r\n      matrixInverse.multiplyXYZ(-this._origin.x, -this._origin.y, -this._origin.z),\r\n      matrixInverse);\r\n  }\r\n  /** Initialize transforms that map each direction of a box (axis aligned) to `[0,1]`.\r\n   * @param min the \"000\" corner of the box\r\n   * @param max the \"111\" corner of the box\r\n   * @param npcToGlobal (object created by caller, re-initialized) transform that carries 01 coordinates into the min,max box.\r\n   * @param globalToNpc (object created by caller, re-initialized) transform that carries world coordinates into 01\r\n   */\r\n  public static initFromRange(min: Point3d, max: Point3d, npcToGlobal?: Transform, globalToNpc?: Transform) {\r\n    const diag = max.minus(min);\r\n    if (diag.x === 0.0) diag.x = 1.0;\r\n    if (diag.y === 0.0) diag.y = 1.0;\r\n    if (diag.z === 0.0) diag.z = 1.0;\r\n\r\n    const rMatrix = new Matrix3d();\r\n    if (npcToGlobal) {\r\n      Matrix3d.createScale(diag.x, diag.y, diag.z, rMatrix);\r\n      Transform.createOriginAndMatrix(min, rMatrix, npcToGlobal);\r\n    }\r\n\r\n    if (globalToNpc) {\r\n      const origin = new Point3d(- min.x / diag.x, - min.y / diag.y, - min.z / diag.z);\r\n      Matrix3d.createScale(1.0 / diag.x, 1.0 / diag.y, 1.0 / diag.z, rMatrix);\r\n      Transform.createOriginAndMatrix(origin, rMatrix, globalToNpc);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module CartesianGeometry */\r\n\r\nimport { AngleProps, Geometry } from \"../Geometry\";\r\nimport { Angle } from \"./Angle\";\r\nimport { Transform } from \"./Transform\";\r\nimport { Matrix3d } from \"./Matrix3d\";\r\nimport { Point3d } from \"./Point3dVector3d\";\r\n/** The properties that define [[YawPitchRollAngles]]. */\r\n/**\r\n * angle properties of a `YawPitchRoll` orientation\r\n * @public\r\n */\r\nexport interface YawPitchRollProps {\r\n  /** yaw field */\r\n  yaw?: AngleProps;\r\n  /** pitch field */\r\n  pitch?: AngleProps;\r\n  /** roll field */\r\n  roll?: AngleProps;\r\n}\r\n\r\n/** Three angles that determine the orientation of an object in space. Sometimes referred to as [Tait–Bryan angles](https://en.wikipedia.org/wiki/Euler_angles).\r\n * @public\r\n */\r\nexport class YawPitchRollAngles {\r\n  /** The yaw angle. */\r\n  public yaw: Angle;\r\n  /** The pitch angle. */\r\n  public pitch: Angle;\r\n  /** The roll angle. */\r\n  public roll: Angle;\r\n\r\n  constructor(yaw: Angle = Angle.zero(), pitch: Angle = Angle.zero(), roll: Angle = Angle.zero()) {\r\n    this.yaw = yaw;\r\n    this.pitch = pitch;\r\n    this.roll = roll;\r\n  }\r\n  /** Freeze this YawPitchRollAngles */\r\n  public freeze() { Object.freeze(this.yaw); Object.freeze(this.pitch); Object.freeze(this.roll); }\r\n  /** constructor for YawPitchRollAngles with angles in degrees. */\r\n  public static createDegrees(yawDegrees: number, pitchDegrees: number, rollDegrees: number): YawPitchRollAngles {\r\n    return new YawPitchRollAngles(Angle.createDegrees(yawDegrees), Angle.createDegrees(pitchDegrees), Angle.createDegrees(rollDegrees));\r\n  }\r\n  /** constructor for YawPitchRollAngles with angles in radians. */\r\n  public static createRadians(yawRadians: number, pitchRadians: number, rollRadians: number): YawPitchRollAngles {\r\n    return new YawPitchRollAngles(Angle.createRadians(yawRadians), Angle.createRadians(pitchRadians), Angle.createRadians(rollRadians));\r\n  }\r\n  /** construct a `YawPitchRoll` object from an object with 3 named angles */\r\n  public static fromJSON(json?: YawPitchRollProps): YawPitchRollAngles {\r\n    json = json ? json : {};\r\n    return new YawPitchRollAngles(Angle.fromJSON(json.yaw), Angle.fromJSON(json.pitch), Angle.fromJSON(json.roll));\r\n  }\r\n  /** populate yaw, pitch and roll fields using `Angle.fromJSON` */\r\n  public setFromJSON(json?: YawPitchRollProps): void {\r\n    json = json ? json : {};\r\n    this.yaw = Angle.fromJSON(json.yaw);\r\n    this.pitch = Angle.fromJSON(json.pitch);\r\n    this.roll = Angle.fromJSON(json.roll);\r\n  }\r\n  /** Convert to a JSON object of form { pitch: 20 , roll: 29.999999999999996 , yaw: 10 }. Any values that are exactly zero (with tolerance `Geometry.smallAngleRadians`) are omitted. */\r\n  public toJSON(): YawPitchRollProps {\r\n    const val: YawPitchRollProps = {};\r\n    if (!this.pitch.isAlmostZero)\r\n      val.pitch = this.pitch.toJSON();\r\n    if (!this.roll.isAlmostZero)\r\n      val.roll = this.roll.toJSON();\r\n    if (!this.yaw.isAlmostZero)\r\n      val.yaw = this.yaw.toJSON();\r\n    return val;\r\n  }\r\n  /**\r\n   * Install all rotations from `other` into `this`.\r\n   * @param other YawPitchRollAngles source\r\n   */\r\n  public setFrom(other: YawPitchRollAngles) {\r\n    this.yaw.setFrom(other.yaw);\r\n    this.pitch.setFrom(other.pitch);\r\n    this.roll.setFrom(other.roll);\r\n  }\r\n  /**\r\n   * * Compare angles between `this` and `other`.\r\n   * * Comparisons are via `isAlmostEqualAllowPeriodShift`.\r\n   * @param other YawPitchRollAngles source\r\n   */\r\n  public isAlmostEqual(other: YawPitchRollAngles) {\r\n    return this.yaw.isAlmostEqualAllowPeriodShift(other.yaw)\r\n      && this.pitch.isAlmostEqualAllowPeriodShift(other.pitch)\r\n      && this.roll.isAlmostEqualAllowPeriodShift(other.roll);\r\n  }\r\n  /**\r\n   * Make a copy of this YawPitchRollAngles.\r\n   */\r\n  public clone() { return new YawPitchRollAngles(this.yaw.clone(), this.pitch.clone(), this.roll.clone()); }\r\n  /**\r\n   * Expand the angles into a (rigid rotation) matrix.\r\n   *\r\n   * * The returned matrix is \"rigid\" -- unit length rows and columns, and its transpose is its inverse.\r\n   * * The \"rigid\" matrix is always a right handed coordinate system.\r\n   * @param result optional pre-allocated `Matrix3d`\r\n   */\r\n  public toMatrix3d(result?: Matrix3d) {\r\n    const c0 = Math.cos(this.yaw.radians);\r\n    const s0 = Math.sin(this.yaw.radians);\r\n    const c1 = Math.cos(this.pitch.radians);\r\n    const s1 = Math.sin(this.pitch.radians);\r\n    const c2 = Math.cos(this.roll.radians);\r\n    const s2 = Math.sin(this.roll.radians);\r\n    return Matrix3d.createRowValues(c0 * c1, -(s0 * c2 + c0 * s1 * s2), (s0 * s2 - c0 * s1 * c2), s0 * c1, (c0 * c2 - s0 * s1 * s2), -(c0 * s2 + s0 * s1 * c2), s1, c1 * s2, c1 * c2, result);\r\n  }\r\n  /** Return the largest angle in radians */\r\n  public maxAbsRadians(): number {\r\n    return Geometry.maxAbsXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);\r\n  }\r\n  /** Return the sum of the angles in squared radians */\r\n  public sumSquaredRadians(): number {\r\n    return Geometry.hypotenuseSquaredXYZ(this.yaw.radians, this.pitch.radians, this.roll.radians);\r\n  }\r\n  /** Returns true if this rotation does nothing.\r\n   * * If allowPeriodShift is false, any nonzero angle is considered a non-identity\r\n   * * If allowPeriodShift is true, all angles are individually allowed to be any multiple of 360 degrees.\r\n   */\r\n  public isIdentity(allowPeriodShift: boolean = true): boolean {\r\n    if (allowPeriodShift)\r\n      return Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.yaw.radians)\r\n        && Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.pitch.radians)\r\n        && Angle.isAlmostEqualRadiansAllowPeriodShift(0.0, this.roll.radians);\r\n    else\r\n      return Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.yaw.radians)\r\n        && Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.pitch.radians)\r\n        && Angle.isAlmostEqualRadiansNoPeriodShift(0.0, this.roll.radians);\r\n  }\r\n  /** Return the largest difference of angles (in radians) between this and other */\r\n  public maxDiffRadians(other: YawPitchRollAngles): number {\r\n    return Math.max(this.yaw.radians - other.yaw.radians, this.pitch.radians - other.pitch.radians, this.roll.radians - other.roll.radians);\r\n  }\r\n  /** Return the largest angle in degrees. */\r\n  public maxAbsDegrees(): number { return Geometry.maxAbsXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }\r\n  /** Return the sum of squared angles in degrees. */\r\n  public sumSquaredDegrees(): number { return Geometry.hypotenuseSquaredXYZ(this.yaw.degrees, this.pitch.degrees, this.roll.degrees); }\r\n  /** Return an object from a Transform as an origin and YawPitchRollAngles. */\r\n  public static tryFromTransform(transform: Transform): {\r\n    origin: Point3d;\r\n    angles: YawPitchRollAngles | undefined;\r\n  } {\r\n    // bundle up the transform's origin with the angle data extracted from the transform\r\n    return {\r\n      angles: YawPitchRollAngles.createFromMatrix3d(transform.matrix),\r\n      origin: Point3d.createFrom(transform.origin),\r\n    };\r\n  }\r\n  /** Attempts to create a YawPitchRollAngles object from an Matrix3d\r\n   * * This conversion fails if the matrix is not rigid (unit rows and columns, transpose is inverse)\r\n   * * In the failure case the method's return value is `undefined`.\r\n   * * In the failure case, if the optional result was supplied, that result will nonetheless be filled with a set of angles.\r\n   */\r\n  public static createFromMatrix3d(matrix: Matrix3d, result?: YawPitchRollAngles): YawPitchRollAngles | undefined {\r\n    const s1 = matrix.at(2, 0);\r\n    const c1 = Math.sqrt(matrix.at(2, 1) * matrix.at(2, 1) + matrix.at(2, 2) * matrix.at(2, 2));\r\n    const pitchA = Angle.createAtan2(s1, c1); // with positive cosine\r\n    const pitchB = Angle.createAtan2(s1, -c1); // with negative cosine\r\n    const angles = result ? result : new YawPitchRollAngles(); // default undefined . . .\r\n    if (c1 < Geometry.smallAngleRadians) { // This is a radians test !!!\r\n      angles.yaw = Angle.createAtan2(-matrix.at(0, 1), matrix.at(1, 1));\r\n      angles.pitch = pitchA;\r\n      angles.roll = Angle.createRadians(0.0);\r\n    } else {\r\n      const yawA = Angle.createAtan2(matrix.at(1, 0), matrix.at(0, 0));\r\n      const rollA = Angle.createAtan2(matrix.at(2, 1), matrix.at(2, 2));\r\n      const yawB = Angle.createAtan2(-matrix.at(1, 0), -matrix.at(0, 0));\r\n      const rollB = Angle.createAtan2(-matrix.at(2, 1), -matrix.at(2, 2));\r\n      const yprA = new YawPitchRollAngles(yawA, pitchA, rollA);\r\n      const yprB = new YawPitchRollAngles(yawB, pitchB, rollB);\r\n      const absFactor = 0.95;\r\n      const radiansA = yprA.maxAbsRadians();\r\n      const radiansB = yprB.maxAbsRadians();\r\n      if (radiansA < absFactor * radiansB) {\r\n        angles.setFrom(yprA);\r\n      } else if (radiansB < absFactor * radiansA) {\r\n        angles.setFrom(yprB);\r\n      } else {\r\n        const sumA = yprA.sumSquaredRadians();\r\n        const sumB = yprB.sumSquaredRadians();\r\n        if (sumA <= sumB) {\r\n          angles.setFrom(yprA);\r\n        } else {\r\n          angles.setFrom(yprB);\r\n        }\r\n      }\r\n    }\r\n    const matrix1 = angles.toMatrix3d();\r\n    return matrix.maxDiff(matrix1) < Geometry.smallAngleRadians ? angles : undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BeJSONFunctions } from \"../Geometry\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"./Matrix4d\";\r\n/** Map4 carries two Matrix4d which are inverses of each other.\r\n * @public\r\n */\r\nexport class Map4d implements BeJSONFunctions {\r\n  private _matrix0: Matrix4d;\r\n  private _matrix1: Matrix4d;\r\n  private constructor(matrix0: Matrix4d, matrix1: Matrix4d) {\r\n    this._matrix0 = matrix0;\r\n    this._matrix1 = matrix1;\r\n  }\r\n  /** Return a reference to (not copy of) the \"forward\" Matrix4d */\r\n  public get transform0(): Matrix4d { return this._matrix0; }\r\n  /** Return a reference to (not copy of) the \"reverse\" Matrix4d */\r\n  public get transform1(): Matrix4d { return this._matrix1; }\r\n  /** Create a Map4d, capturing the references to the two matrices. */\r\n  public static createRefs(matrix0: Matrix4d, matrix1: Matrix4d) {\r\n    return new Map4d(matrix0, matrix1);\r\n  }\r\n  /** Create an identity map. */\r\n  public static createIdentity(): Map4d { return new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity()); }\r\n  /** Create a Map4d with given transform pair.\r\n   * @returns undefined if the transforms are not inverses of each other.\r\n   */\r\n  public static createTransform(transform0: Transform, transform1?: Transform): Map4d | undefined {\r\n    if (transform1 === undefined) {\r\n      transform1 = transform0.inverse();\r\n      if (transform1 === undefined)\r\n        return undefined;\r\n    } else {\r\n      const product = transform0.multiplyTransformTransform(transform1);\r\n      if (!product.isIdentity)\r\n        return undefined;\r\n    }\r\n    return new Map4d(Matrix4d.createTransform(transform0), Matrix4d.createTransform(transform1));\r\n  }\r\n  /**\r\n   * Create a mapping the scales and translates (no rotation) between boxes.\r\n   * @param lowA low point of box A\r\n   * @param highA high point of box A\r\n   * @param lowB low point of box B\r\n   * @param highB high point of box B\r\n   */\r\n  public static createBoxMap(lowA: Point3d, highA: Point3d, lowB: Point3d, highB: Point3d, result?: Map4d): Map4d | undefined {\r\n    const t0 = Matrix4d.createBoxToBox(lowA, highA, lowB, highB, result ? result.transform0 : undefined);\r\n    const t1 = Matrix4d.createBoxToBox(lowB, highB, lowA, highA, result ? result.transform1 : undefined);\r\n    if (t0 && t1) {\r\n      if (result)\r\n        return result;\r\n      return new Map4d(t0, t1);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Copy contents from another Map4d */\r\n  public setFrom(other: Map4d) { this._matrix0.setFrom(other._matrix0), this._matrix1.setFrom(other._matrix1); }\r\n  /** Return a clone of this Map4d */\r\n  public clone(): Map4d { return new Map4d(this._matrix0.clone(), this._matrix1.clone()); }\r\n  /** Reinitialize this Map4d as an identity. */\r\n  public setIdentity() { this._matrix0.setIdentity(); this._matrix1.setIdentity(); }\r\n  /** Set this map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */\r\n  public setFromJSON(json: any): void {\r\n    if (json.matrix0 && json.matrix1) {\r\n      this._matrix0.setFromJSON(json.matrix0);\r\n      this._matrix1.setFromJSON(json.matrix1);\r\n    } else\r\n      this.setIdentity();\r\n  }\r\n  /** Create a map4d from a json object that the two Matrix4d values as properties named matrix0 and matrix1 */\r\n  public static fromJSON(json?: any): Map4d {\r\n    const result = new Map4d(Matrix4d.createIdentity(), Matrix4d.createIdentity());\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Return a json object `{matrix0: value0, matrix1: value1}` */\r\n  public toJSON(): any { return { matrix0: this._matrix0.toJSON(), matrix1: this._matrix1.toJSON() }; }\r\n  /** Test if both matrices are almost equal to those */\r\n  public isAlmostEqual(other: Map4d) {\r\n    return this._matrix0.isAlmostEqual(other._matrix0) && this._matrix1.isAlmostEqual(other._matrix1);\r\n  }\r\n  /** Create a map between a frustum and world coordinates.\r\n   * @param origin lower left of frustum\r\n   * @param uVector Vector from lower left rear to lower right rear\r\n   * @param vVector Vector from lower left rear to upper left rear\r\n   * @param wVector Vector from lower left rear to lower left front, i.e. lower left rear towards eye.\r\n   * @param fraction front size divided by rear size.\r\n   */\r\n  public static createVectorFrustum(origin: Point3d, uVector: Vector3d, vVector: Vector3d, wVector: Vector3d, fraction: number): Map4d | undefined {\r\n    fraction = Math.max(fraction, 1.0e-8);\r\n    const slabToWorld = Transform.createOriginAndMatrix(origin, Matrix3d.createColumns(uVector, vVector, wVector));\r\n    const worldToSlab = slabToWorld.inverse();\r\n    if (!worldToSlab)\r\n      return undefined;\r\n    const worldToSlabMap = new Map4d(Matrix4d.createTransform(worldToSlab), Matrix4d.createTransform(slabToWorld));\r\n    const slabToNPCMap = new Map4d(Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, fraction, 0, 0, 0, fraction - 1.0, 1), Matrix4d.createRowValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1.0 / fraction, 0, 0, 0, (1.0 - fraction) / fraction, 1));\r\n    const result = slabToNPCMap.multiplyMapMap(worldToSlabMap);\r\n    /*\r\n    let numIdentity = 0;\r\n    const productA = worldToSlabMap.matrix0.multiplyMatrixMatrix(worldToSlabMap.matrix1);\r\n    if (productA.isIdentity())\r\n      numIdentity++;\r\n    const productB = slabToNPCMap.matrix0.multiplyMatrixMatrix(slabToNPCMap.matrix1);\r\n    if (productB.isIdentity())\r\n      numIdentity++;\r\n    const product = result.matrix0.multiplyMatrixMatrix(result.matrix1);\r\n    if (product.isIdentity())\r\n      numIdentity++;\r\n    if (numIdentity === 3)\r\n        return result;\r\n      */\r\n    return result;\r\n  }\r\n  /** multiply this*other. The output matrices are\r\n   * * output matrix0 = `this.matrix0 * other.matrix0`\r\n   * * output matrix1 = 'other.matrix1 * this.matrix1`\r\n   */\r\n  public multiplyMapMap(other: Map4d): Map4d {\r\n    return new Map4d(this._matrix0.multiplyMatrixMatrix(other._matrix0), other._matrix1.multiplyMatrixMatrix(this._matrix1));\r\n  }\r\n  /** Exchange the two matrices of the map. */\r\n  public reverseInPlace() {\r\n    const temp = this._matrix0;\r\n    this._matrix0 = this._matrix1;\r\n    this._matrix1 = temp;\r\n  }\r\n  /** return a Map4d whose transform0 is\r\n   * other.transform0 * this.transform0 * other.transform1\r\n   */\r\n  public sandwich0This1(other: Map4d): Map4d {\r\n    return new Map4d(other._matrix0.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix1)), other._matrix0.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix1)));\r\n  }\r\n  /** return a Map4d whose transform0 is\r\n   * other.transform1 * this.transform0 * other.transform0\r\n   */\r\n  public sandwich1This0(other: Map4d): Map4d {\r\n    return new Map4d(other._matrix1.multiplyMatrixMatrix(this._matrix0.multiplyMatrixMatrix(other._matrix0)), other._matrix1.multiplyMatrixMatrix(this._matrix1.multiplyMatrixMatrix(other._matrix0)));\r\n  }\r\n} // Map4d\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d, XYZ } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Point4d, Point4dProps } from \"./Point4d\";\r\n/**\r\n * Coordinate data with `Point4d` numeric data as an array `[x,y,z,w]`\r\n * @public\r\n */\r\nexport type Matrix4dProps = Point4dProps[];\r\n\r\n/**\r\n * * A Matrix4d is a matrix with 4 rows and 4 columns.\r\n * * The 4 rows may be described as the x,y,z,w rows.\r\n * * The 4 columns may be described as the x,y,z,w columns.\r\n * * The matrix is physically stored as a Float64Array with 16 numbers.\r\n * * The layout in the Float64Array is \"by row\"\r\n *   * indices 0,1,2,3 are the \"x row\".   They may be called the xx,xy,xz,xw entries\r\n *   * indices 4,5,6,7 are the \"y row\"    They may be called the yx,yy,yz,yw entries\r\n *   * indices 8,9,10,11 are the \"z row\"  They may be called the zx,zy,zz,zw entries\r\n *   * indices 12,13,14,15 are the \"w row\".  They may be called the wx,wy,wz,ww entries\r\n * * If \"w row\" contains numeric values 0,0,0,1, the Matrix4d is equivalent to a Transform with\r\n *  * The upper right 3x3 matrix (entries 0,1,2,4,5,6,8,9,10) are the 3x3 matrix part of the transform\r\n *  * The far right column entries xw,yw,zw are the \"origin\" (sometimes called \"translation\") part of the transform.\r\n * @public\r\n */\r\nexport class Matrix4d implements BeJSONFunctions {\r\n  private _coffs: Float64Array;\r\n  private constructor() { this._coffs = new Float64Array(16); }\r\n  /** Copy matrix entries from `other` */\r\n  public setFrom(other: Matrix4d): void {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] = other._coffs[i];\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): Matrix4d {\r\n    const result = new Matrix4d();\r\n    for (let i = 0; i < 16; i++)\r\n      result._coffs[i] = this._coffs[i];\r\n    return result;\r\n  }\r\n  /** zero this matrix4d in place. */\r\n  public setZero(): void {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] = 0;\r\n  }\r\n  /** set to identity. */\r\n  public setIdentity(): void {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] = 0;\r\n    this._coffs[0] = this._coffs[5] = this._coffs[10] = this._coffs[15] = 1.0;\r\n  }\r\n  private static is1000(a: number, b: number, c: number, d: number, tol: number): boolean {\r\n    return Math.abs(a - 1.0) <= tol\r\n      && Math.abs(b) <= tol\r\n      && Math.abs(c) <= tol\r\n      && Math.abs(d) <= tol;\r\n  }\r\n  /** set to identity. */\r\n  public isIdentity(tol: number = 1.0e-10): boolean {\r\n    return Matrix4d.is1000(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], tol)\r\n      && Matrix4d.is1000(this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[4], tol)\r\n      && Matrix4d.is1000(this._coffs[10], this._coffs[11], this._coffs[8], this._coffs[9], tol)\r\n      && Matrix4d.is1000(this._coffs[15], this._coffs[12], this._coffs[13], this._coffs[14], tol);\r\n  }\r\n  /** create a Matrix4d filled with zeros. */\r\n  public static createZero(result?: Matrix4d): Matrix4d {\r\n    if (result) {\r\n      result.setZero();\r\n      return result;\r\n    }\r\n    return new Matrix4d(); // this is zero.\r\n  }\r\n  /** create a Matrix4d with values supplied \"across the rows\" */\r\n  public static createRowValues(cxx: number, cxy: number, cxz: number, cxw: number, cyx: number, cyy: number, cyz: number, cyw: number, czx: number, czy: number, czz: number, czw: number, cwx: number, cwy: number, cwz: number, cww: number, result?: Matrix4d): Matrix4d {\r\n    result = result ? result : new Matrix4d();\r\n    result._coffs[0] = cxx;\r\n    result._coffs[1] = cxy;\r\n    result._coffs[2] = cxz;\r\n    result._coffs[3] = cxw;\r\n    result._coffs[4] = cyx;\r\n    result._coffs[5] = cyy;\r\n    result._coffs[6] = cyz;\r\n    result._coffs[7] = cyw;\r\n    result._coffs[8] = czx;\r\n    result._coffs[9] = czy;\r\n    result._coffs[10] = czz;\r\n    result._coffs[11] = czw;\r\n    result._coffs[12] = cwx;\r\n    result._coffs[13] = cwy;\r\n    result._coffs[14] = cwz;\r\n    result._coffs[15] = cww;\r\n    return result;\r\n  }\r\n  /** directly set columns from typical 3d data:\r\n   *\r\n   * * vectorX, vectorY, vectorZ as columns 0,1,2, with weight0.\r\n   * * origin as column3, with weight 1\r\n   */\r\n  public setOriginAndVectors(origin: XYZ, vectorX: Vector3d, vectorY: Vector3d, vectorZ: Vector3d) {\r\n    this._coffs[0] = vectorX.x;\r\n    this._coffs[1] = vectorY.x;\r\n    this._coffs[2] = vectorZ.x;\r\n    this._coffs[3] = origin.x;\r\n    this._coffs[4] = vectorX.y;\r\n    this._coffs[5] = vectorY.y;\r\n    this._coffs[6] = vectorZ.y;\r\n    this._coffs[7] = origin.y;\r\n    this._coffs[8] = vectorX.z;\r\n    this._coffs[9] = vectorY.z;\r\n    this._coffs[10] = vectorZ.z;\r\n    this._coffs[11] = origin.z;\r\n    this._coffs[12] = 0.0;\r\n    this._coffs[13] = 0.0;\r\n    this._coffs[14] = 0.0;\r\n    this._coffs[15] = 1.0;\r\n  }\r\n  /** promote a transform to full Matrix4d (with 0001 in final row) */\r\n  public static createTransform(source: Transform, result?: Matrix4d): Matrix4d {\r\n    const matrix = source.matrix;\r\n    const point = source.origin;\r\n    return Matrix4d.createRowValues(matrix.coffs[0], matrix.coffs[1], matrix.coffs[2], point.x, matrix.coffs[3], matrix.coffs[4], matrix.coffs[5], point.y, matrix.coffs[6], matrix.coffs[7], matrix.coffs[8], point.z, 0, 0, 0, 1, result);\r\n  }\r\n  /** return an identity matrix. */\r\n  public static createIdentity(result?: Matrix4d): Matrix4d {\r\n    result = Matrix4d.createZero(result);\r\n    result._coffs[0] = 1.0;\r\n    result._coffs[5] = 1.0;\r\n    result._coffs[10] = 1.0;\r\n    result._coffs[15] = 1.0;\r\n    return result;\r\n  }\r\n  /** return matrix with translation directly inserted (along with 1 on diagonal) */\r\n  public static createTranslationXYZ(x: number, y: number, z: number, result?: Matrix4d): Matrix4d {\r\n    result = Matrix4d.createZero(result);\r\n    result._coffs[0] = 1.0;\r\n    result._coffs[5] = 1.0;\r\n    result._coffs[10] = 1.0;\r\n    result._coffs[15] = 1.0;\r\n    result._coffs[3] = x;\r\n    result._coffs[7] = y;\r\n    result._coffs[11] = z;\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a Matrix4d with translation and scaling values directly inserted (along with 1 as final diagonal entry)\r\n   * @param tx x entry for translation column\r\n   * @param ty y entry for translation column\r\n   * @param tz z entry for translation column\r\n   * @param scaleX x diagonal entry\r\n   * @param scaleY y diagonal entry\r\n   * @param scaleZ z diagonal entry\r\n   * @param result optional result.\r\n   */\r\n  public static createTranslationAndScaleXYZ(tx: number, ty: number, tz: number, scaleX: number, scaleY: number, scaleZ: number, result?: Matrix4d): Matrix4d {\r\n    return Matrix4d.createRowValues(scaleX, 0, 0, tx, 0, scaleY, 0, ty, 0, 0, scaleZ, tz, 0, 0, 0, 1, result);\r\n  }\r\n  /**\r\n   * Create a mapping the scales and translates (no rotation) from box A to boxB\r\n   * @param lowA low point of box A\r\n   * @param highA high point of box A\r\n   * @param lowB low point of box B\r\n   * @param highB high point of box B\r\n   */\r\n  public static createBoxToBox(lowA: Point3d, highA: Point3d, lowB: Point3d, highB: Point3d, result?: Matrix4d): Matrix4d | undefined {\r\n    const ax = highA.x - lowA.x;\r\n    const ay = highA.y - lowA.y;\r\n    const az = highA.z - lowA.z;\r\n    const bx = highB.x - lowB.x;\r\n    const by = highB.y - lowB.y;\r\n    const bz = highB.z - lowB.z;\r\n    const abx = Geometry.conditionalDivideFraction(bx, ax);\r\n    const aby = Geometry.conditionalDivideFraction(by, ay);\r\n    const abz = Geometry.conditionalDivideFraction(bz, az);\r\n    if (abx !== undefined && aby !== undefined && abz !== undefined) {\r\n      return Matrix4d.createTranslationAndScaleXYZ(lowB.x - abx * lowA.x, lowB.y - aby * lowA.y, lowB.z - abz * lowA.z, abx, aby, abz, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Set from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */\r\n  public setFromJSON(json?: Matrix4dProps) {\r\n    if (Geometry.isArrayOfNumberArray(json, 4, 4))\r\n      for (let i = 0; i < 4; ++i) {\r\n        for (let j = 0; j < 4; ++j)\r\n          this._coffs[i * 4 + j] = json![i][j];\r\n      }\r\n    else\r\n      this.setZero();\r\n  }\r\n  /**\r\n   * Return the largest (absolute) difference between this and other Matrix4d.\r\n   * @param other matrix to compare to\r\n   */\r\n  public maxDiff(other: Matrix4d): number {\r\n    let a = 0.0;\r\n    for (let i = 0; i < 16; i++)\r\n      a = Math.max(a, Math.abs(this._coffs[i] - other._coffs[i]));\r\n    return a;\r\n  }\r\n  /**\r\n   * Return the largest absolute value in the Matrix4d\r\n   */\r\n  public maxAbs(): number {\r\n    let a = 0.0;\r\n    for (let i = 0; i < 16; i++)\r\n      a = Math.max(a, Math.abs(this._coffs[i]));\r\n    return a;\r\n  }\r\n  /** Test for near-equality with `other` */\r\n  public isAlmostEqual(other: Matrix4d): boolean {\r\n    return Geometry.isSmallMetricDistance(this.maxDiff(other));\r\n  }\r\n  /**\r\n   * Convert an Matrix4d to a Matrix4dProps.\r\n   */\r\n  public toJSON(): Matrix4dProps {\r\n    const value = [];\r\n    for (let i = 0; i < 4; ++i) {\r\n      const row = i * 4;\r\n      value.push([this._coffs[row], this._coffs[row + 1], this._coffs[row + 2], this._coffs[row + 3]]);\r\n    }\r\n    return value;\r\n  }\r\n  /** Create from nested array json e.g. `[[1,2,3,4],[0,1,2,4],[0,2,5,1],[0,0,1,2]]` */\r\n  public static fromJSON(json?: Matrix4dProps) {\r\n    const result = new Matrix4d();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /**\r\n   * Return a point with entries from positions [i0, i0+step, i0+2*step, i0+3*step].\r\n   * * There are no tests for index going out of the 0..15 range.\r\n   * * Usual uses are:\r\n   * * * i0 at left of row (0,4,8,12), step = 1 to extract a row.\r\n   * * * i0 at top of row (0,1,2,3), step = 4 to extract a column\r\n   * * * i0 = 0, step = 5 to extract the diagonal\r\n   * @returns a Point4d with 4 entries taken from positions at steps in the flat 16-member array.\r\n   * @param i0 start index (for 16 member array)\r\n   * @param step step between members\r\n   * @param result optional preallocated point.\r\n   */\r\n  public getSteppedPoint(i0: number, step: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this._coffs[i0], this._coffs[i0 + step], this._coffs[i0 + 2 * step], this._coffs[i0 + 3 * step], result);\r\n  }\r\n  /** Return column 0 as Point4d. */\r\n  public columnX(): Point4d { return this.getSteppedPoint(0, 4); }\r\n  /** Return column 1 as Point4d. */\r\n  public columnY(): Point4d { return this.getSteppedPoint(1, 4); }\r\n  /** Return column 2 as Point4d. */\r\n  public columnZ(): Point4d { return this.getSteppedPoint(2, 4); }\r\n  /** Return column 3 as Point4d. */\r\n  public columnW(): Point4d { return this.getSteppedPoint(3, 4); }\r\n  /** Return row 0 as Point4d. */\r\n  public rowX(): Point4d { return this.getSteppedPoint(0, 1); }\r\n  /** Return row 1 as Point4d. */\r\n  public rowY(): Point4d { return this.getSteppedPoint(4, 1); }\r\n  /** Return row 2 as Point4d. */\r\n  public rowZ(): Point4d { return this.getSteppedPoint(8, 1); }\r\n  /** Return row 3 as Point4d. */\r\n  public rowW(): Point4d { return this.getSteppedPoint(12, 1); }\r\n  /**\r\n   * Returns true if the w row has content other than [0,0,0,1]\r\n   */\r\n  public get hasPerspective(): boolean {\r\n    return this._coffs[12] !== 0.0\r\n      || this._coffs[13] !== 0.0\r\n      || this._coffs[14] !== 0.0\r\n      || this._coffs[15] !== 1.0;\r\n  }\r\n  /**\r\n   * Return a Point4d with the diagonal entries of the matrix\r\n   */\r\n  public diagonal(): Point4d { return this.getSteppedPoint(0, 5); }\r\n  /** return the weight component of this matrix */\r\n  public weight(): number { return this._coffs[15]; }\r\n  /** return the leading 3x3 matrix part of this matrix */\r\n  public matrixPart(): Matrix3d {\r\n    return Matrix3d.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[8], this._coffs[9], this._coffs[10]);\r\n  }\r\n  /**\r\n   * Return the (affine, non-perspective) Transform with the upper 3 rows of this matrix\r\n   * @return undefined if this Matrix4d has perspective effects in the w row.\r\n   */\r\n  public get asTransform(): Transform | undefined {\r\n    if (this.hasPerspective)\r\n      return undefined;\r\n    return Transform.createRowValues(this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3], this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7], this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]);\r\n  }\r\n  /** multiply this * other. */\r\n  public multiplyMatrixMatrix(other: Matrix4d, result?: Matrix4d): Matrix4d {\r\n    result = (result && result !== this && result !== other) ? result : new Matrix4d();\r\n    for (let i0 = 0; i0 < 16; i0 += 4) {\r\n      for (let k = 0; k < 4; k++)\r\n        result._coffs[i0 + k] =\r\n          this._coffs[i0] * other._coffs[k] +\r\n          this._coffs[i0 + 1] * other._coffs[k + 4] +\r\n          this._coffs[i0 + 2] * other._coffs[k + 8] +\r\n          this._coffs[i0 + 3] * other._coffs[k + 12];\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply this * transpose(other). */\r\n  public multiplyMatrixMatrixTranspose(other: Matrix4d, result?: Matrix4d): Matrix4d {\r\n    result = (result && result !== this && result !== other) ? result : new Matrix4d();\r\n    let j = 0;\r\n    for (let i0 = 0; i0 < 16; i0 += 4) {\r\n      for (let k = 0; k < 16; k += 4)\r\n        result._coffs[j++] =\r\n          this._coffs[i0] * other._coffs[k] +\r\n          this._coffs[i0 + 1] * other._coffs[k + 1] +\r\n          this._coffs[i0 + 2] * other._coffs[k + 2] +\r\n          this._coffs[i0 + 3] * other._coffs[k + 3];\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply transpose (this) * other. */\r\n  public multiplyMatrixTransposeMatrix(other: Matrix4d, result?: Matrix4d): Matrix4d {\r\n    result = (result && result !== this && result !== other) ? result : new Matrix4d();\r\n    let j = 0;\r\n    for (let i0 = 0; i0 < 4; i0 += 1) {\r\n      for (let k0 = 0; k0 < 4; k0 += 1)\r\n        result._coffs[j++] =\r\n          this._coffs[i0] * other._coffs[k0] +\r\n          this._coffs[i0 + 4] * other._coffs[k0 + 4] +\r\n          this._coffs[i0 + 8] * other._coffs[k0 + 8] +\r\n          this._coffs[i0 + 12] * other._coffs[k0 + 12];\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a transposed matrix. */\r\n  public cloneTransposed(result?: Matrix4d): Matrix4d {\r\n    return Matrix4d.createRowValues(this._coffs[0], this._coffs[4], this._coffs[8], this._coffs[12], this._coffs[1], this._coffs[5], this._coffs[9], this._coffs[13], this._coffs[2], this._coffs[6], this._coffs[10], this._coffs[14], this._coffs[3], this._coffs[7], this._coffs[11], this._coffs[15], result);\r\n  }\r\n  /** multiply matrix times column [x,y,z,w].  return as Point4d.   (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    result = result ? result : Point4d.createZero();\r\n    return result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w, this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w);\r\n  }\r\n  /** multiply matrix times column vectors [x,y,z,w] where [x,y,z,w] appear in blocks in an array.\r\n   * replace the xyzw in the block\r\n   */\r\n  public multiplyBlockedFloat64ArrayInPlace(data: Float64Array) {\r\n    const n = data.length;\r\n    let x, y, z, w;\r\n    for (let i = 0; i + 3 < n; i += 4) {\r\n      x = data[i];\r\n      y = data[i + 1];\r\n      z = data[i + 2];\r\n      w = data[i + 3];\r\n      data[i] = this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w;\r\n      data[i + 1] = this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w;\r\n      data[i + 2] = this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w;\r\n      data[i + 3] = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;\r\n    }\r\n  }\r\n  /** multiply matrix times XYAndZ  and w. return as Point4d  (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyPoint3d(pt: XYAndZ, w: number, result?: Point4d): Point4d {\r\n    return this.multiplyXYZW(pt.x, pt.y, pt.z, w, result);\r\n  }\r\n  /** multiply matrix times and array  of XYAndZ. return as array of Point4d  (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyPoint3dArray(pts: XYAndZ[], results: Point4d[], w: number = 1.0): void {\r\n    pts.forEach((pt, i) => { results[i] = this.multiplyXYZW(pt.x, pt.y, pt.z, w, results[i]); });\r\n  }\r\n  /** multiply [x,y,z,w] times matrix.  return as Point4d.   (And the returned value is NOT normalized down to unit w) */\r\n  public multiplyTransposeXYZW(x: number, y: number, z: number, w: number, result?: Point4d): Point4d {\r\n    result = result ? result : Point4d.createZero();\r\n    return result.set(this._coffs[0] * x + this._coffs[4] * y + this._coffs[8] * z + this._coffs[12] * w, this._coffs[1] * x + this._coffs[5] * y + this._coffs[9] * z + this._coffs[13] * w, this._coffs[2] * x + this._coffs[6] * y + this._coffs[10] * z + this._coffs[14] * w, this._coffs[3] * x + this._coffs[7] * y + this._coffs[11] * z + this._coffs[15] * w);\r\n  }\r\n  /** Returns dot product of row rowIndex of this with column columnIndex of other.\r\n   */\r\n  public rowDotColumn(rowIndex: number, other: Matrix4d, columnIndex: number): number {\r\n    const i = rowIndex * 4;\r\n    const j = columnIndex;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 1] * other._coffs[j + 4]\r\n      + this._coffs[i + 2] * other._coffs[j + 8]\r\n      + this._coffs[i + 3] * other._coffs[j + 12];\r\n  }\r\n  /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.\r\n   */\r\n  public rowDotRow(rowIndexThis: number, other: Matrix4d, rowIndexOther: number): number {\r\n    const i = rowIndexThis * 4;\r\n    const j = rowIndexOther * 4;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 1] * other._coffs[j + 1]\r\n      + this._coffs[i + 2] * other._coffs[j + 2]\r\n      + this._coffs[i + 3] * other._coffs[j + 3];\r\n  }\r\n  /** Returns dot product of row rowIndexThis of this with row rowIndexOther of other.\r\n   */\r\n  public columnDotColumn(columnIndexThis: number, other: Matrix4d, columnIndexOther: number): number {\r\n    const i = columnIndexThis;\r\n    const j = columnIndexOther;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 4] * other._coffs[j + 4]\r\n      + this._coffs[i + 8] * other._coffs[j + 8]\r\n      + this._coffs[i + 12] * other._coffs[j + 12];\r\n  }\r\n  /** Returns dot product of column columnIndexThis of this with row rowIndexOther other.\r\n   */\r\n  public columnDotRow(columnIndexThis: number, other: Matrix4d, rowIndexOther: number): number {\r\n    const i = columnIndexThis;\r\n    const j = 4 * rowIndexOther;\r\n    return this._coffs[i] * other._coffs[j]\r\n      + this._coffs[i + 4] * other._coffs[j + 1]\r\n      + this._coffs[i + 8] * other._coffs[j + 2]\r\n      + this._coffs[i + 12] * other._coffs[j + 3];\r\n  }\r\n  /** Return a matrix entry by row and column index.\r\n   */\r\n  public atIJ(rowIndex: number, columnIndex: number): number {\r\n    return this._coffs[rowIndex * 4 + columnIndex];\r\n  }\r\n  /** multiply matrix * [x,y,z,w]. immediately renormalize to return in a Point3d.\r\n   * If zero weight appears in the result (i.e. input is on eyeplane) leave the mapped xyz untouched.\r\n   */\r\n  public multiplyXYZWQuietRenormalize(x: number, y: number, z: number, w: number, result?: Point3d): Point3d {\r\n    result = result ? result : Point3d.createZero();\r\n    result.set(this._coffs[0] * x + this._coffs[1] * y + this._coffs[2] * z + this._coffs[3] * w, this._coffs[4] * x + this._coffs[5] * y + this._coffs[6] * z + this._coffs[7] * w, this._coffs[8] * x + this._coffs[9] * y + this._coffs[10] * z + this._coffs[11] * w);\r\n    const w1 = this._coffs[12] * x + this._coffs[13] * y + this._coffs[14] * z + this._coffs[15] * w;\r\n    if (!Geometry.isSmallMetricDistance(w1)) {\r\n      const a = 1.0 / w1;\r\n      result.x *= a;\r\n      result.y *= a;\r\n      result.z *= a;\r\n    }\r\n    return result;\r\n  }\r\n  /** multiply matrix * an array of Point4d. immediately renormalize to return in an array of Point3d. */\r\n  public multiplyPoint4dArrayQuietRenormalize(pts: Point4d[], results: Point3d[]): void {\r\n    pts.forEach((pt, i) => { results[i] = this.multiplyXYZWQuietRenormalize(pt.x, pt.y, pt.z, pt.w, results[i]); });\r\n  }\r\n  /** multiply a Point4d, return with the optional result convention. */\r\n  public multiplyPoint4d(point: Point4d, result?: Point4d): Point4d {\r\n    return this.multiplyXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);\r\n  }\r\n  /** multiply a Point4d, return with the optional result convention. */\r\n  public multiplyTransposePoint4d(point: Point4d, result?: Point4d): Point4d {\r\n    return this.multiplyTransposeXYZW(point.xyzw[0], point.xyzw[1], point.xyzw[2], point.xyzw[3], result);\r\n  }\r\n  /** multiply matrix * point. This produces a weighted xyzw.\r\n   * Immediately renormalize back to xyz and return (with optional result convention).\r\n   * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.\r\n   */\r\n  public multiplyPoint3dQuietNormalize(point: XYAndZ, result?: Point3d): Point3d {\r\n    return this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, result);\r\n  }\r\n  /** multiply each matrix * points[i].   This produces a weighted xyzw.\r\n   * Immediately renormalize back to xyz and replace the original point.\r\n   * If zero weight appears in the result (i.e. input is on eyeplane)leave the mapped xyz untouched.\r\n   */\r\n  public multiplyPoint3dArrayQuietNormalize(points: Point3d[]) {\r\n    points.forEach((point) => this.multiplyXYZWQuietRenormalize(point.x, point.y, point.z, 1.0, point));\r\n  }\r\n  /**\r\n   * Add the product terms [xx,xy,xz,xw, yx, yy, yz, yw, zx, zy, zz, zs, wx, wy, wz, ww] to respective entries in the matrix\r\n   * @param x x component for products\r\n   * @param y y component for products\r\n   * @param z z component for products\r\n   * @param w w component for products\r\n   */\r\n  public addMomentsInPlace(x: number, y: number, z: number, w: number) {\r\n    this._coffs[0] += x * x;\r\n    this._coffs[1] += x * y;\r\n    this._coffs[2] += x * z;\r\n    this._coffs[3] += x * w;\r\n    this._coffs[4] += y * x;\r\n    this._coffs[5] += y * y;\r\n    this._coffs[6] += y * z;\r\n    this._coffs[7] += y * w;\r\n    this._coffs[8] += z * x;\r\n    this._coffs[9] += z * y;\r\n    this._coffs[10] += z * z;\r\n    this._coffs[11] += z * w;\r\n    this._coffs[12] += w * x;\r\n    this._coffs[13] += w * y;\r\n    this._coffs[14] += w * z;\r\n    this._coffs[15] += w * w;\r\n  }\r\n  /** accumulate all coefficients of other to this. */\r\n  public addScaledInPlace(other: Matrix4d, scale: number = 1.0) {\r\n    for (let i = 0; i < 16; i++)\r\n      this._coffs[i] += scale * other._coffs[i];\r\n  }\r\n  /**\r\n   * Add scale times rowA to rowB.\r\n   * @param rowIndexA row that is not modified\r\n   * @param rowIndexB row that is modified.\r\n   * @param firstColumnIndex first column modified.  All from there to the right are updated\r\n   * @param scale scale\r\n   */\r\n  public rowOperation(rowIndexA: number, rowIndexB: number, firstColumnIndex: number, scale: number) {\r\n    if (scale === 0.0)\r\n      return;\r\n    let iA = rowIndexA * 4 + firstColumnIndex;\r\n    let iB = rowIndexB * 4 + firstColumnIndex;\r\n    for (let i = firstColumnIndex; i < 4; i++ , iA++ , iB++)\r\n      this._coffs[iB] += scale * this._coffs[iA];\r\n  }\r\n  /** Compute an inverse matrix.\r\n   * * This uses simple Bauss-Jordan elimination -- no pivot.\r\n   * @returns undefined if 1/pivot becomes too large. (i.e. apparent 0 pivot)\r\n   */\r\n  public createInverse(): Matrix4d | undefined {\r\n    const work = this.clone();\r\n    const inverse = Matrix4d.createIdentity();\r\n    // console.log(work.rowArrays());\r\n    // console.log(inverse.rowArrays());\r\n    let pivotIndex;\r\n    let pivotRow;\r\n    let pivotValue;\r\n    let divPivot;\r\n    // Downward gaussian elimination, no pivoting:\r\n    for (pivotRow = 0; pivotRow < 3; pivotRow++) {\r\n      pivotIndex = pivotRow * 5;\r\n      pivotValue = work._coffs[pivotIndex];\r\n      // console.log(\"** pivot row \" + pivotRow + \" pivotvalue \" + pivotValue);\r\n      divPivot = Geometry.conditionalDivideFraction(1.0, pivotValue);\r\n      if (divPivot === undefined)\r\n        return undefined;\r\n      let indexB = pivotIndex + 4;\r\n      for (let rowB = pivotRow + 1; rowB < 4; rowB++ , indexB += 4) {\r\n        const scale = -work._coffs[indexB] * divPivot;\r\n        work.rowOperation(pivotRow, rowB, pivotRow, scale);\r\n        inverse.rowOperation(pivotRow, rowB, 0, scale);\r\n        // console.log(work.rowArrays());\r\n        // console.log(inverse.rowArrays());\r\n      }\r\n    }\r\n    // console.log(\"\\n**********************Backsub\\n\");\r\n    // upward gaussian elimination ...\r\n    for (pivotRow = 1; pivotRow < 4; pivotRow++) {\r\n      pivotIndex = pivotRow * 5;\r\n      pivotValue = work._coffs[pivotIndex];\r\n      // console.log(\"** pivot row \" + pivotRow + \" pivotvalue \" + pivotValue);\r\n      divPivot = Geometry.conditionalDivideFraction(1.0, pivotValue);\r\n      if (divPivot === undefined)\r\n        return undefined;\r\n      let indexB = pivotRow;\r\n      for (let rowB = 0; rowB < pivotRow; rowB++ , indexB += 4) {\r\n        const scale = -work._coffs[indexB] * divPivot;\r\n        work.rowOperation(pivotRow, rowB, pivotRow, scale);\r\n        inverse.rowOperation(pivotRow, rowB, 0, scale);\r\n        // console.log(\"Eliminate Row \" + rowB + \" from pivot \" + pivotRow);\r\n        // console.log(work.rowArrays());\r\n        // console.log(inverse.rowArrays());\r\n      }\r\n    }\r\n    // divide through by pivots (all have been confirmed nonzero)\r\n    inverse.scaleRowsInPlace(1.0 / work._coffs[0], 1.0 / work._coffs[5], 1.0 / work._coffs[10], 1.0 / work._coffs[15]);\r\n    // console.log(\"descaled\", inverse.rowArrays());\r\n    return inverse;\r\n  }\r\n  /** Returns an array-of-arrays of the matrix rows, optionally passing each value through a function.\r\n   * @param f optional function to provide alternate values for each entry (e.g. force fuzz to zero.)\r\n   */\r\n  public rowArrays(f?: (value: number) => any): any {\r\n    if (f)\r\n      return [\r\n        [f(this._coffs[0]), f(this._coffs[1]), f(this._coffs[2]), f(this._coffs[3])],\r\n        [f(this._coffs[4]), f(this._coffs[5]), f(this._coffs[6]), f(this._coffs[7])],\r\n        [f(this._coffs[8]), f(this._coffs[9]), f(this._coffs[10]), f(this._coffs[11])],\r\n        [f(this._coffs[12]), f(this._coffs[13]), f(this._coffs[14]), f(this._coffs[15])]];\r\n    else\r\n      return [\r\n        [this._coffs[0], this._coffs[1], this._coffs[2], this._coffs[3]],\r\n        [this._coffs[4], this._coffs[5], this._coffs[6], this._coffs[7]],\r\n        [this._coffs[8], this._coffs[9], this._coffs[10], this._coffs[11]],\r\n        [this._coffs[12], this._coffs[13], this._coffs[14], this._coffs[15]]];\r\n  }\r\n  /**\r\n   * Scale each row by respective scale factors.\r\n   * @param ax scale factor for row 0\r\n   * @param ay scale factor for row 1\r\n   * @param az scale factor for row 2\r\n   * @param aw scale factor for row 3\r\n   */\r\n  public scaleRowsInPlace(ax: number, ay: number, az: number, aw: number) {\r\n    for (let i = 0; i < 4; i++)\r\n      this._coffs[i] *= ax;\r\n    for (let i = 4; i < 8; i++)\r\n      this._coffs[i] *= ay;\r\n    for (let i = 8; i < 12; i++)\r\n      this._coffs[i] *= az;\r\n    for (let i = 12; i < 16; i++)\r\n      this._coffs[i] *= aw;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty no-console*/\r\n\r\nimport { XYZ, Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Matrix4d } from \"./Matrix4d\";\r\nimport { Point4d } from \"./Point4d\";\r\n/**\r\n * A MomentData structure carries data used in calculation of moments of inertia.\r\n * * origin = local origin used as moments are summed.\r\n * * sums = array of summed moments.\r\n *   * The [i,j] entry of the sums is a summed or integrated moment for product of axis i and j.\r\n *      * axes 0,1,2 are x,y,z\r\n *         * e.g. entry [0,1] is summed product xy\r\n *      * axis 3 is \"w\", which is 1 in sums.\r\n *         * e.g. entry 03 is summed x\r\n * @public\r\n */\r\nexport class MomentData {\r\n  /** Origin used for sums. */\r\n  public origin: Point3d;\r\n  /** Moment sums.\r\n   * * Set to zero at initialization and if requested later.\r\n   * * Accumulated during data entry phase.\r\n   */\r\n  public sums: Matrix4d;\r\n  /** the mapping between principal and world system.\r\n   * * This set up with its inverse already constructed.\r\n   */\r\n  public localToWorldMap: Transform;\r\n\r\n  /** radii of gyration (square roots of principal second moments)\r\n   */\r\n  public radiusOfGyration: Vector3d;\r\n  private constructor() {\r\n    this.origin = Point3d.createZero();\r\n    this.sums = Matrix4d.createZero();\r\n    this.localToWorldMap = Transform.createIdentity();\r\n    this.radiusOfGyration = Vector3d.create();\r\n  }\r\n  /**\r\n   * Return the formal tensor of integrated values `[yy+zz,xy,xz][yx,xx+zz,yz][zx,xy,xx+yy]`\r\n   * @param products matrix of (integrated) `[xx,xy,xz][yx,yy,yz][zx,xy,zz]`\r\n   */\r\n  public static momentTensorFromInertiaProducts(products: Matrix3d): Matrix3d {\r\n    const rr = products.sumDiagonal();\r\n    const result = Matrix3d.createScale(rr, rr, rr);\r\n    result.addScaledInPlace(products, -1.0);\r\n    return result;\r\n  }\r\n  /** Sort the columns of the matrix for increasing moments. */\r\n  public static sortColumnsForIncreasingMoments(axes: Matrix3d, moments: Vector3d) {\r\n    const points = [\r\n      axes.indexedColumnWithWeight(0, moments.x),\r\n      axes.indexedColumnWithWeight(1, moments.y),\r\n      axes.indexedColumnWithWeight(2, moments.z)].sort(\r\n        (dataA: Point4d, dataB: Point4d): number => {\r\n          if (dataA.w < dataB.w) return -1;\r\n          if (dataA.w > dataB.w) return 1;\r\n          return 0;\r\n        });\r\n    axes.setColumnsPoint4dXYZ(points[0], points[1], points[2]);\r\n    moments.set(points[0].w, points[1].w, points[2].w);\r\n  }\r\n  /**\r\n   * Return the principal moment data for an array of points.\r\n   * @param points array of points\r\n   */\r\n  public static pointsToPrincipalAxes(points: Point3d[]): MomentData {\r\n    const moments = new MomentData();\r\n    if (points.length === 0)\r\n      return moments;\r\n    moments.clearSums(points[0]);\r\n    moments.accumulatePointMomentsFromOrigin(points);\r\n    if (moments.shiftSumsToCentroid()) {\r\n      const products = moments.sums.matrixPart();\r\n      const tensor = MomentData.momentTensorFromInertiaProducts(products);\r\n      const moment2 = Vector3d.create();\r\n      const axisVectors = Matrix3d.createZero();\r\n      tensor.fastSymmetricEigenvalues(axisVectors, moment2);\r\n      MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);\r\n      moments.localToWorldMap = Transform.createOriginAndMatrix(moments.origin, axisVectors);\r\n      moments.radiusOfGyration.set(\r\n        Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));\r\n      moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));\r\n    }\r\n    return moments;\r\n  }\r\n  /**\r\n   * Compute principal axes from inertial products\r\n   * @param origin The origin used for the inertia products.\r\n   * @param inertiaProducts The inertia products -- sums or integrals of [xx,xy,xz,xw; yx,yy, yz,yw; zx,zy,zz,zw; wx,wy,wz,w]\r\n   */\r\n  public static inertiaProductsToPrincipalAxes(origin: XYZ, inertiaProducts: Matrix4d): MomentData | undefined {\r\n    const moments = new MomentData();\r\n    moments.sums.setFrom(inertiaProducts);\r\n    moments.origin.setFrom(origin);\r\n    if (!moments.shiftSumsToCentroid())\r\n      return undefined;\r\n    const products = moments.sums.matrixPart();\r\n    const tensor = MomentData.momentTensorFromInertiaProducts(products);\r\n    const moment2 = Vector3d.create();\r\n    const axisVectors = Matrix3d.createZero();\r\n    tensor.fastSymmetricEigenvalues(axisVectors, moment2);\r\n    MomentData.sortColumnsForIncreasingMoments(axisVectors, moment2);\r\n    moments.localToWorldMap = Transform.createOriginAndMatrix(moments.origin, axisVectors);\r\n    moments.radiusOfGyration.set(\r\n      Math.sqrt(moment2.x), Math.sqrt(moment2.y), Math.sqrt(moment2.z));\r\n    moments.radiusOfGyration.scaleInPlace(1.0 / Math.sqrt(moments.sums.weight()));\r\n    return moments;\r\n  }\r\n  /** Clear the MomentData sums to zero, and establish a new origin. */\r\n  public clearSums(origin?: Point3d) {\r\n    this.sums.setZero();\r\n    if (origin)\r\n      this.origin.setFrom(origin);\r\n    else\r\n      this.origin.setZero();\r\n  }\r\n  /** Accumulate products-of-components for given points. */\r\n  public accumulatePointMomentsFromOrigin(points: Point3d[]) {\r\n    for (const p of points) {\r\n      this.sums.addMomentsInPlace(\r\n        p.x - this.origin.x,\r\n        p.y - this.origin.y,\r\n        p.z - this.origin.z,\r\n        1.0);\r\n    }\r\n  }\r\n  /** revise the accumulated sums to be \"around the centroid\" */\r\n  public shiftSumsToCentroid(): boolean {\r\n    const xyz = this.sums.columnW().realPoint();\r\n    if (xyz) {\r\n      this.origin.addInPlace(xyz);\r\n      const translation = Matrix4d.createTranslationXYZ(-xyz.x, -xyz.y, -xyz.z);\r\n      const TA = translation.multiplyMatrixMatrix(this.sums);\r\n      TA.multiplyMatrixMatrixTranspose(translation, this.sums);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Point4d } from \"./Point4d\";\r\n/**\r\n * A Plane4dByOriginAndVectors is a 4d origin and pair of 4d \"vectors\" defining a 4d plane.\r\n * * The parameterization of the plane is    `X = origin + vectorU*u + vectorV * v`\r\n * * With particular weight values `origin.w === 1, vectorU.w === 0, vectorV.w === 0` this is like `Plane3dByOriginAndVectors`\r\n * * With other weights, the deweighted xyz coordinates of points on the 4d plane still form a 3d plane.\r\n * @public\r\n */\r\nexport class PlaneByOriginAndVectors4d {\r\n  /** homogeneous origin */\r\n  public origin: Point4d;\r\n  /** homogeneous u-direction vector */\r\n  public vectorU: Point4d;\r\n  /** homogeneous v-direction vector */\r\n  public vectorV: Point4d;\r\n  private constructor(origin: Point4d, vectorU: Point4d, vectorV: Point4d) {\r\n    this.origin = origin;\r\n    this.vectorU = vectorU;\r\n    this.vectorV = vectorV;\r\n  }\r\n  /** Return a clone of this plane */\r\n  public clone(result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    if (result) {\r\n      result.setFrom(this);\r\n      return result;\r\n    }\r\n    return new PlaneByOriginAndVectors4d(this.origin.clone(), this.vectorU.clone(), this.vectorV.clone());\r\n  }\r\n  /** copy all content from other plane */\r\n  public setFrom(other: PlaneByOriginAndVectors4d): void {\r\n    this.origin.setFrom(other.origin);\r\n    this.vectorU.setFrom(other.vectorU);\r\n    this.vectorV.setFrom(other.vectorV);\r\n  }\r\n  /** Return true if origin, vectorU, and vectorV pass isAlmostEqual. */\r\n  public isAlmostEqual(other: PlaneByOriginAndVectors4d): boolean {\r\n    return this.origin.isAlmostEqual(other.origin)\r\n      && this.vectorU.isAlmostEqual(other.vectorU)\r\n      && this.vectorV.isAlmostEqual(other.vectorV);\r\n  }\r\n  /** Create a plane with (copies of) origin, vectorU, vectorV parameters, all given as full 4d points.\r\n   */\r\n  public static createOriginAndVectors(origin: Point4d, vectorU: Point4d, vectorV: Point4d, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    if (result) {\r\n      result.setOriginAndVectors(origin, vectorU, vectorV);\r\n      return result;\r\n    }\r\n    return new PlaneByOriginAndVectors4d(origin.clone(), vectorU.clone(), vectorV.clone());\r\n  }\r\n  /** Set all numeric data from complete list of (x,y,z,w) in origin, vectorU, and vectorV */\r\n  public setOriginAndVectorsXYZW(x0: number, y0: number, z0: number, w0: number, ux: number, uy: number, uz: number, uw: number, vx: number, vy: number, vz: number, vw: number): PlaneByOriginAndVectors4d {\r\n    this.origin.set(x0, y0, z0, w0);\r\n    this.vectorU.set(ux, uy, uz, uw);\r\n    this.vectorV.set(vx, vy, vz, vw);\r\n    return this;\r\n  }\r\n  /** Copy the contents of origin, vectorU, vectorV parameters to respective member variables */\r\n  public setOriginAndVectors(origin: Point4d, vectorU: Point4d, vectorV: Point4d): PlaneByOriginAndVectors4d {\r\n    this.origin.setFrom(origin);\r\n    this.vectorU.setFrom(vectorU);\r\n    this.vectorV.setFrom(vectorV);\r\n    return this;\r\n  }\r\n  /** Create from complete list of (x,y,z,w) in origin, vectorU, and vectorV */\r\n  public static createOriginAndVectorsXYZW(x0: number, y0: number, z0: number, w0: number, ux: number, uy: number, uz: number, uw: number, vx: number, vy: number, vz: number, vw: number, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    if (result)\r\n      return result.setOriginAndVectorsXYZW(x0, y0, z0, w0, ux, uy, uz, uw, vx, vy, vz, vw);\r\n    return new PlaneByOriginAndVectors4d(Point4d.create(x0, y0, z0, w0), Point4d.create(ux, uy, uz, uw), Point4d.create(vx, vy, vz, uw));\r\n  }\r\n  /** create from origin point, (u=1,v=0) point, and (u=0,v=1) point. */\r\n  public static createOriginAndTargets3d(origin: Point3d, targetU: Point3d, targetV: Point3d, result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(origin.x, origin.y, origin.z, 1.0, targetU.x - origin.x, targetU.y - origin.y, targetU.z - origin.z, 0.0, targetV.x - origin.x, targetV.y - origin.y, targetV.z - origin.z, 0.0, result);\r\n  }\r\n  /** evaluate plane point (full 3d) at given (u,v) coordinate. */\r\n  public fractionToPoint(u: number, v: number, result?: Point4d): Point4d {\r\n    return this.origin.plus2Scaled(this.vectorU, u, this.vectorV, v, result);\r\n  }\r\n/** create a new plane which maps to the cartesian xy plane. */\r\n  public static createXYPlane(result?: PlaneByOriginAndVectors4d): PlaneByOriginAndVectors4d {\r\n    return PlaneByOriginAndVectors4d.createOriginAndVectorsXYZW(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, result);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\nimport { Geometry, BeJSONFunctions } from \"../Geometry\";\r\nimport { XYAndZ } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\n\r\n/**\r\n * 4d point packed in an array of 4 numbers.\r\n * @public\r\n */\r\nexport type Point4dProps = number[];\r\n/**\r\n *\r\n * @param ddg numerator second derivative\r\n * @param dh denominator derivative\r\n * @param ddh denominator second derivative\r\n * @param f primary function (g/h)\r\n * @param df derivative of (g/h)\r\n * @param divh = (1/h)\r\n * @param dgdivh previously computed first derivative of (g/h)\r\n * @internal\r\n */\r\nfunction quotientDerivative2(ddg: number, dh: number, ddh: number,\r\n  f: number, df: number, divh: number): number {\r\n  return divh * (ddg - 2.0 * df * dh - f * ddh);\r\n}\r\n\r\n/** 4 Dimensional point (x,y,z,w) used in perspective calculations.\r\n * * the coordinates are stored in a Float64Array of length 4.\r\n * * properties `x`, `y`, `z`, `w` access array members.\r\n * *\r\n * * The coordinates are physically stored as a single Float64Array with 4 entries. (w last)\r\n * *\r\n * @public\r\n */\r\nexport class Point4d implements BeJSONFunctions {\r\n  /** x,y,z,w are packed into a Float64Array */\r\n  public xyzw: Float64Array;\r\n  /** Set x,y,z,w of this point.  */\r\n  public set(x: number = 0, y: number = 0, z: number = 0, w: number = 0): Point4d {\r\n    this.xyzw[0] = x;\r\n    this.xyzw[1] = y;\r\n    this.xyzw[2] = z;\r\n    this.xyzw[3] = w;\r\n    return this;\r\n  }\r\n  /** Return the x component. */\r\n  public get x() { return this.xyzw[0]; }\r\n  /** Set the x component. */\r\n  public set x(val: number) { this.xyzw[0] = val; }\r\n  /** Return the y component. */\r\n  public get y() { return this.xyzw[1]; }\r\n  /** Set the y component. */\r\n  public set y(val: number) { this.xyzw[1] = val; }\r\n  /** Return the z component. */\r\n  public get z() { return this.xyzw[2]; }\r\n  /** Set the z component. */\r\n  public set z(val: number) { this.xyzw[2] = val; }\r\n  /** Return the w component of this point. */\r\n  public get w() { return this.xyzw[3]; }\r\n  /** Set the w component. */\r\n  public set w(val: number) { this.xyzw[3] = val; }\r\n  /** Construct from coordinates. */\r\n  protected constructor(x: number = 0, y: number = 0, z: number = 0, w: number = 0) {\r\n    this.xyzw = new Float64Array(4);\r\n    this.xyzw[0] = x;\r\n    this.xyzw[1] = y;\r\n    this.xyzw[2] = z;\r\n    this.xyzw[3] = w;\r\n  }\r\n  /** Return a Point4d with specified x,y,z,w */\r\n  public static create(x: number = 0, y: number = 0, z: number = 0, w: number = 0, result?: Point4d): Point4d {\r\n    return result ? result.set(x, y, z, w) : new Point4d(x, y, z, w);\r\n  }\r\n  /** Copy coordinates from `other`. */\r\n  public setFrom(other: Point4d): Point4d {\r\n    this.xyzw[0] = other.xyzw[0];\r\n    this.xyzw[1] = other.xyzw[1];\r\n    this.xyzw[2] = other.xyzw[2];\r\n    this.xyzw[3] = other.xyzw[3];\r\n    return this;\r\n  }\r\n  /** Clone this point */\r\n  public clone(result?: Point4d): Point4d {\r\n    return result ? result.setFrom(this) : new Point4d(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);\r\n  }\r\n  /** Set this point's xyzw from a json array `[x,y,z,w]` */\r\n  public setFromJSON(json?: Point4dProps) {\r\n    if (Geometry.isNumberArray(json, 4))\r\n      this.set(json![0], json![1], json![2], json![3]);\r\n    else\r\n      this.set(0, 0, 0, 0);\r\n  }\r\n\r\n  /** Create a new point with coordinates from a json array `[x,y,z,w]` */\r\n  public static fromJSON(json?: Point4dProps): Point4d {\r\n    const result = new Point4d();\r\n    result.setFromJSON(json);\r\n    return result;\r\n  }\r\n  /** Near-equality test, using `Geometry.isSameCoordinate` on all 4 x,y,z,w */\r\n  public isAlmostEqual(other: Point4d): boolean {\r\n    return Geometry.isSameCoordinate(this.x, other.x)\r\n      && Geometry.isSameCoordinate(this.y, other.y)\r\n      && Geometry.isSameCoordinate(this.z, other.z)\r\n      && Geometry.isSameCoordinate(this.w, other.w);\r\n  }\r\n  /**\r\n   * Test for same coordinate by direct x,y,z,w args\r\n   * @param x x to test\r\n   * @param y y to test\r\n   * @param z z to test\r\n   * @param w w to test\r\n   */\r\n  public isAlmostEqualXYZW(x: number, y: number, z: number, w: number): boolean {\r\n    return Geometry.isSameCoordinate(this.x, x)\r\n      && Geometry.isSameCoordinate(this.y, y)\r\n      && Geometry.isSameCoordinate(this.z, z)\r\n      && Geometry.isSameCoordinate(this.w, w);\r\n  }\r\n\r\n  /**\r\n   * Convert an Angle to a JSON object.\r\n   * @return {*} [x,y,z,w]\r\n   */\r\n  public toJSON(): Point4dProps {\r\n    return [this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]];\r\n  }\r\n  /** Return the 4d distance from this point to other, with all 4 components squared into the hypotenuse.\r\n   * * x,y,z,w all participate without normalization.\r\n   */\r\n  public distanceXYZW(other: Point4d): number {\r\n    return Geometry.hypotenuseXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);\r\n  }\r\n  /** Return the squared 4d distance from this point to other, with all 4 components squared into the hypotenuse.\r\n   * * x,y,z,w all participate without normalization.\r\n   */\r\n  public distanceSquaredXYZW(other: Point4d): number {\r\n    return Geometry.hypotenuseSquaredXYZW(other.xyzw[0] - this.xyzw[0], other.xyzw[1] - this.xyzw[1], other.xyzw[2] - this.xyzw[2], other.xyzw[3] - this.xyzw[3]);\r\n  }\r\n  /** Return the distance between the instance and other after normalizing by weights\r\n   */\r\n  public realDistanceXY(other: Point4d): number | undefined {\r\n    const wA = this.w;\r\n    const wB = other.w;\r\n    if (Geometry.isSmallMetricDistance(wA) || Geometry.isSmallMetricDistance(wB))\r\n      return undefined;\r\n    return Geometry.hypotenuseXY(other.xyzw[0] / wB - this.xyzw[0] / wA, other.xyzw[1] / wB - this.xyzw[1] / wA);\r\n  }\r\n  /** Return the largest absolute distance between corresponding components\r\n   * * x,y,z,w all participate without normalization.\r\n   */\r\n  public maxDiff(other: Point4d): number {\r\n    return Math.max(Math.abs(other.xyzw[0] - this.xyzw[0]), Math.abs(other.xyzw[1] - this.xyzw[1]), Math.abs(other.xyzw[2] - this.xyzw[2]), Math.abs(other.xyzw[3] - this.xyzw[3]));\r\n  }\r\n  /** Return the largest absolute entry of all 4 components x,y,z,w */\r\n  public maxAbs(): number {\r\n    return Math.max(Math.abs(this.xyzw[0]), Math.abs(this.xyzw[1]), Math.abs(this.xyzw[2]), Math.abs(this.xyzw[3]));\r\n  }\r\n  /** Returns the magnitude including all 4 components x,y,z,w */\r\n  public magnitudeXYZW(): number {\r\n    return Geometry.hypotenuseXYZW(this.xyzw[0], this.xyzw[1], this.xyzw[2], this.xyzw[3]);\r\n  }\r\n  /** Returns the magnitude of the leading xyz components.  w is ignored.  (i.e. the leading xyz are NOT divided by w.) */\r\n  public magnitudeSquaredXYZ(): number {\r\n    return Geometry.hypotenuseSquaredXYZ(this.xyzw[0], this.xyzw[1], this.xyzw[2]);\r\n  }\r\n\r\n  /** Return the difference (this-other) using all 4 components x,y,z,w */\r\n  public minus(other: Point4d, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] - other.xyzw[0], this.xyzw[1] - other.xyzw[1], this.xyzw[2] - other.xyzw[2], this.xyzw[3] - other.xyzw[3], result);\r\n  }\r\n  /** Return `((other.w * this) -  (this.w * other))` */\r\n  public crossWeightedMinus(other: Point4d, result?: Vector3d): Vector3d {\r\n    const wa = this.xyzw[3];\r\n    const wb = other.xyzw[3];\r\n    return Vector3d.create(wb * this.xyzw[0] - wa * other.xyzw[0], wb * this.xyzw[1] - wa * other.xyzw[1], wb * this.xyzw[2] - wa * other.xyzw[2], result);\r\n  }\r\n  /** Return the sum of this and other, using all 4 components x,y,z,w */\r\n  public plus(other: Point4d, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + other.xyzw[0], this.xyzw[1] + other.xyzw[1], this.xyzw[2] + other.xyzw[2], this.xyzw[3] + other.xyzw[3], result);\r\n  }\r\n  /** Test if all components are nearly zero. */\r\n  public get isAlmostZero(): boolean {\r\n    return Geometry.isSmallMetricDistance(this.maxAbs());\r\n  }\r\n  /** Create a point with zero in all coordinates. */\r\n  public static createZero(): Point4d { return new Point4d(0, 0, 0, 0); }\r\n  /**\r\n   * Create plane coefficients for the plane containing pointA, pointB, and 0010.\r\n   * @param pointA first point\r\n   * @param pointB second point\r\n   */\r\n  public static createPlanePointPointZ(pointA: Point4d, pointB: Point4d, result?: Point4d) {\r\n    return Point4d.create(pointA.y * pointB.w - pointA.w * pointB.y, pointA.w * pointB.x - pointA.x * pointB.w, 0.0, pointA.x * pointB.y - pointA.y * pointB.x, result);\r\n  }\r\n  /**\r\n   * extract 4 consecutive numbers from a Float64Array into a Point4d.\r\n   * @param data buffer of numbers\r\n   * @param xIndex first index for x,y,z,w sequence\r\n   */\r\n  public static createFromPackedXYZW(data: Float64Array, xIndex: number = 0, result?: Point4d): Point4d {\r\n    return Point4d.create(data[xIndex], data[xIndex + 1], data[xIndex + 2], data[xIndex + 3], result);\r\n  }\r\n  /** Create a `Point4d` with x,y,z from an `XYAndZ` input, and w from a separate number. */\r\n  public static createFromPointAndWeight(xyz: XYAndZ, w: number): Point4d {\r\n    return new Point4d(xyz.x, xyz.y, xyz.z, w);\r\n  }\r\n  /** Return `point + vector * scalar` */\r\n  public plusScaled(vector: Point4d, scaleFactor: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + vector.xyzw[0] * scaleFactor, this.xyzw[1] + vector.xyzw[1] * scaleFactor, this.xyzw[2] + vector.xyzw[2] * scaleFactor, this.xyzw[3] + vector.xyzw[3] * scaleFactor, result);\r\n  }\r\n  /** Return interpolation between instance and pointB at fraction\r\n   */\r\n  public interpolate(fraction: number, pointB: Point4d, result?: Point4d): Point4d {\r\n    const v = 1.0 - fraction;\r\n    return Point4d.create(this.xyzw[0] * v + pointB.xyzw[0] * fraction, this.xyzw[1] * v + pointB.xyzw[1] * fraction, this.xyzw[2] * v + pointB.xyzw[2] * fraction, this.xyzw[3] * v + pointB.xyzw[3] * fraction, result);\r\n  }\r\n  /** Return `point + vectorA * scalarA + vectorB * scalarB` */\r\n  public plus2Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);\r\n  }\r\n  /** Return `point + vectorA * scalarA + vectorB * scalarB + vectorC * scalarC` */\r\n  public plus3Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, vectorC: Point4d, scalarC: number, result?: Point4d): Point4d {\r\n    return Point4d.create(this.xyzw[0] + vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, this.xyzw[1] + vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, this.xyzw[2] + vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, this.xyzw[3] + vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);\r\n  }\r\n  /** Return `point + vectorA * scalarA + vectorB * scalarB` */\r\n  public static createAdd2Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, result?: Point4d): Point4d {\r\n    return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB, result);\r\n  }\r\n  /** Return `point + vectorA \\ scalarA + vectorB * scalarB + vectorC * scalarC` */\r\n  public static createAdd3Scaled(vectorA: Point4d, scalarA: number, vectorB: Point4d, scalarB: number, vectorC: Point4d, scalarC: number, result?: Point4d): Point4d {\r\n    return Point4d.create(vectorA.xyzw[0] * scalarA + vectorB.xyzw[0] * scalarB + vectorC.xyzw[0] * scalarC, vectorA.xyzw[1] * scalarA + vectorB.xyzw[1] * scalarB + vectorC.xyzw[1] * scalarC, vectorA.xyzw[2] * scalarA + vectorB.xyzw[2] * scalarB + vectorC.xyzw[2] * scalarC, vectorA.xyzw[3] * scalarA + vectorB.xyzw[3] * scalarB + vectorC.xyzw[3] * scalarC, result);\r\n  }\r\n  /** Return dot product of (4d) vectors from the instance to targetA and targetB */\r\n  public dotVectorsToTargets(targetA: Point4d, targetB: Point4d): number {\r\n    return (targetA.xyzw[0] - this.xyzw[0]) * (targetB.xyzw[0] - this.xyzw[0]) +\r\n      (targetA.xyzw[1] - this.xyzw[1]) * (targetB.xyzw[1] - this.xyzw[1]) +\r\n      (targetA.xyzw[2] - this.xyzw[2]) * (targetB.xyzw[2] - this.xyzw[2]) +\r\n      (targetA.xyzw[3] - this.xyzw[3]) * (targetB.xyzw[3] - this.xyzw[3]);\r\n  }\r\n  /** return (4d) dot product of the instance and other point. */\r\n  public dotProduct(other: Point4d): number {\r\n    return this.xyzw[0] * other.xyzw[0] + this.xyzw[1] * other.xyzw[1] + this.xyzw[2] * other.xyzw[2] + this.xyzw[3] * other.xyzw[3];\r\n  }\r\n  /** return (4d) dot product of the instance with xyzw */\r\n  public dotProductXYZW(x: number, y: number, z: number, w: number): number {\r\n    return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z + this.xyzw[3] * w;\r\n  }\r\n  /** dotProduct with (point.x, point.y, point.z, 1) Used in PlaneAltitudeEvaluator interface */\r\n  public altitude(point: Point3d): number {\r\n    return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3];\r\n  }\r\n  /** dotProduct with (point.x, point.y, point.z, point.w) Used in PlaneAltitudeEvaluator interface */\r\n  public weightedAltitude(point: Point4d): number {\r\n    return this.xyzw[0] * point.x + this.xyzw[1] * point.y + this.xyzw[2] * point.z + this.xyzw[3] * point.w;\r\n  }\r\n  /** dotProduct with (vector.x, vector.y, vector.z, 0).  Used in PlaneAltitudeEvaluator interface */\r\n  public velocity(vector: Vector3d): number {\r\n    return this.xyzw[0] * vector.x + this.xyzw[1] * vector.y + this.xyzw[2] * vector.z;\r\n  }\r\n  /** dotProduct with (x,y,z, 0).  Used in PlaneAltitudeEvaluator interface */\r\n  public velocityXYZ(x: number, y: number, z: number): number {\r\n    return this.xyzw[0] * x + this.xyzw[1] * y + this.xyzw[2] * z;\r\n  }\r\n  /** unit X vector */\r\n  public static unitX(): Point4d { return new Point4d(1, 0, 0, 0); }\r\n  /** unit Y vector */\r\n  public static unitY(): Point4d { return new Point4d(0, 1, 0, 0); }\r\n  /** unit Z vector */\r\n  public static unitZ(): Point4d { return new Point4d(0, 0, 1, 0); }\r\n  /** unit W vector */\r\n  public static unitW(): Point4d { return new Point4d(0, 0, 0, 1); }\r\n  /** Divide by denominator, but return undefined if denominator is zero. */\r\n  public safeDivideOrNull(denominator: number, result?: Point4d): Point4d | undefined {\r\n    if (denominator !== 0.0) {\r\n      return this.scale(1.0 / denominator, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** scale all components (including w!!) */\r\n  public scale(scale: number, result?: Point4d): Point4d {\r\n    result = result ? result : new Point4d();\r\n    result.xyzw[0] = this.xyzw[0] * scale;\r\n    result.xyzw[1] = this.xyzw[1] * scale;\r\n    result.xyzw[2] = this.xyzw[2] * scale;\r\n    result.xyzw[3] = this.xyzw[3] * scale;\r\n    return result;\r\n  }\r\n  /** Negate components (including w!!) */\r\n  public negate(result?: Point4d): Point4d {\r\n    result = result ? result : new Point4d();\r\n    result.xyzw[0] = -this.xyzw[0];\r\n    result.xyzw[1] = -this.xyzw[1];\r\n    result.xyzw[2] = -this.xyzw[2];\r\n    result.xyzw[3] = -this.xyzw[3];\r\n    return result;\r\n  }\r\n  /**\r\n   * If `this.w` is nonzero, return a 4d point `(x/w,y/w,z/w, 1)`\r\n   * If `this.w` is zero, return undefined.\r\n   * @param result optional result\r\n   */\r\n  public normalizeWeight(result?: Point4d): Point4d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.xyzw[3]);\r\n    result = result ? result : new Point4d();\r\n    return this.safeDivideOrNull(mag, result);\r\n  }\r\n  /**\r\n   * If `this.w` is nonzero, return a 3d point `(x/w,y/w,z/w)`\r\n   * If `this.w` is zero, return undefined.\r\n   * @param result optional result\r\n   */\r\n  public realPoint(result?: Point3d): Point3d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.xyzw[3]);\r\n    if (mag === 0.0)\r\n      return undefined;\r\n    const a = 1.0 / mag; // in zero case everything multiplies right back to true zero.\r\n    return Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);\r\n  }\r\n  /**\r\n   * * If w is nonzero, return Point3d with x/w,y/w,z/w.\r\n   * * If w is zero, return 000\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   * @param w w coordinate\r\n   * @param result optional result\r\n   */\r\n  public static createRealPoint3dDefault000(x: number, y: number, z: number, w: number, result?: Point3d): Point3d {\r\n    const mag = Geometry.correctSmallMetricDistance(w);\r\n    const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\r\n    return Point3d.create(x * a, y * a, z * a, result);\r\n  }\r\n  /**\r\n   * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.\r\n   * * If w is zero, return 000\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   * @param w w coordinate\r\n   * @param dx x coordinate of derivative\r\n   * @param dy y coordinate of derivative\r\n   * @param dz z coordinate of derivative\r\n   * @param dw w coordinate of derivative\r\n   * @param result optional result\r\n   */\r\n  public static createRealDerivativeRay3dDefault000(x: number, y: number, z: number, w: number, dx: number, dy: number, dz: number, dw: number, result?: Ray3d): Ray3d {\r\n    const mag = Geometry.correctSmallMetricDistance(w);\r\n    // real point is X/w.\r\n    // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.\r\n    const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\r\n    const aa = a * a;\r\n    return Ray3d.createXYZUVW(x * a, y * a, z * a, (dx * w - dw * x) * aa, (dy * w - dw * y) * aa, (dz * w - dw * z) * aa, result);\r\n  }\r\n  /**\r\n   * * If w is nonzero, return Vector3d which is the derivative of the projected xyz with given w and 4d derivatives.\r\n   * * If w is zero, return 000\r\n   * @param x x coordinate\r\n   * @param y y coordinate\r\n   * @param z z coordinate\r\n   * @param w w coordinate\r\n   * @param dx x coordinate of derivative\r\n   * @param dy y coordinate of derivative\r\n   * @param dz z coordinate of derivative\r\n   * @param dw w coordinate of derivative\r\n   * @param result optional result\r\n   */\r\n  public static createRealDerivativePlane3dByOriginAndVectorsDefault000(x: number, y: number, z: number, w: number, dx: number, dy: number, dz: number, dw: number, ddx: number, ddy: number, ddz: number, ddw: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const mag = Geometry.correctSmallMetricDistance(w);\r\n    // real point is X/w.\r\n    // real derivative is (X' * w - X *w) / ww, and weight is always 0 by cross products.\r\n    const a = mag === 0 ? 0.0 : (1.0 / mag); // in zero case everything multiplies right back to true zero.\r\n    const aa = a * a;\r\n    const fx = x * a;\r\n    const fy = y * a;\r\n    const fz = z * a;\r\n    const dfx = (dx * w - dw * x) * aa;\r\n    const dfy = (dy * w - dw * y) * aa;\r\n    const dfz = (dz * w - dw * z) * aa;\r\n    return Plane3dByOriginAndVectors.createOriginAndVectorsXYZ(fx, fy, fz, dfx, dfy, dfz, quotientDerivative2(ddx, dw, ddw, fx, dfx, a), quotientDerivative2(ddy, dw, ddw, fy, dfy, a), quotientDerivative2(ddz, dw, ddw, fz, dfz, a), result);\r\n  }\r\n  /**\r\n   * * If this.w is nonzero, return Point3d with x/w,y/w,z/w.\r\n   * * If this.w is zero, return 000\r\n   */\r\n  public realPointDefault000(result?: Point3d): Point3d {\r\n    const mag = Geometry.correctSmallMetricDistance(this.xyzw[3]);\r\n    if (mag === 0.0)\r\n      return Point3d.create(0, 0, 0, result);\r\n    result = result ? result : new Point3d();\r\n    const a = 1.0 / mag;\r\n    return Point3d.create(this.xyzw[0] * a, this.xyzw[1] * a, this.xyzw[2] * a, result);\r\n  }\r\n  /** divide all components (x,y,z,w) by the 4d magnitude.\r\n   *\r\n   * * This is appropriate for normalizing a quaternion\r\n   * * Use normalizeWeight to divide by the w component.\r\n   */\r\n  public normalizeXYZW(result?: Point4d): Point4d | undefined {\r\n    const mag = Geometry.correctSmallMetricDistance(this.magnitudeXYZW());\r\n    result = result ? result : new Point4d();\r\n    return this.safeDivideOrNull(mag, result);\r\n  }\r\n\r\n  /**\r\n   * Return the determinant of the 3x3 matrix using components i,j,k of the 3 inputs.\r\n   */\r\n  public static determinantIndexed3X3(pointA: Point4d, pointB: Point4d, pointC: Point4d, i: number, j: number, k: number) {\r\n    return Geometry.tripleProduct(\r\n      pointA.xyzw[i], pointA.xyzw[j], pointA.xyzw[k],\r\n      pointB.xyzw[i], pointB.xyzw[j], pointB.xyzw[k],\r\n      pointC.xyzw[i], pointC.xyzw[j], pointC.xyzw[k]);\r\n  }\r\n  /**\r\n   * Return a Point4d perpendicular to all 3 inputs. (A higher level cross product concept)\r\n   * @param pointA first point\r\n   * @param pointB second point\r\n   * @param pointC third point\r\n   */\r\n  public static perpendicularPoint4dPlane(pointA: Point4d, pointB: Point4d, pointC: Point4d): Point4d {\r\n    return Point4d.create(\r\n      Point4d.determinantIndexed3X3(pointA, pointB, pointC, 1, 2, 3),\r\n      -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 2, 3, 0),\r\n      Point4d.determinantIndexed3X3(pointA, pointB, pointC, 3, 0, 1),\r\n      -Point4d.determinantIndexed3X3(pointA, pointB, pointC, 0, 1, 2));\r\n  }\r\n  /** Treating this Point4d as plane coefficients, convert to origin and normal form. */\r\n  public toPlane3dByOriginAndUnitNormal(result?: Plane3dByOriginAndUnitNormal): Plane3dByOriginAndUnitNormal | undefined {\r\n    const aa = this.magnitudeSquaredXYZ();\r\n    const direction = Vector3d.create(this.x, this.y, this.z);\r\n    const w = this.w;\r\n    const divW = Geometry.conditionalDivideFraction(1.0, w);\r\n    if (divW !== undefined) {\r\n      const b = -w / aa;\r\n      direction.scaleInPlace(1.0 / Math.sqrt(aa));\r\n      return Plane3dByOriginAndUnitNormal.create(Point3d.create(this.x * b, this.y * b, this.z * b), direction, result);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Normalize so sum of squares of all 4 coordinates is 1. */\r\n  public normalizeQuaternion() {\r\n    const magnitude = Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);\r\n\r\n    if (magnitude > 0.0) {\r\n      const f = 1.0 / magnitude;\r\n      this.x *= f;\r\n      this.y *= f;\r\n      this.z *= f;\r\n      this.w *= f;\r\n    }\r\n    return magnitude;\r\n  }\r\n  /** Return a (normalized) quaternion interpolated between two quaternions. */\r\n  public static interpolateQuaternions(quaternion0: Point4d, fractionParameter: number, quaternion1: Point4d, result?: Point4d): Point4d {\r\n    if (!result)\r\n      result = new Point4d();\r\n    const maxSafeCosine = 0.9995;\r\n\r\n    // return exact quats for special values\r\n    if (0.0 === fractionParameter) {\r\n      result = quaternion0;\r\n      return result;\r\n    }\r\n    if (1.0 === fractionParameter) {\r\n      result = quaternion1;\r\n      return result;\r\n    }\r\n    if (0.5 === fractionParameter) {\r\n      quaternion0.plus(quaternion1, result);\r\n      result.normalizeQuaternion();\r\n      return result;\r\n    }\r\n\r\n    const q0 = quaternion0.clone();\r\n    const q1 = quaternion1.clone();\r\n    let dot = quaternion0.dotProduct(quaternion1);\r\n\r\n    // prevent interpolation through the longer great arc\r\n    if (dot < 0.0) {\r\n      q1.negate(q1);\r\n      dot = -dot;\r\n    }\r\n\r\n    // if nearly parallel, use nlerp\r\n    if (dot > maxSafeCosine) {\r\n      q0.interpolate(fractionParameter, q1, result);\r\n      result.normalizeQuaternion();\r\n      return result;\r\n    }\r\n\r\n    // safety check\r\n    if (dot < -1.0)\r\n      dot = -1.0;\r\n    else if (dot > 1.0)\r\n      dot = 1.0;\r\n\r\n    // create orthonormal basis {q0, q2}\r\n    const q2 = new Point4d();\r\n    q1.plusScaled(q0, -dot, q2);  //  bsiDPoint4d_addScaledDPoint4d(& q2, & q1, & q0, -dot);\r\n    q2.normalizeQuaternion();\r\n\r\n    const angle = Math.acos(dot);\r\n    const angleOfInterpolant = angle * fractionParameter;\r\n    result = Point4d.createAdd2Scaled(q0, Math.cos(angleOfInterpolant), q2, Math.sin(angleOfInterpolant));\r\n    return result;\r\n  }\r\n  /** Measure the \"angle\" between two points, using all 4 components in the dot product that\r\n   * gives the cosine of the angle.\r\n   */\r\n  public radiansToPoint4dXYZW(other: Point4d): number | undefined {\r\n    const magA = this.magnitudeXYZW();\r\n    const magB = other.magnitudeXYZW();\r\n    const dot = this.dotProduct(other);  // == cos (theta) * magA * magB\r\n    const cos = Geometry.conditionalDivideFraction(dot, magA * magB);\r\n    if (cos === undefined)\r\n      return undefined;\r\n    return Math.acos(cos);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\n// import { Angle, AngleSweep, Geometry } from \"../Geometry\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { PascalCoefficients } from \"./PascalCoefficients\";\r\nimport { Degree2PowerPolynomial, Degree3PowerPolynomial, Degree4PowerPolynomial, AnalyticRoots } from \"./Polynomials\";\r\n/* tslint:disable:variable-name*/\r\n/**\r\n * * BezierCoffs is an abstract base class for one-dimensional (u to f(u)) Bezier polynomials.\r\n * * The base class carries a Float64Array with coefficients.\r\n * * The Float64Array is NOT Growable unless derived classes add logic to do so.  Its length is the Bezier polynomial order.\r\n * * The family of derived classes is starts with low order (at least linear through cubic) with highly optimized calculations.\r\n * * The general degree Bezier class also uses this as its base class.\r\n * * The length of the coefficient array is NOT always the bezier order.   Use the `order` property to access the order.\r\n * @internal\r\n */\r\nexport abstract class BezierCoffs {\r\n  /** Array of coefficients.\r\n   * * The number of coefficients is the order of the Bezier polynomial.\r\n   */\r\n  public coffs: Float64Array;\r\n  /**\r\n   * * If `data` is a number, an array of that size is created with zeros.\r\n   * * If `data` is a Float64Array, it is cloned (NOT CAPTURED)\r\n   * * If `data` is a number array, its values are copied.\r\n   */\r\n  constructor(data: number | Float64Array | number[]) {\r\n    if (data instanceof Float64Array) {\r\n      this.coffs = data.slice();\r\n    } else if (Array.isArray(data)) {\r\n      this.coffs = new Float64Array(data.length);\r\n      let i = 0;\r\n      for (const a of data) this.coffs[i++] = a;\r\n    } else {\r\n      this.coffs = new Float64Array(data);\r\n    }\r\n  }\r\n  /**\r\n   * * Ensure the coefficient array size matches order.  (Reallocate as needed)\r\n   * * fill with zeros.\r\n   * @param order required order\r\n   */\r\n  protected allocateToOrder(order: number) {\r\n    if (this.coffs.length !== order) {\r\n      this.coffs = new Float64Array(order);\r\n    } else {\r\n      this.coffs.fill(0);\r\n    }\r\n  }\r\n  /** evaluate the basis fucntions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param buffer optional destination for values.   ASSUMED large enough for order.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public abstract basisFunctions(u: number, result?: Float64Array): Float64Array;\r\n\r\n  /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public abstract sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;\r\n\r\n  /** evaluate the basis functions derivatives at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public abstract sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array;\r\n\r\n  /** Return a deep clone of this bezier. */\r\n  public abstract clone(): BezierCoffs;\r\n  /**\r\n   * create an object of same order with zero coefficients.\r\n   * The base implementation makes a generic Bezier of the same order.\r\n   */\r\n  public createPeer(): BezierCoffs {\r\n    const peer = new UnivariateBezier(this.order);\r\n    return peer;\r\n  }\r\n  /** Evaluate the polynomial at u.\r\n   * @param u bezier parameter for evaluation.\r\n   */\r\n  public abstract evaluate(u: number): number;\r\n  /** The order (number of coefficients) as a readable property  */\r\n  public get order(): number { return this.coffs.length; }\r\n  /** Copy coefficients from other Bezier. Note that the coefficient count (order) of \"this\" can change. */\r\n  public copyFrom(other: BezierCoffs): void {\r\n    if (this.order === other.order)\r\n      for (let i = 0; i < this.coffs.length; i++) { this.coffs[i] = other.coffs[i]; }\r\n    else this.coffs = other.coffs.slice();\r\n  }\r\n  /**\r\n   * Apply a scale factor to all coefficients.\r\n   * @param scale scale factor to apply to all coefficients.\r\n   */\r\n  public scaleInPlace(scale: number): void {\r\n    for (let i = 0; i < this.coffs.length; i++)\r\n      this.coffs[i] *= scale;\r\n  }\r\n  /** add a constant to each coefficient.\r\n   * @param a constant to add.\r\n   */\r\n  public addInPlace(a: number): void {\r\n    for (let i = 0; i < this.coffs.length; i++)\r\n      this.coffs[i] += a;\r\n  }\r\n  /** Compute parameter values where the bezier value matches _targetValue.\r\n   * * The base class finds roots only in 01.  (i.e. ignores _restrictTo01)\r\n   * * Order-specific implementations apply special case  analytic logic, e.g. for degree 1,2,3,4.\r\n   */\r\n  public roots(targetValue: number, _restrictTo01: boolean): number[] | undefined {\r\n    const bezier = UnivariateBezier.create(this);\r\n    bezier.addInPlace(- targetValue);\r\n    return UnivariateBezier.deflateRoots01(bezier);\r\n  }\r\n  /** Given an array of numbers, optionally remove those not in the 0..1 interval.\r\n   * @param roots candidate values\r\n   * @param restrictTo01 If false, no filtering occurs and the pointer to the original array is unchanged.\r\n   *     If true, filtering is done and values are returned, possibly in a new array and possibly in the original.\r\n   */\r\n  public filter01(roots: number[] | undefined, restrictTo01 = false): number[] | undefined {\r\n    if (!roots || !restrictTo01)\r\n      return roots;\r\n    let anyFound = false;\r\n    for (const r of roots) {\r\n      if (Geometry.isIn01(r)) { anyFound = true; break; }\r\n    }\r\n    if (anyFound) {\r\n      const roots01: number[] = [];\r\n      for (const r of roots) { if (Geometry.isIn01(r)) roots01.push(r); }\r\n      return roots01;\r\n    }\r\n    return undefined;\r\n  }\r\n  /** zero out all coefficients. */\r\n  public zero(): void { this.coffs.fill(0); }\r\n  /** Subdivide -- write results into caller-supplied bezier coffs (which must be of the same order) */\r\n  public subdivide(u: number, left: BezierCoffs, right: BezierCoffs): boolean {\r\n    const order = this.order;\r\n    if (left.order !== order && right.order !== order)\r\n      return false;\r\n    const v = 1.0 - u;\r\n    right.copyFrom(this);\r\n    // each left will be filled in directly, so there is no need to initialize it.\r\n    let n1 = order - 1; // number of interpolations in inner loop.\r\n    for (let i0 = 0; i0 < order; i0++) {\r\n      left.coffs[i0] = right.coffs[0];\r\n      for (let i = 0; i < n1; i++)\r\n        right.coffs[i] = v * right.coffs[i] + u * right.coffs[i + 1];\r\n      n1--;\r\n    }\r\n    return true;\r\n  }\r\n  /** Return the maximum absolute difference between coefficients of two sets of BezierCoffs */\r\n  public static maxAbsDiff(dataA: BezierCoffs, dataB: BezierCoffs): number | undefined {\r\n    const order = dataA.order;\r\n    if (dataB.order !== order)\r\n      return undefined;\r\n    let d = 0.0;\r\n    let d1;\r\n    for (let i = 0; i < order; i++) {\r\n      d1 = Math.abs(dataA.coffs[i] - dataB.coffs[i]);\r\n      if (d1 > d)\r\n        d = d1;\r\n    }\r\n    return d;\r\n  }\r\n}\r\n/**\r\n * Static methods to operate on univariate beizer polynomials, with coefficients in simple Float64Array or as components of blocked arrays.\r\n * @internal\r\n */\r\nexport class BezierPolynomialAlgebra {\r\n  /**\r\n   * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.\r\n   * * Symbolically:   `product(s) += scale * (constA - polynomialA(s)) *polynomialB(s)`\r\n   * * Where coefficients of polynomialA(s) are in column indexA and coefficients of polynominalB(s) are differences within column indexB.\r\n   * * Treating data as 2-dimensional array:   `product = sum (iA) sum (iB)    (constA - basisFunction[iA} data[indexA][iA]) * basisFunction[iB] * (dataOrder-1)(data[iB + 1][indexB] - data[iB][indexB])`\r\n   * * Take no action if product length is other than `dataOrder + dataOrder - 2`\r\n   */\r\n  public static accumulateScaledShiftedComponentTimesComponentDelta(\r\n    product: Float64Array,\r\n    data: Float64Array,\r\n    dataBlockSize: number,\r\n    dataOrder: number,\r\n    scale: number,\r\n    indexA: number,\r\n    constA: number,\r\n    indexB: number) {\r\n    const orderB = dataOrder - 1;  // coefficients of the first difference are implicitly present as differences of adjacent entries.\r\n    const orderA = dataOrder;\r\n    const orderC = dataOrder + orderB - 1;\r\n    if (product.length !== orderC) return;\r\n    const coffA = PascalCoefficients.getRow(orderA - 1);\r\n    const coffB = PascalCoefficients.getRow(orderB - 1);\r\n    const coffC = PascalCoefficients.getRow(orderC - 1);\r\n    let qA;\r\n    for (let a = 0; a < orderA; a++) {\r\n      qA = scale * (constA + data[indexA + a * dataBlockSize]) * coffA[a];\r\n      for (let b = 0, k = indexB; b < orderB; b++ , k += dataBlockSize) {\r\n        product[a + b] += qA * coffB[b] * (data[k + dataBlockSize] - data[k]) / coffC[a + b];\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * * Univariate bezierA has its coefficients at offset indexA in each block within the array of blocks.\r\n   * * Univariate bezierB has its coefficients at offset indexB in each block within the array of blocks.\r\n   * * return the sum coefficients for `constA * polynominalA + constB * polynomialB`\r\n   * * Symbolically:   `product(s) = (constA * polynomialA(s) + constB * polynominalB(s)`\r\n   * * The two polyomials are the same order, so this just direct sum of scaled coefficients.\r\n   *\r\n   * * Take no action if product length is other than `dataOrder + dataOrder - 2`\r\n   */\r\n  public static scaledComponentSum(sum: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, indexA: number, constA: number, indexB: number, constB: number) {\r\n    const orderA = dataOrder;\r\n    if (sum.length !== orderA) return;\r\n    for (let a = 0, rowBase = 0; a < orderA; a++ , rowBase += dataBlockSize) {\r\n      sum[a] = constA * data[rowBase + indexA] + constB * data[rowBase + indexB];\r\n    }\r\n  }\r\n  /**\r\n   * * Univariate bezier has its coefficients at offset index in each block within the array of blocks.\r\n   * * return the (dataOrder - 1) differences,\r\n   *\r\n   * * Take no action if difference length is other than `dataOrder - 1`\r\n   */\r\n  public static componentDifference(difference: Float64Array, data: Float64Array, dataBlockSize: number, dataOrder: number, index: number) {\r\n    const orderA = dataOrder;\r\n    const orderDiff = orderA - 1;\r\n    if (difference.length !== orderDiff) return;\r\n    for (let i = 0, k = index; i < orderDiff; k += dataBlockSize, i++)\r\n      difference[i] = data[k + dataBlockSize] - data[k];\r\n  }\r\n\r\n  /**\r\n   * * Univariate bezierA has its coefficients in dataA[i]\r\n   * * Univariate bezierB has its coefficients in dataB[i]\r\n   * * return the product coefficients for polynominalA(s) * polynomialB(s) * scale\r\n   * * Take no action if product length is other than `orderA + orderB - 1`\r\n   */\r\n  public static accumulateProduct(product: Float64Array, dataA: Float64Array, dataB: Float64Array, scale: number = 1.0) {\r\n    const orderA = dataA.length;\r\n    const orderB = dataB.length;\r\n    const orderC = orderA + orderB - 1;\r\n    if (product.length !== orderC) return;\r\n    let a: number;\r\n    let b: number;\r\n    let qA: number;\r\n    const coffA = PascalCoefficients.getRow(orderA - 1);\r\n    const coffB = PascalCoefficients.getRow(orderB - 1);\r\n    const coffC = PascalCoefficients.getRow(orderC - 1);\r\n    for (a = 0; a < orderA; a++) {\r\n      qA = scale * coffA[a] * dataA[a];\r\n      for (b = 0; b < orderB; b++) {\r\n        product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * Univariate bezierA has its coefficients in dataA[i]\r\n   * * Univariate bezierB has its coefficients in dataB[i]\r\n   * * return the product coefficients for polynominalADifferencs(s) * polynomialB(s) * scale\r\n   * * Take no action if product length is other than `orderA + orderB - 2`\r\n   */\r\n  public static accumulateProductWithDifferences(product: Float64Array, dataA: Float64Array, dataB: Float64Array, scale: number = 1.0) {\r\n    const orderA = dataA.length - 1;  // We deal with its differences, which are lower order !!!\r\n    const orderB = dataB.length;\r\n    const orderC = orderA + orderB - 1;\r\n    if (product.length !== orderC) return;\r\n    let a: number;\r\n    let b: number;\r\n    let qA: number;\r\n    const coffA = PascalCoefficients.getRow(orderA - 1);\r\n    const coffB = PascalCoefficients.getRow(orderB - 1);\r\n    const coffC = PascalCoefficients.getRow(orderC - 1);\r\n    for (a = 0; a < orderA; a++) {\r\n      qA = scale * coffA[a] * (dataA[a + 1] - dataA[a]);\r\n      for (b = 0; b < orderB; b++) {\r\n        product[a + b] += qA * coffB[b] * dataB[b] / coffC[a + b];\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * * Univariate bezier has its coefficients in data[i]\r\n   * * return the diference data[i+1]-data[i] in difference.\r\n   * * Take no action if product length is other than `orderA + orderB - 1`\r\n   */\r\n  public static univariateDifference(data: Float64Array, difference: Float64Array) {\r\n    const differenceOrder = difference.length;\r\n    if (difference.length + 1 !== differenceOrder)\r\n      for (let i = 0; i < differenceOrder; i++) {\r\n        difference[i] = data[i + 1] - data[i];\r\n      }\r\n  }\r\n  /**\r\n   * * Univariate bezierA has its coefficients in dataA[i]\r\n   * * Univariate bezierB has its coefficients in resultB[i]\r\n   * * add (with no scaling) bezierA to bezierB\r\n   * * Take no action if resultB.length is other than dataA.length.\r\n   */\r\n  public static accumulate(dataA: Float64Array, orderA: number, resultB: Float64Array) {\r\n    if (resultB.length !== orderA) return;\r\n    for (let i = 0; i < orderA; i++) {\r\n      resultB[i] += dataA[i];\r\n    }\r\n  }\r\n\r\n}\r\n/**\r\n * * The UnivariateBezier class is a univariate bezier polynomial with no particular order.\r\n * * More specific classes -- Order2Bezier, Order3Bezier, Order4Bezier -- can be used when a fixed order is known and the more specialized implementations are appropriate.\r\n * * When working with xy and xyz curves whose order is the common 2,3,4, various queries (e.g. project point to curve)\r\n *     generate higher order one-dimensional bezier polynomials with order that is a small multiple of the\r\n *     curve order.   Hence those polynomials commonly reach degree 8 to 12.\r\n * * Higher order bezier polynomials are possible, but performance and accuracy issues become significant.\r\n * * Some machine-level constraints apply for curves of extrmely high order, e.g. 70.   For instance, at that level use of\r\n *     Pascal triangle coefficients becomes inaccurate because IEEE doubles cannot represent integers that\r\n *     large.\r\n * @internal\r\n */\r\nexport class UnivariateBezier extends BezierCoffs {\r\n  private _order: number;\r\n  /** Query the order of this bezier. */\r\n  public get order() { return this._order; }\r\n  public constructor(data: number | Float64Array | number[]) {\r\n    super(data);\r\n    this._order = super.order;\r\n  }\r\n\r\n  /** (Re) initialize with given order (and all coffs zero) */\r\n  public allocateOrder(order: number) {\r\n    if (this._order !== order) {\r\n      super.allocateToOrder(order);\r\n      this._order = order;\r\n    }\r\n  }\r\n  /** Return a copy, optionally with coffs array length reduced to actual order. */\r\n  public clone(compressToMinimalAllocation: boolean = false): UnivariateBezier {\r\n    if (compressToMinimalAllocation) {\r\n      const result1 = new UnivariateBezier(this.order);\r\n      result1.coffs = this.coffs.slice(0, this.order);\r\n      return result1;\r\n    }\r\n    const result = new UnivariateBezier(this.coffs.length);\r\n    result._order = this._order;\r\n    result.coffs = this.coffs.slice();\r\n    return result;\r\n  }\r\n  /** Create a new bezier which is a copy of other.\r\n   * * Note that `other` may be a more specialized class such as `Order2Bezier`, but the result is general `Bezier`\r\n   * @param other coefficients to copy.\r\n   */\r\n  public static create(other: BezierCoffs): UnivariateBezier {\r\n    const result = new UnivariateBezier(other.order);\r\n    result.coffs = other.coffs.slice();\r\n    return result;\r\n  }\r\n  /**\r\n   * copy coefficients into a new bezier.\r\n   * @param coffs coefficients for bezier\r\n   */\r\n  public static createCoffs(data: number | number[] | Float64Array): UnivariateBezier {\r\n    return new UnivariateBezier(data);\r\n  }\r\n  /**\r\n   * copy coefficients into a new bezier.\r\n   * * if result is omitted, a new UnivariateBezier is allocated and returned.\r\n   * * if result is present but has other order, its coefficients are reallocated\r\n   * * if result is present and has matching order, the values are replace.\r\n   * @param coffs coefficients for bezier\r\n   * @param index0 first index to access\r\n   * @param order number of coefficients, i.e. order for the result\r\n   * @param result optional result.\r\n   *\r\n   */\r\n  public static createArraySubset(coffs: number[] | Float64Array, index0: number, order: number, result?: UnivariateBezier): UnivariateBezier {\r\n    if (!result)\r\n      result = new UnivariateBezier(order);\r\n    else if (result.order !== order)\r\n      result.allocateToOrder(order);\r\n    for (let i = 0; i < order; i++)result.coffs[i] = coffs[index0 + i];\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a product of 2 bezier polynomials.\r\n   * @param bezierA\r\n   * @param bezierB\r\n   */\r\n  public static createProduct(bezierA: BezierCoffs, bezierB: BezierCoffs): UnivariateBezier {\r\n    const result = new UnivariateBezier(bezierA.order + bezierB.order - 1);\r\n    const pascalA = PascalCoefficients.getRow(bezierA.order - 1);\r\n    const pascalB = PascalCoefficients.getRow(bezierB.order - 1);\r\n    const pascalC = PascalCoefficients.getRow(bezierA.order + bezierB.order - 2);\r\n    for (let iA = 0; iA < bezierA.order; iA++) {\r\n      const a = bezierA.coffs[iA] * pascalA[iA];\r\n      for (let iB = 0; iB < bezierB.order; iB++) {\r\n        const b = bezierB.coffs[iB] * pascalB[iB];\r\n        const iC = iA + iB;\r\n        const c = pascalC[iC];\r\n        result.coffs[iC] += a * b / c;\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Add a sqaured bezier polynomial (given as simple coffs)\r\n   * @param coffA coefficients of bezier to square\r\n   * @param scale scale factor\r\n   * @return false if order mismatch -- must have `2 * bezierA.length  === this.order + 1`\r\n   */\r\n  public addSquaredSquaredBezier(coffA: Float64Array, scale: number): boolean {\r\n    const orderA = coffA.length;\r\n    const orderC = this.order;\r\n    if (orderA * 2 !== orderC + 1) return false;\r\n    const pascalA = PascalCoefficients.getRow(orderA - 1);\r\n    const pascalC = PascalCoefficients.getRow(orderC - 1);\r\n    const coffC = this.coffs;\r\n    for (let iA = 0; iA < orderA; iA++) {\r\n      const a = coffA[iA] * pascalA[iA] * scale;\r\n      for (let iB = 0; iB < orderA; iB++) {\r\n        const b = coffA[iB] * pascalA[iB];\r\n        const iC = iA + iB;\r\n        const c = pascalC[iC];\r\n        coffC[iC] += a * b / c;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  private _basisValues?: Float64Array;\r\n  /** evaluate the basis fucntions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\r\n    if (!result || result.length !== this.order) result = new Float64Array(this.order);\r\n    let i = 0;\r\n    for (const a of this._basisValues) result[i++] = a;\r\n    return result;\r\n  }\r\n  /**\r\n   * Sum weights[i] * data[...] in blocks of numPerBlock.\r\n   * This is for low level use -- counts are not checked.\r\n   * @param weights\r\n   * @param data\r\n   * @param numPerBlock\r\n   */\r\n  private static sumWeightedBlocks(weights: Float64Array, numWeights: number, data: Float64Array, numPerBlock: number, result: Float64Array) {\r\n    for (let k0 = 0; k0 < numPerBlock; k0++) {\r\n      result[k0] = 0;\r\n    }\r\n    let k = 0;\r\n    let i;\r\n    for (let iWeight = 0; iWeight < numWeights; iWeight++) {\r\n      const w = weights[iWeight];\r\n      for (i = 0; i < numPerBlock; i++) {\r\n        result[i] += w * data[k++];\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Given (multidimensional) control points, sum the control points weighted by the basis fucntion values at parameter u.\r\n   * @param u bezier parameter\r\n   * @param polygon Array with coefficients in blocks.\r\n   * @param blockSize size of blocks\r\n   * @param result `blockSize` summed values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, blockSize: number, result?: Float64Array): Float64Array {\r\n    const order = this._order;\r\n    if (!result) result = new Float64Array(order);\r\n    this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\r\n    UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Given (multidimensional) control points, sum the control points weighted by the basis function derivative values at parameter u.\r\n   * @param u bezier parameter\r\n   * @param polygon Array with coefficients in blocks.\r\n   * @param blockSize size of blocks\r\n   * @param result `blockSize` summed values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, blockSize: number, result?: Float64Array): Float64Array {\r\n    const order = this._order;\r\n    if (!result) result = new Float64Array(blockSize);\r\n    this._basisValues = PascalCoefficients.getBezierBasisDerivatives(this.order, u, this._basisValues);\r\n    UnivariateBezier.sumWeightedBlocks(this._basisValues, order, polygon, blockSize, result);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    this._basisValues = PascalCoefficients.getBezierBasisValues(this.order, u, this._basisValues);\r\n    let sum = 0;\r\n    for (let i = 0; i < this.order; i++)\r\n      sum += this._basisValues[i] * this.coffs[i];\r\n    return sum;\r\n  }\r\n  /**\r\n   * Apply deflation from the left to a bezier.\r\n   * * This assumes that the left coefficient is zero.\r\n   */\r\n  public deflateLeft() {\r\n    // coefficient 0 is zero (caller promises.)\r\n    // get bezier coffs for both orders ...\r\n    const order1 = this.order;\r\n    const order0 = order1 - 1;\r\n    const coff0 = PascalCoefficients.getRow(order0 - 1);\r\n    const coff1 = PascalCoefficients.getRow(order1 - 1);\r\n    let a;\r\n    for (let i = 0; i < order0; i++) {\r\n      a = this.coffs[i + 1];\r\n      this.coffs[i] = a * coff1[i + 1] / coff0[i];\r\n    }\r\n    this._order--;\r\n  }\r\n\r\n  /**\r\n   * Apply deflation from the right to a frame.\r\n   * * This assumes that the right coefficient is zero.\r\n   * @param frame frame description\r\n   */\r\n  public deflateRight() {\r\n    // final coefficient is zero (caller promises.)\r\n    // get bezier coffs for both orders ...\r\n    const order1 = this.order;\r\n    const order0 = order1 - 1;\r\n    const coff0 = PascalCoefficients.getRow(order0 - 1);\r\n    const coff1 = PascalCoefficients.getRow(order1 - 1);\r\n    let a, b;\r\n    for (let i = 0; i < order0; i++) {\r\n      a = this.coffs[i];\r\n      b = a * coff1[i] / coff0[i];\r\n      this.coffs[i] = b;\r\n    }\r\n    this._order--;\r\n  }\r\n  /**\r\n   * divide the polynomial by `(x-root)`.\r\n   * * If `root` is truly a root.\r\n   * @param root root to remove\r\n   */\r\n  public deflateRoot(root: number): number {\r\n    const orderA = this.order;\r\n    const orderC = orderA - 1;  // the order of the deflated bezier.\r\n    if (orderA === 1) {\r\n      this._order = 0;\r\n      return this.coffs[0];\r\n    }\r\n    if (orderA < 1) {\r\n      this._order = 0;\r\n      return 0.0;\r\n    }\r\n    const pascalA = PascalCoefficients.getRow(orderA - 1);\r\n    const pascalC = PascalCoefficients.getRow(orderC - 1);\r\n    const b0 = -root;\r\n    const b1 = 1.0 - root;\r\n    let remainder = 0;\r\n    if (root > 0.5) {\r\n      let c0 = this.coffs[0] / b0;\r\n      let c1;\r\n      this.coffs[0] = c0;\r\n      let a1 = this.coffs[1];\r\n      for (let i = 1; i < orderC; i++) {\r\n        a1 = this.coffs[i] * pascalA[i];\r\n        c1 = (a1 - c0 * b1) / b0;\r\n        this.coffs[i] = c1 / pascalC[i];\r\n        c0 = c1;\r\n      }\r\n      remainder = this.coffs[orderA - 1] - c0 * b1;\r\n    } else {\r\n      // work backwards (to get division by larger of b0, b1)\r\n      // replace coefficients of a starting wtih orderA -1 --\r\n      // at end move them all forward.\r\n      let c1 = this.coffs[orderA - 1] / b1;\r\n      let c0;\r\n      this.coffs[orderA - 1] = c1;\r\n      let a1;\r\n      for (let i = orderA - 2; i > 0; i--) {\r\n        a1 = this.coffs[i] * pascalA[i];\r\n        c0 = (a1 - c1 * b0) / b1;\r\n        this.coffs[i] = c0 / pascalC[i - 1];  // pascalC index is from destination, which is not shifted.\r\n        c1 = c0;\r\n      }\r\n      remainder = (this.coffs[0] - c1 * b0);\r\n      for (let i = 0; i < orderC; i++)\r\n        this.coffs[i] = this.coffs[i + 1];\r\n    }\r\n    this._order = orderC;\r\n    // This should be zero !!!! (If not, `root` was not really a root!!)\r\n    return remainder;\r\n  }\r\n  private static _basisBuffer?: Float64Array;\r\n  private static _basisBuffer1?: Float64Array;\r\n  /**\r\n   * Run a Newton iteration from startFraction.\r\n   * @param startFraction [in] fraction for first iteration\r\n   * @param tolerance [in] convergence tolerance.   The iteration is considered converged on the\r\n   * second time the tolerance is satisfied.   For a typical iteration (not double root), the extra pass\r\n   * will double the number of digits.  Hence this tolerance is normally set to 10 to 12 digits, trusting\r\n   * that the final iteration will clean it up to nearly machine precision.\r\n   * @returns final fraction of iteration if converged.  undefined if iteration failed to converge.\r\n   */\r\n  public runNewton(startFraction: number, tolerance: number = 1.0e-11): number | undefined {\r\n    const derivativeFactor = this.order - 1;\r\n    let numConverged = 0;\r\n    let u = startFraction;\r\n    let f, df;\r\n    const bigStep = 10.0;\r\n    const order = this.order;\r\n    const coffs = this.coffs;\r\n    const orderD = order - 1;\r\n    for (let iterations = 0; iterations++ < 10;) {\r\n      UnivariateBezier._basisBuffer = PascalCoefficients.getBezierBasisValues(order, u, UnivariateBezier._basisBuffer);\r\n      f = 0; for (let i = 0; i < order; i++) f += coffs[i] * UnivariateBezier._basisBuffer[i];\r\n      UnivariateBezier._basisBuffer1 = PascalCoefficients.getBezierBasisValues(orderD, u, UnivariateBezier._basisBuffer1);\r\n      df = 0; for (let i = 0; i < orderD; i++) df += (coffs[i + 1] - coffs[i]) * UnivariateBezier._basisBuffer1[i];\r\n      df *= derivativeFactor;\r\n      if (Math.abs(f) > bigStep * Math.abs(df))\r\n        return undefined;\r\n      const du = f / df;\r\n      if (Math.abs(du) < tolerance) {\r\n        numConverged++;\r\n        if (numConverged >= 2)\r\n          return u - du;\r\n      } else {\r\n        numConverged = 0;\r\n      }\r\n      u -= du;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // Deflation table.  b0, b1 are coefficients of term being divided out\r\n  // Pascal coffs for b0,b1 are just 1.\r\n  // Each ai is a coefficient of the (known) input, with its Pascal coefficient blended in.\r\n  // each ci is a coefficient of the (unknown) result, with its coefficient blended in.\r\n  // note b0, b1 are both nonzero, so the divisions are safe.\r\n  // within the products, each c[i]*b0 pairs with c[i-1]*b1 (above and right diagonally) to make a[i]\r\n  // first and last c0*b0 and c[orderC-1]*b1 make a0 and a[orderA-1]\r\n  // |    |  b0    | b1      |   equivalence               | solve moving down\r\n  // | c0 | c0* b0 | c0 * b1 |    a0 = c0 * b0             | c0 = a0 / b0\r\n  // | c1 | c1* b0 | c1 * b1 |    a1 = c1 * b0 + c0 * b1   | c1 = (a1 - c0 * b1) / b0\r\n  // | c2 | c2* b0 | c2 * b1\r\n  // Each internal ci = (ai - c[i-1] * b1) /b0\r\n  // first c0*b0 = a0\r\n  // last c[orderC-1]*b1 = a[orderA-1]\r\n  /** Find roots of a bezier polynomial\r\n   * * Only look for roots in 0..1\r\n   * * As roots are found, deflate the polynomial.\r\n   * * bezier coffs are changed (and order reduced) at each step.\r\n   */\r\n  public static deflateRoots01(bezier: UnivariateBezier): number[] | undefined {\r\n    const roots = [];\r\n    const coffs = bezier.coffs;\r\n    let a0, a1, segmentFraction, globalStartFraction, newtonFraction;\r\n    while (bezier.order > 1) {\r\n      const order = bezier.order;\r\n      // Find any crossing\r\n      if (coffs[0] === 0.0) {\r\n        bezier.deflateLeft();\r\n        roots.push(0.0);\r\n        continue;\r\n      }\r\n      let numCrossing = 0;\r\n      let numNewtonOK = 0;\r\n      for (let i = 1; i < order; i++) {\r\n        a0 = coffs[i - 1];\r\n        a1 = coffs[i];\r\n        if (a0 * a1 <= 0.0) {\r\n          numCrossing++;\r\n          segmentFraction = -a0 / (a1 - a0);\r\n          globalStartFraction = (i - 1 + segmentFraction) / (order - 1);\r\n          newtonFraction = bezier.runNewton(globalStartFraction, 1.0e-10);\r\n          if (newtonFraction !== undefined) {\r\n            roots.push(newtonFraction);\r\n            bezier.deflateRoot(newtonFraction);\r\n            numNewtonOK++;\r\n            break;\r\n          }\r\n        }\r\n      }\r\n      if (numNewtonOK)\r\n        continue;\r\n      // if any crossing was found and led to a good newton, the \"continue\" jumped past this.\r\n      // if no crossings found, there are no roots to be had -- accept\r\n      if (numCrossing === 0)\r\n        return roots;\r\n      // reach here if there were crossings but not roots.\r\n      // is this just a local min?  or maybe a big problem?   Whatever, accept it\r\n      return roots;\r\n    }\r\n    return roots;\r\n  }\r\n}\r\n/** Bezier polynomial specialized to order 2 (2 coefficients, straight line function)\\\r\n * @internal\r\n */\r\nexport class Order2Bezier extends BezierCoffs {\r\n  constructor(f0: number = 0.0, f1: number = 0.0) {\r\n    super(2);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n  }\r\n  /** return an Order2Bezier (linear) with the two coefficients from this Order2Bezier */\r\n  public clone(): Order2Bezier {\r\n    return new Order2Bezier(this.coffs[0], this.coffs[1]);\r\n  }\r\n\r\n  /** normally, return fractional coordinate where bezier (a0,a1) has a root.\r\n   * but if the fraction would exceed Geometry.largeFractionResult, return undefined.\r\n   */\r\n  public static solveCoffs(a0: number, a1: number): number | undefined {\r\n    return Geometry.conditionalDivideFraction(-a0, (a1 - a0));\r\n  }\r\n  /** evaluate the basis fucntions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(2);\r\n    result[0] = 1.0 - u;\r\n    result[1] = u;\r\n    return result;\r\n  }\r\n  /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1.0 - u;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = v * polygon[i] + u * polygon[i + n];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(_u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = polygon[i + n] - polygon[i];\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    return (1.0 - u) * this.coffs[0] + u * this.coffs[1];\r\n  }\r\n  /** Same as `roots` method but returns single numeric value instead of array. */\r\n  public solve(rightHandSide: number): number | undefined {\r\n    const df = this.coffs[1] - this.coffs[0];\r\n    return Geometry.conditionalDivideFraction(rightHandSide - this.coffs[0], df);\r\n  }\r\n  /**\r\n   * Concrete implementation of the abstract roots method\r\n   * @param targetValue target function value.\r\n   * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.\r\n   * @returns If no roots, return undefined.  If single root, return an array with the root.\r\n   */\r\n  public roots(targetValue: number, restrictTo01: boolean): number[] | undefined {\r\n    const x = this.solve(targetValue);\r\n    if (x === undefined)\r\n      return undefined;\r\n    if (!restrictTo01 || Geometry.isIn01(x))\r\n      return [x];\r\n    return undefined;\r\n  }\r\n}\r\n\r\n/** Bezier polynomial specialized to order 3 (3 coefficients, paraboloa  function)\r\n * @internal\r\n */\r\nexport class Order3Bezier extends BezierCoffs {\r\n  public constructor(f0: number = 0, f1: number = 0, f2: number = 0) {\r\n    super(3);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n    this.coffs[2] = f2;\r\n  }\r\n  /** Return a deep copy. */\r\n  public clone(): Order3Bezier {\r\n    return new Order3Bezier(this.coffs[0], this.coffs[1], this.coffs[2]);\r\n  }\r\n\r\n  /** evaluate the basis fucntions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(3);\r\n    const v = 1.0 - u;\r\n    result[0] = v * v;\r\n    result[1] = 2.0 * u * v;\r\n    result[2] = u * u;\r\n    return result;\r\n  }\r\n  /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    const b0 = v * v;\r\n    const b1 = 2 * u * v;\r\n    const b2 = u * u;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n];\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const f0 = 2 * (1 - u);\r\n    const f1 = 2 * u;\r\n    const n2 = 2 * n;\r\n    for (let i = 0; i < n; i++) {\r\n      const q = polygon[i + n];\r\n      result[i] = f0 * (q - polygon[i]) + f1 * (polygon[i + n2] - q);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Add the square of a linear bezier.\r\n   * @param f0 linear factor value at u=0.\r\n   * @param f1 linear factor value at u=1.\r\n   * @param a  scale factor.\r\n   */\r\n  public addSquareLinear(f0: number, f1: number, a: number) {\r\n    this.coffs[0] += a * f0 * f0;\r\n    this.coffs[1] += a * f0 * f1;\r\n    this.coffs[2] += a * f1 * f1;\r\n  }\r\n  /**\r\n   * Concrete implementation of the abstract roots method\r\n   * @param targetValue target function value.\r\n   * @param restrictTo01 flag for optional second step to eliminate root outside 0..1.\r\n   * @returns If no roots, return undefined.  If roots exist, return as numeric array.\r\n   */\r\n  public roots(targetValue: number, restrictTo01: boolean): number[] | undefined {\r\n    const a0 = this.coffs[0] - targetValue;\r\n    const a1 = this.coffs[1] - targetValue;\r\n    const a2 = this.coffs[2] - targetValue;\r\n    const a01 = a1 - a0;\r\n    const a12 = a2 - a1;\r\n    const a012 = a12 - a01;\r\n    const roots = Degree2PowerPolynomial.solveQuadratic(a012, 2.0 * a01, a0);\r\n    return super.filter01(roots, restrictTo01);\r\n  }\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    const v = 1.0 - u;\r\n    return this.coffs[0] * v * v + u * (2.0 * this.coffs[1] * v + this.coffs[2] * u);\r\n  }\r\n}\r\n\r\n/** Bezier polynomial specialized to order 4 (4 coefficients, cubic  function)\r\n * @internal\r\n */\r\nexport class Order4Bezier extends BezierCoffs {\r\n  public constructor(f0: number = 0, f1: number = 0, f2: number = 0, f3: number = 0) {\r\n    super(4);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n    this.coffs[2] = f2;\r\n    this.coffs[3] = f3;\r\n  }\r\n  /** return a deep copy */\r\n  public clone(): Order4Bezier {\r\n    return new Order4Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3]);\r\n  }\r\n  /** Create a product of a quadratic and a cubic. */\r\n  public static createProductOrder3Order2(factorA: Order3Bezier, factorB: Order2Bezier): Order4Bezier {\r\n    return new Order4Bezier(\r\n      factorA.coffs[0] * factorB.coffs[0],\r\n      (factorA.coffs[0] * factorB.coffs[1] + 2.0 * factorA.coffs[1] * factorB.coffs[0]) / 3.0,\r\n      (2.0 * factorA.coffs[1] * factorB.coffs[1] + factorA.coffs[2] * factorB.coffs[0]) / 3.0,\r\n      factorA.coffs[2] * factorB.coffs[1]);\r\n  }\r\n  /** evaluate the basis fucntions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(4);\r\n    const v = 1.0 - u;\r\n    const uu = u * u;\r\n    const vv = v * v;\r\n    result[0] = vv * v;\r\n    result[1] = 3.0 * vv * u;\r\n    result[2] = 3.0 * v * uu;\r\n    result[3] = u * uu;\r\n    return result;\r\n  }\r\n  /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    const uu = u * u;\r\n    const vv = v * v;\r\n    const b0 = v * vv;\r\n    const b1 = 3 * u * vv;\r\n    const b2 = 3 * uu * v;\r\n    const b3 = u * uu;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n];\r\n    }\r\n    return result;\r\n  }\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    // QUADRATIC basis functions applied to differences ... (with factor 3 for derivative)\r\n    const f0 = 3 * (v * v);\r\n    const f1 = 6 * u * v;\r\n    const f2 = 3 * u * u;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const q0 = polygon[i];\r\n      const q1 = polygon[i + n];\r\n      const q2 = polygon[i + 2 * n];\r\n      const q3 = polygon[i + 3 * n];\r\n      result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    const v1 = 1.0 - u;\r\n    const v2 = v1 * v1;\r\n    const v3 = v2 * v1;\r\n    return this.coffs[0] * v3\r\n      + u * (3.0 * this.coffs[1] * v2\r\n        + u * (3.0 * this.coffs[2] * v1\r\n          + u * this.coffs[3]));\r\n  }\r\n  /**\r\n   * convert a power polynomial to bezier\r\n   */\r\n  public static createFromDegree3PowerPolynomial(source: Degree3PowerPolynomial): Order4Bezier {\r\n    const f0 = source.evaluate(0.0);\r\n    const d0 = source.evaluateDerivative(0.0);\r\n    const d1 = source.evaluateDerivative(1.0);\r\n    const f1 = source.evaluate(1.0);\r\n    const a = 3.0;\r\n\r\n    return new Order4Bezier(f0, f0 + d0 / a, f1 - d1 / a, f1);\r\n  }\r\n  /** Find real roots, retun in caller-allocated array. */\r\n  public realRoots(e: number, restrictTo01: boolean, roots: GrowableFloat64Array) {\r\n    // Get direct solutions in standard basis\r\n    roots.clear();\r\n    const cc = new Float64Array(4);\r\n    const y0 = this.coffs[0];\r\n    const y1 = this.coffs[1];\r\n    const y2 = this.coffs[2];\r\n    const y3 = this.coffs[3];\r\n    const yMax = Math.max(y0, y1, y2, y3);\r\n    const yMin = Math.min(y0, y1, y2, y3);\r\n    const smallValue = Geometry.smallMetricDistance;\r\n    if (yMin > smallValue)\r\n      return undefined;\r\n    if (yMax < -smallValue)\r\n      return undefined;\r\n\r\n    if (yMin >= -smallValue && yMax < smallValue) {\r\n      // all 4 are near zero . ..\r\n      roots.push(0);\r\n      roots.push(1.0 / 3.0);\r\n      roots.push(2.0 / 3.0);\r\n      roots.push(1.0);\r\n      return;  // p(x) == 0 has infinite roots .... return 4, which is a red flag for cubic\r\n    }\r\n    cc[0] = (y0 - e);\r\n    cc[1] = 3.0 * (y1 - y0);\r\n    cc[2] = 3.0 * (y0 - 2.0 * y1 + y2);\r\n    cc[3] = - y0 + 3.0 * y1 - 3.0 * y2 + y3;\r\n    AnalyticRoots.appendCubicRoots(cc, roots);  // can't have zero solutions after passing minmax conditions . . .\r\n    if (restrictTo01)\r\n      roots.reassign(0, 1);\r\n    return;\r\n  }\r\n\r\n}\r\n/** Bezier polynomial specialized to order 5 (5 coefficients, quartic  function)\r\n * @internal\r\n */\r\nexport class Order5Bezier extends BezierCoffs {\r\n  constructor(f0: number = 0, f1: number = 0, f2: number = 0, f3: number = 0, f4: number = 0) {\r\n    super(5);\r\n    this.coffs[0] = f0;\r\n    this.coffs[1] = f1;\r\n    this.coffs[2] = f2;\r\n    this.coffs[3] = f3;\r\n    this.coffs[4] = f4;\r\n  }\r\n  /** Return a deep copy */\r\n  public clone(): Order5Bezier {\r\n    return new Order5Bezier(this.coffs[0], this.coffs[1], this.coffs[2], this.coffs[3], this.coffs[4]);\r\n  }\r\n  /**\r\n   * convert a power polynomial to bezier\r\n   */\r\n  public static createFromDegree4PowerPolynomial(source: Degree4PowerPolynomial): Order5Bezier {\r\n    const f0 = source.evaluate(0.0);\r\n    const d0 = source.evaluateDerivative(0.0);\r\n    const d4 = source.evaluateDerivative(1.0);\r\n    const f4 = source.evaluate(1.0);\r\n    const a = 0.25;\r\n    const d0a = a * d0;\r\n    const fa = f0 + d0a;\r\n    const fm = 2.0 * fa - f0 + source.coffs[2] / 6.0;\r\n    return new Order5Bezier(f0, fa, fm, f4 - d4 * a, f4);\r\n  }\r\n\r\n  /** evaluate the basis fucntions at specified u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public basisFunctions(u: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(5);\r\n    const v = 1.0 - u;\r\n    const uu = u * u;\r\n    const uuu = uu * u;\r\n    const vv = v * v;\r\n    const vvv = vv * v;\r\n    result[0] = vv * vv;\r\n    result[1] = 4.0 * vvv * u;\r\n    result[2] = 6.0 * vv * uu;\r\n    result[3] = 4.0 * v * uuu;\r\n    result[4] = uu * uu;\r\n    return result;\r\n  }\r\n  /** evaluate the basis fucntions at specified u.   Sum multidimensional control points with basis weights.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctions(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1.0 - u;\r\n    const uu = u * u;\r\n    const uuu = uu * u;\r\n    const vv = v * v;\r\n    const vvv = vv * v;\r\n    const b0 = vv * vv;\r\n    const b1 = 4.0 * vvv * u;\r\n    const b2 = 6.0 * vv * uu;\r\n    const b3 = 4.0 * v * uuu;\r\n    const b4 = uu * uu;\r\n    for (let i = 0; i < n; i++) {\r\n      result[i] = b0 * polygon[i] + b1 * polygon[i + n] + b2 * polygon[i + 2 * n] + b3 * polygon[i + 3 * n] + b4 * polygon[i + 4 * n];\r\n    }\r\n    return result;\r\n  }\r\n  /** evaluate the blocked derivative at u.\r\n   * @param u bezier parameter for evaluation.\r\n   * @param n dimension of control points.\r\n   * @param polygon packed multidimensional control points.   ASSUMED contains `n*order` values.\r\n   * @param result optional destination for values.   ASSUMED size `order`\r\n   * @returns Return a (newly allocated) array of basis function values.\r\n   */\r\n  public sumBasisFunctionDerivatives(u: number, polygon: Float64Array, n: number, result?: Float64Array): Float64Array {\r\n    if (!result) result = new Float64Array(n);\r\n    const v = 1 - u;\r\n    // CUBIC basis functions applied to differences ...\r\n    const uu = u * u;\r\n    const vv = v * v;\r\n    const f0 = 4 * v * vv;\r\n    const f1 = 12 * u * vv;\r\n    const f2 = 12 * uu * v;\r\n    const f3 = 4 * u * uu;\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      const q0 = polygon[i];\r\n      const q1 = polygon[i + n];\r\n      const q2 = polygon[i + 2 * n];\r\n      const q3 = polygon[i + 3 * n];\r\n      const q4 = polygon[i + 4 * n];\r\n      result[i] = f0 * (q1 - q0) + f1 * (q2 - q1) + f2 * (q3 - q2) + f3 * (q4 - q3);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(u: number): number {\r\n    const v1 = 1.0 - u;\r\n    const v2 = v1 * v1;\r\n    const v3 = v2 * v1;\r\n    const v4 = v2 * v2;\r\n    return this.coffs[0] * v4\r\n      + u * (4.0 * this.coffs[1] * v3\r\n        + u * (6.0 * this.coffs[2] * v2\r\n          + u * (4.0 * this.coffs[3] * v1\r\n            + u * this.coffs[4])));\r\n  }\r\n  /** Add the product of a pair of Order3Bezier to this one. */\r\n  public addProductOrder3BezierOrder3Bezier(f: Order3Bezier, g: Order3Bezier, a: number) {\r\n    this.coffs[0] += a * f.coffs[0] * g.coffs[0];\r\n    this.coffs[1] += a * (f.coffs[0] * g.coffs[1] + f.coffs[1] * g.coffs[0]) * 0.5;\r\n    this.coffs[2] += a * (f.coffs[0] * g.coffs[2] + 4.0 * f.coffs[1] * g.coffs[1] + f.coffs[2] * g.coffs[0]) / 6.0;\r\n    this.coffs[3] += a * (f.coffs[1] * g.coffs[2] + f.coffs[2] * g.coffs[1]) * 0.5;\r\n    this.coffs[4] += a * f.coffs[2] * g.coffs[2];\r\n  }\r\n  /** Add a constant to all coefficients (thereby adding the constant to the evaluated bezier) */\r\n  public addConstant(a: number): void {\r\n    for (let i = 0; i < 5; i++) this.coffs[i] += a;\r\n  }\r\n  /** Find real roots, retun in caller-allocated array. */\r\n  public realRoots(e: number, restrictTo01: boolean, roots: GrowableFloat64Array): void {\r\n    roots.clear();\r\n    const y0 = this.coffs[0] - e;\r\n    const y1 = this.coffs[1] - e;\r\n    const y2 = this.coffs[2] - e;\r\n    const y3 = this.coffs[3] - e;\r\n    const y4 = this.coffs[4] - e;\r\n    // Get direct solutions in standard basis\r\n    const yMax = Math.max(y0, y1, y2, y3, y4);\r\n    const yMin = Math.min(y0, y1, y2, y3, y4);\r\n    const smallValue = Geometry.smallMetricDistance;\r\n    if (yMin > smallValue)\r\n      return undefined;\r\n    if (yMax < -smallValue)\r\n      return undefined;\r\n\r\n    if (yMin >= -smallValue && yMax < smallValue) {\r\n      // all 4 are near zero . ..\r\n      roots.push(0);\r\n      roots.push(0.25);\r\n      roots.push(0.5);\r\n      roots.push(0.75);\r\n      roots.push(1.0);\r\n      return; // p(x) == 0 has infinite roots .... return 5, which is a red flag for cubic ...\r\n    }\r\n\r\n    const cc = new Float64Array(5);\r\n\r\n    cc[0] = (y0 - e);\r\n    cc[1] = 4.0 * (-y0 + y1);\r\n    cc[2] = 6.0 * (y0 - 2.0 * y1 + y2);\r\n    cc[3] = 4.0 * (-y0 + 3.0 * y1 - 3.0 * y2 + y3);\r\n    cc[4] = (y0 - 4.0 * y1 + 6.0 * y2 - 4.0 * y3 + y4);\r\n\r\n    AnalyticRoots.appendQuarticRoots(cc, roots);\r\n    if (restrictTo01)\r\n      roots.reassign(0, 1);\r\n    return;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { GrowableBlockedArray } from \"../geometry3d/GrowableBlockedArray\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\n/**\r\n * Blocked array with operations to sort and cluster with a tolerance.\r\n * * Primary sorting is along an \"arbitrary\" sort vector.\r\n * @internal\r\n */\r\nexport class ClusterableArray extends GrowableBlockedArray {\r\n  //  (This is pretty strange)\r\n  // The sort vector is (1,c, c*c, ...)\r\n  // Settint c = 1 makes it 1,1,1 which may be useful for visual scans during debug.\r\n  // c wuith some inobvious digits makes it unlikley tha there will be multiple points on a perpendicular to the sort vector.\r\n  private static readonly _vectorFactor = 0.8732;  // use 1.0 to rig easy tests.\r\n  /** Return a component of the sort vector. */\r\n  public static sortVectorComponent(index: number): number {\r\n    let c = 1.0;\r\n    for (let i = 1; i < index; i++) c *= ClusterableArray._vectorFactor;\r\n    return c;\r\n  }\r\n  private _numCoordinatePerPoint: number;\r\n  private _numExtraDataPerPoint: number;\r\n  /**\r\n   * @param numCoordinatePerPoint number of coordinates per point\r\n   * @param  numExtraDataPerPoint of extra data values per point.\r\n   * @param initialBlockCapacity predicted number of points.  (This does not have to be accurate)\r\n   */\r\n  public constructor(numCoordinatePerPoint: number, numExtraDataPerPoint: number, initialBlockCapacity: number) {\r\n    super(1 + numCoordinatePerPoint + numExtraDataPerPoint, initialBlockCapacity);\r\n    this._numExtraDataPerPoint = numExtraDataPerPoint;\r\n    this._numCoordinatePerPoint = numCoordinatePerPoint;\r\n  }\r\n  /** load a block, placing data[i] at block[i+1] to allow sort coordinate first.\r\n   * @param data array of numDataPerBlock values.\r\n   */\r\n  public addBlock(data: number[]) {\r\n    const i0 = this.newBlockIndex() + 1;\r\n    const n = Math.min(this.numPerBlock - 1, data.length);\r\n    for (let i = 0; i < n; i++)\r\n      this._data[i0 + i] = data[i];\r\n  }\r\n  /** add a block with directly 2 to 5 listed content parameters.\r\n   * This assumes numDataPerPoint is sufficient for the parameters provided.\r\n   */\r\n  public addDirect(x0: number, x1: number, x2?: number, x3?: number, x4?: number) {\r\n    const i0 = this.newBlockIndex();\r\n    this._data[i0 + 1] = x0;\r\n    this._data[i0 + 2] = x1;\r\n    if (x2 !== undefined) this._data[i0 + 3] = x2;\r\n    if (x3 !== undefined) this._data[i0 + 4] = x3;\r\n    if (x4 !== undefined) this._data[i0 + 5] = x4;\r\n  }\r\n\r\n  /** add a block directly from a Point2d with 0 to 3 extras\r\n   * This assumes numDataPerPoint is sufficient for the parameters provided.\r\n   */\r\n  public addPoint2d(xy: Point2d, a?: number, b?: number, c?: number) {\r\n    const i0 = this.newBlockIndex();\r\n    this._data[i0 + 1] = xy.x;\r\n    this._data[i0 + 2] = xy.y;\r\n    if (a !== undefined)\r\n      this._data[i0 + 3] = a;\r\n    if (b !== undefined)\r\n      this._data[i0 + 4] = b;\r\n    if (c !== undefined)\r\n      this._data[i0 + 5] = c;\r\n  }\r\n\r\n  /** add a block with directly from a Point2d with 0 to 3 extras\r\n   * This assumes numDataPerPoint is sufficient for the parameters provided.\r\n   */\r\n  public addPoint3d(xyz: Point3d, a?: number, b?: number, c?: number) {\r\n    const i0 = this.newBlockIndex();\r\n    this._data[i0 + 1] = xyz.x;\r\n    this._data[i0 + 2] = xyz.y;\r\n    this._data[i0 + 3] = xyz.z;\r\n    if (a !== undefined)\r\n      this._data[i0 + 4] = a;\r\n    if (b !== undefined)\r\n      this._data[i0 + 5] = b;\r\n    if (c !== undefined)\r\n      this._data[i0 + 6] = c;\r\n  }\r\n  /** Get the xy coordinates by point index. */\r\n  public getPoint2d(blockIndex: number, result?: Point2d): Point2d {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return Point2d.create(this._data[i0 + 1], this._data[i0 + 2], result);\r\n  }\r\n  /** Get the xyZ coordinates by point index. */\r\n  public getPoint3d(blockIndex: number, result?: Point3d): Point3d {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return Point3d.create(this._data[i0 + 1], this._data[i0 + 2], this._data[i0 + 3], result);\r\n  }\r\n  /** Return a single extra data value */\r\n  public getExtraData(blockIndex: number, i: number): number {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return this._data[i0 + 1 + this._numCoordinatePerPoint + i];\r\n  }\r\n  /** Return a single data value */\r\n  public getData(blockIndex: number, i: number): number {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    return this._data[i0 + i];\r\n  }\r\n\r\n  /** Set a single extra data value */\r\n  public setExtraData(blockIndex: number, i: number, value: number): void {\r\n    const i0 = this.blockIndexToDoubleIndex(blockIndex);\r\n    this._data[i0 + 1 + this._numCoordinatePerPoint + i] = value;\r\n  }\r\n\r\n  /** this value is used as cluster terminator in the Uint232rray of indcies. */\r\n  public static readonly clusterTerminator = 0xFFffFFff;\r\n  /** Test if `x` is the cluster terminator value. */\r\n  public static isClusterTerminator(x: number): boolean { return x === ClusterableArray.clusterTerminator; }\r\n  /** Return an array giving clusters of blocks with similar coordinates.\r\n   *\r\n   * * The contents of each block is assumed to be set up so the primary sort coordinate is first.\r\n   *\r\n   * ** simple coordinate blocks (x,y) or (x,y,z) would work fine but have occasional performance problems because points with same x would generate big blocks of\r\n   * candidates for clusters.\r\n   * ** The usual solution is to u value which is a dot product along some skew direction and have the blocks contain (u,x,y) or (u,x,y,z) for 2d versus 3d.\r\n   * ** apply setupPrimaryClusterSort to prepare that!!!\r\n   * * After a simple lexical sort, consecutive blocks that are within tolerance in the 0 component\r\n   * are inspected.  Within that candidate set, all blocks that are within tolerance for ALL components are clustered.\r\n   * * In the output cluster array, clusters are terminated a invalid index. Test for the invalid index with GrowableBlockArray.isClusterTerminator (x)\r\n   */\r\n  public clusterIndicesLexical(clusterTolerance: number = Geometry.smallMetricDistance): Uint32Array {\r\n    // install primary sort key\r\n    this.setupPrimaryClusterSort();\r\n    // presort by all coordinates ....\r\n    const firstSort = this.sortIndicesLexical();\r\n    const clusterIndices = new Uint32Array(2 * firstSort.length);  // worst case: no duplicates, each index goes in followed by terminator.\r\n    let m = 0;  // number of cluster indices\r\n    const n = this.numBlocks; // and this must match firstSort.length !!\r\n    let clusterStartBlockIndex = 0;\r\n    let candidateBlockIndex = 0;\r\n    let barrierU = 0.0;\r\n    let i = 0;\r\n    let j = 0;\r\n\r\n    const k0 = 1;   // beginning of active column for distance\r\n    const k1 = 1 + this._numCoordinatePerPoint;\r\n    for (i = 0; i < n; i++) {\r\n      clusterStartBlockIndex = firstSort[i];\r\n      if (!ClusterableArray.isClusterTerminator(clusterStartBlockIndex)) {\r\n        // unused block, so it becomes a cluster...\r\n        clusterIndices[m++] = clusterStartBlockIndex;\r\n        barrierU = this.component(clusterStartBlockIndex, 0) + clusterTolerance;\r\n        firstSort[i] = ClusterableArray.clusterTerminator;\r\n        for (j = i + 1; j < n; j++) {\r\n          candidateBlockIndex = firstSort[j];\r\n          if (candidateBlockIndex === ClusterableArray.clusterTerminator) continue; // nearby in sort direction but already in a cluster.\r\n          if (this.component(candidateBlockIndex, 0) >= barrierU) break;\r\n          if (this.distanceBetweenSubBlocks(clusterStartBlockIndex, candidateBlockIndex, k0, k1) < clusterTolerance) {\r\n            clusterIndices[m++] = candidateBlockIndex;            // The candidate is in the block\r\n            firstSort[j] = ClusterableArray.clusterTerminator;  // and it will not be reused as future block base\r\n          }\r\n        }\r\n        clusterIndices[m++] = ClusterableArray.clusterTerminator;\r\n      }\r\n    }\r\n    // Alas, the clusterIndices array has fluff at the end.  So it has to be copied.\r\n    return clusterIndices.slice(0, m);\r\n  }\r\n  /** setup (overwrite!!) the \"0\" component with the dot product of numClusterCoordinate later components with a non-axis aligned vector.\r\n   * This is normally called before clusterIndicesLexical.\r\n   */\r\n  public setupPrimaryClusterSort() {\r\n    const nb = this.numBlocks;\r\n    const nc = this._numCoordinatePerPoint;\r\n    const vector = new Float64Array(nc);\r\n    vector[0] = 1.0;\r\n    for (let c = 1; c < nc; c++) vector[c] = vector[c - 1] * ClusterableArray._vectorFactor;\r\n    let k = 0;\r\n    let dot = 0.0;\r\n    const data = this._data;\r\n    for (let b = 0; b < nb; b++) {\r\n      k = this.blockIndexToDoubleIndex(b);\r\n      dot = 0.0;\r\n      for (let c = 0; c < nc; c++) { dot += vector[c] * data[k + 1 + c]; }\r\n      data[k] = dot;\r\n    }\r\n  }\r\n  /** Convert the cluster data to an array of tuples with point i in the form\r\n   * `[i, primarySortCoordinate, [x,y,..], [extraData0, extraData1, ...]]`\r\n   */\r\n  public toJSON(): any[] {\r\n    const result: any[] = [];\r\n    for (let b = 0; b < this.numBlocks; b++) {\r\n      let i = this.blockIndexToDoubleIndex(b);\r\n      const chunk: any[] = [b, this._data[i++]];\r\n      const coordinates = [];\r\n      for (let c = 0; c < this._numCoordinatePerPoint; c++)coordinates.push(this._data[i++]);\r\n      chunk.push(coordinates);\r\n      for (let c = 0; c < this._numExtraDataPerPoint; c++)\r\n        chunk.push(this._data[i++]);\r\n      result.push(chunk);\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return an array of indices from block index to cluster index.\r\n   * @param clusteredBlocks clusters of block indices followed by separators.\r\n   */\r\n  public createIndexBlockToClusterIndex(clusteredBlocks: Uint32Array): Uint32Array {\r\n    const numBlocks = this.numBlocks;\r\n    const blockToCluster = new Uint32Array(numBlocks);\r\n    blockToCluster.fill(ClusterableArray.clusterTerminator);\r\n    let numCluster = 0;\r\n    for (const b of clusteredBlocks) {\r\n      if (b >= numBlocks) {\r\n        numCluster++;\r\n      } else {\r\n        blockToCluster[b] = numCluster;\r\n      }\r\n    }\r\n    return blockToCluster;\r\n  }\r\n  /**\r\n   * Return an array of indices from block index to index of its cluster's start in the cluster index array.\r\n   * @param clusteredBlocks clusters of block indices followed by separators.\r\n   */\r\n  public createIndexBlockToClusterStart(clusteredBlocks: Uint32Array): Uint32Array {\r\n    const n = clusteredBlocks.length;\r\n    const numBlocks = this.numBlocks;\r\n    const blockToClusterStart = new Uint32Array(numBlocks);\r\n    const terminator = ClusterableArray.clusterTerminator;\r\n    blockToClusterStart.fill(terminator);\r\n    let clusterStart = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      const k = clusteredBlocks[i];\r\n      if (k > numBlocks) {\r\n        clusterStart = i + 1;\r\n      } else {\r\n        blockToClusterStart[k] = clusterStart;\r\n      }\r\n    }\r\n    return blockToClusterStart;\r\n  }\r\n  /** count the clusters in the clusteredBlocks array. */\r\n  public countClusters(clusteredBlocks: Uint32Array): number {\r\n    let numClusters = 0;\r\n    const terminator = ClusterableArray.clusterTerminator;\r\n    for (const b of clusteredBlocks) {\r\n      if (b === terminator)\r\n        numClusters++;\r\n    }\r\n    return numClusters;\r\n  }\r\n  /** create a reverse index: given a cluster index k, clusterToClusterStart[k] is the place\r\n   * the cluster's block indices appear in clusterBlocks\r\n   */\r\n  public createIndexClusterToClusterStart(clusteredBlocks: Uint32Array): Uint32Array {\r\n    let numCluster = this.countClusters(clusteredBlocks);\r\n    const clusterToClusterStart = new Uint32Array(numCluster);\r\n    const terminator = ClusterableArray.clusterTerminator;\r\n    clusterToClusterStart.fill(terminator);\r\n    const n = clusteredBlocks.length;\r\n    let clusterStart = 0;\r\n    for (let i = 0; i < n; i++) {\r\n      const k = clusteredBlocks[i];\r\n      if (k === terminator) {\r\n        clusterStart = i + 1;\r\n      } else if (i === clusterStart) {\r\n        clusterToClusterStart[numCluster++] = clusterStart;\r\n      }\r\n    }\r\n    return clusterToClusterStart;\r\n  }\r\n\r\n  /**\r\n   * Sort terminator-delimited subsets of an array of indices into the table, using a single extraData index as sort key.\r\n   * @param blockedIndices [in] indices, organized as blocks of good indices terminated by the clusterTerminator.\r\n   * @param extraDataIndex index of the extra data key.\r\n   */\r\n  public sortSubsetsBySingleKey(blockedIndices: Uint32Array, dataIndex: number) {\r\n    const dataOffset = 1 + dataIndex;\r\n    let kBegin = 0;\r\n    let swap;\r\n    let key0, key1;\r\n    const numK = blockedIndices.length;\r\n    for (let kEnd = 0; kEnd < numK; kEnd++) {\r\n      if (blockedIndices[kEnd] === ClusterableArray.clusterTerminator) {\r\n        // sort blockedIndices[kBegin ,= k < kEnd].\r\n        //  (search for minimum remaining, swap  . . )\r\n        for (let k0 = kBegin; k0 + 1 < kEnd; k0++) {\r\n          key0 = this.getWithinBlock(blockedIndices[k0], dataOffset);\r\n          for (let k1 = k0 + 1; k1 < kEnd; k1++) {\r\n            key1 = this.getWithinBlock(blockedIndices[k1], dataOffset);\r\n            if (key1 < key0) {\r\n              swap = blockedIndices[k0];\r\n              blockedIndices[k0] = blockedIndices[k1];\r\n              blockedIndices[k1] = swap;\r\n              key0 = key1;\r\n            }\r\n          }\r\n        }\r\n        kBegin = kEnd + 1;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Returns packed points with indices mapping old to new.\r\n   * @param data points to cluster.\r\n   */\r\n  public static clusterPoint3dArray(data: Point3d[], tolerance: number = Geometry.smallMetricDistance):\r\n    PackedPointsWithIndex {\r\n    const clusterArray = new ClusterableArray(3, 0, data.length);\r\n    data.forEach((p: Point3d) => {\r\n      clusterArray.addDirect(p.x, p.y, p.z);\r\n    });\r\n    const order = clusterArray.clusterIndicesLexical(tolerance);\r\n    const result = new PackedPointsWithIndex(data.length);\r\n    let currentClusterIndex = 0;\r\n    let numThisCluster = 0;\r\n    order.forEach((k: number) => {\r\n      if (ClusterableArray.isClusterTerminator(k)) {\r\n        currentClusterIndex++;\r\n        numThisCluster = 0;\r\n      } else {\r\n        if (numThisCluster === 0)\r\n          result.packedPoints.push(data[k].clone());\r\n        result.oldToNew[k] = currentClusterIndex;\r\n        numThisCluster++;\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Returns packed points with indices mapping old to new.\r\n   * @param data points to cluster.\r\n   */\r\n  public static clusterGrowablePoint3dArray(source: GrowableXYZArray, tolerance: number = Geometry.smallMetricDistance):\r\n    PackedPointsWithIndex {\r\n    const clusterArray = new ClusterableArray(3, 0, source.length);\r\n    const p = Point3d.create();\r\n    const numSourcePoint = source.length;\r\n    for (let i = 0; i < numSourcePoint; i++) {\r\n      source.getPoint3dAtUncheckedPointIndex(i, p);\r\n      clusterArray.addDirect(p.x, p.y, p.z);\r\n    }\r\n    const order = clusterArray.clusterIndicesLexical(tolerance);\r\n    const result = new PackedPointsWithIndex(source.length);\r\n    const numPackedPoints = clusterArray.countClusters(order);\r\n    result.growablePackedPoints = new GrowableXYZArray(numPackedPoints);\r\n    let currentClusterIndex = 0;\r\n    let numThisCluster = 0;\r\n    order.forEach((k: number) => {\r\n      if (ClusterableArray.isClusterTerminator(k)) {\r\n        currentClusterIndex++;\r\n        numThisCluster = 0;\r\n      } else {\r\n        if (numThisCluster === 0) // This is the first encounter with a new cluster\r\n          result.growablePackedPoints!.pushFromGrowableXYZArray(source, k);\r\n        result.oldToNew[k] = currentClusterIndex;\r\n        numThisCluster++;\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n}\r\n/**\r\n * Data carrier class for\r\n * * packedPoints = an array of Point3d\r\n * * oldToNew = array of indices from some prior Point3d[] to the packed points.\r\n * @internal\r\n */\r\nclass PackedPointsWithIndex {\r\n  /** Array of Point3d */\r\n  public packedPoints: Point3d[];\r\n  /** array of coordinates packed in GrowableXYZArray  */\r\n  public growablePackedPoints: GrowableXYZArray | undefined;\r\n  /** mapping from old point index to new ponit index. */\r\n  public oldToNew: Uint32Array;\r\n  /** integer value for unknown index. */\r\n  public static readonly invalidIndex = 0xFFFFffff;\r\n\r\n  /** construct a PackedPoints object with\r\n   * * empty packedPoints array\r\n   * * oldToNew indices all initialized to PackedPoints.invalidIndex\r\n   */\r\n  constructor(numOldIndexEntry: number) {\r\n    this.packedPoints = [];\r\n    this.oldToNew = new Uint32Array(numOldIndexEntry);\r\n    for (let i = 0; i < numOldIndexEntry; i++) {\r\n      this.oldToNew[i] = PackedPointsWithIndex.invalidIndex;\r\n    }\r\n  }\r\n  /**\r\n   * Use the oldToNew array to update an array of \"old\" indices.\r\n   * @param indices array of indices into prepacked array.\r\n   * @returns true if all input indices were valid for the oldToNew array.\r\n   */\r\n  public updateIndices(indices: number[]): boolean {\r\n    let numErrors = 0;\r\n    indices.forEach((value: number, i: number, data: number[]) => {\r\n      if (value < this.oldToNew.length) {\r\n        data[i] = this.oldToNew[value];\r\n      } else numErrors++;\r\n    });\r\n    return numErrors === 0;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Numerics */\r\nimport { BeJSONFunctions, Geometry } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\n/**\r\n * OPerations on a \"complex number\" class with real part `x` and complex part `y`\r\n * @internal\r\n */\r\nexport class Complex implements BeJSONFunctions {\r\n  private _x: number;\r\n  /** (propety set) Real part */\r\n  set x(value: number) { this._x = value; }\r\n  /** (propety get) Real part */\r\n  get x(): number { return this._x; }\r\n\r\n  private _y: number;\r\n  /** (propety set) Imaginary part */\r\n  set y(value: number) { this._y = value; }\r\n  /** (propety get) Imaginary part */\r\n  get y(): number { return this._y; }\r\n\r\n  public constructor(x: number = 0, y: number = 0) { this._x = x; this._y = y; }\r\n  /** set x and y parts from args. */\r\n  public set(x: number = 0, y: number = 0): void { this.x = x; this.y = y; }\r\n  /** set `this.x` and `this.y` from `other.x` and `other.y` */\r\n  public setFrom(other: Complex) { this.x = other.x; this.y = other.y; }\r\n  /** clone the complex x,y */\r\n  public clone(): Complex { return new Complex(this.x, this.y); }\r\n  /** test for near equality using coordinate tolerances */\r\n  public isAlmostEqual(other: Complex): boolean { return Geometry.isAlmostEqualNumber(this.x, other.x) && Geometry.isAlmostEqualNumber(this.x, other.x); }\r\n  /** Create a new Complex instance from given x and y. */\r\n  public static create(x: number = 0, y: number = 0, result?: Complex): Complex {\r\n    if (result) {\r\n      result.x = x;\r\n      result.y = y;\r\n      return result;\r\n    }\r\n    return new Complex(x, y);\r\n  }\r\n  /** Return the complex sum `this+other` */\r\n  public plus(other: Complex, result?: Complex): Complex { return Complex.create(this.x + other.x, this.y + other.y, result); }\r\n  /** Return the complex difference  `this-other` */\r\n  public minus(other: Complex, result?: Complex): Complex { return Complex.create(this.x - other.x, this.y - other.y, result); }\r\n  /** Return the complex product  `this * other` */\r\n  public times(other: Complex, result?: Complex): Complex {\r\n    return Complex.create(\r\n      this.x * other.x - this.y * other.y,\r\n      this.x * other.y + this.y * other.x,\r\n      result);\r\n  }\r\n  /** Return the complex product `this * x+i*y`. That is, the second Complex value exists via the args without being formally created as an instance. */\r\n  public timesXY(x: number, y: number, result?: Complex): Complex {\r\n    return Complex.create(\r\n      this.x * x - this.y * y,\r\n      this.x * y + this.y * x,\r\n      result);\r\n  }\r\n  /** Return the mangitude of the complex number */\r\n  public magnitude(): number { return Math.hypot(this.x, this.y); }\r\n  /** Return the angle from x axis to the vector (x,y) */\r\n  public angle(): Angle { return Angle.createAtan2(this.y, this.x); }\r\n  /** Return the xy plane distance between this and other */\r\n  public distance(other: Complex) {\r\n    return Math.hypot(this.x - other.x, this.y - other.y);\r\n  }\r\n  /** Return the squared xy plane distance between this and other. */\r\n  public magnitudeSquared(): number { return this.x * this.x + this.y * this.y; }\r\n  /** Return the complex division `this / other` */\r\n  public divide(other: Complex, result?: Complex): Complex | undefined {\r\n    const bb = other.magnitudeSquared();\r\n    if (bb === 0.0)\r\n      return undefined;\r\n    const divbb = 1.0 / bb;\r\n    return Complex.create(\r\n      (this.x * other.x + this.y * other.y) * divbb,\r\n      (this.y * other.x - this.x * other.y) * divbb,\r\n      result);\r\n  }\r\n  /** Return the complex square root of this. */\r\n  public sqrt(result?: Complex): Complex {\r\n    if ((this.x === 0.0) && (this.y === 0.0))\r\n      return Complex.create(0, 0, result);\r\n\r\n    const x = Math.abs(this.x);\r\n    const y = Math.abs(this.y);\r\n    let r = 0;\r\n    let w = 0;\r\n    if (x >= y) {\r\n      r = y / x;\r\n      w = Math.sqrt(x) * Math.sqrt(0.5 * (1.0 + Math.sqrt(1.0 + r * r)));\r\n    } else {\r\n      r = x / y;\r\n      w = Math.sqrt(y) * Math.sqrt(0.5 * (r + Math.sqrt(1.0 + r * r)));\r\n    }\r\n\r\n    if (this.x >= 0.0) {\r\n      return Complex.create(w, this.y / (2.0 * w), result);\r\n    } else {\r\n      const y1 = (this.y >= 0) ? w : -w;\r\n      return Complex.create(this.y / (2.0 * y1), y1, result);\r\n    }\r\n  }\r\n  /** set the complex x,y from a json object of the form like\r\n   * * x,y key value pairs:   `{x:1,y:2}`\r\n   * * array of numbers:  `[1,2]`\r\n   */\r\n  public setFromJSON(json?: any): void {\r\n    if (Array.isArray(json) && json.length > 1) {\r\n      this.set(json[0], json[1]);\r\n    } else if (json && json.x && json.y) {\r\n      this.set(json.x, json.y);\r\n    } else {\r\n      this.set(0, 0);\r\n    }\r\n  }\r\n  /** Create a `Complex` instance from a json object. */\r\n  public static fromJSON(json?: any): Complex { const result = new Complex(); result.setFromJSON(json); return result; }\r\n\r\n  /**\r\n   * Convert an Complex to a JSON object.\r\n   * @return {*} [x,y]\r\n   */\r\n  public toJSON(): any { return [this.x, this.y]; }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * Ray with xy origin and direction\r\n * @internal\r\n */\r\nexport class Ray2d {\r\n  private _origin: Point2d;\r\n  private _direction: Vector2d;\r\n\r\n  private constructor(origin: Point2d, direction: Vector2d) {\r\n    this._origin = origin;\r\n    this._direction = direction;\r\n  }\r\n  /** Create from 2d `origin` and `target`.\r\n   * * `target - origin` is the direction vector.\r\n   */\r\n  public static createOriginAndTarget(origin: Point2d, target: Point2d): Ray2d {\r\n    return new Ray2d(origin.clone(), origin.vectorTo(target));\r\n  }\r\n  /** Create from (clones of) `origin` point and `direction` vector */\r\n  public static createOriginAndDirection(origin: Point2d, direction: Vector2d): Ray2d {\r\n    return new Ray2d(origin.clone(), direction.clone());\r\n  }\r\n  /** Captuer `origin` and `direction` as ray member variables. */\r\n  public static createOriginAndDirectionCapture(origin: Point2d, direction: Vector2d): Ray2d {\r\n    return new Ray2d(origin, direction);\r\n  }\r\n  /** Get the (REFERENCE TO) the ray origin. */\r\n  public get origin() { return this._origin; }\r\n  /** Get the (REFERENCE TO) the ray direction. */\r\n  public get direction() { return this._direction; }\r\n\r\n  /**\r\n   *  Return a ray that is parallel at distance to the left, specified as fraction of the ray's direction vector.\r\n   */\r\n  public parallelRay(leftFraction: number): Ray2d {\r\n    return new Ray2d(this._origin.addForwardLeft(0.0, leftFraction, this._direction), this._direction);\r\n  }\r\n  /** Return a ray with same origin, direction rotated 90 degrees counterclockwise */\r\n  public ccwPerpendicularRay(): Ray2d {\r\n    return new Ray2d(this._origin, this._direction.rotate90CCWXY());\r\n  }\r\n\r\n  /** Return a ray with same origin, direction rotated 90 degrees clockwise */\r\n  public cwPerpendicularRay(): Ray2d {\r\n    return new Ray2d(this._origin, this._direction.rotate90CWXY());\r\n  }\r\n  /** Normalize the direction vector in place. */\r\n  public normalizeDirectionInPlace(): boolean {\r\n    if (this._direction.normalize(this._direction)) {\r\n      return true;\r\n    } else {\r\n      this._direction.x = 1.0;\r\n      this._direction.y = 0.0;\r\n      // magnitude = 0.0;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Intersect this ray (ASSUMED NORMALIZED) with unbounded line defined by points.\r\n   *  (The normalization assumption affects test for parallel vectors.)\r\n   *  Fraction and dhds passed as number[] to use by reference... Sticking to return of true and false in the case fraction is zero after\r\n   *  a true safe divide\r\n   */\r\n  public intersectUnboundedLine(linePointA: Point2d, linePointB: Point2d, fraction: number[], dhds: number[]): boolean {\r\n    const lineDirection = linePointA.vectorTo(linePointB);\r\n    const vector0 = linePointA.vectorTo(this._origin);\r\n    const h0 = vector0.crossProduct(lineDirection);\r\n    dhds[0] = this._direction.crossProduct(lineDirection);\r\n    // h = h0 + s * dh\r\n    const ff = Geometry.conditionalDivideFraction(-h0, dhds[0]);\r\n    if (ff !== undefined) {\r\n      fraction[0] = ff;\r\n      return true;\r\n    } else {\r\n      fraction[0] = 0.0;\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /** return the ray fraction where point projects to the ray */\r\n  public projectionFraction(point: Point2d): number {\r\n    return this._origin.vectorTo(point).fractionOfProjectionToVector(this._direction);\r\n  }\r\n\r\n  /** return the fraction of projection to the perpendicular ray */\r\n  public perpendicularProjectionFraction(point: Point2d): number {\r\n    const uv = this._direction.crossProduct(this._origin.vectorTo(point));\r\n    const uu = this._direction.magnitudeSquared();\r\n    // Want zero returned if failure case, not undefined\r\n    return Geometry.safeDivideFraction(uv, uu, 0.0);\r\n  }\r\n\r\n  /** Return point from origin plus a scaled vector */\r\n  public fractionToPoint(f: number): Point2d {\r\n    return this._origin.plusScaled(this._direction, f);\r\n  }\r\n}\r\n/**\r\n * Convex hull of points in 2d.\r\n * @internal\r\n */\r\nexport class ConvexPolygon2d {\r\n  // hull points in CCW order, WITHOUT final duplicate...\r\n  private _hullPoints: Point2d[];\r\n\r\n  constructor(points: Point2d[]) {\r\n    this._hullPoints = [];\r\n    // Deep copy of points array given\r\n    for (const point of points) {\r\n      this._hullPoints.push(point);\r\n    }\r\n  }\r\n\r\n  /** Create the hull */\r\n  public static createHull(points: Point2d[]): ConvexPolygon2d {\r\n    return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));\r\n  }\r\n\r\n  /** Create the hull. First try to use the points as given. */\r\n  public static createHullIsValidCheck(points: Point2d[]) {\r\n    if (ConvexPolygon2d.isValidConvexHull(points))\r\n      return new ConvexPolygon2d(points);\r\n    else\r\n      return new ConvexPolygon2d(ConvexPolygon2d.computeConvexHull(points));\r\n  }\r\n\r\n  /** Return a reference of the hull points. */\r\n  public get points(): Point2d[] {\r\n    return this._hullPoints;\r\n  }\r\n\r\n  /** Test if hull points are a convex, CCW polygon */\r\n  public static isValidConvexHull(points: Point2d[]) {\r\n    if (points.length < 3)\r\n      return false;\r\n    const n = points.length;\r\n    for (let i = 0; i < n; i++) {\r\n      const i1 = (i + 1) % n;\r\n      const i2 = (i + 2) % n;\r\n      if (points[i].crossProductToPoints(points[i1], points[i2]) < 0.0)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Return true if the convex hull (to the left of the edges) contains the test point */\r\n  public containsPoint(point: Point2d): boolean {\r\n    let xy0 = this._hullPoints[this._hullPoints.length - 1];\r\n    // double tol = -1.0e-20;  negative tol!!\r\n    for (const i of this._hullPoints) {\r\n      const xy1 = i;\r\n      const c = xy0.crossProductToPoints(xy1, point);\r\n      if (c < 0.0)\r\n        return false;\r\n      xy0 = i;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Return the largest outside. (return 0 if in or on) */\r\n  public distanceOutside(xy: Point2d): number {\r\n    let maxDistance = 0.0;\r\n    const n = this._hullPoints.length;\r\n    let xy0 = this._hullPoints[n - 1];\r\n    // double tol = -1.0e-20;  // negative tol!!\r\n    for (let i = 0; i < n; i++) {\r\n      const xy1 = this._hullPoints[i];\r\n      const c = xy0.crossProductToPoints(xy1, xy);\r\n      if (c < 0.0) {\r\n        const ray = Ray2d.createOriginAndTarget(xy0, xy1);\r\n        const s = ray.projectionFraction(xy);\r\n        let d = 0.0;\r\n        if (s < 0.0)\r\n          d = xy0.distance(xy);\r\n        else if (s > 1.0)\r\n          d = xy1.distance(xy);\r\n        else\r\n          d = xy.distance(ray.fractionToPoint(s));\r\n\r\n        if (d > maxDistance)\r\n          maxDistance = d;\r\n      }\r\n      xy0 = this._hullPoints[i];\r\n    }\r\n    return maxDistance;\r\n  }\r\n\r\n  /** Offset the entire hull (in place) by distance.\r\n   * Returns false if an undefined occurred from normalizing (could occur after changing some hull points already)\r\n   */\r\n  public offsetInPlace(distance: number): boolean {\r\n    const n = this._hullPoints.length;\r\n    if (n >= 3) {\r\n      const hullPoint0 = this._hullPoints[0];\r\n      let edgeA: Vector2d | undefined = this._hullPoints[n - 1].vectorTo(hullPoint0);\r\n      edgeA = edgeA.normalize();\r\n      if (edgeA === undefined) { return false; }\r\n\r\n      let perpA = edgeA.rotate90CWXY();\r\n      let edgeB: Vector2d | undefined;\r\n      let perpB: Vector2d;\r\n      for (let i = 0; i < n; i++) {\r\n        const j = i + 1;\r\n        edgeB = this._hullPoints[i].vectorTo(j < n ? this._hullPoints[j] : hullPoint0);\r\n        edgeB = edgeB.normalize();\r\n        if (edgeB === undefined) { return false; }\r\n\r\n        perpB = edgeB.rotate90CWXY();\r\n        const offsetBisector = Vector2d.createOffsetBisector(perpA, perpB, distance);\r\n        if (offsetBisector === undefined) { return false; }\r\n\r\n        this._hullPoints[i] = this._hullPoints[i].plus(offsetBisector);\r\n        // PerpA takes up reference to perpB, as perpB will die in new iteration\r\n        perpA = perpB;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Return 2 distances bounding the intersection of the ray with a convex hull.\r\n   * ASSUME (for tolerancing) the ray has normalized direction vector.\r\n   * Both negative and positive distances along the ray are possible.\r\n   * Returns range with extremities if less than 3 points, distanceA > distanceB, or if cross product < 0\r\n   */\r\n  public clipRay(ray: Ray2d): Range1d {\r\n    let distanceA = - Number.MAX_VALUE;\r\n    let distanceB = Number.MAX_VALUE;\r\n\r\n    const n = this._hullPoints.length;\r\n\r\n    if (n < 3)\r\n      return Range1d.createNull();\r\n\r\n    let xy0 = this._hullPoints[n - 1];\r\n    for (const xy1 of this._hullPoints) {\r\n      const distance: number[] = [];\r\n      const dhds: number[] = [];\r\n      if (ray.intersectUnboundedLine(xy0, xy1, distance, dhds)) {\r\n        if (dhds[0] > 0.0) {\r\n          if (distance[0] < distanceB)\r\n            distanceB = distance[0];\r\n        } else {\r\n          if (distance[0] > distanceA)\r\n            distanceA = distance[0];\r\n        }\r\n        if (distanceA > distanceB)\r\n          return Range1d.createNull();\r\n      } else {\r\n        // ray is parallel to the edge.\r\n        // Any single point out classifies it all . ..\r\n        if (xy0.crossProductToPoints(xy1, ray.origin) < 0.0)\r\n          return Range1d.createNull();\r\n      }\r\n\r\n      // xy1 is reassigned with each new loop\r\n      xy0 = xy1;\r\n    }\r\n    const range = Range1d.createNull();\r\n    range.extendX(distanceA);\r\n    range.extendX(distanceB);\r\n    return range;\r\n  }\r\n\r\n  /** Return the range of (fractional) ray postions for projections of all points from the arrays. */\r\n  public rangeAlongRay(ray: Ray2d): Range1d {\r\n    const range = Range1d.createNull();\r\n    for (const xy1 of this._hullPoints)\r\n      range.extendX(ray.projectionFraction(xy1));\r\n    return range;\r\n  }\r\n\r\n  /** Return the range of (fractional) ray postions for projections of all points from the arrays. */\r\n  public rangePerpendicularToRay(ray: Ray2d): Range1d {\r\n    const range = Range1d.createNull();\r\n    for (const xy1 of this._hullPoints)\r\n      range.extendX(ray.perpendicularProjectionFraction(xy1));\r\n    return range;\r\n  }\r\n\r\n  /** Computes the hull of a convex polygon from points given. Returns the hull as a new Point2d array.\r\n   *  Returns an empty hull if less than 3 points are given.\r\n   */\r\n  public static computeConvexHull(points: Point2d[]): Point2d[] {\r\n    const hull: Point2d[] = [];\r\n    const n = points.length;\r\n    if (n < 3)\r\n      return hull;\r\n    // Get deep copy\r\n    const xy1: Point2d[] = points.slice(0, n);\r\n    xy1.sort(Geometry.lexicalXYLessThan);\r\n    hull.push(xy1[0]); // This is sure to stay\r\n    hull.push(xy1[1]); // This one can be removed in loop.\r\n\r\n    // First sweep creates upper hull\r\n    for (let i = 2; i < n; i++) {\r\n      const candidate = xy1[i];\r\n      let top = hull.length - 1;\r\n      while (top > 0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {\r\n        top--;\r\n        hull.pop();\r\n      }\r\n      hull.push(candidate);\r\n    }\r\n\r\n    // Second sweep creates lower hull right to left\r\n    const i0 = hull.length - 1;\r\n    // xy1.back () is already on stack.\r\n    hull.push(xy1[n - 2]);\r\n    for (let i = n - 2; i-- > 0;) {\r\n      const candidate = xy1[i];\r\n      let top = hull.length - 1;\r\n      while (top > i0 && hull[top - 1].crossProductToPoints(hull[top], candidate) <= 0.0) {\r\n        top--;\r\n        hull.pop();\r\n      }\r\n      if (i > 0) // don't replicate start point!!!\r\n        hull.push(candidate);\r\n    }\r\n\r\n    return hull;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { SmallSystem } from \"./Polynomials\";\r\n/** base class for Newton iterations in various dimensions.\r\n * Dimension-specific classes carry all dimension-related data and answer generalized queries\r\n * from this base class.\r\n * @internal\r\n */\r\nexport abstract class AbstractNewtonIterator {\r\n  /** Compute a step.  The current x and function values must be retained for use in later method calls */\r\n  public abstract computeStep(): boolean;\r\n  /** return the current step size, scaled for use in tolerance tests.\r\n   * * This is a single number, typically the max of various per-dimension `dx / (1+x)` for the x and dx of that dimension.\r\n   */\r\n  public abstract currentStepSize(): number;\r\n  /**\r\n   * Apply the current step (in all dimensions)\r\n   * @param isFinalStep true if this is a final step.\r\n   */\r\n  public abstract applyCurrentStep(isFinalStep: boolean): boolean;\r\n  /**\r\n   * @param stepSizeTarget tolerance to consider a single step converged.\r\n   * This number should be \"moderately\" strict.   Because 2 successive convergences are required,\r\n   * it is expected that a first \"accept\" for (say) 10 to 14 digit step will be followed by another\r\n   * iteration.   A well behaved newton would then hypothetically double the number of digits to\r\n   * 20 to 28.  Since the IEEE double only carries 16 digits, this second-convergence step will\r\n   * typically achieve full precision.\r\n   * @param successiveConvergenceTarget number of successive convergences required for acceptance.\r\n   * @param maxIterations max number of iterations.   A typical newton step converges in 3 to 6 iterations.\r\n   *     Allow 15 to 20 to catch difficult cases.\r\n   */\r\n  protected constructor(\r\n    stepSizeTolerance: number = 1.0e-11,\r\n    successiveConvergenceTarget: number = 2,\r\n    maxIterations: number = 15) {\r\n    this._stepSizeTolerance = stepSizeTolerance;\r\n    this._successiveConvergenceTarget = successiveConvergenceTarget;\r\n    this._maxIterations = maxIterations;\r\n  }\r\n  /** Number of consecutive steps which passed convergence condition */\r\n  protected _numAccepted: number = 0;\r\n  /** Target number of successive convergences */\r\n  protected _successiveConvergenceTarget: number;\r\n  /** convergence target (the implementation-specific currentStepSize is compared to this) */\r\n  protected _stepSizeTolerance: number;\r\n  /** Max iterations allowed */\r\n  protected _maxIterations: number;\r\n  /** number of iterations (incremented at each step) */\r\n  public numIterations: number = 0;\r\n  /**\r\n   * Test if a step is converged.\r\n   * * Convergence is accepted with enough (_successiveConvergenceTarget) small steps (according to _stepSizeTolerance) occur in succession.\r\n   * @param delta step size as reported by currentStepSize\r\n   */\r\n  public testConvergence(delta: number): boolean {\r\n    if (Math.abs(delta) < this._stepSizeTolerance) {\r\n      this._numAccepted++;\r\n      return this._numAccepted >= this._successiveConvergenceTarget;\r\n    }\r\n    this._numAccepted = 0;\r\n    return false;\r\n  }\r\n  /**\r\n   * Run iterations, calling various methods from base and derived classes:\r\n   * * computeStep -- typically evaluate derivatives and solve lineary system.\r\n   * * currentStepSize -- return numeric measure of the step just computed by computeStep\r\n   * * testConvergence -- test if the step from currentStepSize (along with recent steps) is converged.\r\n   * * applyCurrentStep -- apply the step to the independent variables\r\n   */\r\n  public runIterations(): boolean {\r\n    this._numAccepted = 0;\r\n    this.numIterations = 0;\r\n    while (this.numIterations++ < this._maxIterations && this.computeStep()) {\r\n      if (this.testConvergence(this.currentStepSize())\r\n        && this.applyCurrentStep(true)) {\r\n        return true;\r\n      }\r\n      this.applyCurrentStep(false);\r\n    }\r\n    return false;\r\n  }\r\n}\r\n/** object to evaluate a newton function.  The object must retain most-recent function and derivative\r\n * values for immediate query.\r\n * @internal\r\n */\r\nexport abstract class NewtonEvaluatorRtoRD {\r\n/** evaluate the function and its derivative at x. */\r\n  public abstract evaluate(x: number): boolean;\r\n  /** most recent function value */\r\n  public currentF!: number;\r\n  /** most recent evaluated derivative */\r\n  public currentdFdX!: number;\r\n}\r\n/**\r\n * Newton iterator for use when both function and derivative can be evaluated.\r\n * @internal\r\n */\r\nexport class Newton1dUnbounded extends AbstractNewtonIterator {\r\n  private _func: NewtonEvaluatorRtoRD;\r\n  private _currentStep!: number;\r\n  private _currentX!: number;\r\n  private _target!: number;\r\n  /**\r\n   * Constructor for 1D newton iteration with approximate derivatives.\r\n   * @param func function that returns both function and derivative.\r\n   */\r\n  public constructor(func: NewtonEvaluatorRtoRD) {\r\n    super();\r\n    this._func = func;\r\n    this.setTarget(0);\r\n  }\r\n  /** Set the independent variable */\r\n  public setX(x: number): boolean { this._currentX = x; return true; }\r\n  /** Get the independent variable */\r\n  public getX(): number { return this._currentX; }\r\n  /** Set the target function value */\r\n  public setTarget(y: number) { this._target = y; }\r\n  /** move the current X by the just-computed step */\r\n  public applyCurrentStep(): boolean { return this.setX(this._currentX - this._currentStep); }\r\n  /** Compute the univariate newton step. */\r\n  public computeStep(): boolean {\r\n    if (this._func.evaluate(this._currentX)) {\r\n      const dx = Geometry.conditionalDivideFraction(this._func.currentF - this._target, this._func.currentdFdX);\r\n      if (dx !== undefined) {\r\n        this._currentStep = dx;\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the current step size as a relative number. */\r\n  public currentStepSize(): number {\r\n    return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));\r\n  }\r\n}\r\n\r\n/** object to evaluate a newton function (without derivative).  The object must retain most-recent function value.\r\n * @internal\r\n */\r\nexport abstract class NewtonEvaluatorRtoR {\r\n/** Evalute function value into member currentF */\r\n  public abstract evaluate(x: number): boolean;\r\n  /** Most recent function evaluation. */\r\n  public currentF!: number;\r\n}\r\n\r\n/** Newton iteration for a univariate function, using approximate derivatives.\r\n * @internal\r\n */\r\nexport class Newton1dUnboundedApproximateDerivative extends AbstractNewtonIterator {\r\n  private _func: NewtonEvaluatorRtoR;\r\n  private _currentStep!: number;\r\n  private _currentX!: number;\r\n  /** Step size for iteration.\r\n   * * Initialized to 1e-8, which is appropriate for iteration in fraction space.\r\n   * * Shoulde larger for iteration with real distance as x.\r\n   */\r\n  public derivativeH: number; // step size for approximate derivative\r\n\r\n  /**\r\n   * Constructor for 1D newton iteration with approximate derivatives.\r\n   * @param func function that returns both function and derivative.\r\n   */\r\n  public constructor(func: NewtonEvaluatorRtoR) {\r\n    super();\r\n    this._func = func;\r\n    this.derivativeH = 1.0e-8;\r\n  }\r\n  /** Set the x (independent, iterated) value */\r\n  public setX(x: number): boolean { this._currentX = x; return true; }\r\n  /** Get the independent variable */\r\n  public getX(): number { return this._currentX; }\r\n  /** move the current X by the just-computed step */\r\n  public applyCurrentStep(): boolean { return this.setX(this._currentX - this._currentStep); }\r\n  /** Univariate newton step computed with APPROXIMATE derivative. */\r\n  public computeStep(): boolean {\r\n    if (this._func.evaluate(this._currentX)) {\r\n      const fA = this._func.currentF;\r\n      if (this._func.evaluate(this._currentX + this.derivativeH)) {\r\n        const fB = this._func.currentF;\r\n        const dx = Geometry.conditionalDivideFraction(fA, (fB - fA) / this.derivativeH);\r\n        if (dx !== undefined) {\r\n          this._currentStep = dx;\r\n          return true;\r\n        }\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Return the current step size as a relative number. */\r\n  public currentStepSize(): number {\r\n    return Math.abs(this._currentStep / (1.0 + Math.abs(this._currentX)));\r\n  }\r\n}\r\n\r\n/** object to evaluate a 2-parameter newton function (with derivatives!!).\r\n * @internal\r\n */\r\nexport abstract class NewtonEvaluatorRRtoRRD {\r\n  /** Iteration controller calls this to ask for evaluation of the function and its two partial derivatives.\r\n   * * The implemention returns true, it must set the currentF object.\r\n   */\r\n  public abstract evaluate(x: number, y: number): boolean;\r\n  /** most recent function evaluation as xy parts of the plane */\r\n  public currentF!: Plane3dByOriginAndVectors;\r\n  /**\r\n   * constructor.\r\n   * * This creates a crrentF object to (repeatedly) receive function and derivatives.\r\n   */\r\n  public constructor() {\r\n    this.currentF = Plane3dByOriginAndVectors.createXYPlane();\r\n  }\r\n}\r\n\r\n/**\r\n * Implement evaluation steps for newton iteration in 2 dimensions, using caller supplied NewtonEvaluatorRRtoRRD object.\r\n * @internal\r\n */\r\nexport class Newton2dUnboundedWithDerivative extends AbstractNewtonIterator {\r\n  private _func: NewtonEvaluatorRRtoRRD;\r\n  private _currentStep: Vector2d;\r\n  private _currentUV: Point2d;\r\n\r\n  public constructor(func: NewtonEvaluatorRRtoRRD) {\r\n    super();\r\n    this._func = func;\r\n    this._currentStep = Vector2d.createZero();\r\n    this._currentUV = Point2d.createZero();\r\n  }\r\n  /** Set the current uv coordinates for current iteration */\r\n  public setUV(x: number, y: number): boolean { this._currentUV.set(x, y); return true; }\r\n  /** Get the current u coordinate */\r\n  public getU(): number { return this._currentUV.x; }\r\n  /** Get the current v coordinate */\r\n  public getV(): number { return this._currentUV.y; }\r\n  /** Move the currentUV coordiante by currentStep. */\r\n  public applyCurrentStep(): boolean { return this.setUV(this._currentUV.x - this._currentStep.x, this._currentUV.y - this._currentStep.y); }\r\n  /** Evaluate the functions and derivatives at this._currentUV\r\n   * Invert the jacobian and compute the this._currentStep.\r\n   */\r\n  public computeStep(): boolean {\r\n    if (this._func.evaluate(this._currentUV.x, this._currentUV.y)) {\r\n      const fA = this._func.currentF;\r\n      if (SmallSystem.linearSystem2d(\r\n        fA.vectorU.x, fA.vectorV.x,\r\n        fA.vectorU.y, fA.vectorV.y,\r\n        fA.origin.x, fA.origin.y, this._currentStep))\r\n        return true;\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Return the largest relative step of the x,y, components of the current step.\r\n   */\r\n  public currentStepSize(): number {\r\n    return Geometry.maxAbsXY(\r\n      this._currentStep.x / (1.0 + Math.abs(this._currentUV.x)),\r\n      this._currentStep.y / (1.0 + Math.abs(this._currentUV.y)));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/**\r\n * PascalCoeffients class has static methods which return rows of the PascalTriangle.\r\n * @internal\r\n */\r\nexport class PascalCoefficients {\r\n  private static _allRows: Float64Array[] = [];\r\n  /**\r\n   * * return a row of the pascal table.\r\n   * * The contents must not be altered by the user !!!\r\n   * * Hypothetically the request row can be any integer.\r\n   * * BUT in practice, values 60 create integer entries that are too big for IEEE double.\r\n   */\r\n  public static getRow(row: number): Float64Array {\r\n    const allRows = PascalCoefficients._allRows;\r\n    if (allRows.length === 0) {\r\n      // seed the table . . .\r\n      allRows.push(new Float64Array([1]));\r\n      allRows.push(new Float64Array([1, 1]));\r\n      allRows.push(new Float64Array([1, 2, 1]));\r\n      allRows.push(new Float64Array([1, 3, 3, 1]));\r\n      allRows.push(new Float64Array([1, 4, 6, 4, 1]));\r\n      allRows.push(new Float64Array([1, 5, 10, 10, 5, 1]));\r\n      allRows.push(new Float64Array([1, 6, 15, 20, 15, 6, 1]));\r\n      allRows.push(new Float64Array([1, 7, 21, 35, 35, 21, 7, 1]));\r\n    }\r\n\r\n    while (allRows.length <= row) {\r\n      const k = allRows.length;\r\n      const oldRow = allRows[k - 1];\r\n      const newRow = new Float64Array(k + 1);\r\n      newRow[0] = 1.0;\r\n      for (let i = 1; i < k; i++)\r\n        newRow[i] = oldRow[i - 1] + oldRow[i];\r\n      newRow[k] = 1.0;\r\n      allRows.push(newRow);\r\n    }\r\n    return allRows[row];\r\n  }\r\n  /** Return an array with Bezier weighted pascal coefficients\r\n   * @param row row index in the pascal triangle.  (`row+1` entries)\r\n   * @param u parameter value\r\n   * @param result optional destination array.\r\n   * @note if the destination array is undefined or too small, a new Float64Array is allocated.\r\n   * @note if the destination array is larger than needed, its leading `row+1` values are filled,\r\n   *     and the array is returned.\r\n   */\r\n  public static getBezierBasisValues(order: number, u: number, result?: Float64Array): Float64Array {\r\n    const row = order - 1;\r\n    const pascalRow = PascalCoefficients.getRow(row);\r\n    if (result === undefined || result.length < order)\r\n      result = new Float64Array(order);\r\n    for (let i = 0; i < order; i++)\r\n      result[i] = pascalRow[i];\r\n    // multiply by increasing powers of u ...\r\n    let p = u;\r\n    for (let i = 1; i < order; i++ , p *= u) {\r\n      result[i] *= p;\r\n    }\r\n    // multiply by powers of (1-u), working from right\r\n    const v = 1.0 - u;\r\n    p = v;\r\n    for (let i = order - 2; i >= 0; i-- , p *= v) {\r\n      result[i] *= p;\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return an array with derivatives of Bezier weighted pascal coefficients\r\n   * @param row row index in the pascal triangle.  (`row+1` entries)\r\n   * @param u parameter value\r\n   * @param result optional destination array.\r\n   * @note if the destination array is undefined or too small, a new Float64Array is allocated.\r\n   * @note if the destination array is larger than needed, its leading `row+1` values are filled,\r\n   *     and the array is returned.\r\n   */\r\n  public static getBezierBasisDerivatives(order: number, u: number, result?: Float64Array): Float64Array {\r\n    result = this.getBezierBasisValues(order - 1, u, result);\r\n    // derivative is df/du = (order-1 ) * sum ( q[i+1] - q[i])   summed on 0 <= i < order - 1.\\\r\n    // evaluate lower order basis, overwrite in place from right to left\r\n    const f = order - 1;\r\n    result[order - 1] = f * result[order - 2];\r\n    for (let k = order - 2; k > 0; k--) {\r\n      result[k] = f * (result[k - 1] - result[k]);\r\n    }\r\n    result[0] = - f * result[0];\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\n// import { Angle, AngleSweep, Geometry } from \"../Geometry\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { OptionalGrowableFloat64Array, GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\n// import { Arc3d } from \"../curve/Arc3d\";\r\n\r\n/* tslint:disable:variable-name*/\r\n/**\r\n * degree 2 (quadratic) polynomial in for y = c0 + c1*x + c2*x^2\r\n * @internal\r\n */\r\nexport class Degree2PowerPolynomial {\r\n  /** The three coefficients for the quartatic */\r\n  public coffs: number[];\r\n\r\n  constructor(c0: number = 0, c1: number = 0, c2: number = 0) {\r\n    this.coffs = [c0, c1, c2];\r\n  }\r\n\r\n  /**\r\n   * * Return 2 duplicate roots in double root case.\r\n   * @returns 0, 1, or 2 solutions of the usual quadratic (a*x*x + b * x + c = 0)\r\n   */\r\n  public static solveQuadratic(a: number, b: number, c: number): number[] | undefined {\r\n    const b1 = Geometry.conditionalDivideFraction(b, a);\r\n    const c1 = Geometry.conditionalDivideFraction(c, a);\r\n    if (b1 !== undefined && c1 !== undefined) {\r\n      // now solving xx + b1*x + c1 = 0 -- i.e. implied \"a\" coefficient is 1 . .\r\n      const q = b1 * b1 - 4 * c1;\r\n      if (q > 0) {\r\n        const e = Math.sqrt(q);\r\n        // e is positive, so this sorts algebraically\r\n        return [0.5 * (-b1 - e), 0.5 * (-b1 + e)];\r\n      }\r\n      if (q < 0)\r\n        return undefined;\r\n      const root = -0.5 * b1;\r\n      return [root, root];\r\n    }\r\n    // \"divide by a\" failed.  solve bx + c = 0\r\n    const x = Geometry.conditionalDivideFraction(-c, b);\r\n    if (x !== undefined)\r\n      return [x];\r\n    return undefined;\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  public addConstant(a: number) {\r\n    this.coffs[0] += a;\r\n  }\r\n\r\n  /** Add  `s * (a + b*x)^2` to the quadratic coefficients */\r\n  public addSquaredLinearTerm(a: number, b: number, s: number = 1): void {\r\n    this.coffs[0] += s * (a * a);\r\n    this.coffs[1] += s * (2.0 * a * b);\r\n    this.coffs[2] += s * (b * b);\r\n  }\r\n  /** Return the real roots of this polynomial */\r\n  public realRoots(): number[] | undefined {\r\n    const ss = Degree2PowerPolynomial.solveQuadratic(this.coffs[2], this.coffs[1], this.coffs[0]);\r\n    if (ss && ss.length > 1) {\r\n      if (ss[0] > ss[1]) {\r\n        const temp = ss[0];\r\n        ss[0] = ss[1];\r\n        ss[1] = temp;\r\n      }\r\n    }\r\n    return ss;\r\n  }\r\n\r\n  /** Evaluate the quadratic at x. */\r\n  public evaluate(x: number): number {\r\n    return this.coffs[0] + x * (this.coffs[1] + x * this.coffs[2]);\r\n  }\r\n\r\n  /**\r\n   * Evaluate the bezier function at a parameter value.  (i.e. summ the basis functions times coefficients)\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluateDerivative(x: number): number {\r\n    return this.coffs[1] + 2 * x * this.coffs[2];\r\n  }\r\n\r\n  /** Factor the polynomial in to the form `y0 + c * (x-x0)^2)`, i.e. complete the square. */\r\n  public tryGetVertexFactorization(): { x0: number, y0: number, c: number } | undefined {\r\n    const x = Geometry.conditionalDivideFraction(-this.coffs[1], 2.0 * this.coffs[2]);\r\n    if (x !== undefined) {\r\n      const y = this.evaluate(x);\r\n      return { c: this.coffs[2], x0: x, y0: y };\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Construct a quadratic from input form `c2 * (x-root0) * (x-root1)` */\r\n  public static fromRootsAndC2(root0: number, root1: number, c2: number = 1): Degree2PowerPolynomial {\r\n    return new Degree2PowerPolynomial(\r\n      c2 * root0 * root1,\r\n      - c2 * (root0 + root1),\r\n      c2);\r\n  }\r\n\r\n}\r\n/**\r\n * degree 3 (cubic) polynomial in for y = c0 + c1*x + c2*x^2 + c3*x^3\r\n * @internal\r\n */\r\nexport class Degree3PowerPolynomial {\r\n  /** polynomial coefficients, index corresponds to power */\r\n  public coffs: number[];\r\n\r\n  constructor(c0: number = 0, c1: number = 0, c2: number = 0, c3: number = 1) {\r\n    this.coffs = [c0, c1, c2, c3];\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  public addConstant(a: number) {\r\n    this.coffs[0] += a;\r\n  }\r\n\r\n  /** Add `s * (a + b*x)^2` to the cubic */\r\n  public addSquaredLinearTerm(a: number, b: number, s: number = 1): void {\r\n    this.coffs[0] += s * (a * a);\r\n    this.coffs[1] += s * (2.0 * a * b);\r\n    this.coffs[2] += s * (b * b);\r\n  }\r\n\r\n  /**\r\n   * Evaluate the polynomial at x\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluate(x: number): number {\r\n    return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * this.coffs[3]));\r\n  }\r\n\r\n  /**\r\n   * Evaluate the polynomial derivative\r\n   * @param u parameter for evaluation\r\n   */\r\n  public evaluateDerivative(x: number): number {\r\n    return this.coffs[1] + x * (2.0 * this.coffs[2] + x * 3.0 * this.coffs[3]);\r\n  }\r\n  /** Construct a cubic from the form `c3 * (x-root0) * (x - root1) * (x- root2)` */\r\n  public static fromRootsAndC3(root0: number, root1: number, root2: number, c3: number = 1.0): Degree3PowerPolynomial {\r\n    return new Degree3PowerPolynomial(\r\n      -c3 * root0 * root1 * root2,\r\n      c3 * (root0 * root1 + root1 * root2 + root0 * root2),\r\n      - c3 * (root0 + root1 + root2),\r\n      c3);\r\n  }\r\n}\r\n/**\r\n * degree 4 (quartic) polynomial in for y = c0 + c1*x + c2*x^2 + c4*x^4\r\n * @internal\r\n */\r\nexport class Degree4PowerPolynomial {\r\n  /** polynomial coefficients, index corresponds to power */\r\n  public coffs: number[];\r\n\r\n  constructor(c0: number = 0, c1: number = 0, c2: number = 0, c3: number = 0, c4: number = 0) {\r\n    this.coffs = [c0, c1, c2, c3, c4];\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  public addConstant(a: number) {\r\n    this.coffs[0] += a;\r\n  }\r\n\r\n  /**\r\n   * Evaluate the polynomial\r\n   * @param x x coordinate for evaluation\r\n   */\r\n  public evaluate(x: number): number {\r\n    return this.coffs[0] + x * (this.coffs[1] + x * (this.coffs[2] + x * (this.coffs[3] + x * this.coffs[4])));\r\n  }\r\n\r\n  /**\r\n   * Evaluate the derivative\r\n   * @param x x coordinate for evaluation\r\n   */\r\n  public evaluateDerivative(x: number): number {\r\n    return (this.coffs[1] + x * (2.0 * this.coffs[2] + x * (3.0 * this.coffs[3] + x * 4.0 * this.coffs[4])));\r\n  }\r\n\r\n  /** Construct a quartic from the form `c3 * (x-root0) * (x - root1) * (x- root2) * (x-root3)` */\r\n  public static fromRootsAndC4(root0: number, root1: number, root2: number, root3: number, c4: number = 1): Degree4PowerPolynomial {\r\n    return new Degree4PowerPolynomial(\r\n      c4 * (root0 * root1 * root2 * root3),\r\n      -c4 * (root0 * root1 * root2 + root0 * root1 * root3 + root0 * root2 * root3 + root1 * root2 * root3),\r\n      c4 * (root0 * root1 + root0 * root2 + root0 * root3 + root1 * root2 + root1 * root3 + root2 * root3),\r\n      -c4 * (root0 + root1 + root2 + root3),\r\n      c4);\r\n  }\r\n\r\n}\r\n/**\r\n * polynomial services for an implicit torus with\r\n * * z axis is \"through the donut hole\"\r\n * * `majorRadius` is the radius of the circle \"around the z axis\"\r\n * * `minorRadius` is the radius of circles around the major circle\r\n * * for simple xyz the implict form is\r\n *   * `(x^2+y^2+z^2+(R^2-r^2))^2 = 4 R^2(x^2+y^2)`\r\n * * In weighted form\r\n *   * `(x^2+y^2+z^2+(R^2-r^2)w^2)^2 = 4 R^2 w^2 (x^2+y^2)`\r\n * @internal\r\n */\r\nexport class TorusImplicit {\r\n  /** major (xy plane) radius */\r\n  public majorRadius: number;\r\n  /** hoop (perpendicular to major circle) radius */\r\n  public minorRadius: number;\r\n\r\n  constructor(majorRadiusR: number, minorRadiusr: number) {\r\n    this.majorRadius = majorRadiusR;\r\n    this.minorRadius = minorRadiusr;\r\n  }\r\n\r\n  /** Return sum of (absolute) major and minor radii, which is (half) the box size in x and y directions */\r\n  public boxSize() {\r\n    return (Math.abs(this.majorRadius) + Math.abs(this.minorRadius));\r\n  }\r\n  /** Return scale factor appropriate to control the magnitude of the implicit function. */\r\n  public implicitFunctionScale(): number {\r\n    const a = this.boxSize();\r\n    if (a === 0.0)\r\n      return 1.0;\r\n    return 1.0 / (a * a * a * a);\r\n  }\r\n\r\n  /**\r\n   * At space point (x,y,z) evaluate the implicit form of the toruns (See `ImplicitTorus`)\r\n   */\r\n  public evaluateImplicitFunctionXYZ(x: number, y: number, z: number): number {\r\n    const rho2 = x * x + y * y;\r\n    const z2 = z * z;\r\n    const R2 = this.majorRadius * this.majorRadius;\r\n    const r2 = this.minorRadius * this.minorRadius;\r\n    const f = rho2 + z2 + (R2 - r2);\r\n    const g = 4.0 * R2 * rho2;\r\n    return (f * f - g) * this.implicitFunctionScale();\r\n  }\r\n  /** Evaluate the implicit funciton at a point. */\r\n  public evaluateImplicitFunctionPoint(xyz: Point3d): number {\r\n    return this.evaluateImplicitFunctionXYZ(xyz.x, xyz.y, xyz.z);\r\n  }\r\n  /** Evaluate the implicit function at homogeneous coordiantes */\r\n  public evaluateImplicitFunctionXYZW(x: number, y: number, z: number, w: number) {\r\n    const rho2 = x * x + y * y;\r\n    const z2 = z * z;\r\n    const w2 = w * w;\r\n    const R2 = this.majorRadius * this.majorRadius;\r\n    const r2 = this.minorRadius * this.minorRadius;\r\n    const f = rho2 + z2 + w2 * (R2 - r2);\r\n    const g = w2 * 4.0 * R2 * rho2;\r\n    return (f * f - g) * this.implicitFunctionScale();\r\n  }\r\n\r\n  /** Evaluate the surface point at angles (in radians) on the major and minor circles. */\r\n  public evaluateThetaPhi(thetaRadians: number, phiRadians: number): Point3d {\r\n    const c = Math.cos(thetaRadians);\r\n    const s = Math.sin(thetaRadians);\r\n    // theta=0 point\r\n    const x0 = this.majorRadius + this.minorRadius * Math.cos(phiRadians);\r\n    const z0 = this.minorRadius * Math.sin(phiRadians);\r\n    return Point3d.create(c * x0, s * x0, z0);\r\n  }\r\n\r\n  /** Evaluate partial derivatives at angles (int radians) on major and minor circles. */\r\n  public evaluateDerivativesThetaPhi(thetaRadians: number, phiRadians: number, dxdTheta: Vector3d, dxdPhi: Vector3d) {\r\n    const cTheta = Math.cos(thetaRadians);\r\n    const sTheta = Math.sin(thetaRadians);\r\n    const bx = this.minorRadius * Math.cos(phiRadians);\r\n    const bz = this.minorRadius * Math.sin(phiRadians);\r\n    const x0 = this.majorRadius + bx;\r\n    Vector3d.create(-x0 * sTheta, x0 * cTheta, 0.0, dxdTheta);\r\n    Vector3d.create(-cTheta * bz, -sTheta * bz, bx, dxdPhi);\r\n  }\r\n\r\n  /** Evaluate space point at major and minor angles (in radians) and distance from major hoop. */\r\n  public evaluateThetaPhiDistance(thetaRadians: number, phiRadians: number, distance: number): Point3d {\r\n    const c = Math.cos(thetaRadians);\r\n    const s = Math.sin(thetaRadians);\r\n    // theta=0 point\r\n    const x0 = this.majorRadius + distance * Math.cos(phiRadians);\r\n    const z0 = distance * Math.sin(phiRadians);\r\n    return Point3d.create(c * x0, s * x0, z0);\r\n  }\r\n  /** Given an xyz coordinate in the local system of the toroid, compute the torus parametrization\r\n   * * theta = angular coordinate in xy plane\r\n   * * phi = angular coordinate in minor circle.\r\n   * * distance = distance from major circle\r\n   * * rho = distance from origin to xy part of the input.\r\n   * @param xyz space point in local coordinates.\r\n   * @return object with properties theta, phi, distance, rho\r\n   */\r\n  public xyzToThetaPhiDistance(xyz: Point3d): { theta: number, phi: number, distance: number, rho: number, safePhi: boolean } {\r\n    const rho = xyz.magnitudeXY();\r\n    const majorRadiusFactor = Geometry.conditionalDivideFraction(this.majorRadius, rho);\r\n    let safeMajor;\r\n    let majorCirclePoint;\r\n    if (majorRadiusFactor) {\r\n      safeMajor = true;\r\n      majorCirclePoint = Point3d.create(majorRadiusFactor * xyz.x, majorRadiusFactor * xyz.y, 0.0);\r\n    } else {\r\n      safeMajor = false;\r\n      majorCirclePoint = Point3d.create(xyz.x, xyz.y, 0.0);\r\n    }\r\n    const theta = safeMajor ? Math.atan2(xyz.y, xyz.x) : 0.0;\r\n    const vectorFromMajorCircle = Vector3d.createStartEnd(majorCirclePoint, xyz);\r\n    const distance = vectorFromMajorCircle.magnitude();\r\n    const drho = rho - this.majorRadius;\r\n    let safePhi;\r\n    let phi;\r\n    if (xyz.z === 0.0 && drho === 0.0) {\r\n      phi = 0.0;\r\n      safePhi = false;\r\n    } else {\r\n      phi = Math.atan2(xyz.z, drho);\r\n      safePhi = true;\r\n    }\r\n    return { theta: (theta), phi: (phi), distance: (distance), rho: (rho), safePhi: safeMajor && safePhi };\r\n  }\r\n  /*\r\n    public minorCircle(theta: Angle): Arc3d {\r\n      const c = Math.cos(theta.radians);\r\n      const s = Math.sin(theta.radians);\r\n      return Arc3d.create(\r\n        Point3d.create(c * this.majorRadius, s * this.majorRadius, 0.0),\r\n        Vector3d.create(c * this.minorRadius, s * this.minorRadius, 0.0),\r\n        Vector3d.create(0.0, 0.0, this.minorRadius),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n\r\n    public majorCircle(phi: Angle): Arc3d {\r\n      const c = Math.cos(phi.radians);\r\n      const s = Math.sin(phi.radians);\r\n      const a = this.majorRadius + c * this.minorRadius;\r\n      return Arc3d.create(\r\n        Point3d.create(0.0, 0.0, this.minorRadius * s),\r\n        Vector3d.create(a, 0.0, 0.0),\r\n        Vector3d.create(0.0, a, 0.0),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n  */\r\n}\r\n/**\r\n * evaluation methods for an implicit sphere\r\n * * xyz function `x*x + y*y + z*z - r*r = 0`.\r\n * * xyzw function `x*x + y*y + z*z - r*r*w*w = 0`.\r\n * @internal\r\n */\r\nexport class SphereImplicit {\r\n  /** Radius of sphere. */\r\n  public radius: number;\r\n  constructor(r: number) { this.radius = r; }\r\n\r\n  /** Evaluate the implicit function at coordinates x,y,z */\r\n  public evaluateImplicitFunction(x: number, y: number, z: number): number {\r\n    return x * x + y * y + z * z - this.radius * this.radius;\r\n  }\r\n\r\n  /** Evaluate the implicit function at homogeneous coordinates x,y,z,w */\r\n  public evaluateImplicitFunctionXYZW(wx: number, wy: number, wz: number, w: number): number {\r\n    return (wx * wx + wy * wy + wz * wz) - this.radius * this.radius * w * w;\r\n  }\r\n\r\n  /** Given an xyz coordinate in the local system of the toroid, compute the sphere parametrization\r\n   * * theta = angular coordinate in xy plane\r\n   * * phi = rotation from xy plane towards z axis.\r\n   * @param xyz space point in local coordinates.\r\n   * @return object with properties thetaRadians, phi, r\r\n   */\r\n  public xyzToThetaPhiR(xyz: Point3d): { thetaRadians: number, phiRadians: number, r: number, valid: boolean } {\r\n    const rhoSquared = xyz.x * xyz.x + xyz.y * xyz.y;\r\n    const rho = Math.sqrt(rhoSquared);\r\n    const r = Math.sqrt(rhoSquared + xyz.z * xyz.z);\r\n    let theta;\r\n    let phi;\r\n    let valid;\r\n    if (r === 0.0) {\r\n      theta = phi = 0.0;\r\n      valid = false;\r\n    } else {\r\n      phi = Math.atan2(xyz.z, rho); // At least one of these is nonzero\r\n      if (rhoSquared !== 0.0) {\r\n        theta = Math.atan2(xyz.y, xyz.x);\r\n        valid = true;\r\n      } else {\r\n        theta = 0.0;\r\n        valid = false;\r\n      }\r\n    }\r\n    return { thetaRadians: (theta), phiRadians: (phi), r: (r), valid: (valid) };\r\n  }\r\n\r\n  // public intersectRay(ray: Ray3d, maxHit: number): {rayFractions: number, points: Point3d} {\r\n  //   const q = new Degree2PowerPolynomial();\r\n  //   // Ray is (origin.x + s * direction.x, etc)\r\n  //   // squared distance from origin is (origin.x + s*direction.x)^2 + etc\r\n  //   // sphere radius in local system is 1.\r\n  //   q.addSquaredLinearTerm(ray.origin.x, ray.direction.x);\r\n  //   q.addSquaredLinearTerm(ray.origin.y, ray.direction.y);\r\n  //   q.addSquaredLinearTerm(ray.origin.z, ray.direction.z);\r\n  //   q.addConstant(-this.radius * this.radius);\r\n  //   let ss = [];\r\n  //   let n = q.realRoots(ss);\r\n  //   if (n > maxHit)\r\n  //     n = maxHit;\r\n  //   let rayFractions;\r\n  //   let points;\r\n  //   for (let i = 0; i < n; i++) {\r\n  //     rayFractions[i] = ss[i];\r\n  //     points[i] = Point3d. // What is the equivalent of FromSumOf in TS?\r\n  //   }\r\n  /** Compute the point on a sphere at angular coordinates.\r\n   * @param thetaRadians latitude angle\r\n   * @param phiRadians longitude angle\r\n   */\r\n  public evaluateThetaPhi(thetaRadians: number, phiRadians: number): Point3d {\r\n    const rc = this.radius * Math.cos(thetaRadians);\r\n    const rs = this.radius * Math.sin(thetaRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    return Point3d.create(rc * cosPhi, rs * cosPhi, this.radius * sinPhi);\r\n  }\r\n\r\n  /** Compute the derivatives with respect to spherical angles.\r\n   * @param thetaRadians latitude angle\r\n   * @param phiRadians longitude angle\r\n   */\r\n  public evaluateDerivativesThetaPhi(thetaRadians: number, phiRadians: number, dxdTheta: Vector3d, dxdPhi: Vector3d) {\r\n    const rc = this.radius * Math.cos(thetaRadians);\r\n    const rs = this.radius * Math.sin(thetaRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    Vector3d.create(-rs * cosPhi, rc * cosPhi, 0.0, dxdTheta);\r\n    Vector3d.create(-rc * sinPhi, -rs * sinPhi, this.radius * cosPhi, dxdPhi);\r\n  }\r\n  /*\r\n    public meridianCircle(theta: number): Arc3d {\r\n      const rc = this.radius * Math.cos(theta);\r\n      const rs = this.radius * Math.sin(theta);\r\n      return Arc3d.create(\r\n        Point3d.create(0.0, 0.0, 0.0),\r\n        Vector3d.create(rc, rs, 0),\r\n        Vector3d.create(0, 0, this.radius),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n\r\n    public parallelCircle(phi: number): Arc3d {\r\n      const cr = this.radius * Math.cos(phi);\r\n      const sr = this.radius * Math.sin(phi);\r\n      return Arc3d.create(\r\n        Point3d.create(0, 0, sr),\r\n        Vector3d.create(cr, 0, 0),\r\n        Vector3d.create(0, cr, 0),\r\n        AngleSweep.create360()) as Arc3d;\r\n    }\r\n    */\r\n}\r\n/** AnalyticRoots has static methods for solving quadratic, cubic, and quartic equations.\r\n * @internal\r\n *\r\n */\r\nexport class AnalyticRoots {\r\n  private static readonly _EQN_EPS = 1.0e-9;\r\n  private static readonly _safeDivideFactor = 1.0e-14;\r\n  /** Absolute zero test with a tolerance that has worked well for the analytic root use case . . . */\r\n  private static isZero(x: number): boolean {\r\n    return Math.abs(x) < this._EQN_EPS;\r\n  }\r\n  /** Without actually doing a division, test if (x/y) is small.\r\n   * @param x numerator\r\n   * @param y denominator\r\n   * @param abstol absolute tolerance\r\n   * @param reltol relative tolerance\r\n   */\r\n  private static isSmallRatio(x: number, y: number, abstol: number = 1.0e-9, reltol: number = 8.0e-16) {\r\n    return Math.abs(x) <= abstol || Math.abs(x) < reltol * Math.abs(y);\r\n  }\r\n  /** Return the (real, signed) principal cube root of x */\r\n  public static cbrt(x: number): number {\r\n    return ((x) > 0.0\r\n      ? Math.pow((x), 1.0 / 3.0)\r\n      : ((x) < 0.0\r\n        ? -Math.pow(-(x), 1.0 / 3.0)\r\n        : 0.0));\r\n  }\r\n  /**\r\n   * Try to divide `numerator/denominator` and place the result (or defaultValue) in `values[offset]`\r\n   * @param values array of values.  `values[offset]` will be replaced.\r\n   * @param numerator numerator for division.\r\n   * @param denominator denominator for division.\r\n   * @param defaultValue value to save if denominator is too small to divide.\r\n   * @param offset index of value to replace.\r\n   */\r\n  private static safeDivide(values: Float64Array, numerator: number, denominator: number, defaultValue: number = 0.0, offset: number): boolean {\r\n    if (Math.abs(denominator) > (this._safeDivideFactor * Math.abs(numerator))) {\r\n      values[offset] = numerator / denominator;\r\n      return true;\r\n    }\r\n    values[offset] = defaultValue;\r\n    return false;\r\n  }\r\n  // Used in NewtonMethod for testing if a root has been adjusted past its bounding region\r\n  private static checkRootProximity(roots: GrowableFloat64Array, i: number): boolean {\r\n    if (i === 0) { // Case 1: Beginning Root (check root following it)\r\n      return roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1);\r\n    } else if (i > 0 && i + 1 < roots.length) { // Case 2: Middle Root (check roots before and after)\r\n      return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1)) && (roots.atUncheckedIndex(i) < roots.atUncheckedIndex(i + 1));\r\n    } else { // Case 3: End root (check preceding root)\r\n      return (roots.atUncheckedIndex(i) > roots.atUncheckedIndex(i - 1));\r\n    }\r\n  }\r\n  private static newtonMethodAdjustment(coffs: Float64Array | number[], root: number, degree: number): number | undefined {\r\n    let p = coffs[degree];\r\n    let q = 0.0;\r\n    for (let i = degree - 1; i >= 0; i--) {\r\n      q = p + root * q;\r\n      p = coffs[i] + root * p;\r\n    }\r\n    if (Math.abs(q) >= 1.0e-14 * (1.0 + Math.abs(root))) {\r\n      return p / q;\r\n    }\r\n    return undefined;\r\n  }\r\n  private static improveRoots(coffs: Float64Array | number[], degree: number, roots: GrowableFloat64Array, restrictOrderChanges: boolean) {\r\n    const relTol = 1.0e-10;\r\n\r\n    // Loop through each root\r\n    for (let i = 0; i < roots.length; i++) {\r\n      let dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);\r\n      if (dx === undefined || dx === 0.0) continue;  // skip if newton step had divide by zero.\r\n      const originalValue = roots.atUncheckedIndex(i);\r\n      let counter = 0;\r\n      let convergenceCounter = 0;\r\n\r\n      // Loop through applying changes to found root until dx is diminished or counter is hit\r\n      while (dx !== undefined && dx !== 0.0 && (counter < 10)) {\r\n        // consider it converged if two successive iterations satisfy the (not too demanding) tolerance.\r\n        if (Math.abs(dx) < relTol * (1.0 + Math.abs(roots.atUncheckedIndex(i)))) {\r\n          if (++convergenceCounter > 1)\r\n            break;\r\n        } else {\r\n          convergenceCounter = 0;\r\n        }\r\n\r\n        const rootDX = roots.atUncheckedIndex(i) - dx;\r\n        roots.reassign(i, rootDX);\r\n\r\n        // If root is thrown past one of its neighboring roots, unstable condition is assumed.. revert\r\n        // to originally found root\r\n        if (restrictOrderChanges && !this.checkRootProximity(roots, i)) {\r\n          roots.reassign(i, originalValue);\r\n          break;\r\n        }\r\n\r\n        dx = this.newtonMethodAdjustment(coffs, roots.atUncheckedIndex(i), degree);\r\n        counter++;\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Append (if defined) value to results.\r\n   * @param value optional value to append\r\n   * @param results growning array\r\n   */\r\n  private static appendSolution(value: number | undefined, results: GrowableFloat64Array) {\r\n    if (value !== undefined) {\r\n      results.push(value);\r\n    }\r\n  }\r\n  /**\r\n   * Append 2 solutions -- note that both are required args, no option of omitting as in single solution case\r\n   * @param value1\r\n   * @param value2\r\n   * @param results\r\n   */\r\n  private static append2Solutions(valueA: number, valueB: number, results: GrowableFloat64Array) {\r\n    results.push(valueA);\r\n    results.push(valueB);\r\n  }\r\n\r\n  /**\r\n   * If `co/c1` is a safed division, append it to the values array.\r\n   * @param c0 numerator\r\n   * @param c1 denominaotr\r\n   * @param values array to expand\r\n   */\r\n  public static appendLinearRoot(c0: number, c1: number, values: GrowableFloat64Array) {\r\n    AnalyticRoots.appendSolution(Geometry.conditionalDivideFraction(-c0, c1), values);\r\n  }\r\n  /**\r\n   * * Compute the mean of all the entries in `data`\r\n   * * Return the data value that is farthest away\r\n   */\r\n  public static mostDistantFromMean(data: GrowableFloat64Array | undefined): number {\r\n    if (!data || data.length === 0) return 0;\r\n    let a = 0.0;  // to become the sum and finally the average.\r\n    for (let i = 0; i < data.length; i++) a += data.atUncheckedIndex(i);\r\n    a /= data.length;\r\n    let dMax = 0.0;\r\n    let result = data.atUncheckedIndex(0);\r\n    for (let i = 0; i < data.length; i++) {\r\n      const d = Math.abs(data.atUncheckedIndex(i) - a);\r\n      if (d > dMax) {\r\n        dMax = d;\r\n        result = data.atUncheckedIndex(i);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Append 0, 1, or 2 solutions of a quadratic to the values array.\r\n   * @param c array of coefficients for quadratic `c[0] + c[1] * x + c[2] * x*x`\r\n   * @param values array to be expanded.\r\n   */\r\n  public static appendQuadraticRoots(c: Float64Array | number[], values: GrowableFloat64Array) {\r\n    // Normal form: x^2 + 2px + q = 0\r\n\r\n    const divFactor = Geometry.conditionalDivideFraction(1.0, c[2]);\r\n    if (!divFactor) {\r\n      this.appendLinearRoot(c[0], c[1], values);\r\n      return;\r\n    }\r\n\r\n    const p = 0.5 * c[1] * divFactor;\r\n    const q = c[0] * divFactor;\r\n\r\n    const D = p * p - q;\r\n\r\n    if (this.isZero(D)) {\r\n      this.appendSolution(-p, values);\r\n      return;\r\n    } else if (D < 0) {\r\n      return;\r\n    } else if (D > 0) {\r\n      const sqrt_D = Math.sqrt(D);\r\n      this.append2Solutions(sqrt_D - p, - sqrt_D - p, values);\r\n      return;\r\n    }\r\n    return;\r\n  }\r\n  /** Add `a` to the constant term. */\r\n  private static addConstant(value: number, data: GrowableFloat64Array) {\r\n    for (let i = 0; i < data.length; i++) data.reassign(i, data.atUncheckedIndex(i) + value);\r\n  }\r\n  /** return roots of a cubic c0 + c1 *x + c2 * x^2 + c2 * x3.\r\n   * In the usual case where c0 is non-zero, there are either 1 or 3 roots.\r\n   * But if c0 is zero the (0, 1, or 2) roots of the lower order equation\r\n   */\r\n  private static appendCubicRootsUnsorted(c: Float64Array | number[], results: GrowableFloat64Array) {\r\n    let A: number;\r\n    let B: number;\r\n    let C: number;\r\n    let sq_A: number;\r\n    let p: number;\r\n    let q: number;\r\n    let cb_p: number;\r\n    let D: number;\r\n\r\n    // normal form: x^3 + Ax^2 + Bx + C = 0\r\n\r\n    const scaleFactor = Geometry.conditionalDivideFraction(1.0, c[3]);\r\n    if (!scaleFactor) {\r\n      this.appendQuadraticRoots(c, results);\r\n      return;\r\n    }\r\n\r\n    // It is a real cubic.  There MUST be at least one real solution . . .\r\n    A = c[2] * scaleFactor;\r\n    B = c[1] * scaleFactor;\r\n    C = c[0] * scaleFactor;\r\n\r\n    /*  substitute x = y - A/3 to eliminate quadric term:\r\n        f = y^3 +3py + 2q = 0\r\n        f' = 3y^2 + p\r\n            local min/max at Y = +-sqrt (-p)\r\n            f(+Y) = -p sqrt(-p) + 3p sqrt (-p) + 2q = 2 p sqrt (-p) + 2q\r\n    */\r\n    sq_A = A * A;\r\n    p = (3.0 * B - sq_A) / 9.0;\r\n    q = 1.0 / 2 * (2.0 / 27 * A * sq_A - 1.0 / 3 * A * B + C);\r\n\r\n    // Use Cardano's formula\r\n    cb_p = p * p * p;\r\n    D = q * q + cb_p;\r\n    const origin = A / (-3.0);\r\n    if (D >= 0.0 && this.isZero(D)) {\r\n      if (this.isZero(q)) {\r\n        // One triple solution\r\n        results.push(origin);\r\n        results.push(origin);\r\n        results.push(origin);\r\n        return;\r\n      } else {\r\n        // One single and one double solution\r\n        const u = this.cbrt(-q);\r\n        if (u < 0) {\r\n          results.push(origin + 2 * u);\r\n          results.push(origin - u);\r\n          results.push(origin - u);\r\n          return;\r\n        } else {\r\n          results.push(origin - u);\r\n          results.push(origin - u);\r\n          results.push(origin + 2 * u);\r\n          return;\r\n        }\r\n      }\r\n    } else if (D <= 0) {      // Causes irreducibilis: three real solutions\r\n      const phi = 1.0 / 3 * Math.acos(-q / Math.sqrt(-cb_p));\r\n      const t = 2 * Math.sqrt(-p);\r\n      results.push(origin + t * Math.cos(phi));\r\n      results.push(origin - t * Math.cos(phi + Math.PI / 3));\r\n      results.push(origin - t * Math.cos(phi - Math.PI / 3));\r\n      this.improveRoots(c, 3, results, false);\r\n\r\n      return;\r\n    } else {    // One real solution\r\n      const sqrt_D = Math.sqrt(D);\r\n      const u = this.cbrt(sqrt_D - q);\r\n      const v = -(this.cbrt(sqrt_D + q));\r\n      results.push(origin + u + v);\r\n      this.improveRoots(c, 3, results, false);\r\n      return;\r\n    }\r\n  }\r\n  /** Compute roots of cubic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 */\r\n  public static appendCubicRoots(c: Float64Array | number[], results: GrowableFloat64Array) {\r\n    this.appendCubicRootsUnsorted(c, results);\r\n    results.sort();\r\n  }\r\n\r\n  /** Compute roots of quartic 'c[0] + c[1] * x + c[2] * x^2 + c[3] * x^3 + c[4] * x^4 */\r\n  public static appendQuarticRoots(c: Float64Array | number[], results: GrowableFloat64Array) {\r\n    const coeffs = new Float64Array(4); // at various times .. coefficients of quadratic an cubic intermediates.\r\n    let u: number;\r\n    let v: number;\r\n    let A: number;\r\n    let B: number;\r\n    let C: number;\r\n    let D: number;\r\n    let sq_A: number;\r\n    let p: number;\r\n    let q: number;\r\n    let r: number;\r\n\r\n    // normal form: x^4 + Ax^3 + Bx^2 + Cx + D = 0\r\n\r\n    const coffScale = new Float64Array(1);\r\n    if (!this.safeDivide(coffScale, 1.0, c[4], 0.0, 0)) {\r\n      this.appendCubicRoots(c, results);\r\n      return;\r\n    }\r\n    A = c[3] * coffScale[0];\r\n    B = c[2] * coffScale[0];\r\n    C = c[1] * coffScale[0];\r\n    D = c[0] * coffScale[0];\r\n    const origin = -0.25 * A;\r\n    /*  substitute x = y - A/4 to eliminate cubic term:\r\n        x^4 + px^2 + qx + r = 0 */\r\n    sq_A = A * A;\r\n    p = -3.0 / 8 * sq_A + B;\r\n    q = 0.125 * sq_A * A - 0.5 * A * B + C;\r\n    r = -3.0 / 256 * sq_A * sq_A + 1.0 / 16 * sq_A * B - 1.0 / 4 * A * C + D;\r\n\r\n    const tempStack = new GrowableFloat64Array();\r\n\r\n    if (this.isZero(r)) {\r\n\r\n      // no absolute term: y(y^3 + py + q) = 0\r\n      coeffs[0] = q;\r\n      coeffs[1] = p;\r\n      coeffs[2] = 0;\r\n      coeffs[3] = 1;\r\n      this.appendCubicRootsUnsorted(coeffs, results);\r\n      results.push(0); // APPLY ORIGIN ....\r\n      this.addConstant(origin, results);\r\n      return;\r\n    } else {\r\n\r\n      // Solve the resolvent cubic\r\n      coeffs[0] = 1.0 / 2 * r * p - 1.0 / 8 * q * q;\r\n      coeffs[1] = - r;\r\n      coeffs[2] = - 1.0 / 2 * p;\r\n      coeffs[3] = 1;\r\n\r\n      this.appendCubicRootsUnsorted(coeffs, tempStack);\r\n      const z = this.mostDistantFromMean(tempStack);\r\n\r\n      // ... to build two quadric equations\r\n      u = z * z - r;\r\n      v = 2 * z - p;\r\n\r\n      if (this.isSmallRatio(u, r)) {\r\n        u = 0;\r\n      } else if (u > 0) {\r\n        u = Math.sqrt(u);\r\n      } else {\r\n        return;\r\n      }\r\n\r\n      if (this.isSmallRatio(v, p)) {\r\n        v = 0;\r\n      } else if (v > 0) {\r\n        v = Math.sqrt(v);\r\n      } else {\r\n        for (let i = 0; i < tempStack.length; i++) {\r\n          results.push(tempStack.atUncheckedIndex(i));\r\n        }\r\n        return;\r\n      }\r\n\r\n      coeffs[0] = z - u;\r\n      coeffs[1] = ((q < 0) ? (-v) : (v));\r\n      coeffs[2] = 1;\r\n\r\n      this.appendQuadraticRoots(coeffs, results);\r\n\r\n      coeffs[0] = z + u;\r\n      coeffs[1] = ((q < 0) ? (v) : (-v));\r\n      coeffs[2] = 1;\r\n\r\n      this.appendQuadraticRoots(coeffs, results);\r\n    }\r\n\r\n    // resubstitute\r\n    this.addConstant(origin, results);\r\n\r\n    results.sort();\r\n    this.improveRoots(c, 4, results, true);\r\n\r\n    return;\r\n  }\r\n\r\n  private static appendCosSinRadians(c: number, s: number, cosValues: OptionalGrowableFloat64Array, sinValues: OptionalGrowableFloat64Array,\r\n    radiansValues: OptionalGrowableFloat64Array) {\r\n    if (cosValues) cosValues.push(c);\r\n    if (sinValues) sinValues.push(s);\r\n    if (radiansValues) radiansValues.push(Math.atan2(s, c));\r\n  }\r\n\r\n  /**\r\n   * * Solve the simultaneous equations in variables`c` and`s`:\r\n   *   * A line: `alpha + beta*c + gamma*s = 0`\r\n   *   * The unit circle 'c*c + s*s = 1`\r\n   * * Solution values are returned as 0, 1, or 2(c, s) pairs\r\n   * * Return value indicates one of these solution states:\r\n   *   * -2 -- all coefficients identically 0.   The entire c, s plane-- and therefore the entire unit circle-- is a solution.\r\n   *   * -1 -- beta, gamma are zero, alpha is not.There is no line defined.There are no solutions.\r\n   *   * 0 -- the line is well defined, but passes completely outside the unit circle.\r\n   *     * In this case, (c1, s1) is the circle point closest to the line and(c2, s2) is the line point closest to the circle.\r\n   * * 1 -- the line is tangent to the unit circle.\r\n   *   * Tangency is determined by tolerances, which calls a \"close approach\" point a tangency.\r\n   *    * (c1, s1) is the closest circle point\r\n   *    * (c2, s2) is the line point.\r\n   * * 2 -- two simple intersections.\r\n   * @param alpha constant coefficient on line\r\n   * @param beta x cosine coefficient on line\r\n   * @param gamma y sine coefficient on line\r\n   * @param reltol relative tolerance for tangencies\r\n   * @param cosValues (caller allocated) array to receive solution `c` values\r\n   * @param sinValues (caller allocated) array to receive solution `s` values\r\n   * @param radiansValues (caller allocated) array to receive solution radians values.\r\n   */\r\n  public static appendImplicitLineUnitCircleIntersections(alpha: number, beta: number, gamma: number,\r\n    cosValues: OptionalGrowableFloat64Array, sinValues: OptionalGrowableFloat64Array, radiansValues: OptionalGrowableFloat64Array,\r\n    reltol: number = 1.0e-14): number {\r\n\r\n    let twoTol: number;\r\n    const delta2 = beta * beta + gamma * gamma;\r\n    const alpha2 = alpha * alpha;\r\n    let solutionType = 0;\r\n\r\n    if (reltol < 0.0) {\r\n      twoTol = 0.0;\r\n    } else {\r\n      twoTol = 2.0 * reltol;\r\n    }\r\n\r\n    if (delta2 <= 0.0) {\r\n      solutionType = (alpha === 0) ? -2 : -1;\r\n    } else {\r\n      const lambda = - alpha / delta2;\r\n      const a2 = alpha2 / delta2;\r\n      const D2 = 1.0 - a2;\r\n      if (D2 < -twoTol) {\r\n        const delta = Math.sqrt(delta2);\r\n        const iota = (alpha < 0) ? (1.0 / delta) : (-1.0 / delta);\r\n        this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);\r\n        this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);\r\n        solutionType = 0;\r\n      } else if (D2 < twoTol) {\r\n        const delta = Math.sqrt(delta2);\r\n        const iota = (alpha < 0) ? (1.0 / delta) : (- 1.0 / delta);\r\n        this.appendCosSinRadians(lambda * beta, lambda * gamma, cosValues, sinValues, radiansValues);\r\n        this.appendCosSinRadians(beta * iota, gamma * iota, cosValues, sinValues, radiansValues);\r\n        solutionType = 1;\r\n      } else {\r\n        const mu = Math.sqrt(D2 / delta2);\r\n        /* c0,s0 = closest approach of line to origin */\r\n        const c0 = lambda * beta;\r\n        const s0 = lambda * gamma;\r\n        this.appendCosSinRadians(c0 - mu * gamma, s0 + mu * beta, cosValues, sinValues, radiansValues);\r\n        this.appendCosSinRadians(c0 + mu * gamma, s0 - mu * beta, cosValues, sinValues, radiansValues);\r\n        solutionType = 2;\r\n      }\r\n    }\r\n    return solutionType;\r\n  }\r\n}\r\n/**\r\n * manipulations of polynomials with where `coff[i]` multiplies x^i\r\n * @internal\r\n */\r\n\r\nexport class PowerPolynomial {\r\n\r\n  /** Evaluate a standard bais polynomial at `x`, with `degree` possibly less than `coff.length` */\r\n  public static degreeKnownEvaluate(coff: Float64Array, degree: number, x: number): number {\r\n    if (degree < 0) {\r\n      return 0.0;\r\n    }\r\n    let p = coff[degree];\r\n    for (let i = degree - 1; i >= 0; i--)\r\n      p = x * p + coff[i];\r\n    return p;\r\n  }\r\n  /** Evaluate the standard basis polynomial of degree `coff.length` at `x` */\r\n  public static evaluate(coff: Float64Array, x: number): number {\r\n    const degree = coff.length - 1;\r\n    return this.degreeKnownEvaluate(coff, degree, x);\r\n  }\r\n  /**\r\n   * * Accumulate Q*scale into P.Both are treated as full degree.\r\n   * * (Expect Address exceptions if P is smaller than Q)\r\n   * * Returns degree of result as determined by comparing trailing coefficients to zero\r\n   */\r\n  public static accumulate(coffP: Float64Array, coffQ: Float64Array, scaleQ: number): number {\r\n    let degreeP = coffP.length - 1;\r\n    const degreeQ = coffQ.length - 1;\r\n\r\n    for (let i = 0; i <= degreeQ; i++) {\r\n      coffP[i] += scaleQ * coffQ[i];\r\n    }\r\n\r\n    while (degreeP >= 0 && coffP[degreeP] === 0.0) {\r\n      degreeP--;\r\n    }\r\n    return degreeP;\r\n  }\r\n  /** Zero all coefficients */\r\n  public static zero(coff: Float64Array) {\r\n    for (let i = 0; i < coff.length; i++) {\r\n      coff[i] = 0.0;\r\n    }\r\n  }\r\n}\r\n/**\r\n * manipmulation of polynomials with powers of sine and cosine\r\n * @internal\r\n */\r\nexport class TrigPolynomial {\r\n  // tolerance for small angle decision.\r\n  private static readonly _smallAngle: number = 1.0e-11;\r\n\r\n  /** Standard Basis coefficients for rational sine numerator. */\r\n  public static readonly S = Float64Array.from([0.0, 2.0, -2.0]);\r\n  /** Standard Basis coefficients for rational cosine numerator. */\r\n  public static readonly C = Float64Array.from([1.0, -2.0]);\r\n  /** Standard Basis coefficients for rational denominator. */\r\n  public static readonly W = Float64Array.from([1.0, -2.0, 2.0]);\r\n  /** Standard Basis coefficients for cosine*weight numerator */\r\n  public static readonly CW = Float64Array.from([1.0, -4.0, 6.0, -4.0]);\r\n  /** Standard Basis coefficients for sine*weight numerator */\r\n  public static readonly SW = Float64Array.from([0.0, 2.0, -6.0, 8.0, -4.0]);\r\n  /** Standard Basis coefficients for sine*cosine numerator */\r\n  public static readonly SC = Float64Array.from([0.0, 2.0, -6.0, 4.0]);\r\n  /** Standard Basis coefficients for sine^2 numerator */\r\n  public static readonly SS = Float64Array.from([0.0, 0.0, 4.0, -8.0, 4.0]);\r\n  /** Standard Basis coefficients for cosine^2 numerator */\r\n  public static readonly CC = Float64Array.from([1.0, -4.0, 4.0]);\r\n  /** Standard Basis coefficients for weight^2 */\r\n  public static readonly WW = Float64Array.from([1.0, -4.0, 8.0, -8.0, 4.0]);\r\n  /** Standard Basis coefficients for (Math.Cos^2 - sine^2) numerator */\r\n  public static readonly CCminusSS = Float64Array.from([1.0, -4.0, 0.0, 8.0, -4.0]);\r\n\r\n  /**\r\n   *  Solve a polynomial created from trigonometric condition using\r\n   * Trig.S, Trig.C, Trig.W.  Solution logic includes inferring angular roots\r\n   * corresponding zero leading coefficients (roots at infinity)\r\n   * @param coff Coefficients\r\n   * @param nominalDegree degree of the polynomial under most complex\r\n   *     root case.  If there are any zero coefficients up to this degree, a single root\r\n   *     \"at infinity\" is recorded as its corresponding angular parameter at negative pi/2\r\n   * @param referenceCoefficient A number which represents the size of coefficients\r\n   *     at various stages of computation.  A small fraction of this will be used as a zero\r\n   *     tolerance\r\n   * @param angles Roots are placed here. Assumed preallocated with adequate size.\r\n   * @param numRoots Number of roots  .  Zero roots is possible. (Passed as array of size\r\n   * one to pass-by-reference)\r\n   * Returns false if equation is all zeros.   This usually means any angle is a solution.\r\n   */\r\n  public static solveAngles(coff: Float64Array, nominalDegree: number, referenceCoefficient: number,\r\n    radians: number[]): boolean {\r\n    let maxCoff = Math.abs(referenceCoefficient);\r\n    let a;\r\n    radians.length = 0;\r\n    const relTol = this._smallAngle;\r\n\r\n    for (let i = 0; i <= nominalDegree; i++) {\r\n      a = Math.abs(coff[i]);\r\n      if (a > maxCoff) {\r\n        maxCoff = a;\r\n      }\r\n    }\r\n    const coffTol = relTol * maxCoff;\r\n    let degree = nominalDegree;\r\n    while (degree > 0 && (Math.abs(coff[degree]) <= coffTol)) {\r\n      degree--;\r\n    }\r\n    // let bstat = false;\r\n    const roots = new GrowableFloat64Array();\r\n    if (degree === -1) {\r\n      // Umm.   Dunno.   Nothing there.\r\n      // bstat = false;\r\n    } else {\r\n      // bstat = true;\r\n      if (degree === 0) {\r\n        // p(t) is a nonzero constant\r\n        // No roots, but not degenerate.\r\n        // bstat = true;\r\n      } else if (degree === 1) {\r\n        // p(t) = coff[1] * t + coff[0]...\r\n        roots.push(- coff[0] / coff[1]);\r\n      } else if (degree === 2) {\r\n        AnalyticRoots.appendQuadraticRoots(coff, roots);\r\n      } else if (degree === 3) {\r\n        AnalyticRoots.appendCubicRoots(coff, roots);\r\n      } else if (degree === 4) {\r\n        AnalyticRoots.appendQuarticRoots(coff, roots);\r\n      } else {\r\n        // TODO: WILL WORK WITH BEZIER SOLVER\r\n        // bstat = false;\r\n      }\r\n      if (roots.length > 0) {\r\n        // Each solution t represents an angle with\r\n        //  Math.Cos(theta)=C(t)/W(t),  ,sin(theta)=S(t)/W(t)\r\n        // Division by W has no effect on Atan2 calculations, so we just compute S(t),C(t)\r\n        for (let i = 0; i < roots.length; i++) {\r\n          const ss = PowerPolynomial.evaluate(this.S, roots.atUncheckedIndex(i));\r\n          const cc = PowerPolynomial.evaluate(this.C, roots.atUncheckedIndex(i));\r\n          radians.push(Math.atan2(ss, cc));\r\n        }\r\n\r\n        // Each leading zero at the front of the coefficients corresponds to a root at -PI/2.\r\n        // Only make one entry....\r\n        // for (int i = degree; i < nominalDegree; i++)\r\n        if (degree < nominalDegree) {\r\n          radians.push(-0.5 * Math.PI);\r\n        }\r\n      }\r\n    }\r\n    return radians.length > 0;\r\n  }\r\n  private static readonly _coeffientRelTol = 1.0e-12;\r\n  /**\r\n   * Compute intersections of unit circle `x ^ 2 + y 2 = 1` with general quadric\r\n   * `axx * x ^ 2 + axy * x * y + ayy * y ^ 2 + ax * x + ay * y + a1 = 0`\r\n   * Solutions are returned as angles.Sine and Cosine of the angles are the x, y results.\r\n   * @param axx  Coefficient of x ^ 2\r\n   * @param axy  Coefficient of xy\r\n   * @param ayy  Coefficient of y ^ 2\r\n   * @param ax  Coefficient of x\r\n   * @param ay  Coefficient of y\r\n   * @param a1  Constant coefficient\r\n   * @param angles  solution angles\r\n   * @param numAngle  number of solution angles(Passed as array to make changes to reference)\r\n   */\r\n  public static solveUnitCircleImplicitQuadricIntersection(axx: number, axy: number, ayy: number,\r\n    ax: number, ay: number, a1: number, radians: number[]): boolean {\r\n    const Coffs = new Float64Array(5);\r\n    PowerPolynomial.zero(Coffs);\r\n    let degree = 2;\r\n    if (Math.hypot(axx, axy, ayy) > TrigPolynomial._coeffientRelTol * Math.hypot(ax, ay, a1)) {\r\n      PowerPolynomial.accumulate(Coffs, this.CW, ax);\r\n      PowerPolynomial.accumulate(Coffs, this.SW, ay);\r\n      PowerPolynomial.accumulate(Coffs, this.WW, a1);\r\n      PowerPolynomial.accumulate(Coffs, this.SS, ayy);\r\n      PowerPolynomial.accumulate(Coffs, this.CC, axx);\r\n      PowerPolynomial.accumulate(Coffs, this.SC, axy);\r\n      degree = 4;\r\n    } else {\r\n      PowerPolynomial.accumulate(Coffs, this.C, ax);\r\n      PowerPolynomial.accumulate(Coffs, this.S, ay);\r\n      PowerPolynomial.accumulate(Coffs, this.W, a1);\r\n      degree = 2;\r\n    }\r\n\r\n    let maxCoff = 0.0;\r\n    maxCoff = Math.max(maxCoff,\r\n      Math.abs(axx),\r\n      Math.abs(ayy),\r\n      Math.abs(axy),\r\n      Math.abs(ax),\r\n      Math.abs(ay),\r\n      Math.abs(a1));\r\n\r\n    const b = this.solveAngles(Coffs, degree, maxCoff, radians);\r\n    /*\r\n    for (const theta of angles) {\r\n      const c = theta.cos();\r\n      const s = theta.sin();\r\n      console.log({\r\n        angle: theta, co: c, si: s,\r\n        f: axx * c * c + axy * c * s + ayy * s * s + ax * c + ay * s + a1});\r\n  } */\r\n\r\n    return b;\r\n  }\r\n  /**\r\n   * Compute intersections of unit circle x^2 + y 2 = 1 with the ellipse\r\n   *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)\r\n   * Solutions are returned as angles in the ellipse space.\r\n   * @param cx center x\r\n   * @param cy center y\r\n   * @param ux 0 degree vector x\r\n   * @param uy 0 degree vector y\r\n   * @param vx 90 degree vector x\r\n   * @param vy 90 degree vector y\r\n   * @param ellipseRadians solution angles in ellipse parameter space\r\n   * @param circleRadians solution angles in circle parameter space\r\n   */\r\n  public static solveUnitCircleEllipseIntersection(cx: number, cy: number, ux: number, uy: number,\r\n    vx: number, vy: number, ellipseRadians: number[], circleRadians: number[]): boolean {\r\n    circleRadians.length = 0;\r\n    const acc = ux * ux + uy * uy;\r\n    const acs = 2.0 * (ux * vx + uy * vy);\r\n    const ass = vx * vx + vy * vy;\r\n    const ac = 2.0 * (ux * cx + uy * cy);\r\n    const asi = 2.0 * (vx * cx + vy * cy);\r\n    const a = cx * cx + cy * cy - 1.0;\r\n    const boolstat = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);\r\n    for (const radians of ellipseRadians) {\r\n      const cc = Math.cos(radians);\r\n      const ss = Math.sin(radians);\r\n      const x = cx + ux * cc + vx * ss;\r\n      const y = cy + uy * cc + vy * ss;\r\n      circleRadians.push(Math.atan2(y, x));\r\n    }\r\n    return boolstat;\r\n  }\r\n  /**\r\n   * Compute intersections of unit circle x^2 + y 2 = w^2 with the ellipse\r\n   *         (x,y) = (cx + ux Math.Cos + vx sin, cy + uy Math.Cos + vy sin)/ (cw + uw Math.Cos + vw * Math.Sin)\r\n   * Solutions are returned as angles in the ellipse space.\r\n   * @param cx center x\r\n   * @param cy center y\r\n   * @param cw center w\r\n   * @param ux 0 degree vector x\r\n   * @param uy 0 degree vector y\r\n   * @param uw 0 degree vector w\r\n   * @param vx 90 degree vector x\r\n   * @param vy 90 degree vector y\r\n   * @param vw 90 degree vector w\r\n   * @param ellipseRadians solution angles in ellipse parameter space\r\n   * @param circleRadians solution angles in circle parameter space\r\n   */\r\n  public static solveUnitCircleHomogeneousEllipseIntersection(cx: number, cy: number, cw: number,\r\n    ux: number, uy: number, uw: number,\r\n    vx: number, vy: number, vw: number,\r\n    ellipseRadians: number[], circleRadians: number[]): boolean {\r\n    circleRadians.length = 0;\r\n    const acc = ux * ux + uy * uy - uw * uw;\r\n    const acs = 2.0 * (ux * vx + uy * vy - uw * vw);\r\n    const ass = vx * vx + vy * vy - vw * vw;\r\n    const ac = 2.0 * (ux * cx + uy * cy - uw * cw);\r\n    const asi = 2.0 * (vx * cx + vy * cy - vw * cw);\r\n    const a = cx * cx + cy * cy - cw * cw;\r\n    const boolstat = this.solveUnitCircleImplicitQuadricIntersection(acc, acs, ass, ac, asi, a, ellipseRadians);\r\n    for (const radians of ellipseRadians) {\r\n      const cc = Math.cos(radians);\r\n      const ss = Math.sin(radians);\r\n      const x = cx + ux * cc + vx * ss;\r\n      const y = cy + uy * cc + vy * ss;\r\n      circleRadians.push(Math.atan2(y, x));\r\n    }\r\n    return boolstat;\r\n  }\r\n}\r\n/**\r\n * static methods for commonly appearing sets of equations in 2 or 3 variables\r\n * @public\r\n */\r\nexport class SmallSystem {\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have a simple intersection.\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param a0 start point of line a\r\n   * @param a1  end point of line a\r\n   * @param b0  start point of line b\r\n   * @param b1 end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment2dXYTransverseIntersectionUnbounded(a0: Point2d, a1: Point2d, b0: Point2d, b1: Point2d,\r\n    result: Vector2d): boolean {\r\n    const ux = a1.x - a0.x;\r\n    const uy = a1.y - a0.y;\r\n\r\n    const vx = b1.x - b0.x;\r\n    const vy = b1.y - b0.y;\r\n\r\n    const cx = b0.x - a0.x;\r\n    const cy = b0.y - a0.y;\r\n\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, -t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param a0 start point of line a\r\n   * @param a1  end point of line a\r\n   * @param b0  start point of line b\r\n   * @param b1 end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment3dXYTransverseIntersectionUnbounded(a0: Point3d, a1: Point3d, b0: Point3d, b1: Point3d,\r\n    result: Vector2d): boolean {\r\n    const ux = a1.x - a0.x;\r\n    const uy = a1.y - a0.y;\r\n\r\n    const vx = b1.x - b0.x;\r\n    const vy = b1.y - b0.y;\r\n\r\n    const cx = b0.x - a0.x;\r\n    const cy = b0.y - a0.y;\r\n\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, -t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have a simple intersection using only xy parts of WEIGHTED 4D Points\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param hA0 homogeneous start point of line a\r\n   * @param hA1 homogeneous end point of line a\r\n   * @param hB0 homogeneous start point of line b\r\n   * @param hB1 homogeneous end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment3dHXYTransverseIntersectionUnbounded(hA0: Point4d, hA1: Point4d, hB0: Point4d, hB1: Point4d, result?: Vector2d): Vector2d | undefined {\r\n    // Considering only x,y,w parts....\r\n    // Point Q along B is (in full homogeneous)  `(1-lambda) B0 + lambda 1`\r\n    // PointQ is colinear with A0,A1 when the determinat det (A0,A1,Q) is zero.  (Each column takes xyw parts)\r\n    const alpha0 = Geometry.tripleProduct(\r\n      hA0.x, hA1.x, hB0.x,\r\n      hA0.y, hA1.y, hB0.y,\r\n      hA0.w, hA1.w, hB0.w);\r\n    const alpha1 = Geometry.tripleProduct(\r\n      hA0.x, hA1.x, hB1.x,\r\n      hA0.y, hA1.y, hB1.y,\r\n      hA0.w, hA1.w, hB1.w);\r\n    const fractionB = Geometry.conditionalDivideFraction(-alpha0, alpha1 - alpha0);\r\n    if (fractionB !== undefined) {\r\n      const beta0 = Geometry.tripleProduct(\r\n        hB0.x, hB1.x, hA0.x,\r\n        hB0.y, hB1.y, hA0.y,\r\n        hB0.w, hB1.w, hA0.w);\r\n      const beta1 = Geometry.tripleProduct(\r\n        hB0.x, hB1.x, hA1.x,\r\n        hB0.y, hB1.y, hA1.y,\r\n        hB0.w, hB1.w, hA1.w);\r\n      const fractionA = Geometry.conditionalDivideFraction(-beta0, beta1 - beta0);\r\n      if (fractionA !== undefined)\r\n        return Vector2d.create(fractionA, fractionB, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Return the line fraction at which the (homogeneous) line is closest to a space point as viewed in xy only.\r\n   * @param hA0 homogeneous start point of line a\r\n   * @param hA1 homogeneous end point of line a\r\n   * @param spacePoint homogeneous point in space\r\n   */\r\n  public static lineSegment3dHXYClosestPointUnbounded(hA0: Point4d, hA1: Point4d, spacePoint: Point4d): number | undefined {\r\n    // Considering only x,y,w parts....\r\n    // weighted difference of (A1 w0 - A0 w1) is (cartesian) tangent vector along the line as viewed.\r\n    // The perpendicular (pure vector) W = (-y,x) flip is the direction of projection\r\n    // Point Q along A is (in full homogeneous)  `(1-lambda) A0 + lambda 1 A1`\r\n    // PointQ is colinear with spacePoint and and W when the xyw homogeneous determinant | Q W spacePoint | is zero.\r\n    const tx = hA1.x * hA0.w - hA0.x * hA1.w;\r\n    const ty = hA1.y * hA0.w - hA0.y * hA1.w;\r\n    const det0 = Geometry.tripleProduct(\r\n      hA0.x, -ty, spacePoint.x,\r\n      hA0.y, tx, spacePoint.y,\r\n      hA0.w, 0, spacePoint.w);\r\n    const det1 = Geometry.tripleProduct(\r\n      hA1.x, -ty, spacePoint.x,\r\n      hA1.y, tx, spacePoint.y,\r\n      hA1.w, 0, spacePoint.w);\r\n    return Geometry.conditionalDivideFraction(-det0, det1 - det0);\r\n  }\r\n\r\n  /**\r\n   * Return the line fraction at which the line is closest to a space point as viewed in xy only.\r\n   * @param pointA0 start point\r\n   * @param pointA1 end point\r\n   * @param spacePoint homogeneous point in space\r\n   */\r\n  public static lineSegment3dXYClosestPointUnbounded(pointA0: Point3d, pointA1: Point3d, spacePoint: Point3d): number | undefined {\r\n    // Considering only x,y parts....\r\n    const ux = pointA1.x - pointA0.x;\r\n    const uy = pointA1.y - pointA0.y;\r\n    const uu = ux * ux + uy * uy;\r\n    const vx = spacePoint.x - pointA0.x;\r\n    const vy = spacePoint.y - pointA0.y;\r\n    const uv = ux * vx + uy * vy;\r\n    return Geometry.conditionalDivideFraction(uv, uu);\r\n  }\r\n\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d\r\n   * Return the fractional (not xy) coordinates in result.x, result.y\r\n   * @param a0 start point of line a\r\n   * @param a1  end point of line a\r\n   * @param b0  start point of line b\r\n   * @param b1 end point of line b\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static lineSegment3dClosestApproachUnbounded(a0: Point3d, a1: Point3d, b0: Point3d, b1: Point3d,\r\n    result: Vector2d): boolean {\r\n    return this.ray3dXYZUVWClosestApproachUnbounded(\r\n      a0.x, a0.y, a0.z,\r\n      a1.x - a0.x, a1.y - a0.y, a1.z - a0.z,\r\n      b0.x, b0.y, b0.z,\r\n      b1.x - b0.x, b1.y - b0.y, b1.z - b0.z,\r\n      result);\r\n  }\r\n  /**\r\n   * Return true if lines (a0,a1) to (b0, b1) have closest approach (go by each other) in 3d\r\n   * Return the fractional (not xy) coordinates as x and y parts of a Point2d.\r\n   * @param result point to receive fractional coordinates of intersection.   result.x is fraction on line a. result.y is fraction on line b.\r\n   */\r\n  public static ray3dXYZUVWClosestApproachUnbounded(\r\n    ax: number, ay: number, az: number, au: number, av: number, aw: number,\r\n    bx: number, by: number, bz: number, bu: number, bv: number, bw: number,\r\n    result: Vector2d): boolean {\r\n\r\n    const cx = bx - ax;\r\n    const cy = by - ay;\r\n    const cz = bz - az;\r\n\r\n    const uu = Geometry.hypotenuseSquaredXYZ(au, av, aw);\r\n    const vv = Geometry.hypotenuseSquaredXYZ(bu, bv, bw);\r\n    const uv = Geometry.dotProductXYZXYZ(au, av, aw, bu, bv, bw);\r\n    const cu = Geometry.dotProductXYZXYZ(cx, cy, cz, au, av, aw);\r\n    const cv = Geometry.dotProductXYZXYZ(cx, cy, cz, bu, bv, bw);\r\n    return SmallSystem.linearSystem2d(uu, -uv, uv, -vv, cu, cv, result);\r\n  }\r\n  /**\r\n   * Solve the pair of linear equations\r\n   * * `ux * x + vx + y = cx`\r\n   * * `uy * x + vy * y = cy`\r\n   * @param ux xx coefficient\r\n   * @param vx xy coefficient\r\n   * @param uy yx coefficient\r\n   * @param vy yy ceofficient\r\n   * @param cx x right hand side\r\n   * @param cy y right hand side\r\n   * @param result (x,y) solution.  (MUST be preallocated by caller)\r\n   */\r\n  public static linearSystem2d(\r\n    ux: number, vx: number, // first row of matrix\r\n    uy: number, vy: number, // second row of matrix\r\n    cx: number, cy: number, // right side\r\n    result: Vector2d): boolean {\r\n    const uv = Geometry.crossProductXYXY(ux, uy, vx, vy);\r\n    const cv = Geometry.crossProductXYXY(cx, cy, vx, vy);\r\n    const cu = Geometry.crossProductXYXY(ux, uy, cx, cy);\r\n    const s = Geometry.conditionalDivideFraction(cv, uv);\r\n    const t = Geometry.conditionalDivideFraction(cu, uv);\r\n    if (s !== undefined && t !== undefined) {\r\n      result.set(s, t);\r\n      return true;\r\n    }\r\n    result.set(0, 0);\r\n    return false;\r\n  }\r\n  /**\r\n   * Solve a linear system\r\n   * * x equation: `ux *u * vx * v + wx * w = cx`\r\n   * * y equation: `uy *u * vy * v + wy * w = cy`\r\n   * * z equation: `uz *u * vz * v + wz * w = cz`\r\n   * @param axx row 0, column 0 coefficient\r\n   * @param axy row 0, column 1 coefficient\r\n   * @param axz row 0, column 1 coefficient\r\n   * @param ayx row 1, column 0 coefficient\r\n   * @param ayy row 1, column 1 coefficient\r\n   * @param ayz row 1, column 2 coefficient\r\n   * @param azx row 2, column 0 coefficient\r\n   * @param azy row 2, column 1 coefficient\r\n   * @param azz row 2, column 2 coefficient\r\n   * @param cx right hand side row 0 coefficient\r\n   * @param cy right hand side row 1 coefficient\r\n   * @param cz right hand side row 2 coeficient\r\n   * @param result optional result.\r\n   */\r\n  public static linearSystem3d(\r\n    axx: number, axy: number, axz: number, // first row of matrix\r\n    ayx: number, ayy: number, ayz: number, // second row of matrix\r\n    azx: number, azy: number, azz: number, // second row of matrix\r\n    cx: number, cy: number, cz: number, // right side\r\n    result?: Vector3d): Vector3d | undefined {\r\n    // determinants of various combinations of columns ...\r\n    const detXYZ = Geometry.tripleProduct(axx, ayx, azx, axy, ayy, azy, axz, ayz, azz);\r\n    const detCYZ = Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, axz, ayz, azz);\r\n    const detXCZ = Geometry.tripleProduct(axx, ayx, azx, cx, cy, cz, axz, ayz, azz);\r\n    const detXYC = Geometry.tripleProduct(cx, cy, cz, axy, ayy, azy, cx, cy, cz);\r\n    const s = Geometry.conditionalDivideFraction(detCYZ, detXYZ);\r\n    const t = Geometry.conditionalDivideFraction(detXCZ, detXYZ);\r\n    const u = Geometry.conditionalDivideFraction(detXYC, detXYZ);\r\n    if (s !== undefined && t !== undefined && t !== undefined) {\r\n      return Vector3d.create(s, t, u, result);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\n/** Support class for quadrature -- approximate integrals by summing weighted function values.\r\n * These are filled with x and weight for quadrature between xA and xB\r\n *\r\n * Since quadrature is done in side tight loops, these methods are structured for minimum object\r\n * allocation.\r\n * For methods names setupGauss<N> (where N is a smallish integer), the CALLER creates arrays xMapped and wMapped\r\n * The method installs particular x and weight values.\r\n * @internal\r\n */\r\nexport class Quadrature {\r\n  /** x value for 1 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX1Interval01 = new Float64Array([0.5]);\r\n  /** weight for 1 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW1Interval01 = new Float64Array([1.0]);\r\n\r\n  /** x value for 2 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX2Interval01 = new Float64Array([0.21132486540518708, 0.7886751345948129]);\r\n  /** weight for 2 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW2Interval01 = new Float64Array([0.5, 0.5]);\r\n\r\n  /** x value for 3 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX3Interval01 = new Float64Array([0.1127016653792583, 0.5, 0.8872983346207417]);\r\n  /** weight for 3 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW3Interval01 = new Float64Array([0.2777777777777778, 0.4444444444444444, 0.2777777777777778]);\r\n\r\n  /** x value for 4 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX4Interval01 = new Float64Array([0.06943184420297371, 0.33000947820757187, 0.6699905217924281, 0.9305681557970262]);\r\n  /** weight for 4 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW4Interval01 = new Float64Array([0.17392742256872692, 0.3260725774312731, 0.3260725774312731, 0.17392742256872692]);\r\n\r\n  /** x value for 5 point gauss rule in 0..1 interval */\r\n  public static readonly gaussX5Interval01 = new Float64Array([0.04691007703066802, 0.23076534494715845, 0.5, 0.7692346550528415, 0.9530899229693319]);\r\n  /** weight for 5 point gauss rule in 0..1 interval */\r\n  public static readonly gaussW5Interval01 = new Float64Array([0.11846344252809454, 0.23931433524968324, 0.28444444444444444, 0.23931433524968324, 0.11846344252809454]);\r\n\r\n  /**\r\n   * Given points and weights in a reference interval (usually 0 to 1):\r\n   *\r\n   * * map each xRef[i] to xA + h * xRef[i];\r\n   * * scale each weight wRef[i] to h * wRef[i]\r\n   * * all arrays are assumed to have xRef.length entries.\r\n   * * the return value is xRef.length\r\n   * @param xA beginning of target interval\r\n   * @param h length of target interval\r\n   * @param xRef x coordinates in reference interval\r\n   * @param wRef weights for integration in the reference interval\r\n   * @param xMapped x coordinates to evaluate integrands\r\n   * @param wMapped weights for evaluated integrands\r\n   */\r\n  public static mapWeights(xA: number, h: number, xRef: Float64Array, wRef: Float64Array, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    const n = xRef.length;\r\n    for (let i = 0; i < n; i++) {\r\n      xMapped[i] = xA + h * xRef[i];\r\n      wMapped[i] = h * wRef[i];\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /** Install 1 (ONE) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss1(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX1Interval01, Quadrature.gaussW1Interval01, xMapped, wMapped);\r\n  }\r\n\r\n  /** Install 2 (TWO) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss2(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX2Interval01, Quadrature.gaussW2Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\n        const x0 = 0.5 * (xA + xB);\r\n            const h = 0.5 * (xB - xA);\r\n            const dx = h / Math.sqrt(3);\r\n            xMapped[0] = x0 - dx; xMapped[1] = x0 + dx;\r\n            wMapped[0] = wMapped[1] = h;\r\n            */\r\n  }\r\n  /** Install 3 (THREE) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss3(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX3Interval01, Quadrature.gaussW3Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\n    const x0 = 0.5 * (xA + xB);\r\n    const h = 0.5 * (xB - xA);\r\n    const a = Math.sqrt(0.6);\r\n    const b = h * 5.0 / 9.0;\r\n    const dx = a * h;\r\n    xMapped[0] = x0 - dx; xMapped[1] = x0; xMapped[2] = x0 + dx;\r\n    wMapped[0] = wMapped[2] = b;\r\n    wMapped[1] = h * 8.0 / 9.0;\r\n    return 3;\r\n    */\r\n  }\r\n\r\n  /** Install 5 (FIVE) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss5(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX5Interval01, Quadrature.gaussW5Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\n    const x0 = 0.5 * (xA + xB);\r\n    const h = 0.5 * (xB - xA);\r\n    const q = 2.0 * Math.sqrt(10.0 / 7.0);\r\n    const b = 13.0 * Math.sqrt(70.0);\r\n    const a1 = h * Math.sqrt(5.0 - q) / 3.0;\r\n    const a2 = h * Math.sqrt(5.0 + q) / 3.0;\r\n    const w1 = h * (322.0 + b) / 900.0;\r\n    const w2 = h * (322.0 - b) / 900;\r\n    const w0 = h * 128.0 / 225.0;\r\n    xMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0; xMapped[3] = x0 + a1; xMapped[4] = x0 + a2;\r\n    wMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w0; wMapped[3] = w1; wMapped[4] = w2;\r\n    return 5;\r\n    */\r\n  }\r\n\r\n  /** Install 4 (FOUR) x and weight values for quadrature from xA to xB. */\r\n  public static setupGauss4(xA: number, xB: number, xMapped: Float64Array, wMapped: Float64Array): number {\r\n    return Quadrature.mapWeights(xA, xB - xA, Quadrature.gaussX4Interval01, Quadrature.gaussW4Interval01, xMapped, wMapped);\r\n    /*  // exact formulas for interval xA..xB:\r\nconst x0 = 0.5 * (xA + xB);\r\nconst h = 0.5 * (xB - xA);\r\nconst q = 2.0 * Math.sqrt(6.0 / 5.0);\r\nconst r = Math.sqrt(30.0);\r\nconst a1 = h * Math.sqrt((3 - q) / 7.0);\r\nconst w1 = h * (18.0 + r) / 36.0;\r\nconst a2 = h * Math.sqrt((3 + q) / 7.0);\r\nconst w2 = h * (18.0 - r) / 36.0;\r\nxMapped[0] = x0 - a2; xMapped[1] = x0 - a1; xMapped[2] = x0 + a1; xMapped[3] = x0 + a2;\r\nwMapped[0] = w2; wMapped[1] = w1; wMapped[2] = w1; wMapped[3] = w2;\r\nreturn 4;\r\n*/\r\n  }\r\n  /** Sum function values with given weghts and x values. */\r\n  public static sum1(\r\n    xx: Float64Array,\r\n    ww: Float64Array,\r\n    n: number,\r\n    f: (x: number) => number): number {\r\n    let sum = 0;\r\n    for (let i = 0; i < n; i++)sum += ww[i] * f(xx[i]);\r\n    return sum;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Geometry } from \"../Geometry\";\r\n/**\r\n * A Range1d array is a set of intervals, such as occur when a line is clipped to a (nonconvex) polygon\r\n * @internal\r\n */\r\nexport class Range1dArray {\r\n  /** Internal step: Caller supplies rangeA = interval from left operand of set difference {A - B}\r\n   *  ib = lowest possible index of overlapping interval of {B}\r\n   *  Output live parts of rangeA, advancing B over intervals that do not extend beyond {rangeA}\r\n   *  iB is advanced to the first interval whose high is to the right of {rangeA.high}\r\n   */\r\n  private static advanceIntervalDifference(rangeA: Range1d, dataB: Range1d[], iB: number, retVal: Range1d[]) {\r\n    const nB = dataB.length;\r\n    let low = rangeA.low;\r\n    let high = rangeA.high;\r\n    while (iB < nB) {\r\n      const rangeB = dataB[iB];\r\n      if (rangeB.high < low) {\r\n        iB++;\r\n      } else if (rangeB.high <= high) {\r\n        if (rangeB.low > low)\r\n          retVal.push(Range1d.createXX(low, rangeB.low));\r\n        low = rangeB.high;\r\n        iB++;\r\n      } else {\r\n        // B ends beyond rangeA...\r\n        if (rangeB.low < high)\r\n          high = rangeB.low;\r\n        break;\r\n      }\r\n    }\r\n\r\n    if (low < high)\r\n      retVal.push(Range1d.createXX(low, high));\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Intersect intervals in two pre-sorted sets. Output may NOT be the same as either input. */\r\n  public static differenceSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    const nA = dataA.length;\r\n    const iB = 0;\r\n    const retVal: Range1d[] = [];\r\n    for (let iA = 0; iA < nA; iA++) {\r\n      Range1dArray.advanceIntervalDifference(dataA[iA], dataB, iB, retVal);\r\n    }\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Internal step: Caller ensures rangeA is the \"lower\" interval.\r\n   *  Look rangeB to decide (a) what output interval to create and (b) which read index to advance.\r\n   *  Returns true or false to indicate whether the value associated with rangeA or rangeB should be incremented after this function returns\r\n   */\r\n  private static advanceIntervalIntersection(rangeA: Range1d, rangeB: Range1d, retVal: Range1d[]): boolean {\r\n    if (rangeB.low > rangeA.high) {\r\n      return true;\r\n    } else if (rangeB.high >= rangeA.high) {\r\n      retVal.push(Range1d.createXX(rangeB.low, rangeA.high));\r\n      return true;\r\n    } else {\r\n      retVal.push(Range1d.createXX(rangeB.low, rangeB.high));\r\n      return false;\r\n    }\r\n  }\r\n  /** Boolean intersection among the (presorted) input ranges */\r\n  public static intersectSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    let iA = 0;\r\n    let iB = 0;\r\n    const nA = dataA.length;\r\n    const nB = dataB.length;\r\n    const retVal: Range1d[] = [];\r\n    while (iA < nA && iB < nB) {\r\n      const rangeA = dataA[iA];\r\n      const rangeB = dataB[iB];\r\n      if (rangeA.low <= rangeB.low) {\r\n        if (Range1dArray.advanceIntervalIntersection(rangeA, rangeB, retVal))\r\n          iA++;\r\n        else\r\n          iB++;\r\n      } else {\r\n        if (Range1dArray.advanceIntervalIntersection(rangeB, rangeA, retVal))\r\n          iB++;\r\n        else\r\n          iA++;\r\n      }\r\n    }\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Internal step: Read an interval from the array.\r\n   *  If it overlaps the work interval, advance the work interval, and return true to notify caller to increment read index.\r\n   */\r\n  private static advanceIntervalUnion(workRange: Range1d, source: Range1d[], readIndex: number): boolean {\r\n    if (readIndex >= source.length)\r\n      return false;\r\n    const candidate = source[readIndex];\r\n    if (candidate.low > workRange.high)\r\n      return false;\r\n    if (candidate.high > workRange.high)\r\n      workRange.high = candidate.high;\r\n    return true;\r\n  }\r\n\r\n  /** Boolean union among the (presorted) input ranges */\r\n  public static unionSorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    const nA = dataA.length;\r\n    const nB = dataB.length;\r\n    let iA = 0;\r\n    let iB = 0;\r\n    const retVal: Range1d[] = [];\r\n    while (iA < nA && iB < nB) {\r\n      const rangeA = dataA[iA];\r\n      const rangeB = dataB[iB];\r\n      let workRange: Range1d;\r\n      // Pull from the lower of rangeA and rangeB. This always advances exactly one of the indices -- progress towards getting out.\r\n      if (rangeA.low <= rangeB.low) {\r\n        workRange = rangeA.clone();\r\n        iA++;\r\n      } else {\r\n        workRange = rangeB.clone();\r\n        iB++;\r\n      }\r\n\r\n      let toLoop = true;\r\n      do {\r\n        const resultA = Range1dArray.advanceIntervalUnion(workRange, dataA, iA);\r\n        const resultB = Range1dArray.advanceIntervalUnion(workRange, dataB, iB);\r\n        if (resultA)\r\n          iA++;\r\n        if (resultB)\r\n          iB++;\r\n        if (!(resultA || resultB))\r\n          toLoop = false;\r\n      } while (toLoop);\r\n\r\n      retVal.push(workRange);\r\n    }\r\n\r\n    while (iA < nA)\r\n      retVal.push(dataA[iA++]);\r\n    while (iB < nB)\r\n      retVal.push(dataB[iB++]);\r\n\r\n    return retVal;\r\n  }\r\n\r\n  /** Boolean parity among the (presorted) input ranges */\r\n  public static paritySorted(dataA: Range1d[], dataB: Range1d[]): Range1d[] {\r\n    // Combine the two arrays, and then perform a simplification using simplifySortParity function\r\n    const retVal: Range1d[] = [];\r\n    for (const range of dataA)\r\n      retVal.push(range.clone());\r\n    for (const range of dataB)\r\n      retVal.push(range.clone());\r\n\r\n    // Sort the array\r\n    retVal.sort(compareRange1dLexicalLowHigh);\r\n\r\n    Range1dArray.simplifySortParity(retVal, true);\r\n    return retVal;\r\n  }\r\n\r\n  /** Uses the Range1d specific compare function `compareRange1dLexicalLowHigh` for sorting the array of ranges */\r\n  public static sort(data: Range1d[]) {\r\n    data.sort(compareRange1dLexicalLowHigh);\r\n  }\r\n\r\n  /** Cleans up the array, compressing any overlapping ranges. If removeZeroLengthRanges is set to true, will also remove any Ranges in the form (x, x) */\r\n  public static simplifySortUnion(data: Range1d[], removeZeroLengthRanges: boolean = false) {\r\n    if (data.length < 2)\r\n      return;\r\n\r\n    data.sort(compareRange1dLexicalLowHigh);\r\n\r\n    let currIdx = 0;\r\n    let toInsert = false;\r\n    for (let i = 0; i < data.length; i++) {\r\n      if (i === data.length - 1) {\r\n        if (toInsert) {\r\n          if (!removeZeroLengthRanges || data[i].low !== data[i].high)\r\n            data[currIdx++] = data[i];\r\n        }\r\n        break;\r\n      }\r\n\r\n      if (data[i + 1].low > data[i].high) {\r\n        if (!removeZeroLengthRanges || data[i].low !== data[i].high)\r\n          data[currIdx++] = data[i];\r\n        continue;\r\n      } else {\r\n        data[i + 1].low = data[i].low;\r\n        data[i + 1].high = Math.max(data[i].high, data[i + 1].high);\r\n        toInsert = true;\r\n      }\r\n    }\r\n\r\n    data.length = currIdx;\r\n  }\r\n\r\n  /** Apply parity logic among ranges which are not pre-sorted. */\r\n  public static simplifySortParity(data: Range1d[], removeZeroLengthRanges: boolean = false) {\r\n    const numData: number[] = [];\r\n    for (const range of data) {\r\n      if (range.low !== range.high) {\r\n        numData.push(range.low);\r\n        numData.push(range.high);\r\n      }\r\n    }\r\n    const n = numData.length;\r\n    numData.sort((a: number, b: number): number => {\r\n      if (a < b) return -1;\r\n      if (a > b) return 1;\r\n      return 0;\r\n    });\r\n\r\n    let currIdx = 0;\r\n    let x0;\r\n    let x1;\r\n    for (let i = 0; i < n; i += 2) {\r\n      x0 = numData[i];\r\n      x1 = numData[i + 1];\r\n      if (!removeZeroLengthRanges) {\r\n        Range1d.createXX(x0, x1, data[currIdx++]);\r\n      } else {\r\n        // coalesce intervals that share end and start:\r\n        while (i + 2 < n && numData[i + 2] === x1) {\r\n          i += 2;\r\n          x1 = numData[i + 1];\r\n        }\r\n        if (x1 > x0)\r\n          Range1d.createXX(x0, x1, data[currIdx++]);\r\n      }\r\n    }\r\n\r\n    data.length = currIdx;\r\n  }\r\n\r\n  /** test if value is \"in\" by union rules.\r\n   * * This considers all intervals-- i.e. does not expect or take advantage of sorting.\r\n   */\r\n  public static testUnion(data: Range1d[], value: number): boolean {\r\n    return this.countContainingRanges(data, value) > 0;\r\n  }\r\n  /** test if value is \"in\" by parity rules.\r\n   * * This considers all intervals-- i.e. does not expect or take advantage of sorting.\r\n   */\r\n  public static testParity(data: Range1d[], value: number): boolean {\r\n    let inside = false;\r\n    for (const range of data) {\r\n      if (range.containsX(value))\r\n        inside = !inside;\r\n    }\r\n    return inside;\r\n  }\r\n\r\n  /** linear search to count number of intervals which contain `value`.\r\n   */\r\n  public static countContainingRanges(data: Range1d[], value: number): number {\r\n    let n = 0;\r\n    for (const range of data) {\r\n      if (range.containsX(value))\r\n        n++;\r\n    }\r\n    return n;\r\n  }\r\n\r\n  /** return an array with all the low and high values of all the ranges.\r\n   * @param data array of ranges.\r\n   * @param sort optionally request immediate sort.\r\n   * @param compress optionally request removal of duplicates.\r\n   */\r\n  public static getBreaks(data: Range1d[], result?: GrowableFloat64Array, sort: boolean = false, compress: boolean = false, clear: boolean = true): GrowableFloat64Array {\r\n    if (!result) result = new GrowableFloat64Array(2 * data.length);\r\n    if (clear) result.clear();\r\n    for (const range of data) {\r\n      result.push(range.low);\r\n      result.push(range.high);\r\n    }\r\n    if (sort)\r\n      result.sort();\r\n    if (compress)\r\n      result.compressAdjacentDuplicates();\r\n\r\n    return result;\r\n  }\r\n\r\n  /**  evaluate a point at an array of given fraction values\r\n   * @param data array of ranges.\r\n   * @param initialRangeFraction fraction coordinate applied only to first range. (typically negative)\r\n   * @param rangeFraction fraction within each range.\r\n   * @param includeDegenerateRange if false, skip rangeFraction for 0-length ranges.\r\n   * @param gapFraction fraction within interval from each range high to successor low\r\n   * @param includeDegenerateGap if false, skip rangeFraction for 0-length gaps.\r\n   * @param finalRangeFraction fraction coordinate applied only to last range (typically an extrapolation above)\r\n   * @param result array to receive values\r\n   */\r\n  public static appendFractionalPoints(data: Range1d[], initialRangeFraction: number | undefined, rangeFraction: number | undefined, includeDegenerateRange: boolean,\r\n    gapFraction: number | undefined, includeDegenerateGap: boolean,\r\n    finalRangeFraction: number | undefined, result: GrowableFloat64Array | number[]): GrowableFloat64Array | number[] {\r\n    const numRange = data.length;\r\n    if (numRange > 0) {\r\n      if (undefined !== initialRangeFraction)\r\n        result.push(data[0].fractionToPoint(initialRangeFraction));\r\n      for (let i = 0; i < numRange; i++) {\r\n        if (rangeFraction !== undefined && (includeDegenerateRange || data[i].low !== data[i].high))\r\n          result.push(data[i].fractionToPoint(rangeFraction));\r\n        if (i > 1 && gapFraction !== undefined && (includeDegenerateGap || data[i].low !== data[i].high))\r\n          result.push(Geometry.interpolate(data[i - 1].high, gapFraction, data[i].low));\r\n      }\r\n      if (undefined !== finalRangeFraction)\r\n        result.push(data[numRange - 1].fractionToPoint(finalRangeFraction));\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Return a single range constructed with the low of range 0 and high of final range in the set.  */\r\n  public static firstLowToLastHigh(data: Range1d[]): Range1d {\r\n    if (data.length === 0)\r\n      return Range1d.createNull();\r\n    return Range1d.createXX(data[0].low, data[data.length - 1].high);\r\n  }\r\n  /** sum the lengths of all ranges */\r\n  public static sumLengths(data: Range1d[]): number {\r\n    let sum = 0.0;\r\n    for (const range of data) {\r\n      sum += range.length();\r\n    }\r\n    return sum;\r\n  }\r\n\r\n  /**\r\n   * Test if the low,high values are sorted with no overlap.\r\n   * @param data array of ranges.\r\n   * @param strict if true, consider exact high-to-low match as overlap.\r\n   */\r\n  public static isSorted(data: Range1d[], strict: boolean = true): boolean {\r\n    const n = data.length;\r\n    if (strict) {\r\n      for (let i = 0; i + 1 < n; i++) {\r\n        if (data[i].high >= data[i + 1].low)\r\n          return false;\r\n      }\r\n    } else {\r\n      for (let i = 0; i + 1 < n; i++) {\r\n        if (data[i].high > data[i + 1].low)\r\n          return false;\r\n      }\r\n    }\r\n    return true;\r\n  }\r\n}\r\n\r\n/** Checks low's first, then high's\r\n * @internal\r\n */\r\nexport function compareRange1dLexicalLowHigh(a: Range1d, b: Range1d): number {\r\n  if (a.low < b.low) return -1;\r\n  if (a.low > b.low) return 1;\r\n  if (a.high < b.high) return -1;\r\n  if (a.high > b.high) return 1;\r\n  return 0;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Numerics */\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n\r\n// Enumerated type lies outside of TriDiagonalSystem, as TSLint prevented declaration within class\r\nenum DataState {\r\n  RawMatrix,\r\n  FactorOK,\r\n  FactorFailed,\r\n}\r\n/**\r\n * Linear system operations on a matrix with data only on the diagonal and its immediate left and right neighbors\r\n * @internal\r\n */\r\nexport class TriDiagonalSystem {\r\n\r\n  // Lower diagonal, indexed by rows\r\n  private _aLeft: Float64Array;\r\n  // Upper diagonal, indexed by rows\r\n  private _aRight: Float64Array;\r\n  // Main diagonal, indexed by rows\r\n  private _aDiag: Float64Array;\r\n  // Right sude vector\r\n  private _b: Float64Array;\r\n  // Solution vector\r\n  private _x: Float64Array;\r\n\r\n  private _dataState!: DataState;\r\n\r\n  constructor(n: number) {\r\n    this._aLeft = new Float64Array(n);\r\n    this._aDiag = new Float64Array(n);\r\n    this._aRight = new Float64Array(n);\r\n    this._b = new Float64Array(n);\r\n    this._x = new Float64Array(n);\r\n    this.reset();\r\n  }\r\n\r\n  /** Reset to RawMatrix state with all coefficients zero */\r\n  public reset() {\r\n    this._dataState = DataState.RawMatrix;\r\n    const n = this._aDiag.length;\r\n    for (let i = 0; i < n; i++) {\r\n      this._aLeft[i] = this._aRight[i] = this._aDiag[i] = this._b[i] = this._x[i] = 0.0;\r\n    }\r\n  }\r\n  /** Install data in a row of the matrix */\r\n  public setRow(row: number, left: number, diag: number, right: number) {\r\n    this._aLeft[row] = left;\r\n    this._aDiag[row] = diag;\r\n    this._aRight[row] = right;\r\n  }\r\n  /** Add to row of matrix */\r\n  public addToRow(row: number, left: number, diag: number, right: number) {\r\n    this._aLeft[row] += left;\r\n    this._aDiag[row] += diag;\r\n    this._aRight[row] += right;\r\n  }\r\n  /** Install data in the right side (B) vector */\r\n  public setB(row: number, bb: number) {\r\n    this._b[row] = bb;\r\n  }\r\n  /** Add to an entry in the right side (B) vector */\r\n  public addToB(row: number, bb: number) {\r\n    this._b[row] += bb;\r\n  }\r\n  /** Access data from the right side (B) vector */\r\n  public getB(row: number): number {\r\n    return this._b[row];\r\n  }\r\n  /** Install data in the solution (X) vector */\r\n  public setX(row: number, xx: number) {\r\n    this._x[row] = xx;\r\n  }\r\n  /** Access data frin the solution (X) vector */\r\n  public getX(row: number): number {\r\n    return this._x[row];\r\n  }\r\n  /** Get method for matrix and vector order */\r\n  public order(): number {\r\n    return this._aDiag.length;\r\n  }\r\n  /** Compute product of AX and save as B */\r\n  public multiplyAX(): boolean {\r\n    if (this._dataState === DataState.FactorFailed) {\r\n      return false;\r\n    } else if (this._dataState === DataState.FactorOK) {\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      for (let i = 0; i < nm1; i++) {\r\n        this._b[i] = this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];\r\n      }\r\n      this._b[nm1] = this._aDiag[nm1] * this._x[nm1];\r\n\r\n      for (let i = nm1; i > 0; i--) {\r\n        this._b[i] += this._aLeft[i] * this._b[i - 1];\r\n      }\r\n\r\n      return true;\r\n    } else {\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      this._b[0] = this._aDiag[0] * this._x[0] + this._aRight[0] * this._x[1];\r\n      let i;\r\n      for (i = 1; i < nm1; i++) {\r\n        this._b[i] = this._aLeft[i] * this._x[i - 1] + this._aDiag[i] * this._x[i] + this._aRight[i] * this._x[i + 1];\r\n      }\r\n      this._b[nm1] = this._aLeft[nm1] * this._x[n - 2] + this._aDiag[i] * this._x[nm1];\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /** Compute product of AX and save as B */\r\n  public multiplyAXPoints(pointX: Point3d[], pointB: Point3d[]): boolean {\r\n    pointB.length = 0;\r\n    while (pointB.length < pointX.length)\r\n      pointB.push(Point3d.create());\r\n    pointB.length = pointX.length;\r\n\r\n    if (this._dataState === DataState.FactorFailed) {\r\n      return false;\r\n    } else if (this._dataState === DataState.FactorOK) {\r\n\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      for (let i = 0; i < nm1; i++) {\r\n        Point3d.createAdd2Scaled(pointX[i], this._aDiag[i], pointX[i + 1], this._aRight[i], pointB[i]);\r\n      }\r\n      Point3d.createScale(pointX[nm1], this._aDiag[nm1], pointB[nm1]);\r\n\r\n      for (let i = nm1; i > 0; i--) {\r\n        pointB[i].plusScaled(pointB[i - 1], this._aLeft[i], pointB[i]);\r\n      }\r\n\r\n      return true;\r\n    } else {\r\n      const n = this._aDiag.length;\r\n      const nm1 = n - 1;\r\n      Point3d.createAdd2Scaled(pointX[0], this._aDiag[0], pointX[1], this._aRight[0], pointB[0]);\r\n      let i;\r\n      for (i = 1; i < nm1; i++) {\r\n        Point3d.createAdd3Scaled(\r\n          pointX[i - 1], this._aLeft[i], pointX[i], this._aDiag[i],\r\n          pointX[i + 1], this._aRight[i],\r\n          pointB[i]);\r\n      }\r\n      Point3d.createAdd2Scaled(pointX[n - 2], this._aLeft[nm1], pointX[nm1], this._aDiag[nm1], pointB[nm1]);\r\n      return true;\r\n    }\r\n  }\r\n\r\n  /** Multiply the stored factors together to return to plain matrix form */\r\n  public defactor(): boolean {\r\n    if (this._dataState === DataState.RawMatrix) {\r\n      return true;\r\n    }\r\n    if (this._dataState === DataState.FactorFailed) {\r\n      return false;\r\n    }\r\n    const n = this._aDiag.length;\r\n    const nm1 = n - 1;\r\n\r\n    for (let i = nm1; i > 0; i--) {\r\n      this._aDiag[i] += this._aLeft[i] * this._aRight[i - 1];\r\n      this._aLeft[i] *= this._aDiag[i - 1];\r\n    }\r\n    this._dataState = DataState.RawMatrix;\r\n    return true;\r\n  }\r\n  /** Factor the tridiagonal matrix to LU parts. b, x, not altered */\r\n  public factor(): boolean {\r\n    if (this._dataState === DataState.FactorOK) {\r\n      return true;\r\n    }\r\n    if (this._dataState !== DataState.RawMatrix) {\r\n      return false;\r\n    }\r\n    this._dataState = DataState.FactorFailed;\r\n\r\n    const n1 = this._aDiag.length - 1;    // Last pivot index\r\n    // Eliminate in subdiagonal.\r\n    for (let i = 0; i < n1; i++) {\r\n      const r = Geometry.conditionalDivideFraction(this._aLeft[i + 1], this._aDiag[i]);\r\n      if (!r)\r\n        return false;\r\n      this._aLeft[i + 1] = r;\r\n      this._aDiag[i + 1] -= r * this._aRight[i];\r\n    }\r\n    this._dataState = DataState.FactorOK;\r\n    return true;\r\n  }\r\n  /** Solve AX=B. A is left in factored state. B unchanged. */\r\n  public factorAndBackSubstitute(): boolean {\r\n    const n = this._aDiag.length;\r\n    const n1 = n - 1;\r\n    if (!this.factor())\r\n      return false;\r\n\r\n    // Apply Linv to B, same sequence as was done to A:\r\n    for (let i = 0; i < n; i++) {\r\n      this._x[i] = this._b[i];\r\n    }\r\n    for (let i = 1; i < n; i++) {\r\n      this._x[i] -= this._aLeft[i] * this._x[i - 1];\r\n    }\r\n\r\n    // Print (\"LU  LinvB B\");\r\n    // overwrite X with solution of U * X = Linv B, where RHS is already in X...\r\n    // All diagonals are known to be nonzero. Really.  Really???\r\n    this._x[n1] /= this._aDiag[n1];\r\n\r\n    for (let i = n1 - 1; i >= 0; i--) {\r\n      this._x[i] = (this._x[i] - this._aRight[i] * this._x[i + 1]) / this._aDiag[i];\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /** Solve AX=B. A is left in factored state. B unchanged. vectorB and vectorX may be the same array */\r\n  public factorAndBackSubstitutePointArrays(vectorB: Point3d[], vectorX: Point3d[]): boolean {\r\n    const n = this._aDiag.length;\r\n    if (vectorB.length < n)\r\n      return false;\r\n\r\n    while (vectorX.length < n)\r\n      vectorX.push(Point3d.create(0, 0, 0));\r\n    vectorX.length = n;\r\n    const n1 = n - 1;\r\n    if (!this.factor())\r\n      return false;\r\n\r\n    // Apply Linv to B, same sequence as was done to A:\r\n    if (vectorB !== vectorX) {\r\n      for (let i = 0; i < n; i++) {\r\n        vectorX[i].setFrom(vectorB[i]);\r\n      }\r\n    }\r\n\r\n    let a: number;\r\n    let b: number;\r\n    for (let i = 1; i < n; i++) {\r\n      a = this._aLeft[i];\r\n      vectorX[i].x -= a * vectorX[i - 1].x;\r\n      vectorX[i].y -= a * vectorX[i - 1].y;\r\n      vectorX[i].z -= a * vectorX[i - 1].z;\r\n    }\r\n\r\n    // Print (\"LU  LinvB B\");\r\n    // overwrite X with solution of U * X = Linv B, where RHS is already in X...\r\n    // All diagonals are known to be nonzero. Really.  Really???\r\n    b = 1.0 / this._aDiag[n1];\r\n    vectorX[n1].x *= b;\r\n    vectorX[n1].y *= b;\r\n    vectorX[n1].z *= b;\r\n\r\n    for (let i = n1 - 1; i >= 0; i--) {\r\n      a = this._aRight[i];\r\n      b = 1.0 / this._aDiag[i];\r\n      vectorX[i].x = (vectorX[i].x - a * vectorX[i + 1].x) * b;\r\n      vectorX[i].y = (vectorX[i].y - a * vectorX[i + 1].y) * b;\r\n      vectorX[i].z = (vectorX[i].z - a * vectorX[i + 1].z) * b;\r\n    }\r\n\r\n    return true;\r\n  }\r\n  /** Allocate a complete copy */\r\n  public copy(): TriDiagonalSystem {\r\n    const n = this._aDiag.length;\r\n    const B = new TriDiagonalSystem(n);\r\n    for (let i = 0; i < n; i++) {\r\n      B._aLeft[i] = this._aLeft[i];\r\n      B._aDiag[i] = this._aDiag[i];\r\n      B._aRight[i] = this._aRight[i];\r\n      B._x[i] = this._x[i];\r\n      B._b[i] = this._b[i];\r\n    }\r\n    B._dataState = this._dataState;\r\n    return B;\r\n  }\r\n\r\n  /** return an array form that may be useful for display ... */\r\n  public flatten(): any {\r\n    const n = this._aDiag.length;\r\n    const data = [];\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      data.push(\r\n        [i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], this._b[i]]);\r\n    }\r\n    return data;\r\n  }\r\n\r\n  /** return an array form that may be useful for display ... */\r\n  public flattenWithPoints(xyzB: Point3d[]): any {\r\n    const n = this._aDiag.length;\r\n    const data = [];\r\n\r\n    for (let i = 0; i < n; i++) {\r\n      data.push(\r\n        [i, [this._aLeft[i], this._aDiag[i], this._aRight[i]], this._x[i], xyzB[i].toJSON()]);\r\n    }\r\n    return data;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Geometry } from \"./Geometry\";\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\n\r\n/** The data types of [[AuxChannel]].  The scalar types are used to produce thematic  vertex colors.\r\n * @public\r\n*/\r\nexport enum AuxChannelDataType {\r\n  /** General scalar type - no scaling is applied if associated [[Polyface]] is transformed. */\r\n  Scalar = 0,\r\n  /** Distance (scalar) scaling is applied if associated [[Polyface]] is scaled. 3 Data values (x,y.z) per entry. */\r\n  Distance = 1,\r\n  /** Displacement added to  vertex position.  Transformed and scaled with associated [[Polyface]]. 3 Data values (x,y.z) per entry.,*/\r\n  Vector = 2,\r\n  /** Normal -- replaces vertex normal.  Rotated with associated [[Polyface]] transformation. 3 Data values (x,y.z) per entry. */\r\n  Normal = 3,\r\n}\r\n/**  Represents the [[AuxChannel]] data at a single input value.\r\n * @public\r\n*/\r\nexport class AuxChannelData {\r\n  /** The input value for this data. */\r\n  public input: number;\r\n  /** The vertex values for this data.  A single value per vertex for scalar types and 3 values (x,y,z) for normal or vector channels. */\r\n  public values: number[];\r\n  /** Construct a new [[AuxChannelData]] from input value and vertex values. */\r\n  constructor(input: number, values: number[]) {\r\n    this.input = input;\r\n    this.values = values;\r\n  }\r\n  /** Copy blocks of size `blockSize` from (blocked index) `thisIndex` in this AuxChannelData to (blockIndex) `otherIndex` of `other` */\r\n  public copyValues(other: AuxChannelData, thisIndex: number, otherIndex: number, blockSize: number) {\r\n    for (let i = 0; i < blockSize; i++)\r\n      this.values[thisIndex * blockSize + i] = other.values[otherIndex * blockSize + i];\r\n  }\r\n  /** return a deep copy */\r\n  public clone() {\r\n    return new AuxChannelData(this.input, this.values.slice());\r\n  }\r\n  /** toleranced comparison of the `input` and `value` fields.\r\n   * * Default tolernace is 1.0e-8\r\n   */\r\n  public isAlmostEqual(other: AuxChannelData, tol?: number) {\r\n    const tolerance = tol ? tol : 1.0E-8;\r\n    return Math.abs(this.input - other.input) < tolerance && NumberArray.isAlmostEqual(this.values, other.values, tolerance);\r\n  }\r\n}\r\n/**  Represents a single [[PolyfaceAuxData]] channel. A channel  may represent a single scalar value such as stress or temperature or may represent displacements from vertex position or replacements for normals.\r\n * @public\r\n*/\r\nexport class AuxChannel {\r\n  /** An array of [[AuxChannelData]] that represents the vertex data at one or more input values. */\r\n  public data: AuxChannelData[];\r\n  /** type indicator for this channel.  Setting this causes later transformations to be applied to point, vector, and surface normal data in appropriate ways. */\r\n  public dataType: AuxChannelDataType;\r\n  /** The channel name. This is used to present the [[AuxChannel]] to the user and also to select the [[AuxChannel]] for display from AnalysisStyle */\r\n  public name?: string;\r\n  /** The input name. */\r\n  public inputName?: string;\r\n  /** create a [[AuxChannel]] */\r\n  public constructor(data: AuxChannelData[], dataType: AuxChannelDataType, name?: string, inputName?: string) {\r\n    this.data = data;\r\n    this.dataType = dataType;\r\n    this.name = name;\r\n    this.inputName = inputName;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone() {\r\n    const clonedData = [];\r\n    for (const data of this.data) clonedData.push(data.clone());\r\n    return new AuxChannel(clonedData, this.dataType, this.name, this.inputName);\r\n  }\r\n  /** toleranced comparison of contents. */\r\n  public isAlmostEqual(other: AuxChannel, tol?: number) {\r\n    if (this.dataType !== other.dataType ||\r\n      this.name !== other.name ||\r\n      this.inputName !== other.inputName ||\r\n      this.data.length !== other.data.length)\r\n      return false;\r\n\r\n    for (let i = 0; i < this.data.length; i++)\r\n      if (!this.data[i].isAlmostEqual(other.data[i], tol))\r\n        return false;\r\n\r\n    return true;\r\n  }\r\n  /** return true if the data for this channel is of scalar type (single data entry per value) */\r\n  get isScalar(): boolean { return this.dataType === AuxChannelDataType.Distance || this.dataType === AuxChannelDataType.Scalar; }\r\n  /** return the number of data values per entry (1 for scalar, 3 for point or vector */\r\n  get entriesPerValue(): number { return this.isScalar ? 1 : 3; }\r\n  /** return value count */\r\n  get valueCount(): number { return 0 === this.data.length ? 0 : this.data[0].values.length / this.entriesPerValue; }\r\n  /** return the range of the scalar data. (undefined if not scalar) */\r\n  get scalarRange(): Range1d | undefined {\r\n    if (!this.isScalar) return undefined;\r\n    const range = Range1d.createNull();\r\n    for (const data of this.data) {\r\n      range.extendArray(data.values);\r\n    }\r\n    return range;\r\n  }\r\n}\r\n/**  The `PolyfaceAuxData` structure contains one or more analytical data channels for each vertex of a `Polyface`.\r\n * Typically a `Polyface` will contain only vertex data required for its basic display,the vertex position, normal\r\n * and possibly texture parameter.  The `PolyfaceAuxData` structure contains supplemental data that is generally computed\r\n *  in an analysis program or other external data source.  This can be scalar data used to either overide the vertex colors through *Thematic Colorization* or\r\n *  XYZ data used to deform the mesh by adjusting the vertex postions or normals.\r\n * @public\r\n */\r\nexport class PolyfaceAuxData {\r\n  /** Array with one or more channels of auxilliary data for the associated polyface. */\r\n   public channels: AuxChannel[];\r\n  /** indices The indices (shared by all data in all channels) mapping the data to the mesh facets. */\r\n  public indices: number[];\r\n\r\n  public constructor(channels: AuxChannel[], indices: number[]) {\r\n    this.channels = channels;\r\n    this.indices = indices;\r\n  }\r\n  /** return a deep clone */\r\n  public clone() {\r\n    const clonedChannels = [];\r\n    for (const channel of this.channels) clonedChannels.push(channel.clone());\r\n    return new PolyfaceAuxData(clonedChannels, this.indices.slice());\r\n  }\r\n  /** deep test for equality.\r\n   * * Exact equality for discrete number arrays.\r\n   * * approximate test for coordinate data.\r\n   */\r\n  public isAlmostEqual(other: PolyfaceAuxData, tol?: number): boolean {\r\n    if (!NumberArray.isExactEqual(this.indices, other.indices) || this.channels.length !== other.channels.length)\r\n      return false;\r\n\r\n    for (let i = 0; i < this.channels.length; i++)\r\n      if (!this.channels[i].isAlmostEqual(other.channels[i], tol))\r\n        return false;\r\n\r\n    return true;\r\n  }\r\n  /**\r\n   * class level almostEqual test, allowing either or both to be undefined at point of call.\r\n   * @param left\r\n   * @param right\r\n   * @param tol\r\n   */\r\n  public static isAlmostEqual(left: PolyfaceAuxData | undefined, right: PolyfaceAuxData | undefined, tol?: number): boolean {\r\n    if (left === right) // This catches double undefined !!!\r\n      return true;\r\n    if (left && right)\r\n      return left.isAlmostEqual(right, tol);\r\n    return false;\r\n  }\r\n  /** Create a PolyfaceAuxData for use by a facet iterator  */\r\n  public createForVisitor() {\r\n    const visitorChannels: AuxChannel[] = [];\r\n\r\n    for (const parentChannel of this.channels) {\r\n      const visitorChannelData: AuxChannelData[] = [];\r\n      for (const parentChannelData of parentChannel.data) {\r\n        visitorChannelData.push(new AuxChannelData(parentChannelData.input, []));\r\n      }\r\n      visitorChannels.push(new AuxChannel(visitorChannelData, parentChannel.dataType, parentChannel.name, parentChannel.inputName));\r\n    }\r\n\r\n    return new PolyfaceAuxData(visitorChannels, []);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\n//\r\n//      2------------------3\r\n//      | \\     F4       / |\r\n//      |   6----------7   |\r\n//      |   |          |   |   (BOTTOM = F0)\r\n//      |F5 |   F1     |F3 |\r\n//      |   |          |   |\r\n//      |   4----------5   |\r\n//      | /     F2       \\ |\r\n//      0------------------1\r\n//\r\n/**\r\n * methods for gathering points and indices of a box (8 corners, 6 faces, 12 edges)\r\n * @internal\r\n */\r\nexport class BoxTopology {\r\n  /**\r\n   * static readonly array with the coordinates of the 8 unit cube corners in standard order, which is:\r\n   * x varies fastest\r\n   * * The point indices for the x edges are (0 to 1), (2 to 3), (4 to 5), (6 to 7)\r\n   * * The point indices for the y edges are (0 to 2), (1 to 3), (4 to 6), (5 to 7)\r\n   * * The point indices for the z edges are (0 to 4), (1 to 5), (2 to 6), (3 to 7)\r\n   * * These indices are tabulated in the `axisEdgeVertex[axis][edge][vertex]` array\r\n   */\r\n  public static readonly points = [\r\n    Point3d.create(0, 0, 0),\r\n    Point3d.create(1, 0, 0),\r\n    Point3d.create(0, 1, 0),\r\n    Point3d.create(1, 1, 0),\r\n    Point3d.create(0, 0, 1),\r\n    Point3d.create(1, 0, 1),\r\n    Point3d.create(0, 1, 1),\r\n    Point3d.create(1, 1, 1),\r\n  ];\r\n  /** IN faceId pair, the first component for bottom and top caps is `primaryCapId` */\r\n  public static readonly primaryCapId = -1;\r\n  /** Indices of vertices around faces, in CCW from the outside. */\r\n  public static readonly cornerIndexCCW =\r\n    [\r\n      [1, 0, 2, 3],\r\n      [4, 5, 7, 6],\r\n      [0, 1, 5, 4],\r\n      [1, 3, 7, 5],\r\n      [3, 2, 6, 7],\r\n      [2, 0, 4, 6]];\r\n  /**  // [partnerFace[faceIndex][k] = index of k'th adjacent face  */\r\n  public static readonly partnerFace =\r\n    [\r\n      [5, 4, 3, 2],\r\n      [2, 3, 4, 5],\r\n      [0, 3, 1, 5],\r\n      [0, 4, 1, 2],\r\n      [0, 5, 1, 3],\r\n      [0, 2, 1, 4],\r\n    ];\r\n  /** face id as used in SolidPrimitive methods */\r\n  public static readonly faceId = [\r\n    [BoxTopology.primaryCapId, 0],\r\n    [BoxTopology.primaryCapId, 1],\r\n    [0, 0],\r\n    [0, 1],\r\n    [0, 2],\r\n    [0, 3]];\r\n  /**\r\n   * Table to look up axis indices of edges and normals in box faces.\r\n   * faceDirections[faceIndex] =[[edge0AxisIndex, edge1AxisIndex, normalAxisIndex],[direction sign for along the axis]\r\n   */\r\n  public static readonly faceDirections =\r\n    [\r\n      [[0, 1, 2], [-1, 1, -1]],\r\n      [[0, 1, 2], [1, 1, 1]],\r\n      [[0, 2, 1], [1, -1, 1]],\r\n      [[1, 2, 0], [1, 1, 1]],\r\n      [[0, 2, 1], [-1, 1, 1]],\r\n      [[1, 2, 0], [-1, 1, -1]]];\r\n  /** There are 4 edges in each axis direction.\r\n   *  * axisEdgeVertex[axisIndex][edgeIndex 0..3][*] = vertex index at end of edge in axisIndex direction.\r\n   */\r\n  public static readonly axisEdgeVertex =\r\n    [\r\n      [[0, 1], [2, 3], [4, 5], [6, 7]],\r\n      [[0, 2], [1, 3], [4, 6], [5, 7]],\r\n      [[0, 4], [1, 5], [2, 6], [3, 7]]];\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range2d } from \"../geometry3d/Range\";\r\nimport { IndexedPolyface, IndexedPolyfaceVisitor } from \"./Polyface\";\r\n/**\r\n * Data for a face in a polyface containing facets.\r\n * This is built up cooperatively by the PolyfaceBuilder and its\r\n * callers, and stored as a FaceData array in PolyfaceData.\r\n * @public\r\n */\r\nexport class FacetFaceData {\r\n  private _paramDistanceRange: Range2d;\r\n  private _paramRange: Range2d;\r\n  /** (property accessor) Return a reference to the distance-scaled parameter range. */\r\n  public get paramDistanceRange(): Range2d { return this._paramDistanceRange; }\r\n  /** (property accessor) Return a reference to the parameter range. */\r\n  public get paramRange(): Range2d { return this._paramRange; }\r\n  private constructor(distanceRange: Range2d, paramRange: Range2d) {\r\n    this._paramDistanceRange = distanceRange;\r\n    this._paramRange = paramRange;\r\n  }\r\n  /** Create a FacetFaceData with null ranges. */\r\n  public static createNull(): FacetFaceData {\r\n    return new FacetFaceData(Range2d.createNull(), Range2d.createNull());\r\n  }\r\n  /** Create a deep copy of this FacetFaceData object. */\r\n  public clone(result?: FacetFaceData): FacetFaceData {\r\n    if (result) {\r\n      this._paramDistanceRange.clone(result._paramDistanceRange);\r\n      this._paramRange.clone(result._paramRange);\r\n      return result;\r\n    }\r\n    return new FacetFaceData(this._paramDistanceRange.clone(), this._paramRange.clone());\r\n  }\r\n  /** Restore this FacetFaceData to its null constructor state. */\r\n  public setNull() {\r\n    this._paramDistanceRange.setNull();\r\n    this._paramRange.setNull();\r\n  }\r\n  /** Return distance-based parameter from stored parameter value. */\r\n  public convertParamXYToDistance(x: number, y: number, result?: Point2d): Point2d {\r\n    result = result ? result : Point2d.create();\r\n    const paramDelta = this._paramRange.high.minus(this._paramRange.low);\r\n    result.x = (0 === paramDelta.x) ? x : (this._paramDistanceRange.low.x + (x - this._paramRange.low.x)\r\n      * (this._paramDistanceRange.high.x - this._paramDistanceRange.low.x) / paramDelta.x);\r\n    result.y = (0.0 === paramDelta.y) ? y : (this.paramDistanceRange.low.y + (y - this._paramRange.low.y)\r\n      * (this._paramDistanceRange.high.y - this._paramDistanceRange.low.y) / paramDelta.y);\r\n    return result;\r\n  }\r\n  /** Return normalized (0-1) parameter from stored parameter value. */\r\n  public convertParamXYToNormalized(x: number, y: number, result?: Point2d): Point2d {\r\n    result = result ? result : Point2d.create();\r\n    const paramDelta = this._paramRange.high.minus(this._paramRange.low);\r\n    result.x = (0.0 === paramDelta.x) ? x : ((x - this._paramRange.low.x) / paramDelta.x);\r\n    result.y = (0.0 === paramDelta.y) ? y : ((y - this._paramRange.low.y) / paramDelta.y);\r\n    return result;\r\n  }\r\n  /** Return distance-based parameter from stored parameter value. */\r\n  public convertParamToDistance(param: Point2d, result?: Point2d): Point2d {\r\n    return this.convertParamXYToDistance(param.x, param.y, result);\r\n  }\r\n  /** Return normalized (0-1) parameter from stored parameter value. */\r\n  public convertParamToNormalized(param: Point2d, result?: Point2d): Point2d {\r\n    return this.convertParamXYToNormalized(param.x, param.y, result);\r\n  }\r\n  /** Scale distance paramaters. */\r\n  public scaleDistances(distanceScale: number) {\r\n    this._paramDistanceRange.low.x *= distanceScale;\r\n    this._paramDistanceRange.low.y *= distanceScale;\r\n    this._paramDistanceRange.high.x *= distanceScale;\r\n    this._paramDistanceRange.high.y *= distanceScale;\r\n  }\r\n  /**\r\n   * Sets the param and paramDistance range of this FacetFaceData based on the newly terminated facets that make it up.\r\n   * Takes the polyface itself, the first and last indexes of the facets to be included in the face.\r\n   * Returns true on success, false otherwise.\r\n   */\r\n  public setParamDistanceRangeFromNewFaceData(polyface: IndexedPolyface, facetStart: number, facetEnd: number): boolean {\r\n    const dSTotal = Point2d.create();\r\n    const dSSquaredTotal = Point2d.create();\r\n    this.setNull();\r\n    let aveTotal = 0;\r\n    const visitor = IndexedPolyfaceVisitor.create(polyface, 0);\r\n    if (!visitor.moveToReadIndex(facetStart) || facetEnd <= facetStart)\r\n      return false;\r\n    do {\r\n      const numPointsInFacet = visitor.numEdgesThisFacet;\r\n      const visitorPoints = visitor.point;\r\n      const trianglePointIndexes: number[] = [];\r\n      const visitorParams = visitor.param;\r\n      const triangleParamIndexes: number[] = [];\r\n      if (!visitorParams)\r\n        return false;\r\n      visitorParams.extendRange(this._paramRange);\r\n      const dUV0 = Vector2d.create();\r\n      const dUV1 = Vector2d.create();\r\n      for (let k = 0; k < numPointsInFacet; k++) {\r\n        trianglePointIndexes[2] = k;\r\n        triangleParamIndexes[2] = k;\r\n        if (k > 1) {\r\n          visitorParams.vectorIndexIndex(triangleParamIndexes[1], triangleParamIndexes[0], dUV0);\r\n          visitorParams.vectorIndexIndex(triangleParamIndexes[1], triangleParamIndexes[2], dUV1);\r\n          const delta0 = visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[0]).minus(visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[1]));\r\n          const delta1 = visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[1]).minus(visitorPoints.getPoint3dAtUncheckedPointIndex(trianglePointIndexes[2]));\r\n          const uvCross = Math.abs(dUV0.x * dUV1.y - dUV1.x * dUV0.y);\r\n          if (uvCross) {\r\n            const dwDu = Point3d.createFrom(delta0);\r\n            dwDu.scaleInPlace(dUV1.y);\r\n            dwDu.addScaledInPlace(delta1, -dUV0.y);\r\n            const dwDv = Point3d.createFrom(delta1);\r\n            dwDv.scaleInPlace(dUV0.x);\r\n            dwDv.addScaledInPlace(delta0, -dUV1.x);\r\n            const dS = Point2d.create(dwDu.magnitude() / uvCross, dwDv.magnitude() / uvCross);\r\n            dSTotal.x += dS.x;\r\n            dSTotal.y += dS.y;\r\n            dSSquaredTotal.x += dS.x * dS.x;\r\n            dSSquaredTotal.y += dS.y * dS.y;\r\n            aveTotal++;\r\n          }\r\n        }\r\n        triangleParamIndexes[0] = triangleParamIndexes[1];\r\n        triangleParamIndexes[1] = triangleParamIndexes[2];\r\n        trianglePointIndexes[0] = trianglePointIndexes[1];\r\n        trianglePointIndexes[1] = trianglePointIndexes[2];\r\n      }\r\n    } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < facetEnd);\r\n    if (aveTotal !== 0) {\r\n      const dS = Point2d.create(dSTotal.x / aveTotal, dSTotal.y / aveTotal);\r\n      const standardDeviation = Point2d.create(Math.sqrt(Math.abs((dSSquaredTotal.x / aveTotal) - dS.x * dS.x)), Math.sqrt(Math.abs((dSSquaredTotal.y / aveTotal) - dS.y * dS.y)));\r\n      // TR# 268980 - Add standard deviation to match QV....\r\n      this._paramDistanceRange.low.set(0, 0);\r\n      this._paramDistanceRange.high.set((dS.x + standardDeviation.x) * (this._paramRange.high.x - this._paramRange.low.x), (dS.y + standardDeviation.y) * (this._paramRange.high.y - this._paramRange.low.y));\r\n    }\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// For boundary sorting, an edge exists as a (packed!) Float64Array.\r\n// Fixed entries are:\r\n// 0:\r\n/**\r\n * * For boundary sorting, an edge is a (packed!) Float64Array.\r\n * * Fixed entry positions are:\r\n *   * [0] is start vertex index (in CCW order around its facet)\r\n *   * [1] is end vertex index (in CCW order around its facet)\r\n *   * [2] is facet index.\r\n */\r\nexport class SortableEdge extends Float64Array {\r\n  /** Return the vertex index that appears first in the order stored.  */\r\n  public get vertexIndexA(): number { return this[0]; }\r\n  /** Return the vertex index that appears second in the order stored.  */\r\n  public get vertexIndexB(): number { return this[1]; }\r\n  /** Return the facet index.  */\r\n  public get facetIndex(): number { return this[2]; }\r\n  /** return true if vertexIndexA is less than vertexIndexB */\r\n  public get isLowHigh(): boolean { return this[0] < this[1]; }\r\n  /** Return the vertex index with lower numeric value */\r\n  public get lowVertexIndex(): number { return this[0] < this[1] ? this[0] : this[1]; }\r\n  /** Return the vertex index with higher numeric value */\r\n  public get highVertexIndex(): number { return this[0] > this[1] ? this[0] : this[1]; }\r\n  /** Return true if the vertices edgeA and edgeB are the same vertex indices in opposite order */\r\n  public static areDirectedPartners(edgeA: SortableEdge, edgeB: SortableEdge): boolean { return edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]; }\r\n  /** Return true if the vertices edgeA and edgeB are the same vertex indices with no consideration of order */\r\n  public static areUndirectedPartners(edgeA: SortableEdge, edgeB: SortableEdge): boolean {\r\n    return (edgeA[0] === edgeB[0] && edgeA[1] === edgeB[1]) || ((edgeA[0] === edgeB[1] && edgeA[1] === edgeB[0]));\r\n  }\r\n  public get isNullEdge(): boolean { return this[0] === this[1]; }\r\n  /**\r\n   * lexical comparison of two edges.\r\n   * * If the edges have the same vertex pair (in same or opposite order) they will end up adjacent in a sort\r\n   * * If the edges have 0 or 1 shared vertex indices, the one with lowest low comes first.\r\n   * @param edgeA first edge\r\n   * @param edgeB second edge\r\n   */\r\n  public static lessThan(edgeA: SortableEdge, edgeB: SortableEdge): number {\r\n    // primary compare is based on indirect indices\r\n    const lowA = edgeA.lowVertexIndex;\r\n    const lowB = edgeB.lowVertexIndex;\r\n    if (lowA < lowB)\r\n      return -1;\r\n    if (lowB < lowA)\r\n      return 1;\r\n    const highA = edgeA.highVertexIndex;\r\n    const highB = edgeB.highVertexIndex;\r\n    if (highA < highB)\r\n      return -1;\r\n    if (highB < highA)\r\n      return 1;\r\n    // undirected indices match ... use directed vertexIndexA\r\n    return edgeA.vertexIndexA - edgeB.vertexIndexA;\r\n  }\r\n  public constructor(vertexA: number, vertexB: number, facetIndex: number) {\r\n    super(3);\r\n    this[0] = vertexA;\r\n    this[1] = vertexB;\r\n    this[2] = facetIndex;\r\n  }\r\n  public toJSON(): any { return [this[0], this[1], this[2]]; }\r\n  public static clusterToJSON(data: SortableEdgeCluster): any {\r\n    if (data instanceof SortableEdge)\r\n      return data.toJSON();\r\n\r\n    const result = [];\r\n    for (const edge of data) result.push(edge.toJSON());\r\n  }\r\n  public static clusterArrayToJSON(data: SortableEdgeCluster[]) {\r\n    const result = [];\r\n    for (const cluster of data)\r\n      result.push(SortableEdge.clusterToJSON(cluster));\r\n    return result;\r\n  }\r\n}\r\n\r\nexport type SortableEdgeCluster = SortableEdge | SortableEdge[];\r\n/**\r\n * An IndexedEdgeMatcher carries an array (`edges`) of edges start & end indices for sorting and subsequent analyses (such as testing for closed mesh)\r\n */\r\nexport class IndexedEdgeMatcher {\r\n  public edges: SortableEdge[];\r\n\r\n  constructor() {\r\n    this.edges = [];\r\n  }\r\n  /**\r\n   * push a new edge.\r\n   * @returns the edge (as emplaced at the back of the sortableEdge array)\r\n   * @param vertexA start vertex\r\n   * @param vertexB end vertex\r\n   * @param facetIndex facet index\r\n   */\r\n  public addEdge(vertexA: number, vertexB: number, facetIndex: number): SortableEdge {\r\n    const edge = new SortableEdge(vertexA, vertexB, facetIndex);\r\n    this.edges.push(edge);\r\n    return edge;\r\n  }\r\n  /**\r\n   * Push edges all around a facet, returning to vertexArray[0]\r\n   * @param vertexArray array of vertex indices around facet\r\n   * @param facetIndex\r\n   */\r\n  public addPath(vertexArray: number[], facetIndex: number, closeLoop: boolean = true) {\r\n    if (vertexArray.length === 0) return;\r\n    const m = vertexArray.length - 1;\r\n    for (let i = 0; i < m; i++) {\r\n      this.addEdge(vertexArray[i], vertexArray[i + 1], facetIndex);\r\n    }\r\n    if (closeLoop)\r\n      this.addEdge(vertexArray[m], vertexArray[0], facetIndex);\r\n  }\r\n  /** Sort the edge index array. */\r\n  public sort() {\r\n    this.edges.sort(SortableEdge.lessThan);\r\n  }\r\n  /** Create a single or compound SortableEdgeCluster in dest. */\r\n  private collectSortableEdgeCluster(index0: number, index1: number, dest: SortableEdgeCluster[] | undefined) {\r\n    if (dest !== undefined && index1 > index0) {\r\n      if (index1 === index0 + 1) {\r\n        dest.push(this.edges[index0]);\r\n      } else {\r\n        const cluster = [];\r\n        for (let i = index0; i < index1; i++)\r\n          cluster.push(this.edges[i]);\r\n        dest.push(cluster);\r\n      }\r\n\r\n    }\r\n  }\r\n  /**\r\n   * sort the edges, and look for three categories of paired edges:\r\n   * * caller must allocate all result arrays of interest.\r\n   * * Any combination of the result arrays may be `undefined`, indicating that category is to be ignored.\r\n   * * Any combination of the result arrays may be aliased as the same target, in which case those to categories are merged into the target.\r\n   * * For instance, to ignore manifold pairs and collect all others (singleton and other) as a single array `allOther`, create `const allOther = []` as an empty array and call\r\n   * `sortAndCollectClusters (undefined, allOther, allOther);`\r\n   * @param manifoldPairs optional array to receive pairs of properly mated SortableEdgePairs, i.e. simple interior edges adjacent to two facets in opposing directions.\r\n   * @param singletons optional array to receive edges that are simple boundary edges.\r\n   * @param nullEdges clusters with null edges (same start and end vertex)\r\n   * @param allOtherClusters optional array to receive arrays in which all the edges are partners in an undirected sense but not a simple directed pair.\r\n   */\r\n  public sortAndCollectClusters(manifoldPairs: SortableEdgeCluster[] | undefined, singletons: SortableEdgeCluster[] | undefined, nullEdges: SortableEdgeCluster[] | undefined, allOtherClusters: SortableEdgeCluster[] | undefined) {\r\n    this.sort();\r\n    if (manifoldPairs) manifoldPairs.length = 0;\r\n    if (singletons) singletons.length = 0;\r\n    if (nullEdges) nullEdges.length = 0;\r\n    if (allOtherClusters) allOtherClusters.length = 0;\r\n    const n = this.edges.length;\r\n    let clusterLength;\r\n    for (let index0 = 0; index0 < n; index0 += clusterLength) {\r\n      const baseEdge = this.edges[index0];\r\n      clusterLength = 1;\r\n      for (let index1 = index0 + 1; index1 < n && SortableEdge.areUndirectedPartners(baseEdge, this.edges[index1]); index1++) {\r\n        clusterLength++;\r\n      }\r\n      if (this.edges[index0].isNullEdge) {\r\n        this.collectSortableEdgeCluster(index0, index0 + clusterLength, nullEdges);\r\n      } else if (clusterLength === 2 && SortableEdge.areDirectedPartners(baseEdge, this.edges[index0 + 1])) {\r\n        this.collectSortableEdgeCluster(index0, index0 + 1, manifoldPairs);\r\n      } else if (clusterLength === 1) {\r\n        this.collectSortableEdgeCluster(index0, index0 + 1, singletons);\r\n      } else {\r\n        this.collectSortableEdgeCluster(index0, index0 + clusterLength, allOtherClusters);\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Geometry } from \"./Geometry\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { PolyfaceData } from \"./PolyfaceData\";\r\nimport { FacetFaceData } from \"./FacetFaceData\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\n\r\nfunction allDefined(valueA: any, valueB: any, valueC: any): boolean {\r\n  return valueA !== undefined && valueB !== undefined && valueC !== undefined;\r\n}\r\n\r\n/**\r\n * A Polyface is n abstract mesh structure (of unspecified implementation) that provides a PolyfaceVisitor\r\n * to iterate over its facets.\r\n * @public\r\n */\r\nexport abstract class Polyface extends GeometryQuery {\r\n  /** Underlying polyface data. */\r\n  public data: PolyfaceData;\r\n  protected constructor(data: PolyfaceData) {\r\n    super();\r\n    this._twoSided = false;\r\n    this.data = data;\r\n  }\r\n  /** create and return a visitor for this concrete polyface. */\r\n  public abstract createVisitor(_numWrap: number): PolyfaceVisitor;\r\n  private _twoSided: boolean;\r\n  /** Return the flag indicating if the mesh display must assme both sides are visible. */\r\n  public get twoSided() { return this._twoSided; }\r\n  /** set the flag indicating if the mesh display must assme both sides are visible. */\r\n  public set twoSided(value: boolean) { this._twoSided = value; }\r\n\r\n  /**\r\n   * Check validity of indices into a data array.\r\n   * * It is valid to have  both indices and data undeinfed.\r\n   * * It is NOT valid for just one to be defined.\r\n   * * Index values at indices[indexPositionA <= i < indexPositionB] must be valid indices to the data array.\r\n   * @param indices array of indices.\r\n   * @param indexPositionA first index to test\r\n   * @param indexPositionB one past final index to test\r\n   * @param data data array.  Only its length is referenced.\r\n   */\r\n  public static areIndicesValid(indices: number[] | undefined, indexPositionA: number, indexPositionB: number, data: any | undefined, dataLength: number): boolean {\r\n    if (indices === undefined && data === undefined)\r\n      return true;\r\n    if (!indices || !data)\r\n      return false;\r\n    if (indexPositionA < 0 || indexPositionA >= indices.length)\r\n      return false;\r\n    if (indexPositionB < indexPositionA || indexPositionB > indices.length)\r\n      return false;\r\n    for (let i = indexPositionA; i < indexPositionB; i++)\r\n      if (indices[i] < 0 || indices[i] >= dataLength)\r\n        return false;\r\n    return true;\r\n  }\r\n  /**\r\n   * Returns true if this polyface has no facets.\r\n   */\r\n  public abstract get isEmpty(): boolean;\r\n}\r\n/**\r\n * An `IndexedPolyface` is a set of facets which can have normal, param, and color arrays with independent point, normal, param, and color indices.\r\n * @public\r\n */\r\nexport class IndexedPolyface extends Polyface {\r\n  /** Test if other is an instance of `IndexedPolyface` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof IndexedPolyface; }\r\n  /** Tests for equivalence between two IndexedPolyfaces. */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof IndexedPolyface) {\r\n      return this.data.isAlmostEqual(other.data) && NumberArray.isExactEqual(this._facetStart, other._facetStart) &&\r\n        NumberArray.isExactEqual(this._facetToFaceData, other._facetToFaceData);\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   * Returns true if either the point array or the point index array is empty.\r\n   */\r\n  public get isEmpty(): boolean { return this.data.pointCount === 0 || this.data.pointIndex.length === 0; }\r\n  /**\r\n   * * apply the transform to points\r\n   * * apply the (inverse transpose of) the matrix part to normals\r\n   * * If determinant is negative, also\r\n   *   * negate normals\r\n   *   * reverse index order around each facet.\r\n   * @param transform\r\n   */\r\n  public tryTransformInPlace(transform: Transform) {\r\n    if (this.data.tryTransformInPlace(transform)) {\r\n      const determinant = transform.matrix.determinant();\r\n      if (determinant < 0) {\r\n        this.reverseIndices();\r\n        this.reverseNormals();\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): IndexedPolyface {\r\n    return new IndexedPolyface(this.data.clone(), this._facetStart.slice(), this._facetToFaceData.slice());\r\n  }\r\n  /** Return a deeep clone with transformed points and normals */\r\n  public cloneTransformed(transform: Transform): IndexedPolyface {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Reverse the order of indices around all facets. */\r\n  public reverseIndices() { this.data.reverseIndices(this._facetStart); }\r\n  /** Reverse the direction of all normal vectors. */\r\n  public reverseNormals() { this.data.reverseNormals(); }\r\n  /**\r\n   * * index to the index array entries for a specific facet.\r\n   * * the facet count is facetStart.length - 1\r\n   * * facet [f] indices run from facetStart[f] to upper limit facetStart[f+1].\r\n   * * Note thet the array is initialized with one entry.\r\n   */\r\n  protected _facetStart: number[];\r\n\r\n/**\r\n * * For facet i, _facetToFaceData[i] is the index of the faceData entry for the facet.\r\n * * _facetToFaceData has one entry per facet.\r\n */\r\n  protected _facetToFaceData: number[];\r\n\r\n  /** return face data using a facet index. This is the REFERENCE to the FacetFaceData, not a copy. Returns undefined if none found. */\r\n  public tryGetFaceData(i: number): FacetFaceData | undefined {\r\n    const faceIndex = this._facetToFaceData[i];\r\n    if (faceIndex >= this.data.face.length)\r\n      return undefined;\r\n    return this.data.face[faceIndex];\r\n  }\r\n  /**\r\n   * Constructor for a new polyface.\r\n   * @param data PolyfaceData arrays to capture.\r\n   * @param facetStart optional array of facet start indices (e.g. known during clone)\r\n   * @param facetToFacetData optional array of face identifiers (e.g. known during clone)\r\n   */\r\n  protected constructor(data: PolyfaceData, facetStart?: number[], facetToFaceData?: number[]) {\r\n    super(data);\r\n    if (facetStart)\r\n      this._facetStart = facetStart.slice();\r\n    else {\r\n      this._facetStart = [];\r\n      this._facetStart.push(0);\r\n    }\r\n    if (facetToFaceData)\r\n      this._facetToFaceData = facetToFaceData.slice();\r\n    else\r\n      this._facetToFaceData = [];\r\n  }\r\n  /**\r\n   * * Add facets from source to this polyface.\r\n   * * optionally reverse the facets.\r\n   * * optionally apply a transform to points.\r\n   * * will only copy param, normal, color, and face data if we are already tracking them AND/OR the source contains them\r\n   */\r\n  public addIndexedPolyface(source: IndexedPolyface, reversed: boolean, transform: Transform | undefined) {\r\n    const copyParams = allDefined(this.data.param, source.data.param, source.data.paramIndex);\r\n    const copyNormals = allDefined(this.data.normal, source.data.normal, source.data.normalIndex);\r\n    // Add point data\r\n    const sourceToDestPointIndex = new GrowableFloat64Array();\r\n    sourceToDestPointIndex.ensureCapacity(source.data.pointCount);\r\n    const sourcePoints = source.data.point;\r\n    const xyz = Point3d.create();\r\n    for (let i = 0, n = source.data.point.length; i < n; i++) {\r\n      sourcePoints.getPoint3dAtUncheckedPointIndex(i, xyz);\r\n      if (transform) {\r\n        transform.multiplyPoint3d(xyz, xyz);\r\n        sourceToDestPointIndex.push(this.addPoint(xyz));\r\n      } else\r\n        sourceToDestPointIndex.push(this.addPoint(xyz));\r\n    }\r\n\r\n    // Add point index and facet data\r\n    const numSourceFacets = source._facetStart.length - 1;\r\n    for (let i = 0; i < numSourceFacets; i++) {\r\n      const i0 = source._facetStart[i];\r\n      const i1 = source._facetStart[i + 1];\r\n      if (reversed) {\r\n        for (let j = i1; j-- > i0;) {\r\n          this.addPointIndex(sourceToDestPointIndex.atUncheckedIndex(source.data.pointIndex[j]), source.data.edgeVisible[j]);\r\n        }\r\n      } else {\r\n        for (let j = i0; j < i1; j++) {\r\n          this.addPointIndex(sourceToDestPointIndex.atUncheckedIndex(source.data.pointIndex[j]), source.data.edgeVisible[j]);\r\n        }\r\n      }\r\n      this.terminateFacet(false);\r\n    }\r\n\r\n    // Add param and param index data\r\n    if (copyParams) {\r\n      const myParams = this.data.param!;\r\n\r\n      const startOfNewParams = myParams.length;\r\n      myParams.pushFromGrowableXYArray(source.data.param!);\r\n      for (let i = 0; i < source._facetStart.length; i++) {  // Expect facet start and ends for points to match normals\r\n        const i0 = source._facetStart[i];\r\n        const i1 = source._facetStart[i + 1];\r\n        if (reversed) {\r\n          for (let j = i1; j-- > i0;)\r\n            this.addParamIndex(startOfNewParams + source.data.paramIndex![j]);\r\n        } else {\r\n          for (let j = i0; j < i1; j++)\r\n            this.addParamIndex(startOfNewParams + source.data.paramIndex![j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add normal and normal index data\r\n    if (copyNormals && source.data.normal) {\r\n      const startOfNewNormals = this.data.normal!.length;\r\n      const numNewNOrmals = source.data.normal.length;\r\n      for (let i = 0; i < numNewNOrmals; i++) {\r\n        const sourceNormal = source.data.normal.getVector3dAtCheckedVectorIndex(i)!;\r\n        if (transform) {\r\n          transform.multiplyVector(sourceNormal, sourceNormal);\r\n          this.addNormal(sourceNormal);\r\n        } else {\r\n          this.addNormal(sourceNormal);\r\n        }\r\n      }\r\n      for (let i = 0; i < source._facetStart.length; i++) {  // Expect facet start and ends for points to match normals\r\n        const i0 = source._facetStart[i];\r\n        const i1 = source._facetStart[i + 1];\r\n        if (reversed) {\r\n          for (let j = i1; j-- > i0;)\r\n            this.addNormalIndex(startOfNewNormals + source.data.normalIndex![j]);\r\n        } else {\r\n          for (let j = i0; j < i1; j++)\r\n            this.addNormalIndex(startOfNewNormals + source.data.normalIndex![j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add color and color index data\r\n    if (this.data.color && source.data.color && source.data.colorIndex) {\r\n      const startOfNewColors = this.data.color.length;\r\n      for (const sourceColor of source.data.color) {\r\n        this.addColor(sourceColor);\r\n      }\r\n      for (let i = 0; i < source._facetStart.length; i++) {  // Expect facet start and ends for points to match colors\r\n        const i0 = source._facetStart[i];\r\n        const i1 = source._facetStart[i + 1];\r\n        if (reversed) {\r\n          for (let j = i1; j-- > i0;)\r\n            this.addColorIndex(startOfNewColors + source.data.colorIndex[j - 1]);\r\n        } else {\r\n          for (let j = i0; j < i1; j++)\r\n            this.addColorIndex(startOfNewColors + source.data.colorIndex[j]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Add face and facetToFace index data\r\n    if (source.data.face.length !== 0) {\r\n      const startOfNewFaceData = this.data.face.length;\r\n      for (const face of source.data.face) {\r\n        const sourceFaceData = face.clone();\r\n        this.data.face.push(sourceFaceData);\r\n      }\r\n      for (const facetToFaceIdx of source._facetToFaceData) {\r\n        this._facetToFaceData.push(startOfNewFaceData + facetToFaceIdx);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Return the total number of param indices in zero-terminated style, which includes\r\n   * * all the indices in the packed zero-based table\r\n   * * one additional index for the zero-terminator of each facet.\r\n   * @note Note that all index arrays (point, normal, param, color) have the same counts, so there\r\n   * is not a separate query for each of them.\r\n   */\r\n  public get zeroTerminatedIndexCount(): number { return this.data.pointIndex.length + this._facetStart.length - 1; }\r\n  /** Create an empty facet set, with coordinate and index data to be supplied later.\r\n   * @param needNormals true if normals will be constructed\r\n   * @param needParams true if uv parameters will be constructed\r\n   * @param needColors true if colors will e constructed.\r\n   */\r\n  public static create(needNormals: boolean = false, needParams: boolean = false, needColors: boolean = false): IndexedPolyface {\r\n    return new IndexedPolyface(new PolyfaceData(needNormals, needParams, needColors));\r\n  }\r\n  /** add (a clone of ) a point. return its 0 based index.\r\n   * @param point point coordinates\r\n   * @param priorIndex optional index of prior point to check for repeated coordinates\r\n   * @returns Returns the zero-based index of the added or reused point.\r\n   */\r\n  public addPoint(point: Point3d, priorIndex?: number): number {\r\n    if (priorIndex !== undefined) {\r\n      const distance = this.data.point.distanceIndexToPoint(priorIndex, point);\r\n      if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n        return priorIndex;\r\n    }\r\n    this.data.point.pushXYZ(point.x, point.y, point.z);\r\n    return this.data.point.length - 1;\r\n  }\r\n\r\n  /** add a point.\r\n   * @returns Returns the zero-based index of the added point.\r\n   */\r\n  public addPointXYZ(x: number, y: number, z: number): number { this.data.point.push(Point3d.create(x, y, z)); return this.data.point.length - 1; }\r\n  /** Add a uv param.\r\n   * @returns 0-based index of the added param.\r\n   */\r\n  public addParam(param: Point2d): number {\r\n    if (!this.data.param) this.data.param = new GrowableXYArray();\r\n    this.data.param.push(param);\r\n    return this.data.param.length - 1;\r\n  }\r\n  /** Add a uv parameter to the parameter array.\r\n   * @param priorIndexA first index to check for possible duplicate value.\r\n   * @param priorIndexB second index to check for possible duplicate value.\r\n   * @returns 0-based index of the nadded or reused param.\r\n   */\r\n  public addParamUV(u: number, v: number, priorIndexA?: number, priorIndexB?: number): number {\r\n    if (!this.data.param) this.data.param = new GrowableXYArray();\r\n    if (priorIndexA !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexA, u, v))\r\n      return priorIndexA;\r\n    if (priorIndexB !== undefined && this.data.isAlmostEqualParamIndexUV(priorIndexB, u, v))\r\n      return priorIndexB;\r\n    this.data.param.push(Point2d.create(u, v));\r\n    return this.data.param.length - 1;\r\n  }\r\n\r\n  /** Add a normal vector\r\n   * @param priorIndexA first index to check for possible duplicate value.\r\n   * @param priorIndexB second index to check for possible duplicate value.\r\n   * @returns 0-based index of the nadded or reused normal.\r\n   */\r\n  public addNormal(normal: Vector3d, priorIndexA?: number, priorIndexB?: number): number {\r\n    if (this.data.normal !== undefined) {\r\n      let distance;\r\n\r\n      if (priorIndexA !== undefined) {\r\n        distance = this.data.normal.distanceIndexToPoint(priorIndexA, normal);\r\n        if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n          return priorIndexA;\r\n      }\r\n      if (priorIndexB !== undefined) {\r\n        distance = this.data.normal.distanceIndexToPoint(priorIndexB, normal);\r\n        if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n          return priorIndexB;\r\n      }\r\n      const tailIndex = this.data.normal.length - 1;\r\n      distance = this.data.normal.distanceIndexToPoint(tailIndex, normal);\r\n      if (distance !== undefined && Geometry.isSmallMetricDistance(distance))\r\n        return tailIndex;\r\n    }\r\n\r\n    return this.addNormalXYZ(normal.x, normal.y, normal.z);\r\n  }\r\n\r\n  /** Add a normal vector given by direct coordinates\r\n   * @returns 0-based index of the nadded or reused param.\r\n   */\r\n  public addNormalXYZ(x: number, y: number, z: number): number {\r\n    if (!this.data.normal) this.data.normal = new GrowableXYZArray();\r\n    this.data.normal!.pushXYZ(x, y, z);\r\n    return this.data.normal!.length - 1;\r\n  }\r\n\r\n  /** Add a color\r\n   * @returns 0-based index of the nadded or reused color.\r\n   */\r\n  public addColor(color: number): number {\r\n    if (!this.data.color) this.data.color = [];\r\n    this.data.color.push(color);\r\n    return this.data.color.length - 1;\r\n  }\r\n  /** Add a point index with edge visibility flag. */\r\n  public addPointIndex(index: number, visible: boolean = true): void { this.data.pointIndex.push(index); this.data.edgeVisible.push(visible); }\r\n  /** Add a normal index */\r\n  public addNormalIndex(index: number): void {\r\n    if (!this.data.normalIndex)\r\n      this.data.normalIndex = [];\r\n    this.data.normalIndex.push(index);\r\n  }\r\n  /** Add a param index */\r\n  public addParamIndex(index: number): void {\r\n    if (!this.data.paramIndex)\r\n      this.data.paramIndex = [];\r\n    this.data.paramIndex.push(index);\r\n  }\r\n  /** Add a color index */\r\n  public addColorIndex(index: number): void {\r\n    if (!this.data.colorIndex)\r\n      this.data.colorIndex = [];\r\n    this.data.colorIndex.push(index);\r\n  }\r\n\r\n  /** clean up the open facet.  return the returnValue (so caller can easily return cleanupOpenFacet(\"message\")) */\r\n  public cleanupOpenFacet(): void {\r\n    this.data.trimAllIndexArrays(this.data.pointIndex.length);\r\n  }\r\n  /** announce the end of construction of a facet.\r\n   *\r\n   * * The \"open\" facet is checked for:\r\n   *\r\n   * **  Same number of indices among all active index arrays --  point, normal, param, color\r\n   * **  All indices are within bounds of the respective data arrays.\r\n   * *  in error cases, all index arrays are trimmed back to the size when previous facet was terminated.\r\n   * *  \"undefined\" return is normal.   Any other return is a description of an error.\r\n   */\r\n  public terminateFacet(validateAllIndices: boolean = true): any {\r\n    const numFacets = this._facetStart.length - 1;\r\n    const lengthA = this._facetStart[numFacets];  // number of indices in accepted facets\r\n    const lengthB = this.data.pointIndex.length; // number of indices including the open facet\r\n    if (validateAllIndices) {\r\n      const messages: any[] = [];\r\n\r\n      if (lengthB < lengthA + 2)\r\n        messages.push(\"Less than 3 indices in open facet\");\r\n      if (this.data.normalIndex && this.data.normalIndex.length !== lengthB)\r\n        messages.push(\"normalIndex count must match pointIndex count\");\r\n      if (this.data.paramIndex && this.data.paramIndex.length !== lengthB)\r\n        messages.push(\"paramIndex count must equal pointIndex count\");\r\n      if (this.data.colorIndex && this.data.colorIndex.length !== lengthB)\r\n        messages.push(\"colorIndex count must equal pointIndex count\");\r\n      if (this.data.edgeVisible.length !== lengthB)\r\n        messages.push(\"visibleIndex count must equal pointIndex count\");\r\n\r\n      if (!Polyface.areIndicesValid(this.data.normalIndex, lengthA, lengthB, this.data.normal, this.data.normal ? this.data.normal.length : 0))\r\n        messages.push(\"invalid normal indices in open facet\");\r\n      if (messages.length > 0) {\r\n        this.cleanupOpenFacet();\r\n        return messages;\r\n      }\r\n    }\r\n    // appending to facetStart accepts the facet !!!\r\n    this._facetStart.push(lengthB);\r\n    return undefined;\r\n  }\r\n  /**\r\n   * All terminated facets added since the declaration of the previous face\r\n   * will be grouped into a new face with their own 2D range.\r\n   */\r\n  /** (read-only property) number of facets */\r\n  public get facetCount(): number { return this._facetStart.length - 1; }\r\n  /** (read-only property) number of faces */\r\n  public get faceCount(): number { return this.data.faceCount; }\r\n  /** (read-only property) number of points */\r\n  public get pointCount(): number { return this.data.pointCount; }\r\n  /** (read-only property) number of colors */\r\n  public get colorCount(): number { return this.data.colorCount; }\r\n  /** (read-only property) number of parameters */\r\n  public get paramCount(): number { return this.data.paramCount; }\r\n  /** (read-only property) number of normals */\r\n  public get normalCount(): number { return this.data.normalCount; }\r\n  /** Return the number of edges in a particular facet. */\r\n  public numEdgeInFacet(facetIndex: number): number {\r\n    if (this.isValidFacetIndex(facetIndex))\r\n      return this._facetStart[facetIndex + 1] - this._facetStart[facetIndex];\r\n    return 0;\r\n  }\r\n  /** test if `index` is a valid facet index. */\r\n  public isValidFacetIndex(index: number): boolean { return index >= 0 && index + 1 < this._facetStart.length; }\r\n  /** ASSUME valid facet index . .. return its start index in index arrays. */\r\n  public facetIndex0(index: number): number { return this._facetStart[index]; }\r\n  /** ASSUME valid facet index . .. return its end index in index arrays. */\r\n  public facetIndex1(index: number): number { return this._facetStart[index + 1]; }\r\n  /** create a visitor for this polyface */\r\n  public createVisitor(numWrap: number = 0): PolyfaceVisitor { return IndexedPolyfaceVisitor.create(this, numWrap); }\r\n  /** Return the range of (optionally transformed) points in this mesh. */\r\n  public range(transform?: Transform, result?: Range3d): Range3d { return this.data.range(result, transform); }\r\n  /** Extend `range` with coordinates from this mesh */\r\n  public extendRange(range: Range3d, transform?: Transform): void { this.data.range(range, transform); }\r\n\r\n  /** Given the index of a facet, return the data pertaining to the face it is a part of. */\r\n  public getFaceDataByFacetIndex(facetIndex: number): FacetFaceData {\r\n    return this.data.face[this._facetToFaceData[facetIndex]];\r\n  }\r\n\r\n  /**\r\n   * All terminated facets since the last face declaration will be mapped to a single new FacetFaceData object\r\n   * using facetToFaceData[]. FacetFaceData holds the 2D range of the face. Returns true if successful, false otherwise.\r\n   */\r\n  public setNewFaceData(endFacetIndex: number = 0): boolean {\r\n    const facetStart = this._facetToFaceData.length;\r\n    if (facetStart >= this._facetStart.length)\r\n      return false;\r\n\r\n    if (0 === endFacetIndex)  // The default for endFacetIndex is really the last facet\r\n      endFacetIndex = this._facetStart.length; // Last facetStart index corresponds to the next facet if we were to create one\r\n\r\n    const faceData = FacetFaceData.createNull();\r\n    const visitor = IndexedPolyfaceVisitor.create(this, 0);\r\n\r\n    if (!visitor.moveToReadIndex(facetStart)) {  // Move visitor to first facet of new face\r\n      return false;\r\n    }\r\n\r\n    // If parameter range is provided (by the polyface planeset clipper) then use it\r\n    const paramDefined = this.data.param !== undefined;\r\n    const setParamRange: boolean = faceData.paramRange.isNull && paramDefined;\r\n\r\n    do {\r\n      if (setParamRange && visitor.param !== undefined)\r\n        visitor.param.extendRange(faceData.paramRange);\r\n    } while (visitor.moveToNextFacet() && visitor.currentReadIndex() < endFacetIndex);\r\n\r\n    if (paramDefined && !(this.data.param!.length === 0) && faceData.paramDistanceRange.isNull)\r\n      faceData.setParamDistanceRangeFromNewFaceData(this, facetStart, endFacetIndex);\r\n\r\n    this.data.face.push(faceData);\r\n    const faceDataIndex = this.data.face.length - 1;\r\n    for (let i = this._facetToFaceData.length; i < endFacetIndex; i++)\r\n      this._facetToFaceData.push(0 === this._facetStart[i] ? 0 : faceDataIndex);\r\n\r\n    return true;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleIndexedPolyface(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleIndexedPolyface(this);\r\n  }\r\n}\r\n\r\n/**\r\n * A PolyfaceVisitor manages data while walking through facets.\r\n *\r\n * * The polyface visitor holds data for one facet at a time.\r\n * * The caller can request the position in the addressed facets as a \"readIndex.\"\r\n * * The readIndex value (as a number) is not promised to be sequential. (I.e. it might be a simple facet count or might be\r\n * @public\r\n */\r\nexport interface PolyfaceVisitor extends PolyfaceData {\r\n  /** Load data for the facet with given index. */\r\n  moveToReadIndex(index: number): boolean;\r\n  /** Return  the readIndex of the currently loaded facet */\r\n  currentReadIndex(): number;\r\n  /** Load data for th enext facet. */\r\n  moveToNextFacet(): boolean;\r\n  /** Reset to initial state for reading all facets sequentially with moveToNextFacet */\r\n  reset(): void;\r\n  /** Return the point index of vertex i within the currently loaded facet */\r\n  clientPointIndex(i: number): number;\r\n  /** Return the param index of vertex i within the currently loaded facet */\r\n  clientParamIndex(i: number): number;\r\n  /** Return the normal index of vertex i within the currently loaded facet */\r\n  clientNormalIndex(i: number): number;\r\n  /** Return the color index of vertex i within the currently loaded facet */\r\n  clientColorIndex(i: number): number;\r\n  /** Return the aux data index of vertex i within the currently loaded facet */\r\n  clientAuxIndex(i: number): number;\r\n}\r\n\r\n/**\r\n * An `IndexedPolyfaceVisitor` is an iterator-like object that \"visits\" facets of a mesh.\r\n * * The visitor extends a `PolyfaceData ` class, so it can at any time hold all the data of a single facet.\r\n * @public\r\n */\r\nexport class IndexedPolyfaceVisitor extends PolyfaceData implements PolyfaceVisitor {\r\n  private _currentFacetIndex: number;\r\n  private _nextFacetIndex: number;\r\n  private _numWrap: number;\r\n  private _numEdges: number;\r\n  private _polyface: IndexedPolyface;\r\n  // to be called from static factory method that validates the polyface ...\r\n  private constructor(facets: IndexedPolyface, numWrap: number) {\r\n    super(facets.data.normalCount > 0, facets.data.paramCount > 0, facets.data.colorCount > 0);\r\n    this._polyface = facets;\r\n    this._numWrap = numWrap;\r\n    if (facets.data.auxData)\r\n      this.auxData = facets.data.auxData.createForVisitor();\r\n\r\n    this.reset();\r\n    this._numEdges = 0;\r\n    this._nextFacetIndex = 0;\r\n    this._currentFacetIndex = -1;\r\n\r\n  }\r\n  /** Retrun the numbe rof edges in the current facet.\r\n   * * Not that if this visitor has `numWrap` greater than zero, the number of edges is smaller than the number of points.\r\n   */\r\n  public get numEdgesThisFacet(): number { return this._numEdges; }\r\n  /** Create a visitor for iterating the facets of `polyface`, with indicated number of points to be added to each facet to produce closed point arrays\r\n   * Typical wrap counts are:\r\n   * * 0 -- leave the point arrays with \"missing final edge\"\r\n   * * 1 -- add point 0 as closure point\r\n   * * 2 -- add points 0 and 1 as closure and wrap point.  This is useful when vertex visit requires two adjacent vectors, e.g. for cross products.\r\n   */\r\n  public static create(polyface: IndexedPolyface, numWrap: number): IndexedPolyfaceVisitor {\r\n    return new IndexedPolyfaceVisitor(polyface, numWrap);\r\n  }\r\n  /** Advance the iterator to a particular facet in the client polyface */\r\n  public moveToReadIndex(facetIndex: number): boolean {\r\n    if (!this._polyface.isValidFacetIndex(facetIndex)) return false;\r\n    this._currentFacetIndex = facetIndex;\r\n    this._nextFacetIndex = facetIndex + 1;\r\n    this._numEdges = this._polyface.numEdgeInFacet(facetIndex);\r\n    this.resizeAllDataArrays(this._numEdges + this._numWrap);\r\n    this.gatherIndexedData(this._polyface.data, this._polyface.facetIndex0(this._currentFacetIndex), this._polyface.facetIndex1(this._currentFacetIndex), this._numWrap);\r\n    return true;\r\n  }\r\n  /** Advance the iterator to a the 'next' facet in the client polyface */\r\n  public moveToNextFacet(): boolean {\r\n    if (this._nextFacetIndex !== this._currentFacetIndex)\r\n      return this.moveToReadIndex(this._nextFacetIndex);\r\n    this._nextFacetIndex++;\r\n    return true;\r\n  }\r\n  /** Reset the iterator to start at the first facet of the polyface. */\r\n  public reset(): void {\r\n    this.moveToReadIndex(0);\r\n    this._nextFacetIndex = 0; // so immediate moveToNextFacet stays here.\r\n  }\r\n\r\n  /**\r\n   * Attempts to extract the distance parameter for the given vertex index on the current facet\r\n   * Returns the distance parameter as a point. Returns undefined on failure.\r\n   */\r\n  public tryGetDistanceParameter(index: number, result?: Point2d): Point2d | undefined {\r\n    if (index >= this.numEdgesThisFacet)\r\n      return undefined;\r\n\r\n    if (this.param === undefined || this._polyface.data.face.length === 0)\r\n      return undefined;\r\n\r\n    const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);\r\n    if (!faceData)\r\n      return undefined;\r\n    return faceData.convertParamXYToDistance(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);\r\n  }\r\n\r\n  /**\r\n   * Attempts to extract the normalized parameter (0,1) for the given vertex index on the current facet.\r\n   * Returns the normalized parameter as a point. Returns undefined on failure.\r\n   */\r\n  public tryGetNormalizedParameter(index: number, result?: Point2d): Point2d | undefined {\r\n    if (index >= this.numEdgesThisFacet)\r\n      return undefined;\r\n\r\n    if (this.param === undefined || this._polyface.data.face.length === 0)\r\n      return undefined;\r\n\r\n    const faceData = this._polyface.tryGetFaceData(this._currentFacetIndex);\r\n    if (!faceData)\r\n      return undefined;\r\n    return faceData.convertParamXYToNormalized(this.param.getXAtUncheckedPointIndex(index), this.param.getYAtUncheckedPointIndex(index), result);\r\n  }\r\n  /** Return the index (in the client polyface) of the current facet */\r\n  public currentReadIndex(): number { return this._currentFacetIndex; }\r\n  /** Return the point index of vertex i within the currently loaded facet */\r\n  public clientPointIndex(i: number): number { return this.pointIndex[i]; }\r\n  /** Return the param index of vertex i within the currently loaded facet */\r\n  public clientParamIndex(i: number): number { return this.paramIndex ? this.paramIndex[i] : -1; }\r\n  /** Return the normal index of vertex i within the currently loaded facet */\r\n  public clientNormalIndex(i: number): number { return this.normalIndex ? this.normalIndex[i] : -1; }\r\n  /** Return the color index of vertex i within the currently loaded facet */\r\n  public clientColorIndex(i: number): number { return this.colorIndex ? this.colorIndex[i] : -1; }\r\n  /** Return the aux data index of vertex i within the currently loaded facet */\r\n  public clientAuxIndex(i: number): number { return this.auxData ? this.auxData.indices[i] : -1; }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Geometry, AxisOrder, Angle, AngleSweep, BSIJSONValues } from \"./Geometry\";\r\nimport { IndexedPolyface } from \"./Polyface\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d, XYZ } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { BoxTopology } from \"./BoxTopology\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { CurveChain, CurveCollection } from \"../curve/CurveCollection\";\r\n\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\nimport { AnyCurve } from \"../curve/CurveChain\";\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { HalfEdgeGraph, HalfEdge, HalfEdgeToBooleanFunction } from \"../topology/Graph\";\r\nimport { NullGeometryHandler, UVSurface } from \"../geometry3d/GeometryHandler\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { StrokeCountSection } from \"../curve/Query/StrokeCountChain\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Range1d } from \"../geometry3d/Range\";\r\nimport { ConstructCurveBetweenCurves } from \"../curve/ConstructCurveBetweenCurves\";\r\nimport { CylindricalRangeQuery } from \"../curve/Query/CylindricalRange\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { BilinearPatch } from \"../geometry3d/BilinearPatch\";\r\n\r\n/* tslint:disable:variable-name prefer-for-of*/\r\n\r\n/**\r\n * A FacetSector\r\n * * initially holds coordinate data for a place where xyz and sectionDerivative are known\r\n * * normal is computed as a deferred step using an edge to adjacent place on ruled surface\r\n * * indices are set up even later.\r\n */\r\nclass FacetSector {\r\n  public xyz: Point3d;\r\n  public xyzIndex: number;\r\n  public normal?: Vector3d;\r\n  public normalIndex: number;\r\n  public uv?: Point2d;\r\n  public uvIndex: number;\r\n  public sectionDerivative?: Vector3d;\r\n  public constructor(needNormal: boolean = false, needUV: boolean = false, needSectionDerivative: boolean = false) {\r\n    this.xyz = Point3d.create();\r\n    this.normalIndex = -1;\r\n    this.uvIndex = -1;\r\n\r\n    this.xyzIndex = -1;\r\n    if (needNormal) {\r\n      this.normal = Vector3d.create();\r\n    }\r\n    if (needUV) {\r\n      this.uv = Point2d.create();\r\n      this.uvIndex = -1;\r\n    }\r\n    if (needSectionDerivative) {\r\n      this.sectionDerivative = Vector3d.create();\r\n    }\r\n  }\r\n  /** copy contents (not pointers) from source\r\n   * * ASSUME all fields defined in this are defined int the source (undefined check only needed on this)\r\n   */\r\n  public copyContentsFrom(other: FacetSector) {\r\n    this.xyz.setFromPoint3d(other.xyz);\r\n    this.xyzIndex = other.xyzIndex;\r\n    if (this.normal)\r\n      this.normal.setFromVector3d(other.normal!);\r\n    this.normalIndex = other.normalIndex;\r\n    if (this.uv)\r\n      this.uv.setFrom(other.uv);\r\n    this.uvIndex = other.uvIndex;\r\n    if (this.sectionDerivative)\r\n      this.sectionDerivative.setFrom(other.sectionDerivative!);\r\n  }\r\n  /** access xyz, derivative from given arrays.\r\n   * * ASSUME corresponding defined conditions\r\n   * * xyz and derivative are set.\r\n   * * index fields for updated data are cleared to -1.\r\n   */\r\n  public loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i: number, packedXYZ: GrowableXYZArray, packedDerivatives?: GrowableXYZArray, fractions?: GrowableFloat64Array, v?: number) {\r\n    packedXYZ.getPoint3dAtCheckedPointIndex(i, this.xyz);\r\n    if (fractions && v !== undefined)\r\n      this.uv = Point2d.create(fractions.atUncheckedIndex(i), v);\r\n    this.xyzIndex = -1;\r\n    this.normalIndex = -1;\r\n    this.uvIndex = -1;\r\n    if (this.sectionDerivative !== undefined && packedDerivatives !== undefined)\r\n      packedDerivatives!.getVector3dAtCheckedVectorIndex(i, this.sectionDerivative);\r\n  }\r\n  private static suppressSmallUnitVectorComponents(uvw: XYZ) {\r\n    const tol = 1.0e-15;\r\n    if (Math.abs(uvw.x) < tol) uvw.x = 0.0;\r\n    if (Math.abs(uvw.y) < tol) uvw.y = 0.0;\r\n    if (Math.abs(uvw.z) < tol) uvw.z = 0.0;\r\n  }\r\n  private static _edgeVector: Vector3d = Vector3d.create();\r\n  /**\r\n   * given two sectors with xyz and sectionDerivative (u derivative)\r\n   * use the edge from A to B as v direction in-surface derivative.\r\n   * compute cross products (and normalize)\r\n   * @param sectorA \"lower\" sector\r\n   * @param sectorB \"upper\" sector\r\n   *\r\n   */\r\n  public static computeNormalsAlongRuleLine(sectorA: FacetSector, sectorB: FacetSector) {\r\n    // We expect that if sectionDerivative is defined so is normal.\r\n    // (If not, the cross product calls will generate normals that are never used ..  not good, garbage collector will clean up.)\r\n    if (sectorA.sectionDerivative && sectorB.sectionDerivative) {\r\n      const vectorAB = FacetSector._edgeVector;\r\n      Vector3d.createStartEnd(sectorA.xyz, sectorB.xyz, vectorAB);\r\n      sectorA.sectionDerivative!.crossProduct(vectorAB, sectorA.normal);\r\n      sectorB.sectionDerivative!.crossProduct(vectorAB, sectorB.normal);\r\n      sectorA.normal!.normalizeInPlace();\r\n      sectorB.normal!.normalizeInPlace();\r\n      FacetSector.suppressSmallUnitVectorComponents(sectorA.normal!);\r\n      FacetSector.suppressSmallUnitVectorComponents(sectorB.normal!);\r\n    }\r\n  }\r\n}\r\n/**\r\n * UVSurfaceOps is a class containing static methods operating on UVSurface objects.\r\n * @public\r\n */\r\nexport class UVSurfaceOps {\r\n  private constructor() { }  // private constructor -- no instances.\r\n  /**\r\n   * * evaluate `numEdge+1` points at surface uv parameters interpolated between (u0,v0) and (u1,v1)\r\n   * * accumulate the xyz in a linestring.\r\n   * * If xyzToUV is given, also accumulate transformed values as surfaceUV\r\n   * * use xyzToUserUV transform to convert xyz to uv stored in the linestring (this uv is typically different from surface uv -- e.g. torus cap plane coordintes)\r\n   * @param surface\r\n   * @param u0 u coordinate at start of parameter space line\r\n   * @param v0 v coordinate at end of parameter space line\r\n   * @param u1 u coordinate at start of parameter space line\r\n   * @param v1 v coordinate at end of parameter space line\r\n   * @param numEdge number of edges.   (`numEdge+1` points are evaluated)\r\n   * @param saveUV if true, save each surface uv fractions with `linestring.addUVParamsAsUV (u,v)`\r\n   * @param saveFraction if true, save each fractional coordinate (along the u,v line) with `linestring.addFraction (fraction)`\r\n   *\r\n   * @param xyzToUV\r\n   */\r\n  public static createLinestringOnUVLine(\r\n    surface: UVSurface,\r\n    u0: number,\r\n    v0: number,\r\n    u1: number,\r\n    v1: number,\r\n    numEdge: number,\r\n    saveUV: boolean = false,\r\n    saveFraction: boolean = false): LineString3d {\r\n\r\n    const ls = LineString3d.create();\r\n    const xyz = Point3d.create();\r\n    let fraction, u, v;\r\n    const numEvaluate = numEdge + 1;\r\n    for (let i = 0; i < numEvaluate; i++) {\r\n      fraction = i / numEdge;\r\n      u = Geometry.interpolate(u0, fraction, u1);\r\n      v = Geometry.interpolate(v0, fraction, v1);\r\n      surface.uvFractionToPoint(u, v, xyz);\r\n      ls.addPoint(xyz);\r\n      if (saveUV)\r\n        ls.addUVParamAsUV(u, v);\r\n      if (saveFraction)\r\n        ls.addFraction(fraction);\r\n    }\r\n    return ls;\r\n  }\r\n}\r\n/**\r\n *\r\n * * Simple construction for strongly typed GeometryQuery objects:\r\n *\r\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\r\n *  * Add GeemotryQuery objects:\r\n *\r\n *    * `builder.addGeometryQuery(g: GeometryQuery)`\r\n *    * `builder.addCone(cone: Cone)`\r\n *    * `builder.addTorusPipe(surface: TorusPipe)`\r\n *    * `builder.addLinearSweepLineStrings(surface: LinearSweep)`\r\n *    * `builder.addRotationalSweep(surface: RotatationalSweep)`\r\n *    * `builder.addLinearSweep(surface: LinearSweep)`\r\n *    * `builder.addRuledSweep(surface: RuledSweep)`\r\n *    * `builder.addSphere(sphere: Sphere)`\r\n *    * `builder.addBox(box: Box)`\r\n *    * `buidler.addIndexedPolyface(polyface)`\r\n *  *  Extract with `builder.claimPolyface (true)`\r\n *\r\n * * Simple construction for ephemeral constructive data:\r\n *\r\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\r\n *  * Add from fragmentary data:\r\n *    * `builder.addBetweenLineStrings (linestringA, linestringB, addClosure)`\r\n *    * `builder.addBetweenTransformedLineStrings (curves, transformA, transformB, addClosure)`\r\n *    * `builder.addBetweenStroked (curveA, curveB)`\r\n *    * `builder.addLinearSweepLineStrigns (contour, vector)`\r\n *    * `builder.addPolygon (points, numPointsToUse)`\r\n *    * `builder.addTransformedUnitBox (transform)`\r\n *    * `builder.addTriangleFan (conePoint, linestring, toggleOrientation)`\r\n *    * `builder.addTrianglesInUnchedkedPolygon (linestring, toggle)`\r\n *    * `builder.addUVGrid(surface,numU, numV, createFanInCaps)`\r\n *    * `builder.addGraph(Graph, acceptFaceFunction)`\r\n *  *  Extract with `builder.claimPolyface(true)`\r\n *\r\n * * Low-level detail construction -- direct use of indices\r\n *  * Create a builder with `builder = PolyfaceBuilder.create()`\r\n *  * Add GeometryQuery objects\r\n *    * `builder.findOrAddPoint(point)`\r\n *    * `builder.findOrAddPointInLineString (linestring, index)`\r\n *    * `builder.findorAddTransformedPointInLineString(linestring, index, transform)`\r\n *    * `builder.findOrAddPointXYZ(x,y,z)`\r\n *    * `builder.addTriangle (point0, point1, point2)`\r\n *    * `builder.addQuad (point0, point1, point2, point3)`\r\n *    * `builder.addOneBasedPointIndex (index)`\r\n * @public\r\n */\r\nexport class PolyfaceBuilder extends NullGeometryHandler {\r\n  private _polyface: IndexedPolyface;\r\n  private _options: StrokeOptions;\r\n  /** return (pointer to) the `StrokeOptions` in use by the builder. */\r\n  public get options(): StrokeOptions { return this._options; }\r\n  // State data that affects the current construction.\r\n  private _reversed: boolean;\r\n  /** extract the polyface. */\r\n  public claimPolyface(compress: boolean = true): IndexedPolyface {\r\n    if (compress)\r\n      this._polyface.data.compress();\r\n    return this._polyface;\r\n  }\r\n  /** Toggle (reverse) the flag controlling orientation flips for newly added facets. */\r\n  public toggleReversedFacetFlag() { this._reversed = !this._reversed; }\r\n\r\n  private constructor(options?: StrokeOptions) {\r\n    super();\r\n    this._options = options ? options : StrokeOptions.createForFacets();\r\n    this._polyface = IndexedPolyface.create(this._options.needNormals,\r\n      this._options.needParams, this._options.needColors);\r\n    this._reversed = false;\r\n  }\r\n  /**\r\n   * Create a builder with given StrokeOptions\r\n   * @param options StrokeOptions (captured)\r\n   */\r\n  public static create(options?: StrokeOptions): PolyfaceBuilder {\r\n    return new PolyfaceBuilder(options);\r\n  }\r\n  /** add facets for a transformed unit box. */\r\n  public addTransformedUnitBox(transform: Transform) {\r\n    const pointIndex0 = this._polyface.data.pointCount;\r\n    // these will have sequential indices starting at pointIndex0 . . .\r\n    for (const p of BoxTopology.points)\r\n      this._polyface.addPoint(transform.multiplyPoint3d(p));\r\n\r\n    for (const facet of BoxTopology.cornerIndexCCW) {\r\n      for (const pointIndex of facet)\r\n        this._polyface.addPointIndex(pointIndex0 + pointIndex);\r\n      this._polyface.terminateFacet();\r\n    }\r\n  }\r\n\r\n  /** Add triangles from points[0] to each far edge.\r\n   * @param ls linestring with point coordinates\r\n   * @param toggle if true, wrap the triangle creation in toggleReversedFacetFlag.\r\n   */\r\n  public addTriangleFan(conePoint: Point3d, ls: LineString3d, toggle: boolean): void {\r\n    const n = ls.numPoints();\r\n    if (n > 2) {\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n      const index0 = this.findOrAddPoint(conePoint);\r\n      let index1 = this.findOrAddPointInLineString(ls, 0)!;\r\n      let index2 = 0;\r\n      for (let i = 1; i < n; i++) {\r\n        index2 = this.findOrAddPointInLineString(ls, i)!;\r\n        this.addIndexedTrianglePointIndexes(index0, index1, index2);\r\n        index1 = index2;\r\n      }\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n    }\r\n  }\r\n\r\n  /** Add triangles from points[0] to each far edge\r\n   * * Assume the polygon is convex.\r\n   * * i.e. simple triangulation from point0\r\n   * * i.e. simple cross products give a good normal.\r\n   * @param ls linestring with point coordinates\r\n   * @param reverse if true, wrap the triangle creation in toggleReversedFacetFlag.\r\n   */\r\n  public addTrianglesInUncheckedConvexPolygon(ls: LineString3d, toggle: boolean): void {\r\n    const n = ls.numPoints();\r\n    if (n > 2) {\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n      let normal;\r\n      let normalIndex;\r\n      if (this._options.needNormals) {\r\n        normal = ls.quickUnitNormal(PolyfaceBuilder._workVectorFindOrAdd)!;\r\n        if (toggle)\r\n          normal.scaleInPlace(-1.0);\r\n        normalIndex = this._polyface.addNormal(normal);\r\n      }\r\n      const needParams = this._options.needParams;\r\n\r\n      const packedUV = needParams ? ls.packedUVParams : undefined;\r\n      let paramIndex0 = -1;\r\n      let paramIndex1 = -1;\r\n      let paramIndex2 = -1;\r\n      if (packedUV) {\r\n        paramIndex0 = this.findOrAddParamInGrowableXYArray(packedUV, 0)!;\r\n        paramIndex1 = this.findOrAddParamInGrowableXYArray(packedUV, 1)!;\r\n      }\r\n      const pointIndex0 = this.findOrAddPointInLineString(ls, 0)!;\r\n      let pointIndex1 = this.findOrAddPointInLineString(ls, 1)!;\r\n      let pointIndex2 = 0;\r\n      let numEdge = n;\r\n      if (ls.isPhysicallyClosed)\r\n        numEdge--;\r\n      for (let i = 2; i < numEdge; i++ , pointIndex1 = pointIndex2, paramIndex1 = paramIndex2) {\r\n        pointIndex2 = this.findOrAddPointInLineString(ls, i)!;\r\n        this.addIndexedTrianglePointIndexes(pointIndex0, pointIndex1, pointIndex2, false);\r\n        if (normalIndex !== undefined)\r\n          this.addIndexedTriangleNormalIndexes(normalIndex, normalIndex, normalIndex);\r\n        if (packedUV) {\r\n          paramIndex2 = this.findOrAddParamInGrowableXYArray(packedUV, i)!;\r\n          this.addIndexedTriangleParamIndexes(paramIndex0, paramIndex1, paramIndex2);\r\n        }\r\n        this._polyface.terminateFacet();\r\n      }\r\n      if (toggle)\r\n        this.toggleReversedFacetFlag();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implemetation is free to either create a new point or (if known) return indxex of a prior point with the same coordinates.\r\n   */\r\n  public findOrAddPoint(xyz: Point3d): number {\r\n    return this._polyface.addPoint(xyz);\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implemetation is free to either create a new param or (if known) return indxex of a prior param with the same coordinates.\r\n   */\r\n  public findOrAddParamXY(x: number, y: number): number {\r\n    return this._polyface.addParamUV(x, y);\r\n  }\r\n  private static _workPointFindOrAddA = Point3d.create();\r\n  private static _workVectorFindOrAdd = Vector3d.create();\r\n  private static _workUVFindOrAdd = Point2d.create();\r\n  /**\r\n   * Announce point coordinates.  The implemetation is free to either create a new point or (if knonw) return indxex of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddPointInLineString(ls: LineString3d, index: number, transform?: Transform, priorIndex?: number): number | undefined {\r\n    const q = ls.pointAt(index, PolyfaceBuilder._workPointFindOrAddA);\r\n    if (q) {\r\n      if (transform)\r\n        transform.multiplyPoint3d(q, q);\r\n      return this._polyface.addPoint(q, priorIndex);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implemetation is free to either create a new point or (if knonw) return indxex of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddPointInGrowableXYZArray(xyz: GrowableXYZArray, index: number, transform?: Transform, priorIndex?: number): number | undefined {\r\n    const q = xyz.getPoint3dAtCheckedPointIndex(index, PolyfaceBuilder._workPointFindOrAddA);\r\n    if (q) {\r\n      if (transform)\r\n        transform.multiplyPoint3d(q, q);\r\n      return this._polyface.addPoint(q, priorIndex);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /**\r\n   * Announce param coordinates.  The implemetation is free to either create a new param or (if knonw) return indxex of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the param in the linestring.\r\n   */\r\n  public findOrAddParamInGrowableXYArray(data: GrowableXYArray, index: number): number | undefined {\r\n    if (!data)\r\n      return undefined;\r\n    const q = data.getPoint2dAtUncheckedPointIndex(index, PolyfaceBuilder._workUVFindOrAdd);\r\n    if (q) {\r\n      return this._polyface.addParam(q);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Announce param coordinates, taking u from ls.fractions and v from parameter.  The implemetation is free to either create a new param or (if knonw) return indxex of a prior point with the same coordinates.\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   */\r\n  public findOrAddParamInLineString(ls: LineString3d, index: number, v: number, priorIndexA?: number, priorIndexB?: number): number | undefined {\r\n    const u = (ls.fractions && index < ls.fractions.length) ? ls.fractions.atUncheckedIndex(index) : index / ls.points.length;\r\n    return this._polyface.addParamUV(u, v, priorIndexA, priorIndexB);\r\n  }\r\n\r\n  /**\r\n   * Announce normal coordinates found at index in the linestring's surfaceNormal array\r\n   * @returns Returns the point index in the Polyface.\r\n   * @param index Index of the point in the linestring.\r\n   * @param priorIndex possible prior normal index to reuse\r\n   */\r\n  public findOrAddNormalnLineString(ls: LineString3d, index: number, transform?: Transform, priorIndexA?: number, priorIndexB?: number): number | undefined {\r\n    const linestringNormals = ls.packedSurfaceNormals;\r\n    if (linestringNormals) {\r\n      const q = linestringNormals.getVector3dAtCheckedVectorIndex(index, PolyfaceBuilder._workVectorFindOrAdd);\r\n      if (q) {\r\n        if (transform)\r\n          transform.multiplyVector(q, q);\r\n        return this._polyface.addNormal(q, priorIndexA, priorIndexB);\r\n      }\r\n    }\r\n    return undefined;\r\n\r\n  }\r\n\r\n  /**\r\n   * Announce point coordinates.  The implemetation is free to either create a new point or (if known) return index of a prior point with the same coordinates.\r\n   */\r\n  public findOrAddPointXYZ(x: number, y: number, z: number): number {\r\n    return this._polyface.addPointXYZ(x, y, z);\r\n  }\r\n\r\n  /** Returns a transform who can be applied to points on a triangular facet in order to obtain UV parameters. */\r\n  private getUVTransformForTriangleFacet(pointA: Point3d, pointB: Point3d, pointC: Point3d): Transform | undefined {\r\n    const vectorAB = pointA.vectorTo(pointB);\r\n    const vectorAC = pointA.vectorTo(pointC);\r\n    const unitAxes = Matrix3d.createRigidFromColumns(vectorAB, vectorAC, AxisOrder.XYZ);\r\n    const localToWorld = Transform.createOriginAndMatrix(pointA, unitAxes);\r\n    return localToWorld.inverse();\r\n  }\r\n\r\n  /** Returns the normal to a triangular facet. */\r\n  private getNormalForTriangularFacet(pointA: Point3d, pointB: Point3d, pointC: Point3d): Vector3d {\r\n    const vectorAB = pointA.vectorTo(pointB);\r\n    const vectorAC = pointA.vectorTo(pointC);\r\n    let normal = vectorAB.crossProduct(vectorAC).normalize();\r\n    normal = normal ? normal : Vector3d.create();\r\n    return normal;\r\n  }\r\n\r\n  // ###: Consider case where normals will be reversed and point through the other end of the facet\r\n  /**\r\n   * Add a quad to the polyface given its points in order around the edges.\r\n   * Optionally provide params and the plane normal, otherwise they will be calculated without reference data.\r\n   * Optionally mark this quad as the last piece of a face in this polyface.\r\n   */\r\n  public addQuadFacet(points: Point3d[] | GrowableXYZArray, params?: Point2d[], normals?: Vector3d[]) {\r\n    if (points instanceof GrowableXYZArray)\r\n      points = points.getPoint3dArray();\r\n    // If params and/or normals are needed, calculate them first\r\n    const needParams = this.options.needParams;\r\n    const needNormals = this.options.needNormals;\r\n    let param0: Point2d, param1: Point2d, param2: Point2d, param3: Point2d;\r\n    let normal0: Vector3d, normal1: Vector3d, normal2: Vector3d, normal3: Vector3d;\r\n    if (needParams) {\r\n      if (params !== undefined && params.length > 3) {\r\n        param0 = params[0];\r\n        param1 = params[1];\r\n        param2 = params[2];\r\n        param3 = params[3];\r\n      } else {\r\n        const paramTransform = this.getUVTransformForTriangleFacet(points[0], points[1], points[2]);\r\n        if (paramTransform === undefined) {\r\n          param0 = param1 = param2 = param3 = Point2d.createZero();\r\n        } else {\r\n          param0 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[0]));\r\n          param1 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[1]));\r\n          param2 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[2]));\r\n          param3 = Point2d.createFrom(paramTransform.multiplyPoint3d(points[3]));\r\n        }\r\n      }\r\n    }\r\n    if (needNormals) {\r\n      if (normals !== undefined && normals.length > 3) {\r\n        normal0 = normals[0];\r\n        normal1 = normals[1];\r\n        normal2 = normals[2];\r\n        normal3 = normals[3];\r\n      } else {\r\n        normal0 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n        normal1 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n        normal2 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n        normal3 = this.getNormalForTriangularFacet(points[0], points[1], points[2]);\r\n      }\r\n    }\r\n\r\n    if (this._options.shouldTriangulate) {\r\n      // Add as two triangles, with a diagonal along the shortest distance\r\n      const vectorAC = points[0].vectorTo(points[2]);\r\n      const vectorBD = points[1].vectorTo(points[3]);\r\n\r\n      // Note: We pass along any values for normals or params that we calculated\r\n      if (vectorAC.magnitude() >= vectorBD.magnitude()) {\r\n        this.addTriangleFacet([points[0], points[1], points[2]], needParams ? [param0!, param1!, param2!] : undefined, needNormals ? [normal0!, normal1!, normal2!] : undefined);\r\n        this.addTriangleFacet([points[0], points[2], points[3]], needParams ? [param0!, param2!, param3!] : undefined, needNormals ? [normal0!, normal2!, normal3!] : undefined);\r\n      } else {\r\n        this.addTriangleFacet([points[0], points[1], points[3]], needParams ? [param0!, param1!, param3!] : undefined, needNormals ? [normal0!, normal1!, normal3!] : undefined);\r\n        this.addTriangleFacet([points[1], points[2], points[3]], needParams ? [param1!, param2!, param3!] : undefined, needNormals ? [normal1!, normal2!, normal3!] : undefined);\r\n      }\r\n      return;\r\n    }\r\n\r\n    let idx0, idx1, idx2, idx3;\r\n\r\n    // Add params if needed\r\n    if (needParams) {\r\n      idx0 = this._polyface.addParam(param0!);\r\n      idx1 = this._polyface.addParam(param1!);\r\n      idx2 = this._polyface.addParam(param2!);\r\n      idx3 = this._polyface.addParam(param3!);\r\n      this.addIndexedQuadParamIndexes(idx0, idx1, idx3, idx2);\r\n    }\r\n\r\n    // Add normals if needed\r\n    if (needNormals) {\r\n      idx0 = this._polyface.addNormal(normal0!);\r\n      idx1 = this._polyface.addNormal(normal1!);\r\n      idx2 = this._polyface.addNormal(normal2!);\r\n      idx3 = this._polyface.addNormal(normal3!);\r\n      this.addIndexedQuadNormalIndexes(idx0, idx1, idx3, idx2);\r\n    }\r\n\r\n    // Add point and point indexes last (terminates the facet)\r\n    idx0 = this.findOrAddPoint(points[0]);\r\n    idx1 = this.findOrAddPoint(points[1]);\r\n    idx2 = this.findOrAddPoint(points[2]);\r\n    idx3 = this.findOrAddPoint(points[3]);\r\n    this.addIndexedQuadPointIndexes(idx0, idx1, idx3, idx2);\r\n  }\r\n\r\n  /** Announce a single quad facet's point indexes.\r\n   *\r\n   * * The actual quad may be reversed or trianglulated based on builder setup.\r\n   * *  indexA0 and indexA1 are in the forward order at the \"A\" end of the quad\r\n   * *  indexB0 and indexB1 are in the forward order at the \"B\" end of the quad.\r\n   */\r\n  private addIndexedQuadPointIndexes(indexA0: number, indexA1: number, indexB0: number, indexB1: number, terminate: boolean = true) {\r\n    if (this._reversed) {\r\n      this._polyface.addPointIndex(indexA0);\r\n      this._polyface.addPointIndex(indexB0);\r\n      this._polyface.addPointIndex(indexB1);\r\n      this._polyface.addPointIndex(indexA1);\r\n    } else {\r\n      this._polyface.addPointIndex(indexA0);\r\n      this._polyface.addPointIndex(indexA1);\r\n      this._polyface.addPointIndex(indexB1);\r\n      this._polyface.addPointIndex(indexB0);\r\n    }\r\n    if (terminate)\r\n      this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** For a single quad facet, add the indexes of the corresponding param points. */\r\n  private addIndexedQuadParamIndexes(indexA0: number, indexA1: number, indexB0: number, indexB1: number) {\r\n    if (this._reversed) {\r\n      this._polyface.addParamIndex(indexA0);\r\n      this._polyface.addParamIndex(indexB0);\r\n      this._polyface.addParamIndex(indexB1);\r\n      this._polyface.addParamIndex(indexA1);\r\n    } else {\r\n      this._polyface.addParamIndex(indexA0);\r\n      this._polyface.addParamIndex(indexA1);\r\n      this._polyface.addParamIndex(indexB1);\r\n      this._polyface.addParamIndex(indexB0);\r\n    }\r\n  }\r\n\r\n  /** For a single quad facet, add the indexes of the corresponding normal vectors. */\r\n  private addIndexedQuadNormalIndexes(indexA0: number, indexA1: number, indexB0: number, indexB1: number) {\r\n    if (this._reversed) {\r\n      this._polyface.addNormalIndex(indexA0);\r\n      this._polyface.addNormalIndex(indexB0);\r\n      this._polyface.addNormalIndex(indexB1);\r\n      this._polyface.addNormalIndex(indexA1);\r\n    } else {\r\n      this._polyface.addNormalIndex(indexA0);\r\n      this._polyface.addNormalIndex(indexA1);\r\n      this._polyface.addNormalIndex(indexB1);\r\n      this._polyface.addNormalIndex(indexB0);\r\n    }\r\n  }\r\n\r\n  // ### TODO: Consider case where normals will be reversed and point through the other end of the facet\r\n  /**\r\n   * Add a triangle to the polyface given its points in order around the edges.\r\n   * * Optionally provide params and triangle normals, otherwise they will be calculated without reference data.\r\n   */\r\n  public addTriangleFacet(points: Point3d[] | GrowableXYZArray, params?: Point2d[], normals?: Vector3d[]) {\r\n    if (points.length < 3)\r\n      return;\r\n    let idx0: number;\r\n    let idx1: number;\r\n    let idx2: number;\r\n    let point0, point1, point2;\r\n    if (points instanceof GrowableXYZArray) {\r\n      point0 = points.getPoint3dAtCheckedPointIndex(0)!;\r\n      point1 = points.getPoint3dAtCheckedPointIndex(1)!;\r\n      point2 = points.getPoint3dAtCheckedPointIndex(2)!;\r\n    } else {\r\n      point0 = points[0];\r\n      point1 = points[1];\r\n      point2 = points[2];\r\n    }\r\n\r\n    // Add params if needed\r\n    if (this._options.needParams) {\r\n      if (params && params.length >= 3) { // Params were given\r\n        idx0 = this._polyface.addParam(params[0]);\r\n        idx1 = this._polyface.addParam(params[1]);\r\n        idx2 = this._polyface.addParam(params[2]);\r\n      } else {  // Compute params\r\n        const paramTransform = this.getUVTransformForTriangleFacet(point0, point1, point2);\r\n        idx0 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point0) : undefined));\r\n        idx1 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));\r\n        idx2 = this._polyface.addParam(Point2d.createFrom(paramTransform ? paramTransform.multiplyPoint3d(point1) : undefined));\r\n      }\r\n      this.addIndexedTriangleParamIndexes(idx0, idx1, idx2);\r\n    }\r\n\r\n    // Add normals if needed\r\n    if (this._options.needNormals) {\r\n      if (normals !== undefined && normals.length > 2) { // Normals were given\r\n        idx0 = this._polyface.addNormal(normals[0]);\r\n        idx1 = this._polyface.addNormal(normals[1]);\r\n        idx2 = this._polyface.addNormal(normals[2]);\r\n      } else {  // Compute normals\r\n        const normal = this.getNormalForTriangularFacet(point0, point1, point2);\r\n        idx0 = this._polyface.addNormal(normal);\r\n        idx1 = this._polyface.addNormal(normal);\r\n        idx2 = this._polyface.addNormal(normal);\r\n      }\r\n      this.addIndexedTriangleNormalIndexes(idx0, idx1, idx2);\r\n    }\r\n\r\n    // Add point and point indexes last (terminates the facet)\r\n    idx0 = this.findOrAddPoint(point0);\r\n    idx1 = this.findOrAddPoint(point1);\r\n    idx2 = this.findOrAddPoint(point2);\r\n    this.addIndexedTrianglePointIndexes(idx0, idx1, idx2);\r\n  }\r\n\r\n  /** Announce a single triangle facet's point indexes.\r\n   *\r\n   * * The actual quad may be reversed or trianglulated based on builder setup.\r\n   * *  indexA0 and indexA1 are in the forward order at the \"A\" end of the quad\r\n   * *  indexB0 and indexB1 are in the forward order at the \"B\" end of hte quad.\r\n   */\r\n  private addIndexedTrianglePointIndexes(indexA: number, indexB: number, indexC: number, terminateFacet: boolean = true) {\r\n    if (!this._reversed) {\r\n      this._polyface.addPointIndex(indexA);\r\n      this._polyface.addPointIndex(indexB);\r\n      this._polyface.addPointIndex(indexC);\r\n    } else {\r\n      this._polyface.addPointIndex(indexA);\r\n      this._polyface.addPointIndex(indexC);\r\n      this._polyface.addPointIndex(indexB);\r\n    }\r\n    if (terminateFacet)\r\n      this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** For a single triangle facet, add the indexes of the corresponding params. */\r\n  private addIndexedTriangleParamIndexes(indexA: number, indexB: number, indexC: number) {\r\n    if (!this._reversed) {\r\n      this._polyface.addParamIndex(indexA);\r\n      this._polyface.addParamIndex(indexB);\r\n      this._polyface.addParamIndex(indexC);\r\n    } else {\r\n      this._polyface.addParamIndex(indexA);\r\n      this._polyface.addParamIndex(indexC);\r\n      this._polyface.addParamIndex(indexB);\r\n    }\r\n  }\r\n\r\n  /** For a single triangle facet, add the indexes of the corresponding params. */\r\n  private addIndexedTriangleNormalIndexes(indexA: number, indexB: number, indexC: number) {\r\n    if (!this._reversed) {\r\n      this._polyface.addNormalIndex(indexA);\r\n      this._polyface.addNormalIndex(indexB);\r\n      this._polyface.addNormalIndex(indexC);\r\n    } else {\r\n      this._polyface.addNormalIndex(indexA);\r\n      this._polyface.addNormalIndex(indexC);\r\n      this._polyface.addNormalIndex(indexB);\r\n    }\r\n  }\r\n  /** Find or add xyzIndex and normalIndex for coordinates in the sector. */\r\n  private setSectorIndices(sector: FacetSector) {\r\n    sector.xyzIndex = this.findOrAddPoint(sector.xyz);\r\n    if (sector.normal)\r\n      sector.normalIndex = this._polyface.addNormal(sector.normal);\r\n    if (sector.uv)\r\n      sector.uvIndex = this._polyface.addParam(sector.uv);\r\n  }\r\n  private addSectorQuadA01B01(sectorA0: FacetSector, sectorA1: FacetSector, sectorB0: FacetSector, sectorB1: FacetSector) {\r\n    if (sectorA0.xyz.isAlmostEqual(sectorA1.xyz) && sectorB0.xyz.isAlmostEqual(sectorB1.xyz)) {\r\n      // ignore null quad !!\r\n    } else {\r\n      if (this._options.needNormals)\r\n        this.addIndexedQuadNormalIndexes(sectorA0.normalIndex, sectorA1.normalIndex, sectorB0.normalIndex, sectorB1.normalIndex);\r\n      if (this._options.needParams)\r\n        this.addIndexedQuadParamIndexes(sectorA0.uvIndex, sectorA1.uvIndex, sectorB0.uvIndex, sectorB1.uvIndex);\r\n      this.addIndexedQuadPointIndexes(sectorA0.xyzIndex, sectorA1.xyzIndex, sectorB0.xyzIndex, sectorB1.xyzIndex);\r\n      this._polyface.terminateFacet();\r\n\r\n    }\r\n\r\n  }\r\n  /** Add facets betwee lineStrings with matched point counts.\r\n   * * surface normals are computed from (a) curve tangents in the linestrings and (b)rule line between linestrings.\r\n   * * Facets are announced to addIndexedQuad.\r\n   * * addIndexedQuad is free to apply reversal or triangulation options.\r\n   */\r\n  public addBetweenLineStringsWithRuleEdgeNormals(lineStringA: LineString3d, vA: number, lineStringB: LineString3d, vB: number, addClosure: boolean = false) {\r\n    const pointA = lineStringA.packedPoints;\r\n    const pointB = lineStringB.packedPoints;\r\n    const derivativeA = lineStringA.packedDerivatives;\r\n    const derivativeB = lineStringB.packedDerivatives;\r\n    const fractionA = lineStringA.fractions;\r\n    const fractionB = lineStringB.fractions;\r\n    const needNormals = this._options.needNormals;\r\n    const needParams = this._options.needParams;\r\n    const sectorA0 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorA1 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorB0 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorB1 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorA00 = new FacetSector(needNormals, needParams, needNormals);\r\n    const sectorB00 = new FacetSector(needNormals, needParams, needNormals);\r\n\r\n    const numPoints = pointA.length;\r\n    if (numPoints < 2 || numPoints !== pointB.length) return;\r\n    sectorA0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointA, derivativeA, fractionA, vA);\r\n    sectorB0.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(0, pointB, derivativeB, fractionB, vB);\r\n    if (needNormals)\r\n      FacetSector.computeNormalsAlongRuleLine(sectorA0, sectorB0);\r\n    this.setSectorIndices(sectorA0);\r\n    this.setSectorIndices(sectorB0);\r\n\r\n    sectorA00.copyContentsFrom(sectorA0);\r\n    sectorB00.copyContentsFrom(sectorB0);\r\n    for (let i = 1; i < numPoints; i++) {\r\n      sectorA1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointA, derivativeA, fractionA, vA);\r\n      sectorB1.loadIndexedPointAndDerivativeCoordinatesFromPackedArrays(i, pointB, derivativeA, fractionB, vB);\r\n      FacetSector.computeNormalsAlongRuleLine(sectorA1, sectorB1);\r\n      this.setSectorIndices(sectorA1);\r\n      this.setSectorIndices(sectorB1);\r\n      // create the facet ...\r\n      this.addSectorQuadA01B01(sectorA0, sectorA1, sectorB0, sectorB1);\r\n      sectorA0.copyContentsFrom(sectorA1);\r\n      sectorB0.copyContentsFrom(sectorB1);\r\n    }\r\n    if (addClosure)\r\n      this.addSectorQuadA01B01(sectorA0, sectorA00, sectorB0, sectorB00);\r\n  }\r\n\r\n  /** Add facets betwee lineStrings with matched point counts.\r\n   * * point indices prestored\r\n   * * normal indices prestored\r\n   * * uv indices prestored\r\n   */\r\n  public addBetweenLineStringsWithStoredIndices(lineStringA: LineString3d, lineStringB: LineString3d) {\r\n    const pointA = lineStringA.pointIndices!;\r\n    const pointB = lineStringB.pointIndices!;\r\n    let normalA: GrowableFloat64Array | undefined = lineStringA.normalIndices;\r\n    let normalB: GrowableFloat64Array | undefined = lineStringB.normalIndices;\r\n    if (!this._options.needNormals) {\r\n      normalA = undefined;\r\n      normalB = undefined;\r\n    }\r\n    let paramA: GrowableFloat64Array | undefined = lineStringA.paramIndices;\r\n    let paramB: GrowableFloat64Array | undefined = lineStringB.paramIndices;\r\n    if (!this._options.needParams) {\r\n      paramA = undefined;\r\n      paramB = undefined;\r\n    }\r\n\r\n    const numPoints = pointA.length;\r\n    for (let i = 1; i < numPoints; i++) {\r\n      if (pointA.atUncheckedIndex(i - 1) !== pointA.atUncheckedIndex(i) || pointB.atUncheckedIndex(i - 1) !== pointB.atUncheckedIndex(i)) {\r\n        this.addIndexedQuadPointIndexes(pointA.atUncheckedIndex(i - 1), pointA.atUncheckedIndex(i), pointB.atUncheckedIndex(i - 1), pointB.atUncheckedIndex(i));\r\n        if (normalA && normalB)\r\n          this.addIndexedQuadNormalIndexes(normalA.atUncheckedIndex(i - 1), normalA.atUncheckedIndex(i), normalB.atUncheckedIndex(i - 1), normalB.atUncheckedIndex(i));\r\n        if (paramA && paramB)\r\n          this.addIndexedQuadParamIndexes(paramA.atUncheckedIndex(i - 1), paramA.atUncheckedIndex(i), paramB.atUncheckedIndex(i - 1), paramB.atUncheckedIndex(i));\r\n        this._polyface.terminateFacet();\r\n      }\r\n    }\r\n  }\r\n\r\n  /** Add facets betwee lineStrings with matched point counts.\r\n   *\r\n   * * Facets are announced to addIndexedQuad.\r\n   * * addIndexedQuad is free to apply reversal or triangulation options.\r\n   */\r\n  public addBetweenTransformedLineStrings(curves: AnyCurve, transformA: Transform, transformB: Transform, addClosure: boolean = false) {\r\n    if (curves instanceof LineString3d) {\r\n      const pointA = curves.points;\r\n      const numPoints = pointA.length;\r\n      let indexA0 = this.findOrAddPointInLineString(curves, 0, transformA)!;\r\n      let indexB0 = this.findOrAddPointInLineString(curves, 0, transformB)!;\r\n      const indexA00 = indexA0;\r\n      const indexB00 = indexB0;\r\n      let indexA1 = 0;\r\n      let indexB1 = 0;\r\n      for (let i = 1; i < numPoints; i++) {\r\n        indexA1 = this.findOrAddPointInLineString(curves, i, transformA)!;\r\n        indexB1 = this.findOrAddPointInLineString(curves, i, transformB)!;\r\n        this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);\r\n        indexA0 = indexA1;\r\n        indexB0 = indexB1;\r\n      }\r\n      if (addClosure)\r\n        this.addIndexedQuadPointIndexes(indexA0, indexA00, indexB0, indexB00);\r\n    } else {\r\n      const children = curves.children;\r\n      // just send the children individually -- final compres will fix things??\r\n      if (children)\r\n        for (const c of children) {\r\n          this.addBetweenTransformedLineStrings(c as AnyCurve, transformA, transformB);\r\n        }\r\n    }\r\n  }\r\n\r\n  private addBetweenStrokeSetPair(dataA: AnyCurve, vA: number, dataB: AnyCurve, vB: number) {\r\n    if (dataA instanceof LineString3d && dataB instanceof LineString3d) {\r\n      this.addBetweenLineStringsWithRuleEdgeNormals(dataA, vA, dataB, vB, false);\r\n    } else if (dataA instanceof ParityRegion && dataB instanceof ParityRegion) {\r\n      if (dataA.children.length === dataB.children.length) {\r\n        for (let i = 0; i < dataA.children.length; i++) {\r\n          this.addBetweenStrokeSetPair(dataA.children[i], vA, dataB.children[i], vB);\r\n        }\r\n      }\r\n    } else if (dataA instanceof CurveChain && dataB instanceof CurveChain) {\r\n      const chainA = dataA.children;\r\n      const chainB = dataB.children;\r\n      if (chainA.length === chainB.length) {\r\n        for (let i = 0; i < chainA.length; i++) {\r\n          const cpA = chainA[i];\r\n          const cpB = chainB[i];\r\n          if (cpA instanceof LineString3d && cpB instanceof LineString3d) {\r\n            this.addBetweenLineStringsWithRuleEdgeNormals(cpA, vA, cpB, vB);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Add facets from a Cone\r\n   */\r\n  public addCone(cone: Cone) {\r\n    // ensure identical stroke counts at each end . . .\r\n    let strokeCount = 16;\r\n    if (this._options)\r\n      strokeCount = this._options.applyTolerancesToArc(cone.getMaxRadius());\r\n    let axisStrokeCount = 1;\r\n    const lineStringA = cone.strokeConstantVSection(0.0, strokeCount, this._options);\r\n    const lineStringB = cone.strokeConstantVSection(1.0, strokeCount, this._options);\r\n\r\n    if (this._options) {\r\n      const vDistanceRange = GrowableXYZArray.distanceRangeBetweenCorrespondingPoints(lineStringA.packedPoints, lineStringB.packedPoints);\r\n      axisStrokeCount = this._options.applyMaxEdgeLength(1, vDistanceRange.low);\r\n    }\r\n    const sizes = cone.maxIsoParametricDistance();\r\n    this.addUVGridBody(cone, strokeCount, axisStrokeCount, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\r\n    this.endFace();\r\n\r\n    if (cone.capped) {\r\n      if (!Geometry.isSmallMetricDistance(cone.getRadiusA())) {\r\n        this.addTrianglesInUncheckedConvexPolygon(lineStringA, true);  // lower triangles flip\r\n        this.endFace();\r\n      }\r\n      if (!Geometry.isSmallMetricDistance(cone.getRadiusB())) {\r\n        this.addTrianglesInUncheckedConvexPolygon(lineStringB, false); // upper triangles to not flip.\r\n        this.endFace();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add facets for a TorusPipe.\r\n   */\r\n  public addTorusPipe(surface: TorusPipe, phiStrokeCount?: number, thetaStrokeCount?: number) {\r\n    const thetaFraction = surface.getThetaFraction();\r\n    const numU = Geometry.clamp(Geometry.resolveNumber(phiStrokeCount, 8), 4, 64);\r\n    const numV = Geometry.clamp(\r\n      Geometry.resolveNumber(thetaStrokeCount, Math.ceil(16 * thetaFraction)),\r\n      2, 64);\r\n\r\n    this.toggleReversedFacetFlag();\r\n    const sizes = surface.maxIsoParametricDistance();\r\n    this.addUVGridBody(surface, numU, numV, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\r\n    this.toggleReversedFacetFlag();\r\n\r\n    if (surface.capped && thetaFraction < 1.0) {\r\n      const centerFrame = surface.getConstructiveFrame()!;\r\n      const minorRadius = surface.getMinorRadius();\r\n      const majorRadius = surface.getMajorRadius();\r\n      const a = 2 * minorRadius;\r\n      const r0 = majorRadius - minorRadius;\r\n      const r1 = majorRadius + minorRadius;\r\n      const z0 = -minorRadius;\r\n      const cap0ToLocal = Transform.createRowValues(\r\n        a, 0, 0, r0,\r\n        0, 0, -1, 0,\r\n        0, a, 0, z0);\r\n      const cap0ToWorld = centerFrame.multiplyTransformTransform(cap0ToLocal);\r\n      const worldToCap0 = cap0ToWorld.inverse();\r\n      if (worldToCap0) {\r\n        const ls0 = UVSurfaceOps.createLinestringOnUVLine(surface, 0, 0, 1, 0, numU, false, true);\r\n        ls0.computeUVFromXYZTransform(worldToCap0);\r\n        this.addTrianglesInUncheckedConvexPolygon(ls0, false);\r\n      }\r\n      const thetaRadians = surface.getSweepAngle().radians;\r\n      const cc = Math.cos(thetaRadians);\r\n      const ss = Math.sin(thetaRadians);\r\n\r\n      const cap1ToLocal = Transform.createRowValues(\r\n        -cc * a, 0, -ss, r1 * cc,\r\n        -ss * a, 0, cc, r1 * ss,\r\n        0, a, 0, z0);\r\n\r\n      const cap1ToWorld = centerFrame.multiplyTransformTransform(cap1ToLocal);\r\n      const worldToCap1 = cap1ToWorld.inverse();\r\n      if (worldToCap1) {\r\n        const ls1 = UVSurfaceOps.createLinestringOnUVLine(surface, 1, 1, 0, 1, numU, false, true);\r\n        ls1.computeUVFromXYZTransform(worldToCap1);\r\n        this.addTrianglesInUncheckedConvexPolygon(ls1, false);\r\n      }\r\n\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add point data (no params, normals) for linestrings.\r\n   * * This recurses through curve chains (loops and paths)\r\n   * * linestrings are swept\r\n   * * All other curve types are ignored.\r\n   * @param vector sweep vector\r\n   * @param contour contour which contains only linestrings\r\n   */\r\n  public addLinearSweepLineStringsXYZOnly(contour: AnyCurve, vector: Vector3d) {\r\n    if (contour instanceof LineString3d) {\r\n      const ls = contour as LineString3d;\r\n      let pointA = Point3d.create();\r\n      let pointB = Point3d.create();\r\n      let indexA0 = 0;\r\n      let indexA1 = 0;\r\n      let indexB0 = 0;\r\n      let indexB1 = 0;\r\n      const n = ls.numPoints();\r\n      for (let i = 0; i < n; i++) {\r\n        pointA = ls.pointAt(i, pointA)!;\r\n        pointB = pointA.plus(vector, pointB);\r\n        indexA1 = this.findOrAddPoint(pointA);\r\n        indexB1 = this.findOrAddPoint(pointB);\r\n        if (i > 0) {\r\n          this.addIndexedQuadPointIndexes(indexA0, indexA1, indexB0, indexB1);\r\n        }\r\n        indexA0 = indexA1;\r\n        indexB0 = indexB1;\r\n      }\r\n    } else if (contour instanceof CurveChain) {\r\n      for (const ls of contour.children) {\r\n        this.addLinearSweepLineStringsXYZOnly(ls, vector);\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   * Construct facets for a rotational sweep.\r\n   */\r\n  public addRotationalSweep(surface: RotationalSweep) {\r\n    const contour = surface.getCurves();\r\n    const section0 = StrokeCountSection.createForParityRegionOrChain(contour, this._options);\r\n    const baseStrokes = section0.getStrokes();\r\n\r\n    const axis = surface.cloneAxisRay();\r\n    const perpendicularVector = CylindricalRangeQuery.computeMaxVectorFromRay(axis, baseStrokes);\r\n    const swingVector = axis.direction.crossProduct(perpendicularVector);\r\n    if (this._options.needNormals)\r\n      CylindricalRangeQuery.buildRotationalNormalsInLineStrings(baseStrokes, axis, swingVector);\r\n    const maxDistance = perpendicularVector.magnitude();\r\n    const maxPath = Math.abs(maxDistance * surface.getSweep().radians);\r\n    let numStep = StrokeOptions.applyAngleTol(this._options, 1, surface.getSweep().radians, undefined);\r\n    numStep = StrokeOptions.applyMaxEdgeLength(this._options, numStep, maxPath);\r\n    for (let i = 1; i <= numStep; i++) {\r\n      const transformA = surface.getFractionalRotationTransform((i - 1) / numStep);\r\n      const transformB = surface.getFractionalRotationTransform(i / numStep);\r\n      this.addBetweenRotatedStrokeSets(baseStrokes, transformA, i - 1, transformB, i);\r\n    }\r\n    if (surface.capped) {\r\n      const capContour = surface.getSweepContourRef();\r\n      capContour.purgeFacets();\r\n      capContour.emitFacets(this, true, undefined);\r\n      // final loop pass left transformA at end ..\r\n      capContour.emitFacets(this, false, surface.getFractionalRotationTransform(1.0));\r\n    }\r\n  }\r\n  /**\r\n   * * Recursively visit all children of data.\r\n   * * At each primitive, invoke the computeStrokeCountForOptions method, with options from the builder.\r\n   * @param data\r\n   */\r\n  public applyStrokeCountsToCurvePrimitives(data: AnyCurve | GeometryQuery) {\r\n    const options = this._options;\r\n    if (data instanceof CurvePrimitive) {\r\n      data.computeStrokeCountForOptions(options);\r\n    } else if (data instanceof CurveCollection) {\r\n      const children = data.children;\r\n      if (children)\r\n        for (const child of children) {\r\n          this.applyStrokeCountsToCurvePrimitives(child);\r\n        }\r\n    }\r\n  }\r\n\r\n  private addBetweenStrokeSetsWithRuledNormals(stroke0: AnyCurve, stroke1: AnyCurve, numVEdge: number) {\r\n    const strokeSets = [stroke0];\r\n    const fractions = [0.0];\r\n    for (let vIndex = 1; vIndex < numVEdge; vIndex++) {\r\n      const vFraction = vIndex / numVEdge;\r\n      const strokeA = ConstructCurveBetweenCurves.interpolateBetween(stroke0, vIndex / numVEdge, stroke1) as AnyCurve;\r\n      strokeSets.push(strokeA);\r\n      fractions.push(vFraction);\r\n    }\r\n    strokeSets.push(stroke1);\r\n    fractions.push(1.0);\r\n    for (let vIndex = 0; vIndex < numVEdge; vIndex++) {\r\n      this.addBetweenStrokeSetPair(strokeSets[vIndex], fractions[vIndex], strokeSets[vIndex + 1], fractions[vIndex + 1]);\r\n    }\r\n  }\r\n  private createIndicesInLineString(ls: LineString3d, vParam: number, transform?: Transform) {\r\n\r\n    const n = ls.numPoints();\r\n    {\r\n      const pointIndices = ls.ensureEmptyPointIndices();\r\n      const index0 = this.findOrAddPointInLineString(ls, 0, transform);\r\n      pointIndices.push(index0!);\r\n      if (n > 1) {\r\n        let indexA = index0;\r\n        let indexB;\r\n        for (let i = 1; i + 1 < n; i++) {\r\n          indexB = this.findOrAddPointInLineString(ls, i, transform, indexA);\r\n          pointIndices.push(indexB!);\r\n          indexA = indexB;\r\n        }\r\n        // assume last point can only repeat back to zero ...\r\n        indexB = this.findOrAddPointInLineString(ls, n - 1, transform, index0);\r\n        pointIndices.push(indexB!);\r\n      }\r\n    }\r\n    if (this._options.needNormals && ls.packedSurfaceNormals !== undefined) {\r\n      const normalIndices = ls.ensureEmptyNormalIndices();\r\n      const normalIndex0 = this.findOrAddNormalnLineString(ls, 0, transform);\r\n      normalIndices.push(normalIndex0!);\r\n      let normalIndexA = normalIndex0;\r\n      let normalIndexB;\r\n      if (n > 1) {\r\n        for (let i = 1; i + 1 < n; i++) {\r\n          normalIndexB = this.findOrAddNormalnLineString(ls, i, transform, normalIndexA);\r\n          normalIndices.push(normalIndexB!);\r\n          normalIndexA = normalIndexB;\r\n        }\r\n        // assume last point can only repeat back to zero ...\r\n        normalIndexB = this.findOrAddNormalnLineString(ls, n - 1, transform, normalIndex0, normalIndexA);\r\n        normalIndices.push(normalIndexB!);\r\n      }\r\n    }\r\n    if (this._options.needParams && ls.packedUVParams !== undefined) {\r\n      const uvIndices = ls.ensureEmptyUVIndices();\r\n      const uvIndex0 = this.findOrAddParamInLineString(ls, 0, vParam);\r\n      uvIndices.push(uvIndex0!);\r\n      let uvIndexA = uvIndex0;\r\n      let uvIndexB;\r\n      if (n > 1) {\r\n        for (let i = 1; i + 1 < n; i++) {\r\n          uvIndexB = this.findOrAddParamInLineString(ls, i, vParam, uvIndexA);\r\n          uvIndices.push(uvIndexB!);\r\n          uvIndexA = uvIndexB;\r\n        }\r\n        // assume last point can only repeat back to zero ...\r\n        uvIndexB = this.findOrAddParamInLineString(ls, n - 1, vParam, uvIndexA, uvIndex0);\r\n        uvIndices.push(uvIndexB!);\r\n      }\r\n    }\r\n\r\n  }\r\n\r\n  private addBetweenRotatedStrokeSets(stroke0: AnyCurve, transformA: Transform, vA: number, transformB: Transform, vB: number) {\r\n    if (stroke0 instanceof LineString3d) {\r\n      const strokeA = stroke0.cloneTransformed(transformA) as LineString3d;\r\n      this.createIndicesInLineString(strokeA, vA);\r\n      const strokeB = stroke0.cloneTransformed(transformB) as LineString3d;\r\n      this.createIndicesInLineString(strokeB, vB);\r\n      this.addBetweenLineStringsWithStoredIndices(strokeA, strokeB);\r\n    } else if (stroke0 instanceof ParityRegion) {\r\n      for (let i = 0; i < stroke0.children.length; i++) {\r\n        this.addBetweenRotatedStrokeSets(stroke0.children[i], transformA, vA, transformB, vB);\r\n      }\r\n    } else if (stroke0 instanceof CurveChain) {\r\n      const chainA = stroke0.children;\r\n      for (let i = 0; i < chainA.length; i++) {\r\n        const cpA = chainA[i];\r\n        if (cpA instanceof LineString3d) {\r\n          this.addBetweenRotatedStrokeSets(cpA, transformA, vA, transformB, vB);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /**\r\n   *\r\n   * Add facets from\r\n   * * The swept contour\r\n   * * each cap.\r\n   */\r\n  public addLinearSweep(surface: LinearSweep) {\r\n    const contour = surface.getCurvesRef();\r\n    const section0 = StrokeCountSection.createForParityRegionOrChain(contour, this._options);\r\n    const stroke0 = section0.getStrokes();\r\n    const sweepVector = surface.cloneSweepVector();\r\n    const sweepTransform = Transform.createTranslation(sweepVector);\r\n    const stroke1 = stroke0.cloneTransformed(sweepTransform) as AnyCurve;\r\n    const numVEdge = this._options.applyMaxEdgeLength(1, sweepVector.magnitude());\r\n    this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);\r\n\r\n    if (surface.capped && contour.isAnyRegionType) {\r\n      const contourA = surface.getSweepContourRef();\r\n      contourA.purgeFacets();\r\n\r\n      contourA.emitFacets(this, true, undefined);\r\n      contourA.emitFacets(this, false, sweepTransform);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Add facets from a ruled sweep.\r\n   */\r\n  public addRuledSweep(surface: RuledSweep): boolean {\r\n    const contours = surface.sweepContoursRef();\r\n    let stroke0: AnyCurve | undefined;\r\n    let stroke1: AnyCurve;\r\n    const sectionMaps = [];\r\n    for (let i = 0; i < contours.length; i++) {\r\n      sectionMaps.push(StrokeCountSection.createForParityRegionOrChain(contours[i].curves, this._options));\r\n    }\r\n    if (StrokeCountSection.enforceStrokeCountCompatibility(sectionMaps)) {\r\n      StrokeCountSection.enforceCompatibleDistanceSums(sectionMaps);\r\n      for (let i = 0; i < contours.length; i++) {\r\n        stroke1 = sectionMaps[i].getStrokes();\r\n        if (!stroke1)\r\n          stroke1 = contours[i].curves.cloneStroked();\r\n        if (i > 0 && stroke0 && stroke1) {\r\n          const distanceRange = Range1d.createNull();\r\n          if (StrokeCountSection.extendDistanceRangeBetweenStrokes(stroke0, stroke1, distanceRange)\r\n            && !distanceRange.isNull) {\r\n            const numVEdge = this._options.applyMaxEdgeLength(1, distanceRange.high);\r\n            this.addBetweenStrokeSetsWithRuledNormals(stroke0, stroke1, numVEdge);\r\n          }\r\n        }\r\n        stroke0 = stroke1;\r\n      }\r\n    }\r\n\r\n    if (surface.capped && contours[0].curves.isAnyRegionType) {\r\n      contours[0].purgeFacets();\r\n\r\n      contours[0].emitFacets(this, true, undefined);\r\n      contours[contours.length - 1].purgeFacets();\r\n      contours[contours.length - 1].emitFacets(this, false, undefined);\r\n    }\r\n    return true;\r\n  }\r\n  /**\r\n   * Add facets from a Sphere\r\n   */\r\n  public addSphere(sphere: Sphere, strokeCount?: number) {\r\n    const numStrokeTheta = strokeCount ? strokeCount : this._options.defaultCircleStrokes;\r\n    const numStrokePhi = Geometry.clampToStartEnd(numStrokeTheta * sphere.latitudeSweepFraction, 1, Math.ceil(numStrokeTheta * 0.5));\r\n\r\n    const lineStringA = sphere.strokeConstantVSection(0.0, numStrokeTheta, this._options);\r\n    if (sphere.capped && !Geometry.isSmallMetricDistance(lineStringA.quickLength())) {\r\n      this.addTrianglesInUncheckedConvexPolygon(lineStringA, true);  // lower triangles flip\r\n      this.endFace();\r\n    }\r\n\r\n    const sizes = sphere.maxIsoParametricDistance();\r\n\r\n    this.addUVGridBody(sphere, numStrokeTheta, numStrokePhi, Segment1d.create(0, sizes.x), Segment1d.create(0, sizes.y));\r\n    this.endFace();\r\n\r\n    const lineStringB = sphere.strokeConstantVSection(1.0, numStrokeTheta, this._options);\r\n    if (sphere.capped && !Geometry.isSmallMetricDistance(lineStringB.quickLength())) {\r\n      this.addTrianglesInUncheckedConvexPolygon(lineStringB, false);  // upper triangles do not flip\r\n      this.endFace();\r\n    }\r\n  }\r\n  /**\r\n   * Add facets from a Box\r\n   */\r\n  public addBox(box: Box) {\r\n    const corners = box.getCorners();\r\n    const xLength = Geometry.maxXY(box.getBaseX(), box.getBaseX());\r\n    const yLength = Geometry.maxXY(box.getBaseY(), box.getTopY());\r\n    let zLength = 0.0;\r\n    for (let i = 0; i < 4; i++) {\r\n      zLength = Geometry.maxXY(zLength, corners[i].distance(corners[i + 4]));\r\n\r\n    }\r\n\r\n    const numX = this._options.applyMaxEdgeLength(1, xLength);\r\n    const numY = this._options.applyMaxEdgeLength(1, yLength);\r\n    const numZ = this._options.applyMaxEdgeLength(1, zLength);\r\n    // Wrap the 4 out-of-plane faces as a single parameters space with \"distance\" advancing in x then y then negative x then negative y ...\r\n    const uParamRange = Segment1d.create(0, xLength);\r\n    const vParamRange = Segment1d.create(0, zLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[0], corners[1], corners[4], corners[5]), numX, numZ, uParamRange, vParamRange);\r\n    uParamRange.shift(xLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[1], corners[3], corners[5], corners[7]), numY, numZ, uParamRange, vParamRange);\r\n    uParamRange.shift(yLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[3], corners[2], corners[7], corners[6]), numX, numZ, uParamRange, vParamRange);\r\n    uParamRange.shift(xLength);\r\n    this.addUVGridBody(BilinearPatch.create(corners[2], corners[0], corners[6], corners[4]), numY, numZ, uParamRange, vParamRange);\r\n    // finally end that wraparound face !!\r\n    this.endFace();\r\n    if (box.capped) {\r\n      uParamRange.set(0.0, xLength);\r\n      vParamRange.set(0.0, yLength);\r\n      this.addUVGridBody(BilinearPatch.create(corners[4], corners[5], corners[6], corners[7]), numX, numY, uParamRange, vParamRange);\r\n      this.endFace();\r\n\r\n      uParamRange.set(0.0, xLength);\r\n      vParamRange.set(0.0, yLength);\r\n      this.addUVGridBody(BilinearPatch.create(corners[2], corners[3], corners[0], corners[1]), numX, numY, uParamRange, vParamRange);\r\n      this.endFace();\r\n    }\r\n  }\r\n\r\n  /** Add a polygon to the evolving facets.\r\n   *\r\n   * * Add points to the polyface\r\n   * * indices are added (in reverse order if indicated by the builder state)\r\n   * @param points array of points.  This may contain extra points not to be used in the polygon\r\n   * @param numPointsToUse number of points to use.\r\n   */\r\n  public addPolygon(points: Point3d[], numPointsToUse?: number) {\r\n    // don't use trailing points that match start point.\r\n    if (numPointsToUse === undefined)\r\n      numPointsToUse = points.length;\r\n    while (numPointsToUse > 1 && points[numPointsToUse - 1].isAlmostEqual(points[0]))\r\n      numPointsToUse--;\r\n    let index = 0;\r\n    if (!this._reversed) {\r\n      for (let i = 0; i < numPointsToUse; i++) {\r\n        index = this.findOrAddPoint(points[i]);\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    } else {\r\n      for (let i = numPointsToUse; --i >= 0;) {\r\n        index = this.findOrAddPoint(points[i]);\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    }\r\n    this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** Add a polygon to the evolving facets.\r\n   *\r\n   * * Add points to the polyface\r\n   * * indices are added (in reverse order if indicated by the builder state)\r\n   * @param points array of points.  This may contain extra points not to be used in the polygon\r\n   * @param numPointsToUse number of points to use.\r\n   */\r\n  public addPolygonGrowableXYZArray(points: GrowableXYZArray) {\r\n    // don't use trailing points that match start point.\r\n    let numPointsToUse = points.length;\r\n    while (numPointsToUse > 1 && Geometry.isSmallMetricDistance(points.distance(0, numPointsToUse - 1)!))\r\n      numPointsToUse--;\r\n    let index = 0;\r\n    if (!this._reversed) {\r\n      for (let i = 0; i < numPointsToUse; i++) {\r\n        index = this.findOrAddPointInGrowableXYZArray(points, i)!;\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    } else {\r\n      for (let i = numPointsToUse; --i >= 0;) {\r\n        index = this.findOrAddPointInGrowableXYZArray(points, i)!;\r\n        this._polyface.addPointIndex(index);\r\n      }\r\n    }\r\n    this._polyface.terminateFacet();\r\n  }\r\n\r\n  /** Add a polyface, with optional reverse and transform. */\r\n  public addIndexedPolyface(source: IndexedPolyface, reversed: boolean, transform?: Transform) {\r\n    this._polyface.addIndexedPolyface(source, reversed, transform);\r\n  }\r\n\r\n  /**\r\n   * Produce a new FacetFaceData for all terminated facets since construction of the previous face.\r\n   * Each facet number/index is mapped to the FacetFaceData through the faceToFaceData array.\r\n   * Returns true if successful, and false otherwise.\r\n   */\r\n  public endFace(): boolean {\r\n    return this._polyface.setNewFaceData();\r\n  }\r\n\r\n  /** Double dispatch handler for Cone */\r\n  public handleCone(g: Cone): any { return this.addCone(g); }\r\n  /** Double dispatch handler for TorusPipe */\r\n  public handleTorusPipe(g: TorusPipe): any { return this.addTorusPipe(g); }\r\n  /** Double dispatch handler for Sphere */\r\n  public handleSphere(g: Sphere): any { return this.addSphere(g); }\r\n  /** Double dispatch handler for Box */\r\n  public handleBox(g: Box): any { return this.addBox(g); }\r\n  /** Double dispatch handler for LinearSweep */\r\n  public handleLinearSweep(g: LinearSweep): any { return this.addLinearSweep(g); }\r\n  /** Double dispatch handler for RotationalSweep */\r\n  public handleRotationalSweep(g: RotationalSweep): any { return this.addRotationalSweep(g); }\r\n  /** Double dispatch handler for RuledSweep */\r\n  public handleRuledSweep(g: RuledSweep): any { return this.addRuledSweep(g); }\r\n  /** add facets for a GeometryQuery object.   This is double dispatch through `dispatchToGeometryHandleer(this)` */\r\n  public addGeometryQuery(g: GeometryQuery) { g.dispatchToGeometryHandler(this); }\r\n\r\n  /**\r\n   *\r\n   * * Visit all faces\r\n   * * Test each face with f(node) for any node on the face.\r\n   * * For each face that passes, pass its coordinates to the builder.\r\n   * * Rely on the builder's compress step to find common vertex coordinates\r\n   * @internal\r\n   */\r\n  public addGraph(graph: HalfEdgeGraph, needParams: boolean, acceptFaceFunction: HalfEdgeToBooleanFunction = HalfEdge.testNodeMaskNotExterior) {\r\n    let index = 0;\r\n    const needNormals = this._options.needNormals;\r\n    let normalIndex = 0;\r\n    if (needNormals)\r\n      normalIndex = this._polyface.addNormalXYZ(0, 0, 1);   // big assumption !!!!  someday check if that's where the facets actually are!!\r\n\r\n    graph.announceFaceLoops(\r\n      (_graph: HalfEdgeGraph, seed: HalfEdge) => {\r\n        if (acceptFaceFunction(seed)) {\r\n          let node = seed;\r\n          do {\r\n            index = this.findOrAddPointXYZ(node.x, node.y, node.z);\r\n            this._polyface.addPointIndex(index);\r\n            if (needParams) {\r\n              index = this.findOrAddParamXY(node.x, node.y);\r\n              this._polyface.addParamIndex(index);\r\n            }\r\n            if (needNormals) {\r\n              this._polyface.addNormalIndex(normalIndex);\r\n            }\r\n            node = node.faceSuccessor;\r\n          } while (node !== seed);\r\n          this._polyface.terminateFacet();\r\n        }\r\n        return true;\r\n      });\r\n  }\r\n  /**\r\n   *\r\n   * * For each ndoe in `faces`\r\n   *  * add all of its vertices to the polyface\r\n   *  * add point indices to form a new facet.\r\n   *    * (Note: no normal or param indices are added)\r\n   *  * terminate the facet\r\n   * @internal\r\n   */\r\n  public addGraphFaces(_graph: HalfEdgeGraph, faces: HalfEdge[]) {\r\n    let index = 0;\r\n    for (const seed of faces) {\r\n      let node = seed;\r\n      do {\r\n        index = this.findOrAddPointXYZ(node.x, node.y, node.z);\r\n        this._polyface.addPointIndex(index);\r\n        node = node.faceSuccessor;\r\n      } while (node !== seed);\r\n      this._polyface.terminateFacet();\r\n    }\r\n  }\r\n  /** Create a polyface containing the faces of a HalfEdgeGraph, with test function to filter faces.\r\n   * @internal\r\n   */\r\n  public static graphToPolyface(graph: HalfEdgeGraph, options?: StrokeOptions, acceptFaceFunction: HalfEdgeToBooleanFunction = HalfEdge.testNodeMaskNotExterior): IndexedPolyface {\r\n    const builder = PolyfaceBuilder.create(options);\r\n    builder.addGraph(graph, builder.options.needParams, acceptFaceFunction);\r\n    builder.endFace();\r\n    return builder.claimPolyface();\r\n  }\r\n  /** Create a polyface containing an array of faces of a HalfEdgeGraph, with test function to filter faces.\r\n   * @internal\r\n   */\r\n  public static graphFacesToPolyface(graph: HalfEdgeGraph, faces: HalfEdge[]): IndexedPolyface {\r\n    const builder = PolyfaceBuilder.create();\r\n    builder.addGraphFaces(graph, faces);\r\n    builder.endFace();\r\n    return builder.claimPolyface();\r\n  }\r\n\r\n  /**\r\n   * Given arrays of coordinates for multiple facets.\r\n   * * pointArray[i] is an array of 3 or 4 points\r\n   * * paramArray[i] is an array of matching number of params\r\n   * * normalArray[i] is an array of matching number of normals.\r\n   * @param pointArray array of arrays of point coordinates\r\n   * @param paramArray array of arrays of uv parameters\r\n   * @param normalArray array of arrays of normals\r\n   * @param endFace if true, call this.endFace after adding all the facets.\r\n   */\r\n  public addCoordinateFacets(pointArray: Point3d[][], paramArray?: Point2d[][], normalArray?: Vector3d[][], endFace: boolean = false) {\r\n    for (let i = 0; i < pointArray.length; i++) {\r\n      const params = paramArray ? paramArray[i] : undefined;\r\n      const normals = normalArray ? normalArray[i] : undefined;\r\n\r\n      if (pointArray[i].length === 3)\r\n        this.addTriangleFacet(pointArray[i], params, normals);\r\n      else if (pointArray[i].length === 4)\r\n        this.addQuadFacet(pointArray[i], params, normals);\r\n    }\r\n\r\n    if (endFace)\r\n      this.endFace();\r\n  }\r\n  /**\r\n   * * Evaluate `(numU + 1) * (numV + 1)` grid points (in 0..1 in both u and v) on a surface.\r\n   * * Add the facets for `numU * numV` quads.\r\n   * * uv params are the 0..1 fractions.\r\n   * * normals are cross products of u and v direction partial derivatives.\r\n   * @param surface\r\n   * @param numU\r\n   * @param numV\r\n   */\r\n  public addUVGridBody(surface: UVSurface, numU: number, numV: number, uMap?: Segment1d, vMap?: Segment1d) {\r\n    let xyzIndex0 = new GrowableFloat64Array(numU);\r\n    let xyzIndex1 = new GrowableFloat64Array(numU);\r\n    let paramIndex0: GrowableFloat64Array | undefined;\r\n    let paramIndex1: GrowableFloat64Array | undefined;\r\n    let normalIndex0: GrowableFloat64Array | undefined;\r\n    let normalIndex1: GrowableFloat64Array | undefined;\r\n    const reverse = this._reversed;\r\n    const needNormals = this.options.needNormals;\r\n    if (needNormals) {\r\n      normalIndex0 = new GrowableFloat64Array(numU);\r\n      normalIndex1 = new GrowableFloat64Array(numU);\r\n    }\r\n    const needParams = this.options.needParams;\r\n    if (needParams) {\r\n      paramIndex0 = new GrowableFloat64Array(numU);\r\n      paramIndex1 = new GrowableFloat64Array(numU);\r\n    }\r\n\r\n    let indexSwap;\r\n    xyzIndex0.ensureCapacity(numU);\r\n    xyzIndex1.ensureCapacity(numU);\r\n    const uv = Point2d.create();\r\n    const normal = Vector3d.create();\r\n    const du = 1.0 / numU;\r\n    const dv = 1.0 / numV;\r\n    const plane = Plane3dByOriginAndVectors.createXYPlane();\r\n    for (let v = 0; v <= numV; v++) {\r\n      // evaluate new points ....\r\n      xyzIndex1.clear();\r\n      if (needNormals)\r\n        normalIndex1!.clear();\r\n      if (needParams)\r\n        paramIndex1!.clear();\r\n      for (let u = 0; u <= numU; u++) {\r\n        const uFrac = u * du;\r\n        const vFrac = v * dv;\r\n        surface.uvFractionToPointAndTangents(uFrac, vFrac, plane);\r\n        xyzIndex1.push(this._polyface.addPoint(plane.origin));\r\n        if (needNormals) {\r\n          plane.vectorU.crossProduct(plane.vectorV, normal);\r\n          normal.normalizeInPlace();\r\n          if (reverse)\r\n            normal.scaleInPlace(-1.0);\r\n          normalIndex1!.push(this._polyface.addNormal(normal));\r\n        }\r\n        if (needParams)\r\n          paramIndex1!.push(this._polyface.addParam(Point2d.create(\r\n            uMap ? uMap.fractionToPoint(uFrac) : uFrac,\r\n            vMap ? vMap.fractionToPoint(vFrac) : vFrac,\r\n            uv)));\r\n      }\r\n\r\n      if (v > 0) {\r\n        for (let u = 0; u < numU; u++) {\r\n          this.addIndexedQuadPointIndexes(\r\n            xyzIndex0.atUncheckedIndex(u), xyzIndex0.atUncheckedIndex(u + 1),\r\n            xyzIndex1.atUncheckedIndex(u), xyzIndex1.atUncheckedIndex(u + 1), false);\r\n          if (needNormals)\r\n            this.addIndexedQuadNormalIndexes(\r\n              normalIndex0!.atUncheckedIndex(u), normalIndex0!.atUncheckedIndex(u + 1),\r\n              normalIndex1!.atUncheckedIndex(u), normalIndex1!.atUncheckedIndex(u + 1));\r\n          if (needParams)\r\n            this.addIndexedQuadParamIndexes(\r\n              paramIndex0!.atUncheckedIndex(u), paramIndex0!.atUncheckedIndex(u + 1),\r\n              paramIndex1!.atUncheckedIndex(u), paramIndex1!.atUncheckedIndex(u + 1));\r\n          this._polyface.terminateFacet();\r\n        }\r\n      }\r\n      indexSwap = xyzIndex1; xyzIndex1 = xyzIndex0; xyzIndex0 = indexSwap;\r\n      if (needParams) {\r\n        indexSwap = paramIndex1; paramIndex1 = paramIndex0; paramIndex0 = indexSwap;\r\n      }\r\n      if (needNormals) {\r\n        indexSwap = normalIndex1; normalIndex1 = normalIndex0; normalIndex0 = indexSwap;\r\n      }\r\n\r\n    }\r\n    xyzIndex0.clear();\r\n    xyzIndex1.clear();\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Point3d, Vector3d, Point2d } from \"./PointVector\";\r\nimport { Polyface } from \"./Polyface\";\r\nimport { ClipPlane } from \"../clipping/ClipPlane\";\r\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { PolyfaceBuilder } from \"./PolyfaceBuilder\";\r\n\r\n/** PolyfaceClip is a static class gathering operations using Polyfaces and clippers.\r\n * @public\r\n */\r\nexport class PolyfaceClip {\r\n  /** Clip each facet of polyface to the ClipPlane.\r\n   * * Return all clippees as a new mesh.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyfaceClipPlane(polyface: Polyface, clipper: ClipPlane, insideClip: boolean = true): Polyface {\r\n    const visitor = polyface.createVisitor(0);\r\n    const builder = PolyfaceBuilder.create();\r\n    const work = new GrowableXYZArray(10);\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      clipper.clipConvexPolygonInPlace(visitor.point, work, insideClip);\r\n      if (visitor.point.length > 2)\r\n        builder.addPolygonGrowableXYZArray(visitor.point);\r\n    }\r\n    return builder.claimPolyface(true);\r\n  }\r\n\r\n  /** Clip each facet of polyface to the ClipPlane.\r\n   * * Return all clippees as a new mesh.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyfaceConvexClipPlaneSet(polyface: Polyface, clipper: ConvexClipPlaneSet): Polyface {\r\n    const visitor = polyface.createVisitor(0);\r\n    const builder = PolyfaceBuilder.create();\r\n    const work = new GrowableXYZArray(10);\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      clipper.clipConvexPolygonInPlace(visitor.point, work);\r\n      if (visitor.point.length > 2)\r\n        builder.addPolygonGrowableXYZArray(visitor.point);\r\n    }\r\n    return builder.claimPolyface(true);\r\n  }\r\n\r\n  /** Clip each facet of polyface to the ClipPlane or ConvexClipPlaneSet\r\n   * * This method parses  the variant input types and calls a more specific method.\r\n   * * WARNING: The new mesh is \"points only\".\r\n   */\r\n  public static clipPolyface(polyface: Polyface, clipper: ClipPlane | ConvexClipPlaneSet): Polyface | undefined {\r\n    if (clipper instanceof ClipPlane)\r\n      return this.clipPolyfaceClipPlane(polyface, clipper);\r\n    if (clipper instanceof ConvexClipPlaneSet)\r\n      return this.clipPolyfaceConvexClipPlaneSet(polyface, clipper);\r\n    // (The if tests exhaust the type space -- this line is unreachable.)\r\n    return undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { NumberArray } from \"../geometry3d/PointHelpers\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { ClusterableArray } from \"../numerics/ClusterableArray\";\r\nimport { PolyfaceAuxData } from \"./AuxData\";\r\nimport { FacetFaceData } from \"./FacetFaceData\";\r\nimport { GrowableXYArray } from \"../geometry3d/GrowableXYArray\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/**\r\n * PolyfaceData carries data arrays for point, normal, param, color and their indices.\r\n *\r\n * * IndexedPolyface carries a PolyfaceData as a member. (NOT as a base class -- it already has GeometryQuery as base)\r\n * * IndexedPolyfaceVisitor uses PolyfaceData as a base class.\r\n * @public\r\n */\r\nexport class PolyfaceData {\r\n  // <ul\r\n  // <li>optional arrays (normal, uv, color) must be indicated at constructor time.\r\n  // <li>all arrays are (independently) indexed.\r\n  // <li>with regret, the point, param, normal, and color arrays are exposed publicly.\r\n  // <li>getX methods are \"trusting\" -- no bounds check\r\n  // <li>getX methods return references to X.\r\n  // <li> EXCEPT -- for optional arrays, the return 000.\r\n  // <li>copyX methods move data to caller-supplied result..\r\n  // </ul>\r\n  /** Relative tolerance used in tests for planar facets\r\n   * @internal\r\n   */\r\n  public static readonly planarityLocalRelTol = 1.0e-13;\r\n  /** Coordinate data for points in the facets, packed as numbers in a contiguous array. */\r\n  public point: GrowableXYZArray;\r\n  /** Indices of points at facet vertices. */\r\n  public pointIndex: number[];\r\n  /** booleans indicating visibility of corresponding edges */\r\n  public edgeVisible: boolean[];\r\n  /** Coordinates of normal vectors, packed as numbers in a contguous array */\r\n  public normal: GrowableXYZArray | undefined;\r\n  /** indices of normals at facet vertices. */\r\n  public normalIndex: number[] | undefined;\r\n  /** Coordinates of uv parameters, packed as numbers in a contiguous array. */\r\n  public param?: GrowableXYArray;\r\n  /** Indics of params at facet vertices. */\r\n  public paramIndex: number[] | undefined;\r\n  /** Color values.  These are carried around as simple numbers, but are probably\r\n   * required (by display systems) map exactly to 32 bit integers.\r\n   */\r\n  public color: number[] | undefined;\r\n  /** Indices of colors at facet vertices. */\r\n  public colorIndex: number[] | undefined;\r\n  /** Face data will remain empty until a face is specified. */\r\n  public face: FacetFaceData[];\r\n  /** Auxilliary data */\r\n  public auxData: PolyfaceAuxData | undefined;\r\n  /** Constructor for facets.  The various params control whether respective arrays are to be allocated. */\r\n  public constructor(needNormals: boolean = false, needParams: boolean = false, needColors: boolean = false) {\r\n    this.point = new GrowableXYZArray();\r\n    this.pointIndex = []; this.edgeVisible = [];\r\n    this.face = [];\r\n    if (needNormals) { this.normal = new GrowableXYZArray(); this.normalIndex = []; }\r\n    if (needParams) { this.param = new GrowableXYArray(); this.paramIndex = []; }\r\n    if (needColors) { this.color = []; this.colorIndex = []; }\r\n  }\r\n  /** Return a depp clone. */\r\n  public clone(): PolyfaceData {\r\n    const result = new PolyfaceData();\r\n    result.point = this.point.clone();\r\n    result.pointIndex = this.pointIndex.slice();\r\n    result.edgeVisible = this.edgeVisible.slice();\r\n    result.face = this.face.slice();\r\n\r\n    if (this.normal)\r\n      result.normal = this.normal.clone();\r\n    if (this.param)\r\n      result.param = this.param.clone();\r\n    if (this.color)\r\n      result.color = this.color.slice();\r\n\r\n    if (this.normalIndex)\r\n      result.normalIndex = this.normalIndex.slice();\r\n    if (this.paramIndex)\r\n      result.paramIndex = this.paramIndex.slice();\r\n    if (this.colorIndex)\r\n      result.colorIndex = this.colorIndex.slice();\r\n    if (this.auxData)\r\n      result.auxData = this.auxData.clone();\r\n    return result;\r\n  }\r\n  /** Test for equal indices and nearly equal coordinates */\r\n  public isAlmostEqual(other: PolyfaceData): boolean {\r\n    if (!GrowableXYZArray.isAlmostEqual(this.point, other.point))\r\n      return false;\r\n    if (!NumberArray.isExactEqual(this.pointIndex, other.pointIndex))\r\n      return false;\r\n\r\n    if (!GrowableXYZArray.isAlmostEqual(this.normal, other.normal)) return false;\r\n    if (!NumberArray.isExactEqual(this.normalIndex, other.normalIndex)) return false;\r\n\r\n    if (!GrowableXYArray.isAlmostEqual(this.param, other.param)) return false;\r\n    if (!NumberArray.isExactEqual(this.paramIndex, other.paramIndex)) return false;\r\n\r\n    if (!NumberArray.isExactEqual(this.color, other.color)) return false;\r\n    if (!NumberArray.isExactEqual(this.colorIndex, other.colorIndex)) return false;\r\n\r\n    if (!NumberArray.isExactEqual(this.edgeVisible, other.edgeVisible)) return false;\r\n    if (!PolyfaceAuxData.isAlmostEqual(this.auxData, other.auxData)) return false;\r\n    return true;\r\n  }\r\n  /** Ask if normals are required in this mesh. */\r\n  public get requireNormals(): boolean { return undefined !== this.normal; }\r\n  /** Get the point count */\r\n  public get pointCount() { return this.point.length; }\r\n  /** Get the normal count */\r\n  public get normalCount() { return this.normal ? this.normal.length : 0; }\r\n  /** Get the param count */\r\n  public get paramCount() { return this.param ? this.param.length : 0; }\r\n  /** Get the color count */\r\n  public get colorCount() { return this.color ? this.color.length : 0; }\r\n  /** Get the index count.  Note that there is one count, and all index arrays (point, normal, param, color) must match */\r\n  public get indexCount() { return this.pointIndex.length; }  // ALWAYS INDEXED ... all index vectors must have same length.\r\n  /** Get the number of faces.\r\n   * * Note that a \"face\" is not a facet.\r\n   * * A \"face\" is a subset of facets grouped for application purposes.\r\n   */\r\n  public get faceCount() { return this.face.length; }\r\n\r\n  /** return indexed point. This is a copy of the coordinates, not a reference. */\r\n  public getPoint(i: number): Point3d | undefined { return this.point.getPoint3dAtCheckedPointIndex(i); }\r\n  /** return indexed normal. This is the COPY to the normal, not a reference. */\r\n  public getNormal(i: number): Vector3d | undefined { return this.normal ? this.normal.getVector3dAtCheckedVectorIndex(i) : undefined; }\r\n  /** return indexed param. This is the COPY of the coordinates, not a reference. */\r\n  public getParam(i: number): Point2d | undefined { return this.param ? this.param.getPoint2dAtCheckedPointIndex(i) : undefined; }\r\n  /** return indexed color */\r\n  public getColor(i: number): number { return this.color ? this.color[i] : 0; }\r\n  /** return indexed visibility */\r\n  public getEdgeVisible(i: number): boolean { return this.edgeVisible[i]; }\r\n  /** Copy the contents (not pointer) of point[i] into dest. */\r\n  public copyPointTo(i: number, dest: Point3d): void { this.point.getPoint3dAtUncheckedPointIndex(i, dest); }\r\n  /** Copy the contents (not pointer) of normal[i] into dest. */\r\n  public copyNormalTo(i: number, dest: Vector3d): void { if (this.normal) this.normal.getVector3dAtCheckedVectorIndex(i, dest); }\r\n  /** Copy the contents (not pointer) of param[i] into dest. */\r\n  public copyParamTo(i: number, dest: Point2d): void { if (this.param) this.param.getPoint2dAtCheckedPointIndex(i, dest); }\r\n  /** test if normal at a specified index matches uv */\r\n  public isAlmostEqualParamIndexUV(index: number, u: number, v: number): boolean {\r\n    if (this.param !== undefined && index >= 0 && index < this.param.length)\r\n      return Geometry.isSameCoordinate(u, this.param.getXAtUncheckedPointIndex(index))\r\n        && Geometry.isSameCoordinate(v, this.param.getYAtUncheckedPointIndex(index));\r\n    return false;\r\n  }\r\n  /**\r\n   * * Copy data from other to this.\r\n   * * This is the essense of transfering coordinates spread throughout a large polyface into a visitor's single facet.\r\n   * * \"other\" is the large polyface\r\n   * * \"this\" is the visitor\r\n   * * does NOT copy face data - visitors reference the FacetFaceData array for the whole polyface!!\r\n   * @param other polyface data being mined.\r\n   * @param index0 start index in other's index arrays\r\n   * @param index1 end index (one beyond last data accessed0 in other's index arrays\r\n   * @param numWrap number of points to replicate as wraparound.\r\n   */\r\n  public gatherIndexedData(other: PolyfaceData, index0: number, index1: number, numWrap: number) {\r\n    const numEdge = index1 - index0;\r\n    const numTotal = numEdge + numWrap;\r\n    this.resizeAllDataArrays(numTotal);\r\n    // copy wrapped points\r\n    for (let i = 0; i < numEdge; i++)\r\n      this.point.transferFromGrowableXYZArray(i, other.point, other.pointIndex[index0 + i]);\r\n    for (let i = 0; i < numWrap; i++)\r\n      this.point.transferFromGrowableXYZArray(numEdge + i, this.point, i);\r\n\r\n    // copy wrapped pointIndex\r\n    for (let i = 0; i < numEdge; i++)\r\n      this.pointIndex[i] = other.pointIndex[index0 + i];\r\n    for (let i = 0; i < numWrap; i++)\r\n      this.pointIndex[numEdge + i] = this.pointIndex[i];\r\n    // copy wrapped edge visibility\r\n    for (let i = 0; i < numEdge; i++)\r\n      this.edgeVisible[i] = other.edgeVisible[index0 + i];\r\n    for (let i = 0; i < numWrap; i++)\r\n      this.edgeVisible[numEdge + i] = this.edgeVisible[i];\r\n\r\n    if (this.normal && this.normalIndex && other.normal && other.normalIndex) {\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.normal.transferFromGrowableXYZArray(i, other.normal, other.pointIndex[index0 + i]);\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.normal.transferFromGrowableXYZArray(numEdge + i, this.normal, i);\r\n\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.normalIndex[i] = other.normalIndex[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.normalIndex[numEdge + i] = this.normalIndex[i];\r\n    }\r\n\r\n    if (this.param && this.paramIndex && other.param && other.paramIndex) {\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.param.transferFromGrowableXYArray(i, other.param, other.paramIndex[index0 + i]);\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.param.transferFromGrowableXYArray(numEdge + i, this.param, i);\r\n\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.paramIndex[i] = other.paramIndex[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.paramIndex[numEdge + i] = this.paramIndex[i];\r\n    }\r\n\r\n    if (this.color && this.colorIndex && other.color && other.colorIndex) {\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.color[i] = other.color[this.colorIndex[index0 + i]];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.color[numEdge + i] = this.color[i];\r\n\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.colorIndex[i] = other.colorIndex[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.colorIndex[numEdge + i] = this.colorIndex[i];\r\n    }\r\n    if (this.auxData && other.auxData && this.auxData.channels.length === other.auxData.channels.length) {\r\n      for (let iChannel = 0; iChannel < this.auxData.channels.length; iChannel++) {\r\n        const thisChannel = this.auxData.channels[iChannel];\r\n        const otherChannel = other.auxData.channels[iChannel];\r\n        const blockSize = thisChannel.entriesPerValue;\r\n        if (thisChannel.data.length === otherChannel.data.length) {\r\n          for (let iData = 0; iData < thisChannel.data.length; iData++) {\r\n            const thisData = thisChannel.data[iData];\r\n            const otherData = otherChannel.data[iData];\r\n            for (let i = 0; i < numEdge; i++)\r\n              thisData.copyValues(otherData, i, index0 + i, blockSize);\r\n            for (let i = 0; i < numWrap; i++)\r\n              thisData.copyValues(thisData, numEdge + i, i, blockSize);\r\n          }\r\n        }\r\n      }\r\n      for (let i = 0; i < numEdge; i++)\r\n        this.auxData.indices[i] = other.auxData.indices[index0 + i];\r\n      for (let i = 0; i < numWrap; i++)\r\n        this.auxData.indices[numEdge + i] = this.auxData.indices[i];\r\n    }\r\n  }\r\n  private static trimArray(data: any[] | undefined, length: number) { if (data && length < data.length) data.length = length; }\r\n  /** Trim all index arrays to stated length.\r\n   * * This is called by PolyfaceBuilder to clean up after an aborted construction sequence.\r\n   */\r\n  public trimAllIndexArrays(length: number): void {\r\n    PolyfaceData.trimArray(this.pointIndex, length);\r\n    PolyfaceData.trimArray(this.paramIndex, length);\r\n    PolyfaceData.trimArray(this.normalIndex, length);\r\n    PolyfaceData.trimArray(this.colorIndex, length);\r\n    PolyfaceData.trimArray(this.edgeVisible, length);\r\n    if (this.auxData) {\r\n      PolyfaceData.trimArray(this.auxData.indices, length);\r\n      for (const channel of this.auxData.channels) {\r\n        for (const data of channel.data)\r\n          PolyfaceData.trimArray(data.values, channel.entriesPerValue * length);\r\n      }\r\n    }\r\n  }\r\n  /** Resize all data arrays to specified length */\r\n  public resizeAllDataArrays(length: number): void {\r\n    if (length > this.point.length) {\r\n      while (this.point.length < length) this.point.push(Point3d.create());\r\n      while (this.pointIndex.length < length) this.pointIndex.push(-1);\r\n      while (this.edgeVisible.length < length) this.edgeVisible.push(false);\r\n      if (this.normal)\r\n        while (this.normal.length < length) this.normal.push(Vector3d.create());\r\n      if (this.param)\r\n        while (this.param.length < length) this.param.push(Point2d.create());\r\n      if (this.color)\r\n        while (this.color.length < length) this.color.push(0);\r\n      if (this.auxData) {\r\n        for (const channel of this.auxData.channels) {\r\n          for (const channelData of channel.data) {\r\n            while (channelData.values.length < length * channel.entriesPerValue) channelData.values.push(0);\r\n          }\r\n        }\r\n      }\r\n    } else if (length < this.point.length) {\r\n      this.point.resize(length);\r\n      this.edgeVisible.length = length;\r\n      this.pointIndex.length = length;\r\n      if (this.normal) this.normal.resize(length);\r\n      if (this.param) this.param.resize(length);\r\n      if (this.color) this.color.length = length;\r\n      if (this.auxData) {\r\n        for (const channel of this.auxData.channels) {\r\n          for (const channelData of channel.data) {\r\n            channelData.values.length = length * channel.entriesPerValue;\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** Return the range of the point array (optionally transfomred) */\r\n  public range(result?: Range3d, transform?: Transform): Range3d {\r\n    result = result ? result : Range3d.createNull();\r\n    result.extendArray(this.point, transform);\r\n    return result;\r\n  }\r\n  /** reverse indices facet-by-facet, with the given facetStartIndex array delimiting faces.\r\n   *\r\n   * * facetStartIndex[0] == 0 always -- start of facet zero.\r\n   * * facet k has indices from facetStartIndex[k] <= i < facetStartIndex[k+1]\r\n   * * hence for \"internal\" k, facetStartIndex[k] is both the upper limit of facet k-1 and the start of facet k.\r\n   * *\r\n   */\r\n  public reverseIndices(facetStartIndex?: number[]) {\r\n    if (facetStartIndex && PolyfaceData.isValidFacetStartIndexArray(facetStartIndex)) {\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.pointIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.normalIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.paramIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.colorIndex, true);\r\n      PolyfaceData.reverseIndices(facetStartIndex, this.edgeVisible, false);\r\n    }\r\n  }\r\n  /** Scale all the normals by -1 */\r\n  public reverseNormals() {\r\n    if (this.normal)\r\n      this.normal.scaleInPlace(-1.0);\r\n  }\r\n  /** Apply `transform` to point and normal arrays.\r\n   * * IMPORTANT This base class is just a data carrier.  It does not know if the index order and normal directions have special meaning.\r\n   * * i.e. caller must separately reverse index order and normal direction if needed.\r\n   */\r\n  public tryTransformInPlace(\r\n    transform: Transform): boolean {\r\n    this.point.multiplyTransformInPlace(transform);\r\n\r\n    if (this.normal && !transform.matrix.isIdentity)\r\n      this.normal.multiplyAndRenormalizeMatrix3dInverseTransposeInPlace(transform.matrix);\r\n    return true;\r\n  }\r\n  /**\r\n   * * Search for duplication of coordinates within points, normals, and params.\r\n   * * compress the coordinate arrays.\r\n   * * revise all indexing for the relocated coordinates\r\n   */\r\n  public compress() {\r\n    const packedData = ClusterableArray.clusterGrowablePoint3dArray(this.point);\r\n    this.point = packedData.growablePackedPoints!;\r\n    packedData.updateIndices(this.pointIndex);\r\n    //    if (this.paramIndex)  // Tracking uv params\r\n    //      packedData.updateIndices(this.paramIndex);\r\n    //    if (this.normalIndex) // Tracking normals\r\n    //      packedData.updateIndices(this.normalIndex);\r\n  }\r\n\r\n  /**\r\n   * Test if facetStartIndex is (minimally!) valid:\r\n   * * length must be nonzero (recall that for \"no facets\" the facetStartIndexArray still must contain a 0)\r\n   * * Each entry must be strictly smaller than the one that follows.\r\n   * @param facetStartIndex array of facetStart data.  facet `i` has indices at `facetsStartIndex[i]` to (one before) `facetStartIndex[i+1]`\r\n   */\r\n  public static isValidFacetStartIndexArray(facetStartIndex: number[]): boolean {\r\n    // facetStartIndex for empty facets has a single entry \"0\" -- empty array is not allowed\r\n    if (facetStartIndex.length === 0)\r\n      return false;\r\n    for (let i = 0; i + 1 < facetStartIndex.length; i++)\r\n      if (facetStartIndex[i] >= facetStartIndex[i + 1])\r\n        return false;\r\n    return true;\r\n  }\r\n  /** Reverse data in facet indexing arrays.\r\n   * * parameterized over type T so non-number data -- e.g. boolean visibility flags -- can be reversed.\r\n   */\r\n  public static reverseIndices<T>(facetStartIndex: number[], indices: T[] | undefined, preserveStart: boolean): boolean {\r\n    if (!indices || indices.length === 0)\r\n      return true;  // empty case\r\n    if (indices.length > 0) {\r\n      if (facetStartIndex[facetStartIndex.length - 1] === indices.length) {\r\n        for (let i = 0; i + 1 < facetStartIndex.length; i++) {\r\n          let index0 = facetStartIndex[i];\r\n          let index1 = facetStartIndex[i + 1];\r\n          if (preserveStart) {\r\n            // leave [index0] as is so reversed facet starts at same vertex\r\n            while (index1 > index0 + 2) {\r\n              index1--; index0++;\r\n              const a = indices[index0];\r\n              indices[index0] = indices[index1];\r\n              indices[index1] = a;\r\n            }\r\n          } else {\r\n            // reverse all\r\n            while (index1 > index0 + 1) {\r\n              index1--;\r\n              const a = indices[index0];\r\n              indices[index0] = indices[index1];\r\n              indices[index1] = a;\r\n              index0++;\r\n            }\r\n          }\r\n        }\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Polyface */\r\n\r\n// import { Point2d } from \"./Geometry2d\";\r\n/* tslint:disable:variable-name jsdoc-format no-empty*/\r\n// import { Point3d, Vector3d, Point2d } from \"./PointVector\";\r\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Polyface, PolyfaceVisitor } from \"./Polyface\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { BagOfCurves } from \"../curve/CurveCollection\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { MomentData } from \"../geometry4d/MomentData\";\r\nimport { IndexedEdgeMatcher, SortableEdgeCluster } from \"./IndexedEdgeMatcher\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { PolyfaceBuilder } from \"./PolyfaceBuilder\";\r\nimport { Geometry } from \"../Geometry\";\r\n\r\n/** PolyfaceQuery is a static class whose methods implement queries on a polyface or polyface visitor provided as a parameter to each method.\r\n * @public\r\n */\r\nexport class PolyfaceQuery {\r\n  /** copy the points from a visitor into a Linestring3d in a Loop object */\r\n  public static visitorToLoop(visitor: PolyfaceVisitor) {\r\n    const ls = LineString3d.createPoints(visitor.point.getPoint3dArray());\r\n    return Loop.create(ls);\r\n  }\r\n  /** Create a linestring loop for each facet of the polyface. */\r\n  public static indexedPolyfaceToLoops(polyface: Polyface): BagOfCurves {\r\n    const result = BagOfCurves.create();\r\n    const visitor = polyface.createVisitor(1);\r\n    while (visitor.moveToNextFacet()) {\r\n      const loop = PolyfaceQuery.visitorToLoop(visitor);\r\n      result.tryAddChild(loop);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return the sum of all facets areas. */\r\n  public static sumFacetAreas(source: Polyface | PolyfaceVisitor): number {\r\n    let s = 0;\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumFacetAreas(source.createVisitor(1));\r\n\r\n    const visitor = source as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      s += PolygonOps.sumTriangleAreas(visitor.point.getPoint3dArray());\r\n    }\r\n    return s;\r\n  }\r\n  /** sum volumes of tetrahedra from origin to all facets.\r\n   * * if origin is omitted, the first point encountered (by the visitor) is used as origin.\r\n   * * If the mesh is closed, this sum is the volume.\r\n   * * If the mesh is not closed, this sum is the volume of a mesh with various additional facets\r\n   * from the origin to facets.\r\n  */\r\n  public static sumTetrahedralVolumes(source: Polyface | PolyfaceVisitor, origin?: Point3d): number {\r\n    let s = 0;\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumTetrahedralVolumes(source.createVisitor(0), origin);\r\n    let myOrigin = origin;\r\n    const visitor = source as PolyfaceVisitor;\r\n    const facetOrigin = Point3d.create();\r\n    const targetA = Point3d.create();\r\n    const targetB = Point3d.create();\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      if (myOrigin === undefined)\r\n        myOrigin = visitor.point.getPoint3dAtUncheckedPointIndex(0);\r\n      visitor.point.getPoint3dAtUncheckedPointIndex(0, facetOrigin);\r\n      for (let i = 1; i + 1 < visitor.point.length; i++) {\r\n        visitor.point.getPoint3dAtUncheckedPointIndex(i, targetA);\r\n        visitor.point.getPoint3dAtUncheckedPointIndex(i + 1, targetB);\r\n        s += myOrigin.tripleProductToPoints(facetOrigin, targetA, targetB);\r\n      }\r\n    }\r\n    return s / 6.0;\r\n  }\r\n  /** Return the inertia products [xx,xy,xz,xw, yw, etc] integrated over all facets. */\r\n  public static sumFacetSecondAreaMomentProducts(source: Polyface | PolyfaceVisitor, origin: Point3d): Matrix4d {\r\n    if (source instanceof Polyface)\r\n      return PolyfaceQuery.sumFacetSecondAreaMomentProducts(source.createVisitor(0), origin);\r\n    const products = Matrix4d.createZero();\r\n    const visitor = source as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      PolygonOps.addSecondMomentAreaProducts(visitor.point, origin, products);\r\n    }\r\n    return products;\r\n  }\r\n  /** Compute area moments for the mesh. In the returned MomentData:\r\n   * * origin is the centroid.\r\n   * * localToWorldMap has the origin and principal directions\r\n   * * radiiOfGyration radii for rotation around the x,y,z axes.\r\n   */\r\n  public static computePrincipalAreaMoments(source: Polyface): MomentData | undefined {\r\n    const origin = source.data.getPoint(0);\r\n    if (!origin) return undefined;\r\n    const inertiaProducts = PolyfaceQuery.sumFacetSecondAreaMomentProducts(source, origin);\r\n    return MomentData.inertiaProductsToPrincipalAxes(origin, inertiaProducts);\r\n  }\r\n  /**\r\n   * Test if the facets in `source` occur in perfectly mated pairs, as is required for a closed manifold volume.\r\n   * @param source\r\n   */\r\n  public static isPolyfaceClosedByEdgePairing(source: Polyface): boolean {\r\n    const edges = new IndexedEdgeMatcher();\r\n    const visitor = source.createVisitor(1) as PolyfaceVisitor;\r\n    visitor.reset();\r\n    while (visitor.moveToNextFacet()) {\r\n      const numEdges = visitor.pointCount - 1;\r\n      for (let i = 0; i < numEdges; i++) {\r\n        edges.addEdge(visitor.clientPointIndex(i), visitor.clientPointIndex(i + 1), visitor.currentReadIndex());\r\n      }\r\n    }\r\n    const badClusters: SortableEdgeCluster[] = [];\r\n    edges.sortAndCollectClusters(undefined, badClusters, undefined, badClusters);\r\n    return badClusters.length === 0;\r\n  }\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Announce each pair of linestring segment and on-facet segment through a callback.\r\n   * * Facets are ASSUMED to be convex and planar.\r\n   */\r\n  public static announceSweepLinestringToConvexPolyfaceXY(linestringPoints: GrowableXYZArray, polyface: Polyface,\r\n    announce: AnnounceDrapePanel): any {\r\n    const visitor = polyface.createVisitor(0);\r\n    const numLinestringPoints = linestringPoints.length;\r\n    const segmentPoint0 = Point3d.create();\r\n    const segmentPoint1 = Point3d.create();\r\n    const localSegmentPoint0 = Point3d.create();\r\n    const localSegmentPoint1 = Point3d.create();\r\n    const clipFractions = Segment1d.create(0, 1);\r\n    const localFrame = Transform.createIdentity();\r\n    let frame;\r\n    for (visitor.reset(); visitor.moveToNextFacet();) {\r\n      // For each triangle within the facet ...\r\n      for (let k1 = 1; k1 + 1 < visitor.point.length; k1++) {\r\n        frame = visitor.point.fillLocalXYTriangleFrame(0, k1, k1 + 1, localFrame);\r\n        if (frame) {\r\n          // For each stroke of the linestring ...\r\n          for (let i1 = 1; i1 < numLinestringPoints; i1++) {\r\n            linestringPoints.getPoint3dAtCheckedPointIndex(i1 - 1, segmentPoint0);\r\n            linestringPoints.getPoint3dAtCheckedPointIndex(i1, segmentPoint1);\r\n            frame.multiplyInversePoint3d(segmentPoint0, localSegmentPoint0);\r\n            frame.multiplyInversePoint3d(segmentPoint1, localSegmentPoint1);\r\n            clipFractions.set(0, 1);\r\n            /** (x,y,1-x-y) are barycentric coordinates in the triangle !!! */\r\n            if (clipFractions.clipBy01FunctionValuesPositive(localSegmentPoint0.x, localSegmentPoint1.x)\r\n              && clipFractions.clipBy01FunctionValuesPositive(localSegmentPoint0.y, localSegmentPoint1.y)\r\n              && clipFractions.clipBy01FunctionValuesPositive(\r\n                1 - localSegmentPoint0.x - localSegmentPoint0.y,\r\n                1 - localSegmentPoint1.x - localSegmentPoint1.y)) {\r\n              /* project the local segment point to the plane. */\r\n              const localClippedPointA = localSegmentPoint0.interpolate(clipFractions.x0, localSegmentPoint1);\r\n              const localClippedPointB = localSegmentPoint0.interpolate(clipFractions.x1, localSegmentPoint1);\r\n              const worldClippedPointA = localFrame.multiplyPoint3d(localClippedPointA)!;\r\n              const worldClippedPointB = localFrame.multiplyPoint3d(localClippedPointB)!;\r\n              const planePointA = localFrame.multiplyXYZ(localClippedPointA.x, localClippedPointA.y, 0.0)!;\r\n              const planePointB = localFrame.multiplyXYZ(localClippedPointB.x, localClippedPointB.y, 0.0)!;\r\n              const splitParameter = Geometry.inverseInterpolate01(localSegmentPoint0.z, localSegmentPoint1.z);\r\n              // emit 1 or 2 panels, oriented so panel normal is always to the left of the line.\r\n              if (splitParameter !== undefined && splitParameter > clipFractions.x0 && splitParameter < clipFractions.x1) {\r\n                const piercePointX = segmentPoint0.interpolate(splitParameter, segmentPoint1);\r\n                const piercePointY = piercePointX.clone();   // so points are distinct for the two triangle announcements.\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointA, piercePointX, planePointA], 2, 1);\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointB, piercePointY, planePointB], 1, 2);\r\n              } else if (localSegmentPoint0.z > 0) {  // segment is entirely above\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointA, worldClippedPointB, planePointB, planePointA], 3, 2);\r\n              } else // segment is entirely under\r\n                announce(linestringPoints, i1 - 1, polyface, visitor.currentReadIndex(), [worldClippedPointB, worldClippedPointA, planePointA, planePointB], 2, 3);\r\n            }\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** Find segments (within the linestring) which project to facets.\r\n   * * Assemble each segment pair as a facet in a new polyface\r\n   * * Facets are ASSUMED to be convex and planar.\r\n   */\r\n  public static sweepLinestringToFacetsXYreturnSweptFacets(linestringPoints: GrowableXYZArray, polyface: Polyface): Polyface {\r\n    const builder = PolyfaceBuilder.create();\r\n    this.announceSweepLinestringToConvexPolyfaceXY(linestringPoints, polyface,\r\n      (_linestring: GrowableXYZArray, _segmentIndex: number,\r\n        _polyface: Polyface, _facetIndex: number, points: Point3d[]) => {\r\n        if (points.length === 4)\r\n          builder.addQuadFacet(points);\r\n        else if (points.length === 3)\r\n          builder.addTriangleFacet(points);\r\n\r\n      });\r\n    return builder.claimPolyface(true);\r\n  }\r\n\r\n}\r\n/** Announce the points on a drape panel.\r\n * * The first two points in the array are always along the draped line segment.\r\n * * The last two are always on the facet.\r\n * * If there are 4 points, those two pairs are distinct, i.e. both segment points are to the same side of the facet.\r\n * * If there are 3 points, those two pairs share an on-facet point.\r\n * * The panel is ordered so the outward normal is to the right of the draped segment.\r\n * @param indexAOnFacet index (in points) of the point that is the first facet point for moving forward along the linestring\r\n * @param indexBOnFacet index (in points) of the point that is the second facet point for moving forward along the linestring\r\n * @public\r\n */\r\nexport type AnnounceDrapePanel = (linestring: GrowableXYZArray, segmentIndex: number,\r\n  polyface: Polyface, facetIndex: number, points: Point3d[], indexAOnFacet: number, indexBOnFacet: number) => any;\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Serialization */\r\n\r\n/* tslint:disable: object-literal-key-quotes */\r\n\r\n/**\r\n * Utilities to compare json objects by search through properties.\r\n * @internal\r\n */\r\nexport class DeepCompare {\r\n  /** Statistical accumulations during searchers. */\r\n  public typeCounts = {\r\n    \"numbers\": 0,\r\n    \"arrays\": 0,\r\n    \"functions\": 0,\r\n    \"objects\": 0,\r\n    \"strings\": 0,\r\n    \"booleans\": 0,\r\n    \"undefined\": 0,\r\n  };\r\n  /** Counts of property names encountered during various searches. */\r\n  public propertyCounts: { [key: string]: any } = {};\r\n  /** Array of error descriptions. */\r\n  public errorTracker: any[] = [];\r\n  /** relative tolerance for declaring numeric values equal. */\r\n  public numberRelTol: number;\r\n  public constructor(numberRelTol = 1.0e-12) { this.numberRelTol = numberRelTol; }\r\n\r\n  /** test if _a and _b are within tolerance.\r\n   * * If not, push error message to errorTracker.\r\n   */\r\npublic compareNumber(_a: number, _b: number) {\r\n    if (Math.abs(_b - _a) < this.numberRelTol * (1 + Math.abs(_a) + Math.abs(_b))) {\r\n      return this.announce(true);\r\n    } else {\r\n      this.errorTracker.unshift(_b);\r\n      this.errorTracker.unshift(_a);\r\n      this.errorTracker.unshift(\"In \" + this.errorTracker[this.errorTracker.length - 1] + \" property: Mismatched values\");\r\n      return this.announce(false);\r\n    }\r\n  }\r\n\r\n  private compareArray(a: any[], b: any[]) {\r\n    if (a.length !== b.length) {\r\n      const aCounter: { [key: string]: any } = {};\r\n      const bCounter: { [key: string]: any } = {};\r\n      // Append object to tracker that counts the properties of each array element (which is an object) in b, ONLY AT THIS LEVEL\r\n      for (const i of b) {\r\n        if (typeof i === \"object\" && typeof i !== \"function\" && !Array.isArray(i)) {\r\n          for (const property in i) {\r\n            if (i.hasOwnProperty(property)) {\r\n              // Add property to counter if not already there\r\n              if (!bCounter.hasOwnProperty(property))\r\n                bCounter[property] = 0;\r\n              bCounter[property]++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.errorTracker.unshift(bCounter);\r\n      // Append object to tracker that counts the properties of each array element (which is an object) in a, ONLY AT THIS LEVEL\r\n      for (const i of a) {\r\n        if (typeof i === \"object\" && typeof i !== \"function\" && !Array.isArray(i)) {\r\n          for (const property in i) {\r\n            if (i.hasOwnProperty(property)) {\r\n              // Add property to counter if not already there\r\n              if (!aCounter.hasOwnProperty(property))\r\n                aCounter[property] = 0;\r\n              aCounter[property]++;\r\n            }\r\n          }\r\n        }\r\n      }\r\n      this.errorTracker.unshift(aCounter);\r\n\r\n      this.errorTracker.unshift(\"Mismatched array lengths a: [\" + a.length + \"] b: [\" + b.length + \"]\");\r\n      return this.announce(false);\r\n    }\r\n    // Keep track of result for each element of array\r\n    let toReturn = true;\r\n    for (let i = 0; i < a.length; i++) {\r\n      toReturn = toReturn && this.compareInternal(a[i], b[i]);\r\n      // If false, break the loop\r\n      if (!toReturn) { this.errorTracker.unshift(\"[\" + i.toString() + \"]\"); break; }\r\n    }\r\n    return this.announce(toReturn);\r\n  }\r\n\r\n  private compareObject(a: any, b: any) {\r\n    // Check that both objects contain the same amount of properties\r\n    if (a == null && b == null)\r\n      return this.announce(true);\r\n    if ((Object.keys(a)).length !== (Object.keys(b)).length) {\r\n      this.errorTracker.unshift(\"Mismatched property lists [\" + (Object.keys(a)) + \"][\" + (Object.keys(b)) + \"]\");\r\n      return this.announce(false);\r\n    }\r\n    // Keep track of result for each property of object\r\n    let toReturn = true;\r\n    for (const property in a) {\r\n      // Only check non-generic object properties\r\n      if (a.hasOwnProperty(property)) {\r\n        // If property does not exist in propertyCounter, add it\r\n        if (!this.propertyCounts.hasOwnProperty(property)) {\r\n          this.propertyCounts[property] = 0;\r\n        }\r\n        this.propertyCounts[property]++;\r\n\r\n        // Check that same property exists in b\r\n        if (!(b.hasOwnProperty(property))) {\r\n          this.errorTracker.unshift(\"Property \" + property + \" of A not in B\");\r\n          this.errorTracker.unshift(a);\r\n          this.errorTracker.unshift(b);\r\n          return this.announce(false);\r\n        }\r\n\r\n        toReturn = toReturn && this.compareInternal(a[property], b[property]);\r\n        // If not true, push property and break the loop\r\n        if (!toReturn) { this.errorTracker.unshift(property); break; }\r\n      }\r\n    }\r\n    return this.announce(toReturn);\r\n  }\r\n\r\n  // this is a convenient place for a breakpoint on failures in areSameStructure.\r\n  private announce(value: boolean): boolean {\r\n    if (value)\r\n      return true;\r\n    return false;\r\n  }\r\n\r\n  /** Main entry for comparing deep json objects.\r\n   * * errorTracker, typeCounts, and propertyCounts are cleared.\r\n   */\r\n  public compare(a: any, b: any, tolerance?: number): boolean {\r\n    if (tolerance !== undefined)\r\n      this.numberRelTol = tolerance;\r\n    this.errorTracker.length = 0;\r\n    this.typeCounts.numbers = this.typeCounts.arrays = this.typeCounts.functions = this.typeCounts.objects = this.typeCounts.strings = this.typeCounts.booleans = this.typeCounts.undefined = 0;\r\n    this.propertyCounts = {};\r\n    return this.compareInternal(a, b);\r\n  }\r\n\r\n  // Recursive function for comparing any two nodes in a json object \"tree\"\r\n  private compareInternal(a: any, b: any): boolean {\r\n    if (typeof a !== typeof b) {\r\n      return this.announce(false);\r\n    }\r\n    if ((typeof a === \"number\") && (typeof b === \"number\")) {\r\n      this.typeCounts.numbers++;\r\n      return this.compareNumber(a, b);\r\n    } else if (Array.isArray(a) && Array.isArray(b)) {\r\n      this.typeCounts.arrays++;\r\n      return this.compareArray(a, b);\r\n    } else if (typeof a === \"function\" && typeof b === \"function\") {\r\n      // No current necessity to check functions\r\n      this.typeCounts.functions++;\r\n      return true;\r\n    } else if (typeof a === \"object\" && typeof b === \"object\") {\r\n      // Argument is object but not array or function\r\n      this.typeCounts.objects++;\r\n      return (a === b) ? true : this.compareObject(a, b);\r\n    } else if (typeof a === \"string\" && typeof b === \"string\") {\r\n      this.typeCounts.strings++;\r\n      return a === b;\r\n    } else if (typeof a === \"boolean\" && typeof b === \"boolean\") {\r\n      this.typeCounts.booleans++;\r\n      return a === b;\r\n    } else if (typeof a === \"undefined\" && typeof b === \"undefined\") {\r\n      // As long as both are undefined, return true\r\n      this.typeCounts.undefined++;\r\n      return true;\r\n    } else {\r\n      // Unsupported type\r\n      return this.announce(false);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Serialization */\r\n\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Plane3dByOriginAndUnitNormal } from \"../geometry3d/Plane3dByOriginAndUnitNormal\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Point2d, Vector2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\n\r\nimport { Range1d, Range2d, Range3d } from \"../geometry3d/Range\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Map4d } from \"../geometry4d/Map4d\";\r\nimport { Matrix4d } from \"../geometry4d/Matrix4d\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { UnionRegion } from \"../curve/UnionRegion\";\r\nimport { BagOfCurves } from \"../curve/CurveCollection\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { BSplineCurve3d, BSplineCurve3dBase } from \"../bspline/BSplineCurve\";\r\nimport { BSplineSurface3d, BSplineSurface3dH, WeightStyle } from \"../bspline/BSplineSurface\";\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\n\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { TransitionSpiral3d } from \"../curve/TransitionSpiral\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PointString3d } from \"../curve/PointString3d\";\r\nimport { ClipPlane } from \"../clipping/ClipPlane\";\r\nimport { ConvexClipPlaneSet } from \"../clipping/ConvexClipPlaneSet\";\r\nimport { GrowableFloat64Array } from \"../geometry3d/GrowableFloat64Array\";\r\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\r\nimport { UnionOfConvexClipPlaneSets } from \"../clipping/UnionOfConvexClipPlaneSets\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { CurveChainWithDistanceIndex } from \"../curve/CurveChainWithDistanceIndex\";\r\nimport { KnotVector, BSplineWrapMode } from \"../bspline/KnotVector\";\r\nimport { SolidPrimitive } from \"../solid/SolidPrimitive\";\r\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\r\n\r\n/* tslint:disable:no-console */\r\n/**\r\n * `Sample` has static methods to create a variety of geometry samples useful in testing.\r\n * @alpha\r\n */\r\nexport class Sample {\r\n  /** Array with assorted Point2d samples */\r\n  public static readonly point2d: Point2d[] = [\r\n    Point2d.create(0, 0),\r\n    Point2d.create(1, 0),\r\n    Point2d.create(0, 1),\r\n    Point2d.create(2, 3)];\r\n\r\n  /** Array with assorted Point3d samples */\r\n  public static readonly point3d: Point3d[] = [\r\n    Point3d.create(0, 0, 0),\r\n    Point3d.create(1, 0, 0),\r\n    Point3d.create(0, 1, 0),\r\n    Point3d.create(0, 1, 0),\r\n    Point3d.create(0, 0, 1),\r\n    Point3d.create(2, 3, 0),\r\n    Point3d.create(0, 2, 5),\r\n    Point3d.create(-3, 0, 5),\r\n    Point3d.create(4, 3, -2)];\r\n\r\n  /** Return an array of Point3d, with x,y,z all stepping through a range of values.\r\n   * x varies fastest, then y then z\r\n   */\r\n  public static createPoint3dLattice(low: number, step: number, high: number): Point3d[] {\r\n    const points = [];\r\n    for (let z = low; z <= high; z += step)\r\n      for (let y = low; y <= high; y += step)\r\n        for (let x = low; x <= high; x += step)\r\n          points.push(Point3d.create(x, y, z));\r\n    return points;\r\n  }\r\n\r\n  /** Return an array of Point2d, with x,y all stepping through a range of values.\r\n   * x varies fastest, then y\r\n   */\r\n  public static createPoint2dLattice(low: number, step: number, high: number): Point2d[] {\r\n    const points = [];\r\n    for (let y = low; y <= high; y += step)\r\n      for (let x = low; x <= high; x += step)\r\n        points.push(Point2d.create(x, y));\r\n    return points;\r\n  }\r\n  /** Array with assorted Point4d samples */\r\n  public static readonly point4d: Point4d[] = [\r\n    Point4d.create(0, 0, 0, 1),\r\n    Point4d.create(1, 0, 0, 1),\r\n    Point4d.create(0, 1, 0, 1),\r\n    Point4d.create(0, 1, 0, 1),\r\n    Point4d.create(0, 0, 1, 1),\r\n    Point4d.create(2, 3, 0, 1),\r\n    Point4d.create(0, 2, 5, 1),\r\n    Point4d.create(-3, 0, 5, 1),\r\n    Point4d.create(-3, 0, 5, 0.3),\r\n    Point4d.create(-3, 0, 5, -0.2),\r\n    Point4d.create(4, 3, -2, 1)];\r\n  /** Array with assorted nonzero vector samples. */\r\n  public static createNonZeroVectors(): Vector3d[] {\r\n    return [\r\n      Vector3d.create(1, 0, 0),\r\n      Vector3d.create(0, 1, 0),\r\n      Vector3d.create(0, 0, 1),\r\n      Vector3d.create(-1, 0, 0),\r\n      Vector3d.create(0, -1, 0),\r\n      Vector3d.create(0, 0, -1),\r\n      Vector3d.createPolar(1.0, Angle.createDegrees(20)),\r\n      Vector3d.createSpherical(1.0, Angle.createDegrees(20), Angle.createDegrees(10)),\r\n      Vector3d.createPolar(2.0, Angle.createDegrees(20)),\r\n      Vector3d.createSpherical(2.0, Angle.createDegrees(20), Angle.createDegrees(10)),\r\n      Vector3d.create(2, 3, 0)];\r\n  }\r\n  /** Array with assorted nonzero Vector2d samples */\r\n  public static readonly vector2d: Vector2d[] = [\r\n    Vector2d.create(1, 0),\r\n    Vector2d.create(0, 1),\r\n    Vector2d.create(0, 0),\r\n    Vector2d.create(-1, 0),\r\n    Vector2d.create(0, -1),\r\n    Vector2d.create(0, 0),\r\n    Vector2d.createPolar(1.0, Angle.createDegrees(20)),\r\n    Vector2d.createPolar(2.0, Angle.createDegrees(20)),\r\n    Vector2d.create(2, 3)];\r\n  /** Return an array with assorted Range3d samples */\r\n  public static createRange3ds(): Range3d[] {\r\n    return [\r\n      Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1),\r\n      Range3d.createXYZ(1, 2, 3),\r\n      Range3d.createXYZXYZ(-2, -3, 1, 200, 301, 8)];\r\n  }\r\n  /** Create 5 points of a (axis aligned) rectangle with corners (x0,y0) and (x1,y1) */\r\n  public static createRectangleXY(x0: number, y0: number, ax: number, ay: number, z: number = 0): Point3d[] {\r\n    return [\r\n      Point3d.create(x0, y0, z),\r\n      Point3d.create(x0 + ax, y0, z),\r\n      Point3d.create(x0 + ax, y0 + ay, z),\r\n      Point3d.create(x0, y0 + ay, z),\r\n      Point3d.create(x0, y0, z),\r\n    ];\r\n  }\r\n  /** Access the last point in the array. push another shifted by dx,dy,dz.\r\n   * * No push if all are 0.\r\n   * * If array is empty, push a leading 000\r\n   */\r\n  public static pushMove(data: Point3d[], dx: number, dy: number, dz: number = 0.0) {\r\n    if (data.length === 0)\r\n      data.push(Point3d.create(0, 0, 0));\r\n    const back = data[data.length - 1];\r\n    if (dx !== 0 || dy !== 0 || dz !== 0)\r\n      data.push(Point3d.create(back.x + dx, back.y + dy, back.z + dz));\r\n  }\r\n  /** push a clone of the data[0] */\r\n  public static pushClosure(data: Point3d[]) {\r\n    if (data.length > 0)\r\n      data.push(data[data.length - 1].clone());\r\n  }\r\n  /** Return an array with numPoints on the unit circle (counting clousre) */\r\n  public static createUnitCircle(numPoints: number): Point3d[] {\r\n    const points: Point3d[] = [];\r\n    const dTheta = Geometry.safeDivideFraction(Math.PI * 2, numPoints - 1, 0.0);\r\n    for (let i = 0; i < numPoints; i++) {\r\n      const theta = i * dTheta;\r\n      points.push(Point3d.create(Math.cos(theta), Math.sin(theta), 0.0));\r\n    }\r\n    return points;\r\n  }\r\n  /** Create points for an L shpaed polygon\r\n   * * lower left at x0,y0.\r\n   * * ax,ay are larger side lengths (lower left to corners along x and y directions)\r\n   * * bx,by are smaller side lengths (innder corner to points along x and y directions)\r\n   */\r\n  public static createLShapedPolygon(x0: number, y0: number, ax: number, ay: number, bx: number, by: number, z: number = 0): Point3d[] {\r\n    return [\r\n      Point3d.create(x0, y0, z),\r\n      Point3d.create(x0 + ax, y0, z),\r\n      Point3d.create(x0 + ax, y0 + by),\r\n      Point3d.create(x0 + bx, y0 + by),\r\n      Point3d.create(x0 + bx, y0 + ay, z),\r\n      Point3d.create(x0, y0 + ay, z),\r\n      Point3d.create(x0, y0, z),\r\n    ];\r\n  }\r\n  /** Create assorted clip planes. */\r\n  public static createClipPlanes(): ClipPlane[] {\r\n    const plane0 = ClipPlane.createNormalAndDistance(Vector3d.create(1, 0, 0), 2.0)!;\r\n    const plane1 = plane0.cloneNegated();\r\n    const plane2 = plane1.clone();\r\n    plane2.setFlags(true, true);\r\n    return [\r\n      plane0, plane1, plane2,\r\n      ClipPlane.createNormalAndDistance(Vector3d.create(3, 4, 0), 2.0)!,\r\n      ClipPlane.createEdgeXY(Point3d.create(1, 0, 0), Point3d.create(24, 32, 0))!];\r\n  }\r\n\r\n  /**\r\n   * * A first-quadrant unit square\r\n   * * Two squares -- first and fourth quadrant unit squares\r\n   * * Three squares -- first, second and fourtn quarant unit squares\r\n   */\r\n  public static createClipPlaneSets(): UnionOfConvexClipPlaneSets[] {\r\n    const result = [];\r\n    const quadrant1 = ConvexClipPlaneSet.createXYBox(0, 0, 1, 1);\r\n    result.push(UnionOfConvexClipPlaneSets.createConvexSets([quadrant1.clone()]));\r\n    const quadrant2 = ConvexClipPlaneSet.createXYBox(-1, 0, 0, 1);\r\n    const quadrant4 = ConvexClipPlaneSet.createXYBox(0, -1, 1, 0);\r\n\r\n    result.push(UnionOfConvexClipPlaneSets.createConvexSets([\r\n      quadrant1.clone(),\r\n      quadrant4.clone()]));\r\n    result.push(UnionOfConvexClipPlaneSets.createConvexSets([\r\n      quadrant1.clone(),\r\n      quadrant2.clone(),\r\n      quadrant4.clone()]));\r\n    return result;\r\n  }\r\n  /** Create (unweighted) bspline curves.\r\n   * order varies from 2 to 5\r\n   */\r\n  public static createBsplineCurves(includeMultipleKnots: boolean = false): BSplineCurve3d[] {\r\n    const result: BSplineCurve3d[] = [];\r\n    const yScale = 0.1;\r\n    for (const order of [2, 3, 4, 5]) {\r\n      const points = [];\r\n      for (const x of [0, 1, 2, 3, 4, 5, 7]) {\r\n        points.push(Point3d.create(x, yScale * (1 + x * x), 0.0));\r\n      }\r\n      const curve = BSplineCurve3d.createUniformKnots(points, order) as BSplineCurve3d;\r\n      result.push(curve);\r\n    }\r\n    if (includeMultipleKnots) {\r\n      const interiorKnotCandidates = [1, 2, 2, 3, 4, 5, 5, 6, 7, 7, 8];\r\n      for (const order of [3, 4]) {\r\n        const numPoints = 8;\r\n        const points = [];\r\n        for (let i = 0; i < numPoints; i++)\r\n          points.push(Point3d.create(i, i * i, 0));\r\n        const knots = [];\r\n        for (let i = 0; i < order - 1; i++) knots.push(0);\r\n        const numInteriorNeeded = numPoints - order;\r\n        for (let i = 0; i < numInteriorNeeded; i++)knots.push(interiorKnotCandidates[i]);\r\n        const lastKnot = knots[knots.length - 1] + 1;\r\n        for (let i = 0; i < order - 1; i++) knots.push(lastKnot);\r\n        const curve = BSplineCurve3d.create(points, knots, order);\r\n        if (curve)\r\n          result.push(curve);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Create weighted bspline curves.\r\n   * order varies from 2 to 5\r\n   */\r\n  public static createBspline3dHCurves(): BSplineCurve3dH[] {\r\n    const result: BSplineCurve3dH[] = [];\r\n    const yScale = 0.1;\r\n    for (const weightVariation of [0, 0.125]) {\r\n      for (const order of [2, 3, 4, 5]) {\r\n        const points = [];\r\n        for (const x of [0, 1, 2, 3, 4, 5, 7]) {\r\n          points.push(Point4d.create(x, yScale * (1 + x * x), 0.0, 1.0 + weightVariation * Math.sin(x * Math.PI * 0.25)));\r\n        }\r\n        const curve = BSplineCurve3dH.createUniformKnots(points, order) as BSplineCurve3dH;\r\n        result.push(curve);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Create weighted bsplines for circular arcs.\r\n   */\r\n  public static createBspline3dHArcs(): BSplineCurve3dH[] {\r\n    const result: BSplineCurve3dH[] = [];\r\n    const halfRadians = Angle.degreesToRadians(60.0);\r\n    const c = Math.cos(halfRadians);\r\n    const s = Math.sin(halfRadians);\r\n    // const sec = 1.0 / c;\r\n    // const t = s / c;\r\n    const points = [\r\n      Point4d.create(1, 0, 0, 1),\r\n      Point4d.create(c, s, 0, c),\r\n      Point4d.create(-c, s, 0, 1),\r\n      Point4d.create(-1, 0, 0, c),\r\n      Point4d.create(-c, -s, 0, 1),\r\n      Point4d.create(c, -s, 0, c),\r\n      Point4d.create(1, 0, 0, 1)];\r\n    const knots = [0, 0, 1, 1, 2, 2, 3, 3];\r\n\r\n    const curve = BSplineCurve3dH.create(points, knots, 3) as BSplineCurve3dH;\r\n    result.push(curve);\r\n    return result;\r\n  }\r\n\r\n  /** Return array   [x,y,z,w] bspline control points for an arc in 90 degree bspline spans.\r\n   * @param points array of [x,y,z,w]\r\n   * @param center center of arc\r\n   * @param axes matrix with 0 and 90 degree axes\r\n   * @param radius0 radius mulitplier for x direction.\r\n   * @param radius90 radius multiplier for y direction.\r\n   * @param applyWeightsToXYZ\r\n   */\r\n  public static createBsplineArc90SectionToXYZWArrays(\r\n    center: Point3d,\r\n    axes: Matrix3d,\r\n    radius0: number,\r\n    radius90: number,\r\n    applyWeightsToXYZ: boolean): number[][] {\r\n    const a = Math.sqrt(0.5);\r\n    const xyz = Point3d.create();\r\n    Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0, 0.0, 0, xyz);\r\n    const controlPoints = [];\r\n    controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);\r\n    const cornerTrig = [1, 1, -1, -1, 1];\r\n    const axisTrig = [1, 0, -1, 0, 1];\r\n    for (let i = 0; i < 4; i++) {\r\n      Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * cornerTrig[i + 1], radius90 * cornerTrig[i], 0, xyz);\r\n      controlPoints.push([xyz.x, xyz.y, xyz.z, a]);\r\n      Matrix3d.xyzPlusMatrixTimesCoordinates(center, axes, radius0 * axisTrig[i + 1], radius90 * axisTrig[i], 0, xyz);\r\n      controlPoints.push([xyz.x, xyz.y, xyz.z, 1.0]);\r\n    }\r\n    if (applyWeightsToXYZ) {\r\n      for (const xyzw of controlPoints) {\r\n        const b = xyzw[3];\r\n        xyzw[0] *= b;\r\n        xyzw[1] *= b;\r\n        xyzw[2] *= b;\r\n      }\r\n    }\r\n    return controlPoints;\r\n  }\r\n\r\n  /**\r\n   * Create both unweigthed and weighted bspline curves.\r\n   * (This is the combined results from createBsplineCurves and createBspline3dHCurves)\r\n   */\r\n  public static createMixedBsplineCurves(): BSplineCurve3dBase[] {\r\n    const arrayA = Sample.createBsplineCurves();\r\n    const arrayB = Sample.createBspline3dHCurves();\r\n    const result = [];\r\n    for (const a of arrayA) result.push(a);\r\n    for (const b of arrayB) result.push(b);\r\n    return result;\r\n  }\r\n\r\n  /** create a plane from origin and normal coordinates -- default to 001 normal if needed. */\r\n  public static createPlane(x: number, y: number, z: number, u: number, v: number, w: number): Plane3dByOriginAndUnitNormal {\r\n    const point = Point3d.create(x, y, z);\r\n    const vector = Vector3d.create(u, v, w).normalize();\r\n    if (vector) {\r\n      const plane = Plane3dByOriginAndUnitNormal.create(point, vector);\r\n      if (plane)\r\n        return plane;\r\n    }\r\n    return Sample.createPlane(x, y, z, u, v, 1);\r\n  }\r\n\r\n  /** Create ray from origina and direction components.   (Normalize the direction) */\r\n  public static createRay(x: number, y: number, z: number, u: number, v: number, w: number): Ray3d {\r\n    return Ray3d.create(\r\n      Point3d.create(x, y, z),\r\n      Vector3d.create(u, v, w).normalize() as Vector3d);\r\n  }\r\n  /** Assorted Plane3dBYOriginandUnitNormal */\r\n  public static readonly plane3dByOriginAndUnitNormal: Plane3dByOriginAndUnitNormal[] = [\r\n    Plane3dByOriginAndUnitNormal.createXYPlane(),\r\n    Plane3dByOriginAndUnitNormal.createYZPlane(),\r\n    Plane3dByOriginAndUnitNormal.createZXPlane(),\r\n    Sample.createPlane(0, 0, 0, 3, 0, 1),\r\n    Sample.createPlane(1, 2, 3, 2, 4, -1)];\r\n\r\n  /** Asorted Ray3d, not all unit direction vectors. */\r\n  public static readonly ray3d: Ray3d[] = [\r\n    Sample.createRay(0, 0, 0, 1, 0, 0),\r\n    Sample.createRay(0, 0, 0, 0, 1, 0),\r\n    Sample.createRay(0, 0, 0, 0, 0, 1),\r\n    Sample.createRay(0, 0, 0, 1, 2, 0),\r\n    Sample.createRay(1, 2, 3, 4, 2, -1)];\r\n  /** Assorted angles.  All prinicipal directions, some others included. */\r\n  public static readonly angle: Angle[] = [\r\n    Angle.createDegrees(0),\r\n    Angle.createDegrees(90),\r\n    Angle.createDegrees(180),\r\n    Angle.createDegrees(-90),\r\n    Angle.createDegrees(30),\r\n    Angle.createDegrees(-105)];\r\n  /** Assorted angle sweeps */\r\n  public static readonly angleSweep: AngleSweep[] = [\r\n    AngleSweep.createStartEndDegrees(0, 90),\r\n    AngleSweep.createStartEndDegrees(0, 180),\r\n    AngleSweep.createStartEndDegrees(-90, 0),\r\n    AngleSweep.createStartEndDegrees(0, -90),\r\n    AngleSweep.createStartEndDegrees(0, 30),\r\n    AngleSweep.createStartEndDegrees(45, 110)];\r\n\r\n  /** assorted line segments */\r\n  public static readonly lineSegment3d: LineSegment3d[] = [\r\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 0, 0)),\r\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(0, 1, 0)),\r\n    LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(0, 0, 1)),\r\n    LineSegment3d.create(Point3d.create(1, 2, 3), Point3d.create(-2, -3, 0.5))];\r\n  /** Assorted lines strings */\r\n  public static createLineStrings(): LineString3d[] {\r\n    return [\r\n      LineString3d.createPoints(\r\n        [\r\n          Point3d.create(0, 0, 0),\r\n          Point3d.create(1, 0, 0)]),\r\n      LineString3d.createPoints(\r\n        [\r\n          Point3d.create(0, 0, 0),\r\n          Point3d.create(1, 0, 0),\r\n          Point3d.create(1, 1, 0)]),\r\n      LineString3d.createPoints(\r\n        [\r\n          Point3d.create(0, 0, 0),\r\n          Point3d.create(1, 0, 0),\r\n          Point3d.create(1, 1, 0),\r\n          Point3d.create(2, 2, 0)])];\r\n  }\r\n  /** Assorted Range1d:   single point, null, simple forward, simple reverse */\r\n  public static readonly range1d: Range1d[] = [\r\n    Range1d.createX(1),\r\n    Range1d.createNull(),\r\n    Range1d.createXX(1, 2),\r\n    Range1d.createXX(2, 1)];\r\n  /** Assorted range2d: single point, null, 2 point with various creation orders. */\r\n  public static readonly range2d: Range2d[] = [\r\n    Range2d.createXY(1, 2),\r\n    Range2d.createNull(),\r\n    Range2d.createXYXY(1, 2, 0, 3),\r\n    Range2d.createXYXY(1, 2, 3, 4)];\r\n  /** Assorted range2d: single point, null, 2 point with various creation orders. */\r\n  public static readonly range3d: Range3d[] = [\r\n    Range3d.createXYZ(1, 2, 3),\r\n    Range3d.createNull(),\r\n    Range3d.createXYZXYZ(1, 2, 0, 3, 4, 7),\r\n    Range3d.createXYZXYZ(1, 2, 3, -2, -4, -1)];\r\n  /** Assorted Matrix3d:\r\n   * * identity\r\n   * * roation around x\r\n   * * rotation around general vector\r\n   * * uniformscale\r\n   * * nonuniform scale (including negative scales!)\r\n   */\r\n  public static createMatrix3dArray(): Matrix3d[] {\r\n    return [\r\n      Matrix3d.createIdentity(),\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, 0, 0), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, -2, 5), Angle.createDegrees(-6.0)) as Matrix3d,\r\n\r\n      Matrix3d.createUniformScale(2.0),\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, 2, 3), Angle.createDegrees(49.0)) as Matrix3d,\r\n      Matrix3d.createScale(1, 1, -1),\r\n      Matrix3d.createScale(2, 3, 4)];\r\n  }\r\n  /** Assorted invertibel transforms. */\r\n  public static createInvertibleTransforms(): Transform[] {\r\n    return [\r\n      Transform.createIdentity(),\r\n      Transform.createTranslationXYZ(1, 2, 0),\r\n      Transform.createTranslationXYZ(1, 2, 3),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(4, 1, -2),\r\n        Matrix3d.createUniformScale(2.0)),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(4, 1, -2),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.create(1, 2, 3), Angle.createRadians(10)) as Matrix3d)];\r\n  }\r\n\r\n  /** Return an array of Matrix3d with various skew and scale.  This includes at least:\r\n   * * identity\r\n   * * 3 disinct diagonals.\r\n   * * The distinct diagonal base with smaller value added to\r\n   *    other 6 spots in succession.\r\n   * * the distinct diagonals with all others also smaller nonzeros.\r\n   */\r\n  public static createScaleSkewMatrix3d(): Matrix3d[] {\r\n    return [\r\n      Matrix3d.createRowValues(\r\n        1, 0, 0,\r\n        0, 1, 0,\r\n        0, 0, 1),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 2, 0,\r\n        0, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 2,\r\n        0, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        1, 6, 0,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 1,\r\n        0, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 0,\r\n        1, 0, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 0, 0,\r\n        0, 6, 0,\r\n        0, 1, 7),\r\n      Matrix3d.createRowValues(\r\n        5, 2, 3,\r\n        2, 6, 1,\r\n        -1, 2, 7)];\r\n  }\r\n\r\n  /** Return an array of singular Matrix3d.  This includes at least:\r\n   * * all zeros\r\n   * * one nonzero column\r\n   * * two independent columns, third is zero\r\n   * * two independent columns, third is sum of those\r\n   * * two independent columns, third is copy of one\r\n   */\r\n  public static createSingularMatrix3d(): Matrix3d[] {\r\n    const vectorU = Vector3d.create(2, 3, 6);\r\n    const vectorV = Vector3d.create(-1, 5, 2);\r\n    const vectorUplusV = vectorU.plus(vectorV);\r\n    const vector0 = Vector3d.createZero();\r\n    return [\r\n      Matrix3d.createZero(),\r\n      // one nonzero column\r\n      Matrix3d.createColumns(vectorU, vector0, vector0),\r\n      Matrix3d.createColumns(vector0, vectorU, vector0),\r\n      Matrix3d.createColumns(vector0, vector0, vector0),\r\n      // two independent nonzero columns with zero\r\n      Matrix3d.createColumns(vectorU, vectorV, vector0),\r\n      Matrix3d.createColumns(vector0, vectorU, vectorV),\r\n      Matrix3d.createColumns(vectorV, vector0, vector0),\r\n      // third column dependent\r\n      Matrix3d.createColumns(vectorU, vectorV, vectorUplusV),\r\n      Matrix3d.createColumns(vectorU, vectorUplusV, vectorV),\r\n      Matrix3d.createColumns(vectorUplusV, vectorV, vectorU),\r\n      // two independent with duplicate\r\n      Matrix3d.createColumns(vectorU, vectorV, vectorU),\r\n      Matrix3d.createColumns(vectorU, vectorU, vectorV),\r\n      Matrix3d.createColumns(vectorV, vectorV, vectorU)];\r\n  }\r\n\r\n  /**\r\n   * Return an array of rigid transforms.  This includes (at least)\r\n   * * Identity\r\n   * * translation with identity matrix\r\n   * * rotation around origin and arbitrary vector\r\n   * * rotation around space point and arbitrary vector\r\n   */\r\n  public static createRigidTransforms(): Transform[] {\r\n    return [\r\n      Transform.createIdentity(),\r\n      Transform.createTranslationXYZ(1, 2, 3),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(0, 0, 0),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.unitY(), Angle.createDegrees(10)) as Matrix3d),\r\n      Transform.createFixedPointAndMatrix(\r\n        Point3d.create(4, 1, -2),\r\n        Matrix3d.createRotationAroundVector(\r\n          Vector3d.create(1, 2, 3), Angle.createDegrees(10)) as Matrix3d)];\r\n  }\r\n  /**\r\n   * Return a single rigid transform with all terms nonzero.\r\n   */\r\n  public static createMessyRigidTransform(fixedPoint?: Point3d): Transform {\r\n    return Transform.createFixedPointAndMatrix(\r\n      fixedPoint ? fixedPoint : Point3d.create(1, 2, 3),\r\n      Matrix3d.createRotationAroundVector(Vector3d.create(0.3, -0.2, 1.2), Angle.createDegrees(15.7))!);\r\n  }\r\n  /** Return various rigid matrices:\r\n   * * identity\r\n   * * small rotations around x, y, z\r\n   * * small rotation around (1,2,3)\r\n   */\r\n  public static createRigidAxes(): Matrix3d[] {\r\n    return [\r\n      Matrix3d.createIdentity(),\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.unitX(), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.unitY(), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.unitZ(), Angle.createDegrees(10)) as Matrix3d,\r\n      Matrix3d.createRotationAroundVector(\r\n        Vector3d.create(1, 2, 3), Angle.createDegrees(10)) as Matrix3d,\r\n    ];\r\n  }\r\n\r\n  /**\r\n   * Return various Matrix4d\r\n   * * Simple promotion of each Sample.createInvertibleTransforms ()\r\n   * * optional nasty [1,2,3,4...15] row order\r\n   * @param includeIrregular if true, include [1,2,..15] row major\r\n   */ // promote each transform[] to a Matrix4d.\r\n  public static createMatrix4ds(includeIrregular: boolean = false): Matrix4d[] {\r\n    const result = [];\r\n    let transform;\r\n    for (transform of Sample.createInvertibleTransforms())\r\n      result.push(Matrix4d.createTransform(transform));\r\n    if (includeIrregular) {\r\n      result.push(Matrix4d.createRowValues(\r\n        1, 2, 3, 4,\r\n        5, 6, 7, 8,\r\n        9, 10, 11, 12,\r\n        13, 14, 15, 16));\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Create full Map4d for each `Sample.createInvertibleTransforms ()`\r\n   */\r\n  public static createMap4ds(): Map4d[] {\r\n    const result = [];\r\n    let transform;\r\n    for (transform of Sample.createInvertibleTransforms()) {\r\n      const inverse = transform.inverse();\r\n      if (inverse) {\r\n        const map = Map4d.createTransform(transform, inverse);\r\n        if (map)\r\n          result.push(map);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /** Assorted simple `Path` objects. */\r\n  public static createSimplePaths(withGaps: boolean = false): Path[] {\r\n    const p1 = [[Point3d.create(0, 10, 0)], [Point3d.create(6, 10, 0)], [Point3d.create(6, 10, 1), [Point3d.create(0, 10, 0)]]];\r\n    const point0 = Point3d.create(0, 0, 0);\r\n    const point1 = Point3d.create(10, 0, 0);\r\n    const segment1 = LineSegment3d.create(point0, point1);\r\n    const vectorU = Vector3d.unitX(3);\r\n    const vectorV = Vector3d.unitY(3);\r\n    const arc2 = Arc3d.create(point1.minus(vectorU), vectorU, vectorV, AngleSweep.createStartEndDegrees(0, 90));\r\n    const simplePaths = [\r\n      Path.create(segment1),\r\n      Path.create(segment1, arc2),\r\n      Path.create(\r\n        LineSegment3d.create(point0, point1),\r\n        LineString3d.create(\r\n          Point3d.create(10, 0, 0),\r\n          Point3d.create(10, 5, 0)),\r\n        LineString3d.create(p1)),\r\n      Sample.createCappedArcPath(4, 0, 180),\r\n    ];\r\n    if (withGaps)\r\n      simplePaths.push(\r\n        Path.create(\r\n          LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(10, 0, 0)),\r\n          LineSegment3d.create(Point3d.create(10, 10, 0), Point3d.create(5, 0, 0))));\r\n\r\n    return simplePaths;\r\n  }\r\n  /** Assorted `PointString3d` objects. */\r\n  public static createSimplePointStrings(): PointString3d[] {\r\n    const p1 = [[Point3d.create(0, 10, 0)], [Point3d.create(6, 10, 0)], [Point3d.create(6, 10, 0), [Point3d.create(6, 10, 0)]]];\r\n    const simplePaths = [\r\n      PointString3d.create(Point3d.create(1, 2, 0)),\r\n      PointString3d.create(Point3d.create(0, 0, 0), Point3d.create(10, 0, 0)),\r\n      PointString3d.create(\r\n        Point3d.create(10, 0, 0),\r\n        Point3d.create(10, 5, 0)),\r\n      PointString3d.create(p1)];\r\n\r\n    return simplePaths;\r\n  }\r\n  /** Assorted `Loop` objects */\r\n  public static createSimpleLoops(): Loop[] {\r\n    const point0 = Point3d.create(0, 0, 0);\r\n    const point1 = Point3d.create(10, 0, 0);\r\n    const point2 = Point3d.create(10, 5, 0);\r\n    const point3 = Point3d.create(0, 5, 0);\r\n    const result = [\r\n      // rectangle with single linestring\r\n      Loop.create(LineString3d.create(point0, point1, point2, point3, point0)),\r\n      // unit circle\r\n      Loop.create(Arc3d.createUnitCircle()),\r\n      // rectangle, but with individual line segments\r\n      Loop.create(\r\n        LineSegment3d.create(point0, point1),\r\n        LineSegment3d.create(point1, point2),\r\n        LineSegment3d.create(point2, point3),\r\n        LineSegment3d.create(point3, point0),\r\n      ),\r\n      // Semicircle\r\n      Sample.createCappedArcLoop(4, -90, 90),\r\n    ];\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a square wave along x direction\r\n   * @param dx0 distance along x axis at y=0\r\n   * @param dy vertical rise\r\n   * @param dx1 distance along x axis at y=dy\r\n   * @param numPhase number of phases of the jump.\r\n   * @param dyReturn y value for return to origin.  If 0, the wave ends at y=0 after then final \"down\" with one extra horizontal dx0\r\n   *     If nonzero, rise to that y value, return to x=0, and return down to origin.\r\n   *\r\n   */\r\n  public static createSquareWave(origin: Point3d, dx0: number, dy: number, dx1: number, numPhase: number, dyReturn: number): Point3d[] {\r\n    const result = [origin.clone()];\r\n    for (let i = 0; i < numPhase; i++) {\r\n      this.pushMove(result, dx0, 0);\r\n      this.pushMove(result, 0, dy);\r\n      this.pushMove(result, dx1, 0);\r\n      this.pushMove(result, 0, -dy);\r\n    }\r\n    this.pushMove(result, dx0, 0);\r\n    if (dyReturn !== 0.0) {\r\n      this.pushMove(result, 0, dyReturn);\r\n      result.push(Point3d.create(origin.x, origin.y + dyReturn));\r\n      result.push(result[0].clone());\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Append numPhase teeth.  Each tooth starts with dxLow dwell at inital y, then sloped rise, then dwell at top, then sloped fall\r\n   * If no points are present, start with 000.  (this happends in pushMove) Otherwise start from final point.\r\n   * @param points point array to receive points\r\n   * @param dxLow starting step along x direction\r\n   * @param riseX width of rising and falling parts\r\n   * @param riseY height of rise\r\n   * @param dxHigh width at top\r\n   * @param numPhase number of phases.\r\n   */\r\n  public static appendSawTooth(points: Point3d[], dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhase: number) {\r\n    for (let i = 0; i < numPhase; i++) {\r\n      this.pushMove(points, dxLow, 0, 0);\r\n      this.pushMove(points, riseX, riseY, 0);\r\n      this.pushMove(points, dxHigh, 0, 0);\r\n      this.pushMove(points, riseX, -riseY, 0);\r\n    }\r\n  }\r\n  /**\r\n   * Create a pair of sawtooth patterns, one (nominally) outbound and up, the other inbound and down.\r\n   * * return phase count adjusted to end at start x\r\n   * * enter return dx values as lengths -- sign will be negated in construction.\r\n   * @param origin start of entire path.\r\n   * @param dxLow low outbound dwell\r\n   * @param riseX x part of outbound rise and fall\r\n   * @param riseY y part of outbound rise and fall\r\n   * @param dxHigh high outbound dwell\r\n   * @param numPhaseOutbound number of phases outbuond.  Final phase followed by dxLow dwell.\r\n   * @param dyFinal rise after final dwell.\r\n   * @param dxLowReturn dwell at return high\r\n   * @param riseXReturn rise x part of return\r\n   * @param riseYReturn rise y part of return\r\n   * @param dxHighReturn  dwell at return high\r\n   */\r\n  public static createBidirectionalSawtooth(origin: Point3d, dxLow: number, riseX: number, riseY: number, dxHigh: number, numPhaseOutbound: number,\r\n    dyFinal: number,\r\n    dxLowReturn: number, riseXReturn: number, riseYReturn: number, dxHighReturn: number): Point3d[] {\r\n    const data = [origin.clone()];\r\n    const x0 = data[0].x;\r\n    this.appendSawTooth(data, dxLow, riseX, riseY, dxHigh, numPhaseOutbound);\r\n    this.pushMove(data, dxLow, 0, 0);\r\n    this.pushMove(data, 0, dyFinal);\r\n    const x1 = data[data.length - 1].x;\r\n    const returnPhase = Math.abs(dxLowReturn + 2 * riseXReturn + dxHighReturn);\r\n    const totalDX = Math.abs(x1 - x0);\r\n    const numReturnPhase = Math.floor(Math.abs(totalDX / returnPhase));\r\n    this.appendSawTooth(data, -dxLowReturn, -riseXReturn, riseYReturn, -dxHighReturn, numReturnPhase);\r\n    const x2 = data[data.length - 1].x;\r\n    this.pushMove(data, x0 - x2, 0, 0);\r\n    data.push(data[0].clone());\r\n    return data;\r\n  }\r\n  /** append to a linestring, taking steps along given vector directions\r\n   * If the linestring is empty, a 000 point is added.\r\n   * @param linestring LineString3d to receive points.\r\n   * @param numPhase number of phases of the sawtooth\r\n   * @param vectors any number of vector steps.\r\n   */\r\n  public static appendPhases(linestring: LineString3d, numPhase: number, ...vectors: Vector3d[]): void {\r\n    const tailPoint = linestring.endPoint(); // and this defaults to 000 . ..\r\n    if (linestring.numPoints() === 0)\r\n      linestring.addPoint(tailPoint);\r\n\r\n    for (let i = 0; i < numPhase; i++) {\r\n      for (const v of vectors) {\r\n        tailPoint.addInPlace(v);\r\n        linestring.addPoint(tailPoint);\r\n      }\r\n    }\r\n  }\r\n  /** Assorted loops in xy plane:\r\n   * * unit square\r\n   * * rectangle\r\n   * * L shape\r\n   */\r\n  public static createSimpleXYPointLoops(): Point3d[][] {\r\n    const result = [];\r\n    result.push(Sample.createRectangleXY(0, 0, 1, 1));\r\n    result.push(Sample.createRectangleXY(0, 0, 4, 3));\r\n    result.push(Sample.createLShapedPolygon(0, 0, 5, 4, 1, 2));\r\n    return result;\r\n  }\r\n  /** Assorted `ParityReigon` objects */\r\n  public static createSimpleParityRegions(): ParityRegion[] {\r\n    const pointC = Point3d.create(-5, 0, 0);\r\n    const point0 = Point3d.create(0, 0, 0);\r\n    const point1 = Point3d.create(1, 2, 0);\r\n    const point2 = Point3d.create(6, 4, 0);\r\n    const ax = 10.0;\r\n    const ay = 8.0;\r\n    const bx = 3.0;\r\n    const by = 2.0;\r\n    const r2 = 0.5;\r\n    const result = [\r\n      ParityRegion.create(\r\n        Loop.create(\r\n          Arc3d.createXY(pointC, 2.0)),\r\n        Loop.create(Arc3d.createXY(pointC, 1.0))),\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.createRectangleXY(point0, ax, ay)),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by))),\r\n      ParityRegion.create(\r\n        Loop.create(LineString3d.createRectangleXY(point0, ax, ay)),\r\n        Loop.create(LineString3d.createRectangleXY(point1, bx, by)),\r\n        Loop.create(Arc3d.createXY(point2, r2))),\r\n    ];\r\n    return result;\r\n  }\r\n  /** Union region. */\r\n  public static createSimpleUnions(): UnionRegion[] {\r\n    const parityRegions = Sample.createSimpleParityRegions();\r\n    const loops = Sample.createSimpleLoops();\r\n    const result = [\r\n      UnionRegion.create(loops[0], parityRegions[0]),\r\n    ];\r\n    return result;\r\n  }\r\n  /** Assorted unstructured curve sets. */\r\n  public static createBagOfCurves(): BagOfCurves[] {\r\n    const parityRegions = Sample.createSimpleParityRegions();\r\n    const loops = Sample.createSimpleLoops();\r\n    const result = [\r\n      BagOfCurves.create(loops[0], parityRegions[0], LineSegment3d.createXYXY(0, 1, 4, 2, 1)),\r\n      // a bag with just an arc\r\n      BagOfCurves.create(Arc3d.createUnitCircle()),\r\n      // a bag with just a line segment\r\n      BagOfCurves.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 1, 0))),\r\n      // a bag with just a linestring\r\n      BagOfCurves.create(LineString3d.create(Point3d.create(0, 0, 0), Point3d.create(1, 1, 0), Point3d.create(2, 1, 0))),\r\n    ];\r\n    return result;\r\n  }\r\n\r\n  /** Assorted smooth curve primitives:\r\n   * * line segments\r\n   * * arcs\r\n   */\r\n  public static createSmoothCurvePrimitives(size: number = 1.0): CurvePrimitive[] {\r\n    const alpha = 0.1;\r\n    const beta = 0.3;\r\n    return [\r\n      LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(size, 0, 0)),\r\n      LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(size, size, 0)),\r\n      Arc3d.create(\r\n        Point3d.create(0, 0, 0),\r\n        Vector3d.create(size, 0, 0),\r\n        Vector3d.create(0, size, 0),\r\n        AngleSweep.createStartEndDegrees(0, 90)) as Arc3d,\r\n      Arc3d.create(\r\n        Point3d.create(0, 0, 0),\r\n        Vector3d.create(size, 0, 0),\r\n        Vector3d.create(0, size, 0),\r\n        AngleSweep.createStartEndDegrees(-40, 270)) as Arc3d,\r\n      Arc3d.create(\r\n        Point3d.create(0, 0, 0),\r\n        Vector3d.create(size, alpha * size, 0),\r\n        Vector3d.create(-alpha * beta * size, beta * size, 0),\r\n        AngleSweep.createStartEndDegrees(-40, 270)) as Arc3d,\r\n    ];\r\n  }\r\n  /** assorted small polyface grids, possibly expanded by gridMultiplier */\r\n  public static createSimpleIndexedPolyfaces(gridMultiplier: number): IndexedPolyface[] {\r\n    return [\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        gridMultiplier * 3, 2 * gridMultiplier, false, false, false),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, true, false, false),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, false, true, false),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, false, false, true),\r\n      Sample.createTriangularUnitGridPolyface(\r\n        Point3d.create(),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitY(),\r\n        3 * gridMultiplier, 2 * gridMultiplier, true, true, true),\r\n    ];\r\n  }\r\n  /**\r\n   * Build a mesh that is a (possibly skewed) grid in a plane.\r\n   * @param origin \"lower left\" coordinate\r\n   * @param vectorX step in \"X\" direction\r\n   * @param vectorY step in \"Y\" direction\r\n   * @param numXVertices number of vertices in X direction\r\n   * @param numYVertices number of vertices in y direction\r\n   * @param createParams true to create parameters, with paramter value `(i,j)` for point at (0 based) vertex in x,y directions\r\n   * @param createNormals true to create a (single) normal indexed from all facets\r\n   * @param createColors true to create a single color on each quad.  (shared between its triangles)\r\n   * @note edgeVisible is false only on the diagonals\r\n   */\r\n  public static createTriangularUnitGridPolyface(origin: Point3d, vectorX: Vector3d, vectorY: Vector3d,\r\n    numXVertices: number, numYVertices: number, createParams: boolean = false, createNormals: boolean = false, createColors: boolean = false): IndexedPolyface {\r\n    const mesh = IndexedPolyface.create(createNormals, createParams, createColors);\r\n    const normal = vectorX.crossProduct(vectorY);\r\n    if (createNormals) {\r\n      normal.normalizeInPlace();\r\n      mesh.addNormalXYZ(normal.x, normal.y, normal.z);  // use XYZ to help coverage count!!\r\n    }\r\n\r\n    // Push to coordinate arrays\r\n    for (let j = 0; j < numYVertices; j++) {\r\n      for (let i = 0; i < numXVertices; i++) {\r\n        mesh.addPoint(origin.plus2Scaled(vectorX, i, vectorY, j));\r\n        if (createParams)\r\n          mesh.addParamUV(i, j);\r\n      }\r\n    }\r\n    let color = 10; // arbitrrily start at color 10 so colorIndex is different from color.\r\n    // Push elements to index array (vertices are calculated using i and j positioning for each point)\r\n    let thisColorIndex = 0;\r\n    for (let j = 0; j + 1 < numYVertices; j++) {\r\n      for (let i = 0; i + 1 < numXVertices; i++) {\r\n        const vertex00 = numXVertices * j + i;\r\n        const vertex10 = vertex00 + 1;\r\n        const vertex01 = vertex00 + numXVertices;\r\n        const vertex11 = vertex01 + 1;\r\n        // Push lower triangle\r\n        mesh.addPointIndex(vertex00, true);\r\n        mesh.addPointIndex(vertex10, true);\r\n        mesh.addPointIndex(vertex11, false);\r\n        // make color === faceIndex\r\n        if (createColors) {\r\n          thisColorIndex = mesh.addColor(color++);\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n        }\r\n        // param indexing matches points .  .\r\n        if (createParams) {\r\n          mesh.addParamIndex(vertex00);\r\n          mesh.addParamIndex(vertex10);\r\n          mesh.addParamIndex(vertex11);\r\n        }\r\n\r\n        if (createNormals) {\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n        }\r\n        mesh.terminateFacet(false);\r\n\r\n        // upper triangle\r\n        mesh.addPointIndex(vertex11, true);\r\n        mesh.addPointIndex(vertex01, true);\r\n        mesh.addPointIndex(vertex00, false);\r\n        // make color === faceIndex\r\n        if (createColors) {\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n          mesh.addColorIndex(thisColorIndex);\r\n        }\r\n        // param indexing matches points.\r\n        if (createParams) {\r\n          mesh.addParamIndex(vertex11);\r\n          mesh.addParamIndex(vertex01);\r\n          mesh.addParamIndex(vertex00);\r\n        }\r\n        if (createNormals) {\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n          mesh.addNormalIndex(0);\r\n        }\r\n        mesh.terminateFacet(false);\r\n      }\r\n    }\r\n    return mesh;\r\n  }\r\n  /** Create an xy grid of points in single array with x varying fastest. */\r\n  public static createXYGrid(numU: number, numV: number, dX: number = 1.0, dY: number = 1.0): Point3d[] {\r\n    const points = [];\r\n    for (let j = 0; j < numV; j++) {\r\n      for (let i = 0; i < numU; i++) {\r\n        points.push(Point3d.create(i * dX, j * dY, 0));\r\n      }\r\n    }\r\n    return points;\r\n  }\r\n  /** Create simple bspline surface on xy plane grid. */\r\n  public static createXYGridBsplineSurface(numU: number, numV: number, orderU: number, orderV: number): BSplineSurface3d | undefined {\r\n    return BSplineSurface3d.create(\r\n      Sample.createXYGrid(numU, numV, 1.0, 1.0), numU, orderU, undefined, numV, orderV, undefined);\r\n  }\r\n  /**\r\n   * Create a bspline surface whose poles area on circular paths.\r\n   * * (BUT not weighted bspline, therefore although u and v isolines \"go around\" they are not true circles.)\r\n   * @param radiusU major radius\r\n   * @param radiusV minor radius\r\n   * @param numU number of facets around major hoop\r\n   * @param numV number of facets around minor hoop\r\n   * @param orderU major hoop order\r\n   * @param orderV minor hoop order\r\n   */\r\n  public static createPseudoTorusBsplineSurface(radiusU: number, radiusV: number, numU: number, numV: number, orderU: number, orderV: number): BSplineSurface3d | undefined {\r\n    const points = [];\r\n    const numUPole = numU + orderU - 1;\r\n    const numVPole = numV + orderV - 1;\r\n    const uKnots = KnotVector.createUniformWrapped(numU, orderU - 1, 0, 1);\r\n    const vKnots = KnotVector.createUniformWrapped(numV, orderV - 1, 0, 1);\r\n    const dURadians = 2.0 * Math.PI / numU;\r\n    const dVRadians = 2.0 * Math.PI / numV;\r\n    for (let iV = 0; iV < numVPole; iV++) {\r\n      const vRadians = iV * dVRadians;\r\n      const cV = Math.cos(vRadians);\r\n      const sV = Math.sin(vRadians);\r\n      for (let iU = 0; iU < numUPole; iU++) {\r\n        const uRadians = iU * dURadians;\r\n        const cU = Math.cos(uRadians);\r\n        const sU = Math.sin(uRadians);\r\n        const rho = radiusU + cV * radiusV;\r\n        points.push(Point3d.create(rho * cU, rho * sU, sV * radiusV));\r\n\r\n      }\r\n    }\r\n    const result = BSplineSurface3d.create(points, numUPole, orderU, uKnots.knots, numVPole, orderV, vKnots.knots);\r\n    if (result) {\r\n      result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);\r\n      result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a Bspline surface for a cone.\r\n   * @param centerA center at section A\r\n   * @param centerB center at section B\r\n   * @param radiusA radius at point A\r\n   * @param radiusB radius at point B\r\n   */\r\n  public static createConeBsplineSurface(\r\n    centerA: Point3d,\r\n    centerB: Point3d,\r\n    radiusA: number,\r\n    radiusB: number,\r\n    numSection: number): BSplineSurface3dH | undefined {\r\n    if (numSection < 2)\r\n      numSection = 2;\r\n    const controlPoints: number[][][] = [];\r\n    const numVPole = numSection;\r\n    const q1 = 0.25;\r\n    const q2 = 0.5;\r\n    const q3 = 0.75;\r\n\r\n    const uKnots = [0, 0, q1, q1, q2, q2, q3, q3, 1, 1];\r\n    const vKnots = [];\r\n    const dv = 1.0 / (numSection - 1);\r\n    for (let i = 0; i < numSection; i++) {\r\n      vKnots.push(i * dv);\r\n    }\r\n    const center = Point3d.create();\r\n    const vectorAB = Vector3d.createStartEnd(centerA, centerB);\r\n    const axes = Matrix3d.createRigidHeadsUp(vectorAB, AxisOrder.ZXY);\r\n    let r0, r90, v;\r\n    for (let iV = 0; iV < numVPole; iV++) {\r\n      v = iV * dv;\r\n      centerA.interpolate(v, centerB, center);\r\n      r0 = r90 = Geometry.interpolate(radiusA, v, radiusB);\r\n      controlPoints.push(Sample.createBsplineArc90SectionToXYZWArrays(center, axes, r0, r90, false));\r\n    }\r\n\r\n    const result = BSplineSurface3dH.createGrid(controlPoints,\r\n      WeightStyle.WeightsSeparateFromCoordinates,\r\n      3, uKnots, 2, vKnots);\r\n    // if (result) {\r\n    // result.setWrappable(0, BSplineWrapMode.OpenByAddingControlPoints);\r\n    // result.setWrappable(1, BSplineWrapMode.OpenByAddingControlPoints);\r\n    // }\r\n    return result;\r\n  }\r\n  /** Create bspline surface on xy grid with weights. */\r\n  public static createWeightedXYGridBsplineSurface(\r\n    numU: number, numV: number, orderU: number, orderV: number,\r\n    weight00: number = 1.0,\r\n    weight10: number = 1.0,\r\n    weight01: number = 1.0,\r\n    weight11: number = 1.0): BSplineSurface3dH | undefined {\r\n    const xyzPoles = Sample.createXYGrid(numU, numV, 1.0, 1.0);\r\n    const weights = [];\r\n    for (let i = 0; i < numU; i++)\r\n      for (let j = 0; j < numV; j++) {\r\n        const wu0 = Geometry.interpolate(weight00, i / (numU - 1), weight10);\r\n        const wu1 = Geometry.interpolate(weight01, i / (numU - 1), weight11);\r\n        weights.push(Geometry.interpolate(wu0, j / (numV - 1), wu1));\r\n      }\r\n\r\n    return BSplineSurface3dH.create(xyzPoles,\r\n      weights,\r\n      numU, orderU, undefined,\r\n      numV, orderV, undefined);\r\n  }\r\n  /** assorted linear sweeps */\r\n  public static createSimpleLinearSweeps(): LinearSweep[] {\r\n    const result: LinearSweep[] = [];\r\n    const base = Loop.create(LineString3d.createRectangleXY(Point3d.create(), 2, 3));\r\n    const vectorZ = Vector3d.create(0, 0, 1.234);\r\n    const vectorQ = Vector3d.create(0.1, 0.21, 1.234);\r\n    result.push(LinearSweep.create(base, vectorZ, false) as LinearSweep);\r\n    result.push(LinearSweep.create(base, vectorZ, true) as LinearSweep);\r\n    result.push(LinearSweep.create(base, vectorQ, false) as LinearSweep);\r\n    result.push(LinearSweep.create(base, vectorQ, true) as LinearSweep);\r\n    result.push(LinearSweep.create(Sample.createCappedArcLoop(5, -45, 90), vectorQ, true) as LinearSweep);\r\n    for (const curve of Sample.createSmoothCurvePrimitives()) {\r\n      const path = Path.create(curve);\r\n      result.push(LinearSweep.create(path, vectorZ, false)!);\r\n    }\r\n    // coordinates for a clearly unclosed linestring ....\r\n    const xyPoints = [\r\n      Point2d.create(0, 0),\r\n      Point2d.create(1, 0),\r\n      Point2d.create(1, 1)];\r\n\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false)!);\r\n    // this forces artificial closure point . . .\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true)!);\r\n\r\n    // add a not-quite-exact closure point ...\r\n    const e = 1.0e-11;\r\n    xyPoints.push(Point2d.create(e, e));\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false)!);\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true)!);\r\n    // make it a better closure\r\n    xyPoints.pop();\r\n    xyPoints.push(xyPoints[0]);\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, false)!);\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, 3, true)!);\r\n    // negative sweep ...\r\n    result.push(LinearSweep.createZSweep(xyPoints, 1, -3, true)!);\r\n    return result;\r\n  }\r\n  /**\r\n   * Create an array of primitives with an arc centerd at origin and a line segment closing back to the arc start.\r\n   * This can be bundled into Path or Loop by caller.\r\n   */\r\n  public static createCappedArcPrimitives(radius: number, startDegrees: number, endDegrees: number): CurvePrimitive[] {\r\n    const arc = Arc3d.create(\r\n      Point3d.create(0, 0, 0),\r\n      Vector3d.unitX(radius),\r\n      Vector3d.unitY(radius),\r\n      AngleSweep.createStartEndDegrees(startDegrees, endDegrees));\r\n    return [arc, LineSegment3d.create(arc.fractionToPoint(1.0), arc.fractionToPoint(0.0))];\r\n  }\r\n  /** Return a Path structure for a segment of arc, with closure segment */\r\n  public static createCappedArcPath(radius: number, startDegrees: number, endDegrees: number): Path {\r\n    return Path.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));\r\n  }\r\n  /** Return a Loop structure for a segment of arc, with closure segment */\r\n  public static createCappedArcLoop(radius: number, startDegrees: number, endDegrees: number): Loop {\r\n    return Loop.createArray(Sample.createCappedArcPrimitives(radius, startDegrees, endDegrees));\r\n  }\r\n  /** Create assorted rotational sweeps. */\r\n  public static createSimpleRotationalSweeps(): RotationalSweep[] {\r\n    const result: RotationalSweep[] = [];\r\n    // rectangle in xy plane\r\n    const base = Loop.create(LineString3d.createRectangleXY(Point3d.create(1, 0, 0), 2, 3));\r\n    // rotate around the y axis\r\n    for (const axis of [\r\n      Ray3d.createXYZUVW(0, 0, 0, 0, 1, 0),\r\n      Ray3d.createXYZUVW(5, 0, 0, 0, 1, 0),\r\n      Ray3d.createXYZUVW(-1, 0, 0, -1, 1, 0)]) {\r\n      result.push(RotationalSweep.create(base, axis, Angle.createDegrees(45.0), false) as RotationalSweep);\r\n      result.push(RotationalSweep.create(base, axis, Angle.createDegrees(150.0), true) as RotationalSweep);\r\n    }\r\n\r\n    return result;\r\n  }\r\n  /** Create assorted spheres */\r\n  public static createSpheres(includeEllipsoidal: boolean = false): Sphere[] {\r\n    const result: Sphere[] = [];\r\n    result.push(Sphere.createCenterRadius(Point3d.create(0, 0, 0), 1.0));\r\n    result.push(Sphere.createCenterRadius(Point3d.create(1, 2, 3), 3.0));\r\n    const s1 = Sphere.createCenterRadius(Point3d.create(1, 2, 3), 2.0,\r\n      AngleSweep.createStartEndDegrees(-45, 80));\r\n    s1.capped = true;\r\n    result.push(s1);\r\n    // still a sphere, but with axes KIJ . .\r\n    const s2 = Sphere.createFromAxesAndScales(\r\n      Point3d.create(1, 2, 3),\r\n      Matrix3d.createRowValues(\r\n        0, 1, 0,\r\n        0, 0, 1,\r\n        1, 0, 0),\r\n      4, 4, 4,\r\n      AngleSweep.createStartEndDegrees(-45, 45), true)!;\r\n    result.push(s2);\r\n    if (includeEllipsoidal)\r\n      result.push(Sphere.createDgnSphere(\r\n        Point3d.create(1, 2, 3),\r\n        Vector3d.unitX(),\r\n        Vector3d.unitZ(), 3, 2, AngleSweep.createFullLatitude(), false)!);\r\n    return result;\r\n  }\r\n  /** Create true (non-spherical) ellipsoids. */\r\n  public static createEllipsoids(): Sphere[] {\r\n    return [\r\n      Sphere.createEllipsoid(\r\n        Transform.createOriginAndMatrix(\r\n          Point3d.create(0, 0, 0),\r\n          Matrix3d.createRowValues(\r\n            4, 1, 1,\r\n            1, 4, 1,\r\n            0.5, 0.2, 5)),\r\n        AngleSweep.createFullLatitude(),\r\n        true)!];\r\n  }\r\n  /** Create assorted cones. */\r\n  public static createCones(): Cone[] {\r\n    const result: Cone[] = [];\r\n    const origin = Point3d.create(0, 0, 0);\r\n    const topZ = Point3d.create(0, 0, 5);\r\n    const centerA = Point3d.create(1, 2, 1);\r\n    const centerB = Point3d.create(2, 3, 8);\r\n    result.push(Cone.createAxisPoints(Point3d.create(0, 0, 0), Point3d.create(0, 0, 1), 0.5, 0.5, false) as Cone);\r\n\r\n    result.push(Cone.createAxisPoints(centerA, centerB, 0.5, 0.5, false) as Cone);\r\n    result.push(Cone.createAxisPoints(origin, topZ, 1.0, 0.2, true) as Cone);\r\n    result.push(Cone.createAxisPoints(centerA, centerB, 0.2, 0.5, false) as Cone);\r\n    result.push(Cone.createAxisPoints(origin, centerB, 1.0, 0.0, false) as Cone);\r\n    result.push(Cone.createAxisPoints(topZ, origin, 0.0, 1.0, true) as Cone);\r\n    return result;\r\n  }\r\n  /** Create assorted Torus Pipes */\r\n  public static createTorusPipes(): TorusPipe[] {\r\n    const result: TorusPipe[] = [];\r\n    const center = Point3d.create(1, 2, 3);\r\n\r\n    const frame = Matrix3d.createRotationAroundVector(\r\n      Vector3d.create(1, 2, 3), Angle.createRadians(10)) as Matrix3d;\r\n    const vectorX = frame.columnX();\r\n    const vectorY = frame.columnY();\r\n    const vectorZ = frame.columnZ();\r\n    result.push(TorusPipe.createInFrame(Transform.createIdentity(), 5.0, 0.8, Angle.create360(), false)!);\r\n    result.push(TorusPipe.createInFrame(Transform.createIdentity(), 5.0, 1.0, Angle.createDegrees(90), true)!);\r\n    result.push(TorusPipe.createDgnTorusPipe(center, vectorX, vectorY, 10, 1, Angle.createDegrees(180), true)!);\r\n\r\n    result.push(TorusPipe.createDgnTorusPipe(center, vectorY, vectorZ, 10, 1, Angle.createDegrees(45), true) as TorusPipe);\r\n\r\n    return result;\r\n  }\r\n  /** Create assorted boxes. */\r\n  public static createBoxes(capped: boolean = true): Box[] {\r\n    const result: Box[] = [];\r\n    const cornerA = Point3d.create(1, 2, 3);\r\n    const aX = 3.0;\r\n    const aY = 2.0;\r\n    const bX = 1.5;\r\n    const bY = 1.0;\r\n    const h = 5.0;\r\n    const frame = Matrix3d.createRotationAroundVector(\r\n      Vector3d.create(0, 0, 1), Angle.createDegrees(10)) as Matrix3d;\r\n    const vectorX = frame.columnX();\r\n    const vectorY = frame.columnY();\r\n    const cornerB = Matrix3d.xyzPlusMatrixTimesCoordinates(cornerA, frame, 0, 0, h);\r\n    result.push(Box.createDgnBox(cornerA, Vector3d.unitX(), Vector3d.unitY(),\r\n      cornerB, aX, aY, aX, aY, capped) as Box);\r\n\r\n    result.push(Box.createDgnBox(cornerA, Vector3d.unitX(), Vector3d.unitY(),\r\n      cornerB, aX, aY, bX, bY, capped) as Box);\r\n    result.push(Box.createDgnBox(cornerA, vectorX, vectorY, cornerB, aX, aY, bX, bY, capped) as Box);\r\n\r\n    const frameY = Matrix3d.createRotationAroundVector(\r\n      Vector3d.create(0, 1, 0), Angle.createDegrees(10)) as Matrix3d;\r\n    result.push(Box.createDgnBox(cornerA, frameY.columnX(), frameY.columnY(),\r\n      cornerA.plusScaled(frameY.columnZ(), h), aX, aY, bX, bY, capped) as Box);\r\n    return result;\r\n  }\r\n  /** create an array of points for a rectangle with corners (x0,y0,z) and (x1,y1,z)\r\n   */\r\n  public static createRectangle(x0: number, y0: number, x1: number, y1: number, z: number = 0.0, closed: boolean = false): Point3d[] {\r\n    const points = [\r\n      Point3d.create(x0, y0, z),\r\n      Point3d.create(x1, y0, z),\r\n      Point3d.create(x1, y1, z),\r\n      Point3d.create(x0, y1, z),\r\n    ];\r\n    if (closed)\r\n      points.push(Point3d.create(x0, y0, z));\r\n    return points;\r\n  }\r\n  /** Create assorted ruled sweeps */\r\n  public static createRuledSweeps(includeParityRegion: boolean = false, includeBagOfCurves: boolean = false): RuledSweep[] {\r\n    const allSweeps = [];\r\n    const contour0 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 3, 2, 0)));\r\n    const contour1 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 3, 2.5, 2)));\r\n    const contour2 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 4, 3.5, 4)));\r\n    const contour3 = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 2, 1, 7)));\r\n    const allContours = [contour0, contour1, contour2];\r\n    allSweeps.push(RuledSweep.create([contour0, contour1], true) as RuledSweep);\r\n    allSweeps.push(RuledSweep.create([contour0, contour1, contour2], true) as RuledSweep);\r\n    allSweeps.push(RuledSweep.create([contour0, contour1, contour2, contour3], true) as RuledSweep);\r\n    allSweeps.push(RuledSweep.create(allContours, false) as RuledSweep);\r\n\r\n    const curves = Sample.createSmoothCurvePrimitives();\r\n    for (const c of curves) {\r\n      const frame = c.fractionToFrenetFrame(0.0);\r\n      if (frame) {\r\n        const perpVector = frame.matrix.columnZ();\r\n        perpVector.scaleInPlace(10.0);\r\n        const c1 = c.cloneTransformed(Transform.createTranslation(perpVector)) as CurvePrimitive;\r\n        allSweeps.push(RuledSweep.create([Path.create(c), Path.create(c1)], false)!);\r\n      }\r\n    }\r\n    if (includeParityRegion) {\r\n      const outer = Loop.create(LineString3d.create(this.createRectangleXY(0, 0, 5, 6, 0)));\r\n      const inner = Loop.create(LineString3d.create(this.createRectangleXY(1, 1, 2, 3, 0)));\r\n      const contourA = ParityRegion.create(outer, inner);\r\n      const contourB = contourA.clone();\r\n      contourB.tryTranslateInPlace(0, 0, 2);\r\n      allSweeps.push(RuledSweep.create([contourA, contourB], false)!);\r\n    }\r\n    if (includeBagOfCurves) {\r\n      const contourA = BagOfCurves.create(LineSegment3d.createXYZXYZ(1, 1, 0, 3, 1, 0));\r\n      const contourB = BagOfCurves.create(LineSegment3d.createXYZXYZ(1, 1, 1, 3, 1, 1));\r\n      allSweeps.push(RuledSweep.create([contourA, contourB], false)!);\r\n    }\r\n\r\n    return allSweeps;\r\n  }\r\n  /**\r\n   * Uniformly spaced numbers\r\n   * @param a0 first entry\r\n   * @param delta step between entries\r\n   * @param n number of entries\r\n   */\r\n  public static createGrowableArrayCountedSteps(a0: number, delta: number, n: number): GrowableFloat64Array {\r\n    const data = new GrowableFloat64Array(n);\r\n    for (let i = 0; i < n; i++)\r\n      data.push(a0 + i * delta);\r\n    return data;\r\n  }\r\n  /**\r\n   * Create points on a unit circle\r\n   * @param radius first entry\r\n   * @param numEdge number of edges of chorded circle.  Angle step is 2PI/numEdge (whether or not closed)\r\n   * @param closed true to include final point (i.e. return numEdge+1 points)\r\n   */\r\n  public static createGrowableArrayCirclePoints(radius: number, numEdge: number, closed: boolean = false,\r\n    centerX: number = 0, centerY: number = 0, data?: GrowableXYZArray): GrowableXYZArray {\r\n    if (!data) data = new GrowableXYZArray();\r\n    data.ensureCapacity(numEdge + (closed ? 1 : 0));\r\n    const delta = 2.0 * Math.PI / numEdge;\r\n    for (let i = 0; i < numEdge; i++) {\r\n      const radians = i * delta;\r\n      data.push(Point3d.create(centerX + radius * Math.cos(radians), centerY + radius * Math.sin(radians)));\r\n    }\r\n    return data;\r\n  }\r\n\r\n  private static pushIfDistinct(points: Point3d[], xyz: Point3d, tol: number = 1.0e-12) {\r\n    if (points.length === 0 || points[points.length - 1].distanceXY(xyz) > tol)\r\n      points.push(xyz);\r\n  }\r\n\r\n  private static appendToFractalEval(points: Point3d[], pointA: Point3d, pointB: Point3d, pattern: Point2d[], numRecursion: number, perpendicularFactor: number) {\r\n    const point0 = pointA.clone();\r\n    Sample.pushIfDistinct(points, pointA);\r\n\r\n    for (const uv of pattern) {\r\n      const point1 = pointA.interpolatePerpendicularXY(uv.x, pointB, perpendicularFactor * uv.y);\r\n      if (numRecursion > 0)\r\n        Sample.appendToFractalEval(points, point0, point1, pattern, numRecursion - 1, perpendicularFactor);\r\n      Sample.pushIfDistinct(points, point1);\r\n      point0.setFrom(point1);\r\n    }\r\n\r\n    Sample.pushIfDistinct(points, pointB);\r\n  }\r\n\r\n  /**\r\n   * For each edge of points, construct a transform (with scale, rotate, and translate) that spreads the patter out along the edge.\r\n   * Repeat recursively for each edge\r\n   * @returns Returns an array of recusively generated fractal points\r\n   * @param poles level-0 (coarse) polygon whose edges are to be replaced by recursive fractals\r\n   * @param pattern pattern to map to each edge of poles (and to edges of the recursion)\r\n   * @param numRecursion  number of recursions\r\n   * @param perpendicularFactor factor to apply to perpendicular sizing.\r\n   */\r\n  public static createRecursvieFractalPolygon(poles: Point3d[], pattern: Point2d[], numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const points: Point3d[] = [];\r\n    Sample.pushIfDistinct(points, poles[0]);\r\n    for (let i = 0; i + 1 < poles.length; i++) {\r\n      if (numRecursion > 0)\r\n        Sample.appendToFractalEval(points, poles[i], poles[i + 1], pattern, numRecursion - 1, perpendicularFactor);\r\n      Sample.pushIfDistinct(points, poles[i + 1]);\r\n    }\r\n    return points;\r\n  }\r\n\r\n  /** Primary shape is a \"triangle\" with lower edge pushed in so it becomes a mild nonconvex quad.\r\n   *  Fractal effects are gentle.\r\n   */\r\n  public static nonConvexQuadSimpleFractal(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.5, 0.1),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(0, 0, 0),\r\n      Point3d.create(0.6, 0.1, 0),\r\n      Point3d.create(1, 0.1, 0),\r\n      Point3d.create(0.6, 1, 0),\r\n      Point3d.create(),\r\n    ];\r\n    return Sample.createRecursvieFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n\r\n  /** create a diamond with convex fractal */\r\n  public static createFractalDiamonConvexPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.3, 0.05),\r\n      Point2d.create(0.5, 0.10),\r\n      Point2d.create(0.7, 0.04),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(0, -1, 0),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(0, 1, 0),\r\n      Point3d.create(-1, 0, 0),\r\n      Point3d.create(0, -1, 0),\r\n    ];\r\n    return Sample.createRecursvieFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** Create fracta on a sqaure, with pattern shfit to both directions. */\r\n  public static createFractalSquareReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0),\r\n      Point2d.create(0.5, 0.2),\r\n      Point2d.create(0.75, -0.1),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(0, 1, 0),\r\n      Point3d.create(0, 0, 0),\r\n    ];\r\n    return Sample.createRecursvieFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** Create a fractal on a non-convex base and reversing pattern */\r\n  public static createFractalHatReversingPattern(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0),\r\n      Point2d.create(0.25, 0.1),\r\n      Point2d.create(0.50, 0.1),\r\n      Point2d.create(0.50, -0.1),\r\n      Point2d.create(0.75, -0.1),\r\n      Point2d.create(0.75, 0),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(0, 1, 0),\r\n      Point3d.create(0, 0, 0),\r\n    ];\r\n    return Sample.createRecursvieFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** Create a fractal on a primary L shape with a reversing pattern */\r\n  public static createFractalLReversingPatterh(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0),\r\n      Point2d.create(0.5, 0.2),\r\n      Point2d.create(0.75, -0.1),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(2, 2, 0),\r\n      Point3d.create(2, 3, 0),\r\n      Point3d.create(0, 3, 0),\r\n      Point3d.create(),\r\n    ];\r\n    return Sample.createRecursvieFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n\r\n  /** Fractal with fewer concavity changes.... */\r\n  public static createFractalLMildConcavePatter(numRecursion: number, perpendicularFactor: number): Point3d[] {\r\n    const pattern: Point2d[] = [\r\n      Point2d.create(),\r\n      Point2d.create(0.25, 0.05),\r\n      Point2d.create(0.5, 0.15),\r\n      Point2d.create(0.75, 0.05),\r\n      Point2d.create(1.0, 0.0),\r\n    ];\r\n    const poles: Point3d[] = [\r\n      Point3d.create(),\r\n      Point3d.create(1, 0, 0),\r\n      Point3d.create(1, 1, 0),\r\n      Point3d.create(2, 2, 0),\r\n      Point3d.create(1.5, 3, 0),\r\n      Point3d.create(0, 3, 0),\r\n      Point3d.create(),\r\n    ];\r\n    return Sample.createRecursvieFractalPolygon(poles, pattern, numRecursion, perpendicularFactor);\r\n  }\r\n  /** append interpolated points from the array tail to the target. */\r\n  public static appendSplits(points: Point3d[], target: Point3d, numSplit: number, includeTarget: boolean) {\r\n    const pointA = points[points.length - 1];\r\n    for (let i = 0; i < numSplit; i++)\r\n      points.push(pointA.interpolate(i / numSplit, target));\r\n    if (includeTarget)\r\n      points.push(target);\r\n  }\r\n  /**\r\n   * Triangle with 3 given vertices, and indicated extra points on each each.\r\n   * @param numSplitAB number of extra points on edge AB\r\n   * @param numSplitBC number of extra points on edge BC\r\n   * @param numSplitCA number of extra points on edge CA\r\n   * @param wrap true to replicate vertexA at end\r\n   * @param xyzA vertexA\r\n   * @param xyzB vertexB\r\n   * @param xyzC vertexC\r\n   */\r\n  public static createTriangleWithSplitEdges(\r\n    numSplitAB: number,\r\n    numSplitBC: number,\r\n    numSplitCA: number,\r\n    wrap: boolean = true,\r\n    xyzA: Point3d = Point3d.create(0, 0, 0),\r\n    xyzB: Point3d = Point3d.create(1, 0, 0),\r\n    xyzC: Point3d = Point3d.create(0, 1, 0)): Point3d[] {\r\n    const result = [xyzA.clone()];\r\n    Sample.appendSplits(result, xyzB, numSplitAB, true);\r\n    Sample.appendSplits(result, xyzC, numSplitBC, true);\r\n    Sample.appendSplits(result, xyzA, numSplitCA, wrap);\r\n    return result;\r\n  }\r\n  /** Create a box (xyz) from half-lengths and center. */\r\n  public static createCenteredBoxEdges(ax: number = 1, ay: number = 1, az: number = 0, cx: number = 0, cy: number = 0, cz: number = 0,\r\n    geometry?: GeometryQuery[]): GeometryQuery[] {\r\n    if (!geometry)\r\n      geometry = [];\r\n    const x0 = cx - ax;\r\n    const y0 = cy - ay;\r\n    const z0 = cz - az;\r\n\r\n    const x1 = cx + ax;\r\n    const y1 = cy + ay;\r\n    const z1 = cz + az;\r\n\r\n    for (const z of [z0, z1]) {\r\n      geometry.push(\r\n        LineString3d.create(\r\n          Point3d.create(x0, y0, z),\r\n          Point3d.create(x1, y0, z),\r\n          Point3d.create(x1, y1, z),\r\n          Point3d.create(x0, y1, z),\r\n          Point3d.create(x0, y0, z)));\r\n    }\r\n    geometry.push(LineSegment3d.createXYZXYZ(x0, y0, z0, x0, y0, z1));\r\n    geometry.push(LineSegment3d.createXYZXYZ(x1, y0, z0, x1, y0, z1));\r\n    geometry.push(LineSegment3d.createXYZXYZ(x1, y1, z0, x1, y1, z1));\r\n    geometry.push(LineSegment3d.createXYZXYZ(x0, y1, z0, x0, y1, z1));\r\n    return geometry;\r\n  }\r\n  /** Assorted transition spirals\r\n   * * (All combinations of bearing radius bearing radius length subsests.)\r\n   */\r\n  public static createSimpleTransitionSpirals(): TransitionSpiral3d[] {\r\n    // 5 spirals exercise the intricate \"4 out of 5\" input ruls for spirals . ..\r\n    const r1 = 1000.0;\r\n    const r0 = 0.0;\r\n    const averageCurvature = TransitionSpiral3d.averageCurvatureR0R1(r0, r1);\r\n    const arcLength = 100.0;\r\n    const dThetaRadians = arcLength * averageCurvature;\r\n\r\n    return [\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians),\r\n        undefined,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        Angle.createDegrees(0), undefined,\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        undefined, Angle.createRadians(dThetaRadians),\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, undefined,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians),\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", undefined, r1,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians),\r\n        arcLength,\r\n        undefined, Transform.createIdentity())!,\r\n      TransitionSpiral3d.create(\"clothoid\", r0, r1,\r\n        Angle.createDegrees(0), Angle.createRadians(dThetaRadians), undefined,\r\n        Segment1d.create(0, 0.5),\r\n        Transform.createOriginAndMatrix(Point3d.create(1, 2, 0),\r\n          Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(15))!))!,\r\n    ];\r\n  }\r\n  /** Create a Bezier curve with significant twist effects\r\n   * * r and theta are circle in xy plane at steps in thetaStepper\r\n   * * z varies with sin(phi) at steps in phiStepper.\r\n   */\r\n  public static createTwistingBezier(order: number,\r\n    x0: number,\r\n    y0: number,\r\n    r: number,\r\n    thetaStepper: AngleSweep,\r\n    phiStepper: AngleSweep,\r\n    weightInterval?: Segment1d,\r\n  ): CurvePrimitive | undefined {\r\n\r\n    if (weightInterval !== undefined) {\r\n      const points = [];\r\n      for (let i = 0; i < order; i++) {\r\n        const theta = thetaStepper.fractionToRadians(i);\r\n        const phi = phiStepper.fractionToRadians(i);\r\n        const weight = weightInterval.fractionToPoint(i / (order - 1));\r\n        points.push(Point4d.create(\r\n          weight * (x0 + r * Math.cos(theta)),\r\n          weight * (y0 + r * Math.sin(theta)),\r\n          weight * Math.sin(phi), weight));\r\n      }\r\n      return BezierCurve3dH.create(points)!;\r\n    } else {\r\n      const points = [];\r\n      for (let i = 0; i < order; i++) {\r\n        const theta = thetaStepper.fractionToRadians(i);\r\n        const phi = phiStepper.fractionToRadians(i);\r\n        points.push(Point3d.create(x0 + r * Math.cos(theta), y0 + r * Math.sin(theta), Math.sin(phi)));\r\n      }\r\n      return BezierCurve3d.create(points);\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Create various curve chains with distance indexing.\r\n   * * LineSegment\r\n   * * CircularArc\r\n   * * LineString\r\n   * * order 3 bspline\r\n   * * order 4 bspline\r\n   * * alternating lines and arcs\r\n   */\r\n  public static createCurveChainWithDistanceIndex(): CurveChainWithDistanceIndex[] {\r\n    const pointsA = [Point3d.create(0, 0, 0), Point3d.create(1, 3, 0), Point3d.create(2, 4, 0), Point3d.create(3, 3, 0), Point3d.create(4, 0, 0)];\r\n    const result = [];\r\n    // one singleton per basic curve type ...\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(LineSegment3d.create(Point3d.create(0, 0, 0), Point3d.create(5, 0, 0)))));\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(Arc3d.createCircularStartMiddleEnd(\r\n        Point3d.create(0, 0, 0), Point3d.create(3, 3, 0), Point3d.create(6, 0, 0))!)));\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(LineString3d.create(pointsA))));\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(BSplineCurve3d.createUniformKnots(pointsA, 3)!)));\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(BSplineCurve3d.createUniformKnots(pointsA, 4)!)));\r\n    result.push(CurveChainWithDistanceIndex.createCapture(\r\n      Path.create(\r\n        LineSegment3d.create(pointsA[0], pointsA[1]),\r\n        Arc3d.createCircularStartMiddleEnd(pointsA[1], pointsA[2], pointsA[3])!,\r\n        LineSegment3d.create(pointsA[3], pointsA[4]))));\r\n    return result;\r\n  }\r\n  /**\r\n   * Create a square wave path.\r\n   * @param numTooth number of teeth.\r\n   * @param dxA x size of \"A\" part\r\n   * @param dxB x size of \"B\" part\r\n   * @param yA y for A part\r\n   * @param yB y for B part\r\n   * @param structure 1 for line segments, 2 for one linestring per tooth, 0 for single linestring\r\n   */\r\n  public static createSquareWavePath(numTooth: number, dxA: number, dxB: number, yA: number, yB: number, structure: number): Path {\r\n    const dxAB = dxA + dxB;\r\n    const path = Path.create();\r\n    // build the whole linestring ...\r\n    const allPoints = new GrowableXYZArray(4 * numTooth);\r\n    let x2 = 0.0;\r\n    for (let i = 0; i < numTooth; i++) {\r\n      const x0 = i * dxAB;\r\n      const x1 = x0 + dxA;\r\n      x2 = (i + 1) * dxAB;\r\n      allPoints.pushXYZ(x0, yA, 0);\r\n      allPoints.pushXYZ(x1, yA, 0.0);\r\n      allPoints.pushXYZ(x1, yB, 0.0);\r\n      allPoints.pushXYZ(x2, yB, 0.0);\r\n    }\r\n    allPoints.pushXYZ(x2, yA, 0.0);\r\n\r\n    const numPoints = allPoints.length;\r\n\r\n    if (structure === 1) {\r\n      const pointA = Point3d.create();\r\n      const pointB = Point3d.create();\r\n      allPoints.getPoint3dAtUncheckedPointIndex(0, pointA);\r\n      for (let i1 = 0; i1 + 1 < numPoints; i1++) {\r\n        allPoints.getPoint3dAtUncheckedPointIndex(i1, pointB);\r\n        path.tryAddChild(LineSegment3d.create(pointA, pointB));\r\n        pointA.setFromPoint3d(pointB);\r\n      }\r\n    } else if (structure === 2) {\r\n      for (let i0 = 0; i0 + 4 < numPoints; i0 += 4) {\r\n        const ls = LineString3d.create();\r\n        ls.addSteppedPoints(allPoints, i0, 1, 5);\r\n        path.tryAddChild(ls);\r\n      }\r\n\r\n    } else {\r\n      const ls = LineString3d.create();\r\n      ls.addSteppedPoints(allPoints, 0, 1, numPoints);\r\n      path.tryAddChild(ls);\r\n\r\n    }\r\n    return path;\r\n  }\r\n\r\n  /**\r\n   * Create various elliptic arcs\r\n   * * circle with vector0, vector90 aligned with x,y\r\n   * * circle with axes rotated\r\n   * *\r\n   * @param radiusRatio = vector90.magnitude / vector0.magnitude\r\n   */\r\n  public static createArcs(radiusRatio: number = 1.0, sweep: AngleSweep = AngleSweep.create360()): Arc3d[] {\r\n    const arcs = [];\r\n    const center0 = Point3d.create(0, 0, 0);\r\n    const a = 1.0;\r\n    const b = radiusRatio;\r\n    const direction0 = Vector3d.createPolar(a, Angle.createDegrees(35.0));\r\n    const direction90 = direction0.rotate90CCWXY();\r\n    direction90.scaleInPlace(radiusRatio);\r\n    arcs.push(Arc3d.create(center0, Vector3d.create(a, 0, 0), Vector3d.create(0, b, 0), sweep));\r\n    arcs.push(Arc3d.create(center0, direction0, direction90, sweep));\r\n    return arcs;\r\n  }\r\n  /**\r\n   * Create many arcs, optionally including skews\r\n   * * @param skewFactor array of skew factors.  for each skew factor, all base arcs are replicated with vector90 shifted by the factor times vector0\r\n   */\r\n  public static createManyArcs(skewFactors: number[] = []): Arc3d[] {\r\n    const result: Arc3d[] = [];\r\n    const sweep1 = AngleSweep.createStartEndDegrees(-10, 75);\r\n    const sweep2 = AngleSweep.createStartEndDegrees(160.0, 380.0);\r\n    for (const arcs of [\r\n      Sample.createArcs(1.0), Sample.createArcs(0.5),\r\n      Sample.createArcs(1.0, sweep1), Sample.createArcs(0.3, sweep2)]) {\r\n      for (const arc of arcs)\r\n        result.push(arc);\r\n    }\r\n    const numBase = result.length;\r\n    for (const skewFactor of skewFactors) {\r\n      for (let i = 0; i < numBase; i++) {\r\n        const originalArc = result[i];\r\n        result.push(Arc3d.create(originalArc.center, originalArc.vector0, originalArc.vector90.plusScaled(originalArc.vector0, skewFactor), originalArc.sweep));\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create edges of a range box.\r\n   * * Linestrings on low and high z\r\n   * * single lines on each low z to high z edge.\r\n   * * @param range (possibly null) range\r\n   */\r\n  public static createRangeEdges(range: Range3d): BagOfCurves | undefined {\r\n    if (range.isNull)\r\n      return undefined;\r\n    const corners = range.corners();\r\n\r\n    return BagOfCurves.create(\r\n      LineString3d.create(corners[0], corners[1], corners[3], corners[2], corners[0]),\r\n      LineString3d.create(corners[4], corners[5], corners[7], corners[6], corners[4]),\r\n      LineSegment3d.create(corners[0], corners[4]),\r\n      LineSegment3d.create(corners[1], corners[5]),\r\n      LineSegment3d.create(corners[2], corners[6]),\r\n      LineSegment3d.create(corners[3], corners[7]));\r\n  }\r\n  /** Create swept \"solids\" that can be capped.\r\n   * * At least one of each solid type.\r\n   * * each is within 10 of the origin all directions.\r\n   */\r\n  public static createClosedSolidSampler(capped: boolean): SolidPrimitive[] {\r\n    const result = [];\r\n    result.push(Box.createRange(Range3d.createXYZXYZ(0, 0, 0, 3, 2, 5), capped)!);\r\n\r\n    result.push(Cone.createAxisPoints(Point3d.create(0, 0, 0), Point3d.create(0, 0, 5), 1.0, 1.0, capped)!);\r\n\r\n    result.push(Sphere.createCenterRadius(Point3d.create(0, 0, 0), 1.0)!);\r\n\r\n    result.push(TorusPipe.createInFrame(Transform.createIdentity(), 3.0, 1.0, Angle.create360(), capped)!);\r\n    const arcA = Arc3d.createXY(Point3d.create(6, 1, 0), 1.0, AngleSweep.createStartEndDegrees(-90, 0));\r\n    const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);\r\n    const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);\r\n    const pointQ2 = arcA.fractionAndDistanceToPointOnTangent(1.0, 0.5);\r\n    const pointR1 = Point3d.create(point0.x, pointQ1.y);\r\n    const pointR2 = Point3d.create(point0.x, pointQ1.y);\r\n    const linestringQ1 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);\r\n    const linestringQ2 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ2, pointR2, point0);\r\n    const contourZ = Path.create(linestringQ1.clone());\r\n\r\n    const contourA = Loop.create(\r\n      LineSegment3d.create(point0, arcA.fractionToPoint(0)),\r\n      arcA.clone(),\r\n      linestringQ1.clone());\r\n    const contourB = Loop.create(\r\n      LineSegment3d.create(point0, arcA.fractionToPoint(0)),\r\n      arcA.clone(),\r\n      linestringQ2.clone());\r\n    contourB.tryTransformInPlace(Transform.createTranslationXYZ(1, 1, 3));\r\n\r\n    // const contourC = contourB.cloneTransformed(Transform.createTranslationXYZ(2, 1, 4))!;\r\n    result.push(LinearSweep.create(contourA, Vector3d.create(0, 0, 5), capped)!);\r\n    const axis = Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);\r\n    result.push(RotationalSweep.create(contourA.clone()!, axis.clone(), Angle.createDegrees(90), capped)!);\r\n\r\n    if (!capped)\r\n      result.push(RotationalSweep.create(contourZ.clone()!, axis.clone(), Angle.createDegrees(90), false)!);\r\n\r\n    result.push(RuledSweep.create([contourA.clone()!, contourB.clone()!], capped)!);\r\n\r\n    const transformC = Transform.createScaleAboutPoint(Point3d.create(0, 0, 8), 0.5);\r\n    const contourC = contourB.cloneTransformed(transformC)!;\r\n    result.push(RuledSweep.create([contourA.clone()!, contourB.clone()!, contourC.clone()!], capped)!);\r\n    return result;\r\n  }\r\n  /** Create a rotational sweep with segment, arc, and linestring in its contour.\r\n   */\r\n  public static createRotationalSweepLineSegment3dArc3dLineString3d(capped: boolean): SolidPrimitive[] {\r\n    const result = [];\r\n    const arcA = Arc3d.createXY(Point3d.create(6, 1, 0), 1.0, AngleSweep.createStartEndDegrees(-90, 0));\r\n    const point0 = arcA.fractionAndDistanceToPointOnTangent(0.0, -4);\r\n    const pointQ1 = arcA.fractionAndDistanceToPointOnTangent(1.0, 2);\r\n    const pointR1 = Point3d.create(point0.x, pointQ1.y);\r\n    const linestringQ1 = LineString3d.create(arcA.fractionToPoint(1.0), pointQ1, pointR1, point0);\r\n    const contourZ = Path.create(linestringQ1.clone());\r\n    const axis = Ray3d.createXYZUVW(0, 8, 0, 1, 0, 0);\r\n    result.push(RotationalSweep.create(contourZ.clone()!, axis.clone(), Angle.createDegrees(90), capped)!);\r\n    return result;\r\n  }\r\n  /**\r\n   * Create points:\r\n   * *  `numRadialEdges` radially from origin to polar point (r,sweep.start)\r\n   * * `numArcEdges` along arc from (r,sweep.start) to (r,sweep.end)\r\n   * * `numRadialEdges` returning to origin.\r\n   * * optionally include closure point at origin.\r\n   * @param x0 center x\r\n   * @param y0 center y\r\n   * @param radius radius of circle.\r\n   * @param sweep start and end angles of sweep.\r\n   * @param numRadialEdges number of edges from center to arc\r\n   * @param numArcEdges number of edges along arc\r\n   * @param addCLosure true to repeat center as closure point\r\n   */\r\n  public static createCutPie(x0: number, y0: number, radius: number, sweep: AngleSweep, numRadialEdges: number, numArcEdges: number, addClosure = false): Point3d[] {\r\n\r\n    const points = [];\r\n    const center = Point3d.create(x0, y0);\r\n    points.push(center);\r\n    const pointA = Point3d.create(x0 + radius * Math.cos(sweep.startRadians), y0 + radius * Math.sin(sweep.startRadians));\r\n    const pointB = Point3d.create(x0 + radius * Math.cos(sweep.endRadians), y0 + radius * Math.sin(sweep.endRadians));\r\n    for (let i = 1; i < numRadialEdges; i++)\r\n      points.push(center.interpolate(i / numRadialEdges, pointA));\r\n    points.push(pointA);\r\n    for (let i = 1; i < numArcEdges; i++) {\r\n      const radians = sweep.fractionToRadians(i / numArcEdges);\r\n      points.push(Point3d.create(x0 + radius * Math.cos(radians), y0 + radius * Math.sin(radians)));\r\n    }\r\n    points.push(pointB);\r\n    for (let i = 1; i < numRadialEdges; i++)\r\n      points.push(pointB.interpolate(i / numRadialEdges, center));\r\n    if (addClosure)\r\n      points.push(center.clone());\r\n    return points;\r\n  }\r\n  /**\r\n   * * let ay = 4\r\n   * * base polygon has vertices (0,0), (ax,0), (2*ax,0), (2* ax,ay), (ax,ay), (0,ay), (0,0).\r\n   * * shift the x coordinates of vertices 1,4 by indicated amounts (0-based numbering)\r\n   * * shift the y coordinates for points 1,2,3,4 by indicated amounts (in 0-based numbering)\r\n   * * This is useful for testing non-y-monootonic face situations.\r\n   * * Return as points.\r\n   * @param dy1\r\n   * @param dy2\r\n   * @param dy3\r\n   * @param dy4\r\n   */\r\n  public static creatVerticalStaggerPolygon(dy1: number, dy2: number, dy3: number, dy4: number,\r\n    ax: number,\r\n    ay: number,\r\n    dx1: number,\r\n    dx4: number): Point3d[] {\r\n    return [Point3d.create(0, 0),\r\n    Point3d.create(ax + dx1, dy1),\r\n    Point3d.create(2 * ax, dy2),\r\n    Point3d.create(2 * ax, ay + dy3),\r\n    Point3d.create(ax + dx4, ay + dy4),\r\n    Point3d.create(0.0, ay),\r\n    Point3d.create(0, 0)];\r\n  }\r\n  /**\r\n   * make line segments for each pair of adjacent points.\r\n   * @param points array of points\r\n   * @param forceClosure if true, inspect coordinates to determine if a closure edge is needed.\r\n   */\r\n  public static convertPointsToSegments(points: Point3d[], forceClosure: boolean = false): LineSegment3d[] {\r\n    const segments = [];\r\n    const n = points.length;\r\n    for (let i = 0; i + 1 < n; i++) {\r\n      segments.push(LineSegment3d.create(points[i], points[i + 1]));\r\n    }\r\n    if (forceClosure && n > 1 && !points[0].isAlmostEqual(points[n - 1]))\r\n      segments.push(LineSegment3d.create(points[n - 1], points[0]));\r\n    return segments;\r\n  }\r\n  /**\r\n   * Create a star by alternating radii (with equal anguar steps)\r\n   * @param r0 first point radius\r\n   * @param r1 second point radius\r\n   * @param numPoint number of points\r\n   * @param close true to add closure edge.\r\n   */\r\n  public static createStar(cx: number, cy: number, cz: number, r0: number, r1: number, numPoint: number, close: boolean): Point3d[] {\r\n    const points = [];\r\n    const angleStepRadians = Math.PI / numPoint;\r\n    let radians;\r\n    for (let i = 0; i < numPoint; i++) {\r\n      radians = 2 * i * angleStepRadians;\r\n      points.push(Point3d.create(cx + r0 * Math.cos(radians), cy + r0 * Math.sin(radians), cz));\r\n      radians = (2 * i + 1) * angleStepRadians;\r\n      points.push(Point3d.create(cx + r1 * Math.cos(radians), cy + r1 * Math.sin(radians), cz));\r\n    }\r\n    if (close)\r\n      points.push(points[0].clone());\r\n    return points;\r\n  }\r\n  /**\r\n   * Create an outer star A\r\n   * Place multiple inner stars B with centers on circle C\r\n   * @param rA0 radius to star tips on starA\r\n   * @param rA1 radius to star tips on starA\r\n   * @param numAPoint number of points on starA\r\n   * @param rB0 radius to star B tips\r\n   * @param rB1 radius to star B  tips\r\n   * @param numBPoint\r\n   * @param rC radius for inner star centers\r\n   * @param numC number of inner stars\r\n   */\r\n  public static createStarsInStars(rA0: number, rA1: number, numAPoint: number, rB0: number, rB1: number, numBPoint: number, rC: number, numC: number, close: boolean): Point3d[][] {\r\n    const loops: Point3d[][] = [];\r\n    loops.push(this.createStar(0, 0, 0, rA0, rA1, numAPoint, close));\r\n    if (numC > 0) {\r\n      const radiansStep = Math.PI * 2.0 / numC;\r\n      for (let i = 0; i < numC; i++) {\r\n        const radians = i * radiansStep;\r\n        loops.push(\r\n          this.createStar(rC * Math.cos(radians), rC * Math.sin(radians), 0.0, rB0, rB1, numBPoint, close));\r\n      }\r\n    }\r\n    return loops;\r\n  }\r\n  private static appendGeometry(source: GeometryQuery[], dest: GeometryQuery[]) {\r\n    for (const g of source) dest.push(g);\r\n  }\r\n  /** Create a simple example of each GeometryQuery type .... */\r\n  public static createAllGeometryQueryTypes(): GeometryQuery[] {\r\n    const result: GeometryQuery[] = [];\r\n    const pointA = Point3d.create(0, 0, 0);\r\n    const pointB = Point3d.create(1, 0, 0);\r\n    const pointC = Point3d.create(1, 1, 0);\r\n    const pointD = Point3d.create(0, 1, 0);\r\n    const pointABC = [pointA, pointB, pointC];\r\n    const pointABCD = [pointA, pointB, pointC, pointD];\r\n    const pointABCDA = [pointA, pointB, pointC, pointD, pointA];\r\n    result.push(LineSegment3d.create(pointA, pointB));\r\n    result.push(CoordinateXYZ.create(pointA));\r\n    result.push(Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC)!);\r\n    result.push(PointString3d.create(pointA, pointB));\r\n    result.push(TransitionSpiral3d.createRadiusRadiusBearingBearing(Segment1d.create(0, 100), AngleSweep.createStartEndDegrees(0, 5), Segment1d.create(0, 0.5), Transform.createIdentity()));\r\n    result.push(LineString3d.create(pointABCD));\r\n    result.push(BezierCurve3d.create(pointABC)!);\r\n    result.push(BezierCurve3dH.create(pointABC)!);\r\n\r\n    result.push(BSplineCurve3d.createUniformKnots(pointABC, 3)!);\r\n    result.push(BSplineCurve3dH.createUniformKnots(pointABC, 3)!);\r\n\r\n    result.push(Loop.create(LineString3d.create(pointABCDA)));\r\n    result.push(Path.create(LineString3d.create(pointABCD)));\r\n    result.push(this.createConeBsplineSurface(pointA, pointC, 1, 2, 4)!);\r\n    result.push(this.createXYGridBsplineSurface(8, 4, 4, 3)!);\r\n    this.appendGeometry(this.createClosedSolidSampler(true), result);\r\n    result.push(this.createTriangularUnitGridPolyface(pointA, Vector3d.unitX(), Vector3d.unitY(), 4, 5));\r\n    this.appendGeometry(this.createSimpleParityRegions(), result);\r\n    this.appendGeometry(this.createSimpleUnions(), result);\r\n    this.appendGeometry(this.createBagOfCurves(), result);\r\n\r\n    return result;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Serialization */\r\n\r\n// import { Geometry, Angle, AxisOrder, BSIJSONValues } from \"../Geometry\";\r\nimport { Geometry, AngleProps, AngleSweepProps, AxisOrder } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { Point2d } from \"../geometry3d/Point2dVector2d\";\r\nimport { XYProps, XYZProps } from \"../geometry3d/XYZProps\";\r\nimport { Point3d, XYZ, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Segment1d } from \"../geometry3d/Segment1d\";\r\nimport { YawPitchRollAngles, YawPitchRollProps } from \"../geometry3d/YawPitchRollAngles\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { CoordinateXYZ } from \"../curve/CoordinateXYZ\";\r\nimport { TransitionSpiral3d } from \"../curve/TransitionSpiral\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { UnionRegion } from \"../curve/UnionRegion\";\r\nimport { BagOfCurves, CurveCollection } from \"../curve/CurveCollection\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { PolyfaceAuxData, AuxChannel, AuxChannelData, AuxChannelDataType } from \"../polyface/AuxData\";\r\nimport { BSplineCurve3d } from \"../bspline/BSplineCurve\";\r\nimport { BSplineSurface3d, BSplineSurface3dH, WeightStyle } from \"../bspline/BSplineSurface\";\r\nimport { Sphere } from \"../solid/Sphere\";\r\nimport { Cone } from \"../solid/Cone\";\r\nimport { Box } from \"../solid/Box\";\r\nimport { TorusPipe } from \"../solid/TorusPipe\";\r\nimport { LinearSweep } from \"../solid/LinearSweep\";\r\nimport { RotationalSweep } from \"../solid/RotationalSweep\";\r\nimport { RuledSweep } from \"../solid/RuledSweep\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { PointString3d } from \"../curve/PointString3d\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\r\nimport { BSplineCurve3dH } from \"../bspline/BSplineCurve3dH\";\r\nimport { Point4d } from \"../geometry4d/Point4d\";\r\nimport { BezierCurve3dH } from \"../bspline/BezierCurve3dH\";\r\nimport { BezierCurve3d } from \"../bspline/BezierCurve3d\";\r\nimport { BSplineWrapMode } from \"../bspline/KnotVector\";\r\n\r\n/* tslint:disable: object-literal-key-quotes no-console*/\r\n/**\r\n * `ImodelJson` namespace has classes for serializing and deserialization json objects\r\n * @public\r\n */\r\nexport namespace IModelJson {\r\n  /**\r\n   * Property rules for json objects that can be deserialized to various Curve and Solid objects\r\n   * @public\r\n   */\r\n  export interface GeometryProps extends CurvePrimitiveProps, SolidPrimitiveProps, CurveCollectionProps {\r\n    /** `{indexedMesh:...}` */\r\n    indexedMesh?: IndexedMeshProps;\r\n    /** `{point:...}` */\r\n    point?: XYZProps;\r\n    /** `{bsurf:...}` */\r\n    bsurf?: BSplineSurfaceProps;\r\n  }\r\n  /**\r\n   * Property rules for json objects that can be deserialized to various CurvePrimitives\r\n   * * Only one of these is allowed in each instance.\r\n   * @public\r\n   */\r\n  export interface CurvePrimitiveProps {\r\n    /** `{lineSegment:...}` */\r\n    lineSegment?: [XYZProps, XYZProps];\r\n    /** `{lineString:...}` */\r\n    lineString?: XYZProps[];\r\n    /** `{bcurve:...}` */\r\n    bcurve?: BcurveProps;\r\n    /** `{transitionSpiral:...}` */\r\n    transitionSpiral?: TransitionSpiralProps;\r\n    /** `{arc:...}` */\r\n    arc?: ArcByVectorProps | [XYZProps, XYZProps, XYZProps];\r\n  }\r\n\r\n  /**\r\n   * Property rules for json objects that can be deserialized to single point\r\n   * @public\r\n   */\r\n  export interface PointProps {\r\n    /** `{point:...}` */\r\n    point?: XYZProps;\r\n  }\r\n\r\n  /**\r\n   * Property rules for json objects that can be deserialized to a BsplineSurface\r\n   * See `BCurveProps` for discussion of knot and pole counts.\r\n   * @public\r\n   */\r\n  export interface BSplineSurfaceProps {\r\n    /** polynomial order (one more than degree) in the u parameter direction */\r\n    orderU: number;\r\n    /** polynomial order (one more than degree) in the v parameter direction */\r\n    orderV: number;\r\n    /** Square grid of control points (aka poles) in row major order (row is along the u direction) */\r\n    points: [[[number]]];   // each inner array is xyz or xyzw for a single control point. each middle array is a row of control points.\r\n    /** Array of knots for the u direction bspline */\r\n    uKnots: [number];\r\n    /** Array of knots for the v direction bspline */\r\n    vKnots: [number];\r\n  }\r\n\r\n  /**\r\n   * Interface for a collection of curves, eg. as used as a swept contour.\r\n   * @public\r\n   */\r\n  export interface CurveCollectionProps extends PlanarRegionProps {\r\n    /** A sequence of curves joined head to tail: */\r\n    path?: [CurvePrimitiveProps];\r\n    /** A collection of curves with no required structure or connections: */\r\n    bagofCurves?: [CurveCollectionProps];\r\n  }\r\n\r\n  /**\r\n   * Interface for a collection of curves that bound a planar region\r\n   * @public\r\n   */\r\n  export interface PlanarRegionProps {\r\n    /** `{loop:...}`\r\n     * * A sequence of curves which connect head to tail, with the final connecting back to the first\r\n     */\r\n    loop?: [CurvePrimitiveProps];\r\n    /** `{parityRegion:...}`\r\n     * * A collection of loops, with composite inside/outside determined by parity rules.\r\n     * * (The single outer boundary with one or more holes is a parityRegion)\r\n     */\r\n    parityRegion?: [{ loop: [CurvePrimitiveProps] }];\r\n    /** `{unionRegion:...}`\r\n     * * A collection of loops and parityRegions\r\n     */\r\n\r\n    unionRegion?: [PlanarRegionProps];\r\n  }\r\n  /**\r\n   * Interface for solid primitives: box, sphere, cylinder, cone, torusPipe, linear sweep, rotational sweep, ruled sweep.\r\n   * @public\r\n   */\r\n  export interface SolidPrimitiveProps {\r\n    /** `{cylinder:...}` */\r\n    cylinder?: CylinderProps;\r\n    /** `{box:...}` */\r\n    box?: BoxProps;\r\n    /** `{sphere:............}` */\r\n    sphere?: SphereProps;\r\n    /** `{cone:............}` */\r\n    cone?: ConeProps;\r\n    /** `{torusPipe:............}` */\r\n    torusPipe?: TorusPipeProps;\r\n    /** `{linearSweep:.........}` */\r\n    linearSweep?: LinearSweepProps;\r\n    /** `{rotationalSweep:...}` */\r\n    rotationalSweep?: RotationalSweepProps;\r\n    /** `{ruledSweep:...}` */\r\n    ruledSweep?: RuledSweepProps;\r\n  }\r\n  /**\r\n   * * There are multiple ways to specify an orientation\r\n   * * A \"Best\" among these is application specific.\r\n   * * An object with AxesProps should only specify one of the variants.\r\n   * * YawPitchRollAngles uses 3 angles.\r\n   * * * Cases where only one of the 3 is nonzero are intuitive\r\n   * * * Cases where more than one is nonzero have difficult interactions and order issues.\r\n   * * xyVectors uses a vector along the x direction and a vector into positive xy plane\r\n   *    along any direction not parallel to x.\r\n   * * * In most cases, users supply a normalized x and the actual normalized y vector.\r\n   * * zxVectors uses a z vector and another vector into the positive zx plane.\r\n   * * * In most cases, users supply a normalized z and the actual normalized x vector.\r\n   * @public\r\n   */\r\n  export interface AxesProps {\r\n    /**\r\n     * See YawPitchAngles class for further information about using 3 rotations to specify orientation.\r\n     * @public\r\n     */\r\n    yawPitchRollAngles?: YawPitchRollProps;\r\n    /**\r\n     * Cartesian coordinate directions defined by X direction then Y direction.\r\n     * * The right side contains two vectors in an array.\r\n     * * The first vector gives the x axis direction\r\n     * * * This is normalized to unit length.\r\n     * * The second vector gives the positive y direction inthe xy plane.\r\n     * * * This vector is adjusted to be unit length and perpendicular to the x direction.\r\n     */\r\n    xyVectors?: [XYZProps, XYZProps];\r\n    /**\r\n     * Cartesian coordinate directions defined by X direction then Y direction.\r\n     * * The right side contains two vectors in an array.\r\n     * * The first vector gives the z axis direction\r\n     * * * This is normalized to unit length.\r\n     * * The second vector gives the positive x direction inthe zx plane.\r\n     * * * This vector is adjusted to be unit length and perpendicular to the z direction.\r\n     */\r\n    zxVectors?: [XYZProps, XYZProps];\r\n  }\r\n\r\n  /**\r\n   * Interface for Arc3d value defined by center, vectorX, vectorY and sweepStartEnd.\r\n   * @public\r\n   */\r\n  export interface ArcByVectorProps {\r\n    /** Arc center point */\r\n    center: XYZProps;\r\n    /** Vector from center to 0-degree point (commonly callled major axis vector) */\r\n    vectorX: XYZProps;\r\n    /** Vector from center to 90-degree point (common called minor axis vector) */\r\n    vectorY: XYZProps;\r\n    /** Start and end angles in parameterization `X=C+cos(theta) * vectorX + sin(theta) * vectorY` */\r\n    sweepStartEnd: AngleSweepProps;\r\n  }\r\n\r\n  /**\r\n   * Interface for Cone value defined by centers, radii, and (optional) vectors for circular section planes.\r\n   * * VectorX and vectorY are optional.\r\n   * * If either one is missing, both vectors are constructed perpendicular to the vector from start to end.\r\n   * @public\r\n   */\r\n  export interface ConeProps extends AxesProps {\r\n    /** Point on axis at start section. */\r\n    start: XYZProps;\r\n    /** Point on axis at end section  */\r\n    end: XYZProps;\r\n\r\n    /** radius at `start` section */\r\n    startRadius: number;\r\n    /** radius at `end` section */\r\n    endRadius?: number;\r\n    /** optional x vector in start section.  Omit for circular sections perpendicular to axis. */\r\n    vectorX?: XYZProps;\r\n    /** optional y vector in start section.  Omit for circular sections perpendicular to axis. */\r\n    vectorY?: XYZProps;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for cylinder defined by a radius and axis start and end centers.\r\n   * @public\r\n   */\r\n  export interface CylinderProps {\r\n    /** axis point at start */\r\n    start: XYZProps;\r\n    /** axis point at end */\r\n    end: XYZProps;\r\n    /** cylinder radius */\r\n    radius: number;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a linear sweep of a base curve or region.\r\n   * @public\r\n   */\r\n  export interface LinearSweepProps {\r\n    /** The swept curve or region.  Any curve collection */\r\n    contour: CurveCollectionProps;\r\n    /** The sweep vector  */\r\n    vector: XYZProps;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a rotational sweep of a base curve or region around an axis.\r\n   * @public\r\n   */\r\n  export interface RotationalSweepProps {\r\n    /** The swept curve or region.  Any curve collection */\r\n    contour: CurveCollectionProps;\r\n    /** any point on the axis of rotation. */\r\n    center: XYZProps;\r\n    /** The axis of rotation  */\r\n    axis: XYZProps;\r\n    /** sweep angle */\r\n    sweepAngle: AngleProps;\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a surface with ruled sweeps between corresponding curves on successvie contours\r\n   * @public\r\n   */\r\n  export interface RuledSweepProps {\r\n    /** The swept curve or region.  An array of curve collections.  */\r\n    contour: [CurveCollectionProps];\r\n    /** flag for circular end caps. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for spiral\r\n   * * Any 4 (but not 5) of the 5 values `[startBearing, endBearing, startRadius, endRadius, length]`\r\n   *       may be defined.\r\n   * * In radius data, zero radius indicates straight line (infinite radius)\r\n   * * Note that the inherited AxesProps allows multiple ways to specify orientation of the placement..\r\n   * @public\r\n   */\r\n  export interface TransitionSpiralProps extends AxesProps {\r\n\r\n    /** origin of the coordinate system. */\r\n    origin: XYZProps;\r\n    /** angle at departure from origin. */\r\n    startBearing?: AngleProps;\r\n    /** End bearing. */\r\n    endBearing?: AngleProps;\r\n    /** Radius at start  (0 for straight line) */\r\n    startRadius?: number;\r\n    /** Radius at end  (0 for straight line) */\r\n    endRadius?: number;\r\n    /** length along curve */\r\n    curveLength?: number;\r\n    /** Fractional part of active interval. */\r\n    fractionInterval?: number[];\r\n    /** TransitionSpiral type.   Default is `\"clothoid\"` */\r\n    type?: string; //   one of:   \"clothoid\" | \"biquadratic\" | \"bloss\" | \"cosine\" | \"sine\";\r\n    /** A fractional portion of the spiral may be selected.\r\n     * * If this is missing, fraction range is `[0,1]`\r\n     */\r\n    intervalFractions?: [number, number];\r\n  }\r\n\r\n  /**\r\n   * Interface for bspline curve (aka bcurve)\r\n   * @public\r\n   */\r\n  export interface BcurveProps {\r\n    /** control points */\r\n    points: [XYZProps];\r\n    /** knots. */\r\n    knots: [number];\r\n    /** order of polynomial\r\n     * * The order is the number of basis functions that are in effect at any knot value.\r\n     * * The order is the number of points that affect the curve at any knot value,\r\n     *     i.e. the size of the \"local support\" set\r\n     * * `order=2` is lines (degree 1)\r\n     * * `order=3` is quadratic (degree 2)\r\n     * * `order=4` is cubic (degree 3)\r\n     * * The number of knots follows the convention \"poles+order= knots\".\r\n     * * In this convention (for example), a clamped cubic with knots `[0,0,0,0, 1,2,3,4,4,4,4]`\r\n     * has:\r\n     * * * 4 (`order`) copies of the start and end knot (0 and 4) and\r\n     * * * 3 interior knots\r\n     * * Hence expect 7 poles.\r\n     */\r\n    order: number;\r\n    /** optional flag for periodic data. */\r\n    closed?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for Box (or frustum with all rectangular sections parallel to primary xy section)\r\n   * * Orientation may be given in any `AxesProp`s way (yawPitchRoll, xyVectors, zxVectors)\r\n   * * if topX or topY are omitted, each defaults to its baseX or baseY peer.\r\n   * * `topOrigin` is determined with this priority order:\r\n   * * * `topOrigin` overrides given `height`\r\n   * * * on the z axis at distance `height`\r\n   * * * If both `topOrigin` and `height` are omitted, `height` defaults to `baseX`\r\n   * @public\r\n   */\r\n  export interface BoxProps extends AxesProps {\r\n    /** Origin of the box coordinate system  (required) */\r\n    origin: XYZProps;\r\n    /** base x size (required) */\r\n    baseX: number;\r\n    /** base size\r\n     * * if omitted, defaults to baseX.\r\n     */\r\n    baseY: number;\r\n    /** top origin.\r\n     * * This is NOT required to be on the z axis.\r\n     * * If omitted, a `heigh` must be present to given topOrigin on z axis.\r\n     */\r\n    topOrigin?: XYZProps;\r\n    /** optional height.  This is only used if `topOrigin` is omitted. */\r\n    height?: number;\r\n    /** x size on top section.\r\n     * * If omitted, `baseX` is used\r\n     */\r\n    topX?: number;\r\n    /** y size on top section.\r\n     * * If omitted, `baseY` is used\r\n     */\r\n    topY?: number;\r\n    /** optional capping flag. */\r\n    capped?: boolean;\r\n\r\n  }\r\n\r\n  /**\r\n   * Interface for Sphere (with optionally different radius to pole versus equator)\r\n   * * Orientation may be given in any `AxesProp`s way (yawPitchRoll, xyVectors, zxVectors)\r\n   * @public\r\n   */\r\n  export interface SphereProps extends AxesProps {\r\n    /** Center of the sphere coordinate system */\r\n    center: XYZProps;\r\n\r\n    /** primary radius */\r\n    radius?: number;\r\n    /** optional x radius */\r\n    radiusX?: number;\r\n    /** optional y radius */\r\n    radiusY?: number;\r\n\r\n    /** optonal radius at poles.  */\r\n    radiusZ?: number;\r\n\r\n    /** optional sweep range for latitude.  Default latitude limits are [-90,90 ] degrees. */\r\n    latitudeStartEnd?: AngleSweepProps;\r\n    /** optional capping flag. If missing, implied false */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for TorusPipe data\r\n   * * Orientation may be given in any `AxesProp`s way (yawPitchRoll, xyVectors, zxVectors)\r\n   * * Both radii are required.\r\n   * * axes are required\r\n   * * Axis definintion is\r\n   * * xy plane contains the major circle\r\n   * * x axis points from donut hole center to flow center at start of pipe.\r\n   * * z axis points through the hole.\r\n   * @public\r\n   */\r\n  export interface TorusPipeProps extends AxesProps {\r\n    /** Center of the full torus coordinate system. (donut hole center) */\r\n    center: XYZProps;\r\n\r\n    /** primary radius  (elbow radius) */\r\n    majorRadius: number;\r\n    /** pipe radius */\r\n    minorRadius?: number;\r\n    /** sweep angle.\r\n     * * if omitted, full 360 degree sweep.\r\n     */\r\n    sweepAngle?: AngleProps;\r\n    /** optional capping flag. If missing, implied false */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for a ruled sweep.\r\n   * @public\r\n   */\r\n  export interface RuledSweepProps {\r\n    /** Array of contours */\r\n    countour: [CurveCollectionProps];\r\n    /** optional capping flag. */\r\n    capped?: boolean;\r\n  }\r\n\r\n  /**\r\n   * Interface for an indexed mesh.\r\n   * * IMPORTANT: All indices are one-based.\r\n   * * i.e. vertex index given as 11 appears at index 10 in the data array.\r\n   * * This is to allow a negated index to mean \"don't draw the followinge edge\"\r\n   * * Although negative indices are not allowed for normalIndex, colorIndex, or paramIndex, the \"one based\" style\r\n   *     is used for them so that all indices within the indexedMesh json object are handled similarly.\r\n   * * In all index arrays, a ZERO indicates \"end of facet\".\r\n   * @public\r\n   */\r\n  export interface IndexedMeshProps {\r\n    /** vertex coordinates */\r\n    point: [XYZProps];\r\n    /** surface normals */\r\n    normal?: [XYZProps];\r\n    /** texture space (uv parameter) coordinates */\r\n    param?: [XYProps];\r\n    /** 32 bit color values */\r\n    color?: [number];\r\n\r\n    /** SIGNED ONE BASED ZERO TERMINATED array of point indices. */\r\n    pointIndex: [number];\r\n    /** ONE BASED ZERO TERMINATED array of param indices.  ZERO is terminator for single facet. */\r\n    paramIndex?: [number];\r\n    /** ONE BASED ZERO TERMINATED array of normal indices. ZERO is terminator for single facet. */\r\n    normalIndex?: [number];\r\n    /** ONE BASED ZERO TERMINATED array of color indices. ZERO is terminator for single facet. */\r\n    colorIndex?: [number];\r\n  }\r\n  /** parser servoces for \"iModelJson\" schema\r\n   * * 1: create a reader with `new ImodelJsonReader`\r\n   * * 2: parse json fragment to strongly typed geometry: `const g = reader.parse (fragment)`\r\n   * @public\r\n   */\r\n  export class Reader {\r\n\r\n    public constructor() { // empty ctor\r\n    }\r\n\r\n    private static parseVector3dProperty(json: any, propertyName: string, defaultValue?: Vector3d | undefined): Vector3d | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Geometry.isNumberArray(value, 3))\r\n          return Vector3d.create(value[0], value[1], value[2]);\r\n        if (XYZ.isXAndY(value))\r\n          return Vector3d.fromJSON(value);\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parsePoint3dProperty(json: any, propertyName: string, defaultValue?: Point3d | undefined): Point3d | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Geometry.isNumberArray(value, 3))\r\n          return Point3d.create(value[0], value[1], value[2]);\r\n        if (XYZ.isXAndY(value))\r\n          return Point3d.fromJSON(value);\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parseSegment1dProperty(json: any, propertyName: string, defaultValue?: Segment1d | undefined): Segment1d | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Geometry.isNumberArray(value, 2))\r\n          return Segment1d.create(value[0], value[1]);\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parseNumberProperty(json: any, propertyName: string, defaultValue?: number | undefined): number | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Number.isFinite(value))\r\n          return value as number;\r\n      }\r\n      return defaultValue;\r\n    }\r\n    /* ==============\r\n        private static parseNumberArrayProperty(json: any, propertyName: string, minValues: number, maxValues: number, defaultValue?: number[] | undefined): number[] | undefined {\r\n          if (json.hasOwnProperty(propertyName)) {\r\n            const value = json[propertyName];\r\n            if (Array.isArray(value)\r\n              && value.length >= minValues && value.length <= maxValues) {\r\n              const result = [];\r\n              for (const a of value) {\r\n                result.push(a);\r\n              }\r\n              return result;\r\n            }\r\n          }\r\n          return defaultValue;\r\n        }\r\n    */\r\n    private static parseAngleProperty(json: any, propertyName: string, defaultValue?: Angle | undefined): Angle | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        return Angle.fromJSON(value);\r\n      }\r\n      return defaultValue;\r\n    }\r\n    /**\r\n     * @param defaultFunction function to call if needed to produce a default value\r\n     */\r\n    private static parseAngleSweepProps(json: any, propertyName: string, defaultFunction?: () => AngleSweep): AngleSweep | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        return AngleSweep.fromJSON(value);\r\n      }\r\n      if (defaultFunction === undefined)\r\n        return undefined;\r\n      return defaultFunction();\r\n    }\r\n\r\n    private static parseBooleanProperty(json: any, propertyName: string, defaultValue?: boolean | undefined): boolean | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (value === true) return true;\r\n        if (value === false) return false;\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static loadContourArray(json: any, propertyName: string): CurveCollection[] | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (Array.isArray(value)) {\r\n          const result = [];\r\n          for (const contourData of value) {\r\n            const contour = Reader.parse(contourData);\r\n            if (contour instanceof CurveCollection) {\r\n              result.push(contour);\r\n            }\r\n          }\r\n          if (result.length > 0)\r\n            return result;\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    private static parseYawPitchRollAnglesToMatrix3d(json: YawPitchRollProps): Matrix3d | undefined {\r\n      const ypr = YawPitchRollAngles.fromJSON(json);\r\n      return ypr.toMatrix3d();\r\n    }\r\n\r\n    private static parseStringProperty(json: any, propertyName: string, defaultValue?: string | undefined): string | undefined {\r\n      if (json.hasOwnProperty(propertyName)) {\r\n        const value = json[propertyName];\r\n        if (value.type === \"string\")\r\n          return value;\r\n      }\r\n      return defaultValue;\r\n    }\r\n\r\n    private static parseAxesFromVectors(json: any, axisOrder: AxisOrder, createDefaultIdentity: boolean): Matrix3d | undefined {\r\n      if (Array.isArray(json) && json.length === 2) {\r\n        const xVector = Vector3d.fromJSON(json[0]);\r\n        const yVector = Vector3d.fromJSON(json[1]);\r\n        const matrix = Matrix3d.createRigidFromColumns(xVector, yVector, axisOrder);\r\n        if (matrix) return matrix;\r\n      }\r\n      if (createDefaultIdentity)\r\n        return Matrix3d.createIdentity();\r\n      return undefined;\r\n    }\r\n    /**\r\n     * Look for orientation data and convert to Matrix3d.\r\n     * * Search order is:\r\n     * * * yawPitchRollAngles\r\n     * * * xyVectors\r\n     * * * zxVectors\r\n     * @param json [in] json source data\r\n     * @param createDefaultIdentity [in] If true and no orientation is present, return an identity matrix.  If false and no orientation is present, return undefined.\r\n     */\r\n    private static parseOrientation(json: any, createDefaultIdentity: boolean): Matrix3d | undefined {\r\n      if (json.yawPitchRollAngles) {\r\n        return Reader.parseYawPitchRollAnglesToMatrix3d(json.yawPitchRollAngles);\r\n      } else if (json.xyVectors) {\r\n        return Reader.parseAxesFromVectors(json.xyVectors, AxisOrder.XYZ, createDefaultIdentity);\r\n      } else if (json.zxVectors) {\r\n        return Reader.parseAxesFromVectors(json.zxVectors, AxisOrder.ZXY, createDefaultIdentity);\r\n      }\r\n      if (createDefaultIdentity)\r\n        return Matrix3d.createIdentity();\r\n      return undefined;\r\n    }\r\n\r\n    private static parseArcByVectorProps(data?: ArcByVectorProps): Arc3d | undefined {\r\n      if (data\r\n        && data.center !== undefined\r\n        && data.vectorX !== undefined\r\n        && data.vectorY !== undefined\r\n        && data.sweepStartEnd !== undefined\r\n      ) {\r\n        return Arc3d.create(\r\n          Point3d.fromJSON(data.center),\r\n          Vector3d.fromJSON(data.vectorX),\r\n          Vector3d.fromJSON(data.vectorY),\r\n          AngleSweep.fromJSON(data.sweepStartEnd));\r\n      }\r\n      return undefined;\r\n    }\r\n    // remark: Returns LineString3d as last default when give points are colinear.\r\n    private static parseArcBy3Points(data?: ArcByVectorProps): Arc3d | LineString3d | undefined {\r\n      if (Array.isArray(data) && data.length > 2) {\r\n        const pointA = Point3d.fromJSON(data[0]);\r\n        const pointB = Point3d.fromJSON(data[1]);\r\n        const pointC = Point3d.fromJSON(data[2]);\r\n        return Arc3d.createCircularStartMiddleEnd(pointA, pointB, pointC);\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    private static parseArcObject(data?: ArcByVectorProps): Arc3d | LineString3d | undefined {\r\n      let arc: Arc3d | LineString3d | undefined = Reader.parseArcByVectorProps(data);\r\n      if (arc)\r\n        return arc;\r\n      arc = Reader.parseArcBy3Points(data);\r\n      return arc; // possibly undefined.\r\n    }\r\n    /** Parse point content (right side) `[1,2,3]` to a CoordinateXYZ object. */\r\n    public static parseCoordinate(data?: any): CoordinateXYZ | undefined {\r\n      const point = Point3d.fromJSON(data);\r\n      if (point)\r\n        return CoordinateXYZ.create(point);\r\n      return undefined;\r\n    }\r\n    /** Parse TransitionSpiral content (right side) to TransitionSpiral3d\r\n     * @alpha\r\n     */\r\n    public static parseTransitionSpiral(data?: TransitionSpiralProps): TransitionSpiral3d | undefined {\r\n      const axes = Reader.parseOrientation(data, true)!;\r\n      const origin = Reader.parsePoint3dProperty(data, \"origin\");\r\n      // the create method will juggle any 4 out of these 5 inputs to define the other ..\r\n      const startBearing = Reader.parseAngleProperty(data, \"startBearing\");\r\n      const endBearing = Reader.parseAngleProperty(data, \"endBearing\");\r\n      const startRadius = Reader.parseNumberProperty(data, \"startRadius\");\r\n      const endRadius = Reader.parseNumberProperty(data, \"endRadius\");\r\n      const length = Reader.parseNumberProperty(data, \"curveLength\", undefined);\r\n\r\n      const interval = Reader.parseSegment1dProperty(data, \"fractionInterval\", undefined);\r\n\r\n      const spiralType = Reader.parseStringProperty(data, \"spiralType\", \"clothoid\");\r\n      if (origin)\r\n        return TransitionSpiral3d.create(\r\n          spiralType,\r\n          startRadius, endRadius,\r\n          startBearing, endBearing,\r\n          length,\r\n          interval,\r\n          Transform.createOriginAndMatrix(origin, axes));\r\n      return undefined;\r\n    }\r\n    /**\r\n     * Special closed case if the input was forced to bezier . . . (e.g. arc)\r\n     *       (b-1) 0 0 0  a . . . b 111 (a+1)\r\n     *       with {order} clamp-like values .. no pole duplication needed, but throw out 2 knots at each end . ..\r\n     * @param numPoles number of poles\r\n     * @param knots knot vector\r\n     * @param order curve order\r\n     * @param newKnots array to receive new knots.\r\n     * @returns true if this is a closed-but-clamped case and corrected knots are filled in.\r\n     */\r\n    private static getCorrectedKnotsForClosedClamped(numPoles: number, knots: number[], order: number, newKnots: number[]): boolean {\r\n      const numKnots = knots.length;\r\n      if (numPoles + 2 * order - 1 === numKnots\r\n        && knots[0] < knots[1]\r\n        && knots[numKnots - 2] < knots[numKnots - 1]) {\r\n        const a0 = knots[1];\r\n        const a1 = knots[numKnots - 2];\r\n        for (let i = 2; i <= order; i++) {\r\n          if (knots[i] !== a0)\r\n            return false;\r\n          if (knots[numKnots - 1 - i] !== a1)\r\n            return false;\r\n        }\r\n        // copy only the \"minimal\" set - without the typical extra knots from microstation and psd.\r\n        for (let i = 2; i + 2 < numKnots; i++)\r\n          newKnots.push(knots[i]);\r\n        return true;\r\n      }\r\n      return false;\r\n    }\r\n    /** Parse `bcurve` content (right side)to  BSplineCurve3d or BSplineCurve3dH object. */\r\n    public static parseBcurve(data?: any): BSplineCurve3d | BSplineCurve3dH | undefined {\r\n      if (data === undefined)\r\n        return undefined;\r\n      if (Array.isArray(data.points) && Array.isArray(data.knots) && Number.isFinite(data.order) && data.closed !== undefined) {\r\n        if (data.points[0].length === 4) {\r\n          const hPoles: Point4d[] = [];\r\n          for (const p of data.points) hPoles.push(Point4d.fromJSON(p));\r\n          const knots: number[] = [];\r\n          let wrapMode = BSplineWrapMode.None;\r\n          if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {\r\n            // leave the poles alone -- knots are fixed.\r\n            wrapMode = BSplineWrapMode.OpenByRemovingKnots;\r\n          } else if (data.closed) {\r\n            for (const knot of data.knots) knots.push(knot);\r\n            for (let i = 0; i + 1 < data.order; i++) {\r\n              hPoles.push(hPoles[i].clone());\r\n            }\r\n            wrapMode = BSplineWrapMode.OpenByAddingControlPoints;\r\n          } else {\r\n            // simple case .. just copy\r\n            for (const knot of data.knots) knots.push(knot);\r\n          }\r\n          const newCurve = BSplineCurve3dH.create(hPoles, knots, data.order);\r\n          if (newCurve) {\r\n            if (data.closed === true)\r\n              newCurve.setWrappable(wrapMode);\r\n            return newCurve;\r\n          }\r\n        } else if (data.points[0].length === 3 || data.points[0].length === 2) {\r\n\r\n          const poles: Point3d[] = [];\r\n          for (const p of data.points) poles.push(Point3d.fromJSON(p));\r\n          const knots: number[] = [];\r\n          let wrapMode = BSplineWrapMode.None;\r\n          if (data.closed && this.getCorrectedKnotsForClosedClamped(data.points.length, data.knots, data.order, knots)) {\r\n            wrapMode = BSplineWrapMode.OpenByRemovingKnots;\r\n            // leave the poles alone -- knots are fixed.\r\n          } else if (data.closed) {\r\n            for (const knot of data.knots) knots.push(knot);\r\n            for (let i = 0; i + 1 < data.order; i++) {\r\n              poles.push(poles[i].clone());\r\n            }\r\n            wrapMode = BSplineWrapMode.OpenByAddingControlPoints;\r\n          } else {\r\n            // simple case .. just copy\r\n            for (const knot of data.knots) knots.push(knot);\r\n          }\r\n          const newCurve = BSplineCurve3d.create(poles, knots, data.order);\r\n          if (newCurve) {\r\n            if (data.closed === true)\r\n              newCurve.setWrappable(wrapMode);\r\n            return newCurve;\r\n          }\r\n        }\r\n\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Parse array of json objects to array of instances. */\r\n    public static parseArray(data?: any): any[] | undefined {\r\n      if (Array.isArray(data)) {\r\n        const myArray = [];\r\n        let c;\r\n        for (c of data) {\r\n          const g = Reader.parse(c);\r\n          if (g !== undefined)\r\n            myArray.push(g);\r\n        }\r\n        return myArray;\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    // For each nonzero index, Announce Math.abs (value) -1\r\n    private static addZeroBasedIndicesFromSignedOneBased(data: any, f: (x: number) => any): void {\r\n      if (data && Geometry.isNumberArray(data)) {\r\n        for (const value of data) {\r\n          if (value !== 0)\r\n            f(Math.abs(value) - 1);\r\n        }\r\n      }\r\n    }\r\n    /** parse polyface aux data content to PolyfaceAuxData instance */\r\n    public static parsePolyfaceAuxData(data?: any): PolyfaceAuxData | undefined {\r\n\r\n      if (!Array.isArray(data.channels) || !Array.isArray(data.indices))\r\n        return undefined;\r\n\r\n      const outChannels: AuxChannel[] = [];\r\n      for (const inChannel of data.channels) {\r\n        if (Array.isArray(inChannel.data) && inChannel.hasOwnProperty(\"dataType\")) {\r\n          const outChannelData: AuxChannelData[] = [];\r\n          for (const inChannelData of inChannel.data) {\r\n            if (inChannelData.hasOwnProperty(\"input\") && Array.isArray(inChannelData.values))\r\n              outChannelData.push(new AuxChannelData(inChannelData.input, inChannelData.values));\r\n          }\r\n          outChannels.push(new AuxChannel(outChannelData, inChannel.dataType as AuxChannelDataType, inChannel.name, inChannel.inputName));\r\n        }\r\n      }\r\n\r\n      const auxData = new PolyfaceAuxData(outChannels, []);\r\n      Reader.addZeroBasedIndicesFromSignedOneBased(data.indices, (x: number) => { auxData.indices.push(x); });\r\n\r\n      return auxData;\r\n    }\r\n\r\n    /** parse indexed mesh content to an IndexedPolyface instance */\r\n    public static parseIndexedMesh(data?: any): any | undefined {\r\n      // {Coord:[[x,y,z],. . . ],   -- simple xyz for each ponit\r\n      // CoordIndex[1,2,3,0]    -- zero-terminated, one based !!!\r\n      if (data.hasOwnProperty(\"point\") && Array.isArray(data.point)\r\n        && data.hasOwnProperty(\"pointIndex\") && Array.isArray(data.pointIndex)) {\r\n        const polyface = IndexedPolyface.create();\r\n        if (data.hasOwnProperty(\"normal\") && Array.isArray(data.normal)) {\r\n          for (const uvw of data.normal) {\r\n            if (Geometry.isNumberArray(uvw, 3))\r\n              polyface.addNormal(Vector3d.create(uvw[0], uvw[1], uvw[2]));\r\n          }\r\n        }\r\n        if (data.hasOwnProperty(\"param\") && Array.isArray(data.param)) {\r\n          for (const uv of data.param) {\r\n            if (Geometry.isNumberArray(uv, 2))\r\n              polyface.addParam(Point2d.create(uv[0], uv[1]));\r\n          }\r\n        }\r\n        if (data.hasOwnProperty(\"color\") && Array.isArray(data.color)) {\r\n          for (const c of data.color) {\r\n            polyface.addColor(c);\r\n          }\r\n        }\r\n\r\n        for (const p of data.point) polyface.addPoint(Point3d.fromJSON(p));\r\n\r\n        for (const p of data.pointIndex) {\r\n          if (p === 0)\r\n            polyface.terminateFacet(false); // we are responsible for index checking !!!\r\n          else {\r\n            const p0 = Math.abs(p) - 1;\r\n            polyface.addPointIndex(p0, p > 0);\r\n          }\r\n        }\r\n\r\n        if (data.hasOwnProperty(\"normalIndex\")) {\r\n          Reader.addZeroBasedIndicesFromSignedOneBased(data.normalIndex,\r\n            (x: number) => { polyface.addNormalIndex(x); });\r\n        }\r\n        if (data.hasOwnProperty(\"paramIndex\")) {\r\n          Reader.addZeroBasedIndicesFromSignedOneBased(data.paramIndex,\r\n            (x: number) => { polyface.addParamIndex(x); });\r\n        }\r\n\r\n        if (data.hasOwnProperty(\"colorIndex\")) {\r\n          Reader.addZeroBasedIndicesFromSignedOneBased(data.colorIndex,\r\n            (x: number) => { polyface.addColorIndex(x); });\r\n        }\r\n        if (data.hasOwnProperty(\"auxData\"))\r\n          polyface.data.auxData = Reader.parsePolyfaceAuxData(data.auxData);\r\n\r\n        return polyface;\r\n      }\r\n      return undefined;\r\n    }\r\n    /** parse contents of a curve collection to a CurveCollection instance */\r\n    public static parseCurveCollectionMembers(result: CurveCollection, data?: any): CurveCollection | undefined {\r\n      if (data && Array.isArray(data)) {\r\n        for (const c of data) {\r\n          const g = Reader.parse(c);\r\n          if (g !== undefined)\r\n            result.tryAddChild(g);\r\n        }\r\n        return result;\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse content of `bsurf` to BSplineSurface3d or BSplineSurface3dH */\r\n    public static parseBsurf(data?: any): BSplineSurface3d | BSplineSurface3dH | undefined {\r\n      if (data.hasOwnProperty(\"uKnots\") && Array.isArray(data.uKnots)\r\n        && data.hasOwnProperty(\"vKnots\") && Array.isArray(data.vKnots)\r\n        && data.hasOwnProperty(\"orderU\") && Number.isFinite(data.orderU)\r\n        && data.hasOwnProperty(\"orderV\") && Number.isFinite(data.orderV)\r\n        && data.hasOwnProperty(\"points\") && Array.isArray(data.points)\r\n      ) {\r\n        const orderU = data.orderU;\r\n        const orderV = data.orderV;\r\n        if (Array.isArray(data.points[0]) && Array.isArray(data.points[0][0])) {\r\n          const d = data.points[0][0].length;\r\n          /** xyz surface (no weights) */\r\n          if (d === 3) {\r\n            return BSplineSurface3d.createGrid(data.points,\r\n              orderU, data.uKnots,\r\n              orderV, data.vKnots);\r\n          }\r\n          /** xyzw surface (weights already applied) */\r\n          if (d === 4) {\r\n            return BSplineSurface3dH.createGrid(data.points,\r\n              WeightStyle.WeightsAlreadyAppliedToCoordinates,\r\n              orderU, data.uKnots,\r\n              orderV, data.vKnots);\r\n          }\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse `cone` contents to `Cone` instance  */\r\n    public static parseConeProps(json?: ConeProps): any {\r\n      const axes = Reader.parseOrientation(json, false);\r\n      const start = Reader.parsePoint3dProperty(json, \"start\");\r\n      const end = Reader.parsePoint3dProperty(json, \"end\");\r\n\r\n      const startRadius = Reader.parseNumberProperty(json, \"startRadius\");\r\n      const endRadius = Reader.parseNumberProperty(json, \"endRadius\", startRadius);\r\n\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false) as boolean;\r\n\r\n      if (start\r\n        && end\r\n        && startRadius !== undefined\r\n        && endRadius !== undefined) {\r\n        if (axes === undefined) {\r\n          const axisVector = Vector3d.createStartEnd(start, end);\r\n          const frame = Matrix3d.createRigidHeadsUp(axisVector, AxisOrder.ZXY);\r\n          const vectorX = frame.columnX();\r\n          const vectorY = frame.columnY();\r\n          return Cone.createBaseAndTarget(start, end, vectorX, vectorY, startRadius, endRadius, capped);\r\n        } else {\r\n          return Cone.createBaseAndTarget(start, end, axes.columnX(), axes.columnY(), startRadius, endRadius, capped);\r\n        }\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Parse `cylinder` content to `Cone` instance */\r\n    public static parseCylinderProps(json?: CylinderProps): any {\r\n      const start = Reader.parsePoint3dProperty(json, \"start\");\r\n      const end = Reader.parsePoint3dProperty(json, \"end\");\r\n      const radius = Reader.parseNumberProperty(json, \"radius\");\r\n\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false) as boolean;\r\n\r\n      if (start\r\n        && end\r\n        && radius !== undefined) {\r\n        return Cone.createAxisPoints(start, end, radius, radius, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse line segment (array of 2 points) properties to `LineSegment3d` instance */\r\n    private static parseLineSegmentProps(value: any[]): any {\r\n      if (Array.isArray(value) && value.length > 1)\r\n        return LineSegment3d.create(Point3d.fromJSON(value[0]), Point3d.fromJSON(value[1]));\r\n    }\r\n    /** Parse linear sweep content to `LinearSweep` instance. */\r\n    public static parseLinearSweep(json?: any): any {\r\n      const contour = Reader.parse(json.contour);\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\");\r\n      const extrusionVector = Reader.parseVector3dProperty(json, \"vector\");\r\n      if (contour\r\n        && capped !== undefined\r\n        && extrusionVector\r\n      ) {\r\n        return LinearSweep.create(contour, extrusionVector, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse rotational sweep contents to `RotationalSweep` instance */\r\n    public static parseRotationalSweep(json?: RotationalSweepProps): RotationalSweep | undefined {\r\n      if (json === undefined)\r\n        return undefined;\r\n      const contour = Reader.parse(json.contour);\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\");\r\n      const axisVector = Reader.parseVector3dProperty(json, \"axis\");\r\n      const center = Reader.parsePoint3dProperty(json, \"center\");\r\n      const sweepDegrees = Reader.parseNumberProperty(json, \"sweepAngle\");\r\n      if (contour\r\n        && sweepDegrees !== undefined\r\n        && capped !== undefined\r\n        && axisVector\r\n        && center\r\n      ) {\r\n        return RotationalSweep.create(\r\n          contour,\r\n          Ray3d.createCapture(center, axisVector),\r\n          Angle.createDegrees(sweepDegrees),\r\n          capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse box contents to `Box` instance */\r\n    public static parseBox(json?: BoxProps): Box | undefined {\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false);\r\n      const baseOrigin = Reader.parsePoint3dProperty(json, \"baseOrigin\");\r\n      const baseX = Reader.parseNumberProperty(json, \"baseX\");\r\n      const baseY = Reader.parseNumberProperty(json, \"baseY\", baseX);\r\n      let topOrigin = Reader.parsePoint3dProperty(json, \"topOrigin\");\r\n      const topX = Reader.parseNumberProperty(json, \"topX\", baseX);\r\n      const topY = Reader.parseNumberProperty(json, \"topY\", baseY);\r\n      const height = Reader.parseNumberProperty(json, \"height\", baseX);\r\n      const axes = Reader.parseOrientation(json, true)!;\r\n\r\n      if (baseOrigin && !topOrigin)\r\n        topOrigin = Matrix3d.xyzMinusMatrixTimesXYZ(baseOrigin, axes, Vector3d.create(0, 0, height));\r\n\r\n      if (capped !== undefined\r\n        && baseX !== undefined\r\n        && baseY !== undefined\r\n        && topY !== undefined\r\n        && topX !== undefined\r\n        && axes\r\n        && baseOrigin\r\n        && topOrigin\r\n      ) {\r\n        return Box.createDgnBoxWithAxes(baseOrigin, axes, topOrigin, baseX, baseY, topX, topY, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse `SphereProps` to `Sphere` instance. */\r\n    public static parseSphere(json?: SphereProps): Sphere | undefined {\r\n      const center = Reader.parsePoint3dProperty(json, \"center\");\r\n      // optional unqualified radius . . .\r\n      const radius = Reader.parseNumberProperty(json, \"radius\");\r\n      // optional specific X\r\n      const radiusX = Reader.parseNumberProperty(json, \"radiusX\", radius);\r\n      // missing Y and Z both pick up radiusX  (which may have already been defaulted from unqualified radius)\r\n      const radiusY = Reader.parseNumberProperty(json, \"radiusX\", radiusX);\r\n      const radiusZ = Reader.parseNumberProperty(json, \"radiusX\", radiusX);\r\n      const latitudeStartEnd = Reader.parseAngleSweepProps(json, \"latitudeStartEnd\"); // this may be undfined!!\r\n\r\n      const axes = Reader.parseOrientation(json, true)!;\r\n\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false);\r\n\r\n      if (center !== undefined\r\n        && radiusX !== undefined\r\n        && radiusY !== undefined\r\n        && radiusZ !== undefined\r\n        && capped !== undefined) {\r\n        return Sphere.createFromAxesAndScales(center, axes, radiusX, radiusY, radiusZ, latitudeStartEnd, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse RuledSweepProps to RuledSweep instance. */\r\n    public static parseRuledSweep(json?: RuledSweepProps): RuledSweep | undefined {\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false);\r\n      const contours = this.loadContourArray(json, \"contour\");\r\n      if (contours !== undefined\r\n        && capped !== undefined) {\r\n        return RuledSweep.create(contours, capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse TorusPipe props to TorusPipe instance. */\r\n    public static parseTorusPipe(json?: TorusPipeProps): TorusPipe | undefined {\r\n\r\n      const axes = Reader.parseOrientation(json, true)!;\r\n      const center = Reader.parsePoint3dProperty(json, \"center\");\r\n      const radiusA = Reader.parseNumberProperty(json, \"majorRadius\");\r\n      const radiusB = Reader.parseNumberProperty(json, \"minorRadius\");\r\n      const sweepAngle = Reader.parseAngleProperty(json, \"sweepAngle\", undefined);\r\n      const capped = Reader.parseBooleanProperty(json, \"capped\", false)!;\r\n      if (center\r\n        && radiusA !== undefined\r\n        && radiusB !== undefined\r\n      ) {\r\n\r\n        return TorusPipe.createDgnTorusPipe(center, axes.columnX(), axes.columnY(),\r\n          radiusA, radiusB,\r\n          sweepAngle ? sweepAngle : Angle.createDegrees(360), capped);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** Parse an array object to array of Point3d instances. */\r\n    public static parsePointArray(json?: any[]): Point3d[] {\r\n      const points = [];\r\n      if (json && Array.isArray(json)) {\r\n        for (const member of json) {\r\n          if (XYZ.isXAndY(member)) {\r\n            points.push(Point3d.fromJSON(member));\r\n          } else if (Geometry.isNumberArray(member, 2)) {\r\n            points.push(Point3d.fromJSON(member));\r\n          }\r\n        }\r\n      }\r\n      return points;\r\n    }\r\n    /** Deserialize `json` to `GeometryQuery` instances. */\r\n    public static parse(json?: any): any {\r\n      if (json !== undefined && json as object) {\r\n        if (json.lineSegment !== undefined) {\r\n          return Reader.parseLineSegmentProps(json.lineSegment);\r\n        } else if (json.lineString !== undefined) {\r\n          return LineString3d.create(Reader.parsePointArray(json.lineString));\r\n        } else if (json.arc !== undefined) {\r\n          return Reader.parseArcObject(json.arc);\r\n        } else if (json.hasOwnProperty(\"point\")) {\r\n          return Reader.parseCoordinate(json.point);\r\n\r\n        } else if (json.hasOwnProperty(\"bcurve\")) {\r\n          return Reader.parseBcurve(json.bcurve);\r\n        } else if (json.hasOwnProperty(\"path\")) {\r\n          return Reader.parseCurveCollectionMembers(new Path(), json.path);\r\n        } else if (json.hasOwnProperty(\"loop\")) {\r\n          return Reader.parseCurveCollectionMembers(new Loop(), json.loop);\r\n        } else if (json.hasOwnProperty(\"parityRegion\")) {\r\n          return Reader.parseCurveCollectionMembers(new ParityRegion(), json.parityRegion);\r\n        } else if (json.hasOwnProperty(\"unionRegion\")) {\r\n          return Reader.parseCurveCollectionMembers(new UnionRegion(), json.unionRegion);\r\n        } else if (json.hasOwnProperty(\"bagOfCurves\")) {\r\n          return Reader.parseCurveCollectionMembers(new BagOfCurves(), json.bagOfCurves);\r\n        } else if (json.hasOwnProperty(\"indexedMesh\")) {\r\n          return Reader.parseIndexedMesh(json.indexedMesh);\r\n        } else if (json.hasOwnProperty(\"bsurf\")) {\r\n          return Reader.parseBsurf(json.bsurf);\r\n        } else if (json.hasOwnProperty(\"cone\")) {\r\n          return Reader.parseConeProps(json.cone);\r\n        } else if (json.hasOwnProperty(\"cylinder\")) {\r\n          return Reader.parseCylinderProps(json.cylinder);\r\n        } else if (json.hasOwnProperty(\"sphere\")) {\r\n          return Reader.parseSphere(json.sphere);\r\n        } else if (json.hasOwnProperty(\"linearSweep\")) {\r\n          return Reader.parseLinearSweep(json.linearSweep);\r\n        } else if (json.hasOwnProperty(\"box\")) {\r\n          return Reader.parseBox(json.box);\r\n        } else if (json.hasOwnProperty(\"rotationalSweep\")) {\r\n          return Reader.parseRotationalSweep(json.rotationalSweep);\r\n        } else if (json.hasOwnProperty(\"ruledSweep\")) {\r\n          return Reader.parseRuledSweep(json.ruledSweep);\r\n        } else if (json.hasOwnProperty(\"torusPipe\")) {\r\n          return Reader.parseTorusPipe(json.torusPipe);\r\n        } else if (json.hasOwnProperty(\"pointString\")) {\r\n          return PointString3d.create(Reader.parsePointArray(json.pointString));\r\n        } else if (json.hasOwnProperty(\"transitionSpiral\")) {\r\n          return Reader.parseTransitionSpiral(json.transitionSpiral);\r\n        } else if (Array.isArray(json))\r\n          return Reader.parseArray(json);\r\n      }\r\n      return undefined;\r\n    }\r\n  }\r\n  // ISSUE: include 3d in names?\r\n  // ISSUE: would like shorter term than lineSegment\r\n  // ISSUE: is arc clear?\r\n  // ISSUE: label center, vectorX, vector90 on arc?\r\n  // ISSUE: sweep data on arc -- serialize as AngleSweep?\r\n  /**\r\n   * Class to deserialize json objects into GeometryQuery objects\r\n   * @public\r\n   */\r\n  export class Writer extends GeometryHandler {\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLineSegment3d(data: LineSegment3d): any {\r\n      return { \"lineSegment\": [data.point0Ref.toJSON(), data.point1Ref.toJSON()] };\r\n    }\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleCoordinateXYZ(data: CoordinateXYZ): any {\r\n      return { \"point\": data.point.toJSON() };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleArc3d(data: Arc3d): any {\r\n      return {\r\n        \"arc\": {\r\n          \"center\": data.center.toJSON(),\r\n          \"vectorX\": data.vector0.toJSON(),\r\n          \"vectorY\": data.vector90.toJSON(),\r\n          \"sweepStartEnd\": [data.sweep.startDegrees, data.sweep.endDegrees],\r\n        },\r\n      };\r\n    }\r\n    /**\r\n     * Insert orientation description to a data object.\r\n     * @param matrix matrix with orientation\r\n     * @param omitIfIdentity omit the axis data if the matrix is an identity.\r\n     * @param data AxesProps object to be annotated.\r\n     */\r\n    private static insertOrientationFromMatrix(data: AxesProps, matrix: Matrix3d | undefined, omitIfIdentity: boolean) {\r\n      if (omitIfIdentity) {\r\n        if (matrix === undefined)\r\n          return;\r\n        if (matrix.isIdentity)\r\n          return;\r\n      }\r\n      if (matrix)\r\n        data.xyVectors = [matrix.columnX().toJSON(), matrix.columnY().toJSON()];\r\n      else\r\n        data.xyVectors = [[1, 0, 0], [0, 1, 0]];\r\n    }\r\n    private static isIdentityXY(xVector: Vector3d, yVector: Vector3d): boolean {\r\n      return xVector.isAlmostEqualXYZ(1, 0, 0) && yVector.isAlmostEqualXYZ(0, 1, 0);\r\n    }\r\n\r\n    /**\r\n     * Insert orientation description to a data object.\r\n     * @param matrix matrix with orientation\r\n     * @param omitIfIdentity omit the axis data if the matrix is an identity.\r\n     * @param data AxesProps object to be annotated.\r\n     */\r\n    private static insertOrientationFromXYVectors(data: AxesProps, vectorX: Vector3d, vectorY: Vector3d, omitIfIdentity: boolean) {\r\n      if (omitIfIdentity && Writer.isIdentityXY(vectorX, vectorY))\r\n        return;\r\n      data.xyVectors = [vectorX.toJSON(), vectorY.toJSON()];\r\n    }\r\n\r\n    /**\r\n     * Insert orientation description to a data object, with orientation defined by u and v direction\r\n     * vectors.\r\n     * @param vectorX u direction\r\n     * @param vectorV v direction\r\n     * @param omitIfIdentity omit the axis data if the vectorU and vectorV are global x and y vectors.\r\n     * @param data AxesProps object to be annotated.\r\n     */\r\n    private static insertXYOrientation(data: AxesProps, vectorU: Vector3d, vectorV: Vector3d, omitIfIdentity: boolean) {\r\n      if (omitIfIdentity) {\r\n        if (vectorU.isAlmostEqualXYZ(1, 0, 0) && vectorV.isAlmostEqualXYZ(0, 1, 0))\r\n          return;\r\n      }\r\n      data.xyVectors = [vectorU.toJSON(), vectorV.toJSON()];\r\n    }\r\n    /**\r\n     * parse properties of a TransitionSpiral.\r\n     * @alpha\r\n     */\r\n    public handleTransitionSpiral(data: TransitionSpiral3d): any {\r\n      // TODO: HANDLE NONRIGID TRANSFORM !!\r\n      // the spiral may have indication of how it was defined.  If so, use defined/undefined state of the orignial data\r\n      // as indication of what current data to use.  (Current data may have changed due to transforms.)\r\n      const originalProperties = data.originalProperties;\r\n\r\n      const value: TransitionSpiralProps = {\r\n        origin: data.localToWorld.origin.toJSON(),\r\n        type: data.getSpiralType()!,\r\n      };\r\n      Writer.insertOrientationFromMatrix(value, data.localToWorld.matrix, true);\r\n\r\n      if (!data.activeFractionInterval.isExact01)\r\n        value.fractionInterval = [data.activeFractionInterval.x0, data.activeFractionInterval.x1];\r\n      // Object.defineProperty(value, \"fractionInterval\", { value: [data.activeFractionInterval.x0, data.activeFractionInterval.x1] });\r\n\r\n      // if possible, do selective output of defining data (omit exactly one out of the 5, matching original definition)\r\n      if (originalProperties !== undefined && originalProperties.numDefinedProperties() === 4) {\r\n        if (originalProperties.radius0 !== undefined)\r\n          value.startRadius = data.radius01.x0;\r\n        if (originalProperties.radius1 !== undefined)\r\n          value.endRadius = data.radius01.x1;\r\n        if (originalProperties.bearing0 !== undefined)\r\n          value.startBearing = data.bearing01.startAngle.toJSON();\r\n        if (originalProperties.bearing1 !== undefined)\r\n          value.endBearing = data.bearing01.endAngle.toJSON();\r\n        if (originalProperties.curveLength !== undefined)\r\n          value.curveLength = data.curveLength();\r\n      } else {\r\n        // uh oh ... no original data, but the spiral itself knows all 5 values.  We don't know which to consider primary.\r\n        // DECISION -- put everything out, let readers make sense if they can. (It should be consistent ?)\r\n        value.startRadius = data.radius01.x0;\r\n        value.endRadius = data.radius01.x1;\r\n        value.startBearing = data.bearing01.startAngle.toJSON();\r\n        value.endBearing = data.bearing01.endAngle.toJSON();\r\n        value.curveLength = data.curveLength();\r\n      }\r\n      return { \"transitionSpiral\": value };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleCone(data: Cone): any {\r\n\r\n      const radiusA = data.getRadiusA();\r\n      const radiusB = data.getRadiusB();\r\n      const centerA = data.getCenterA();\r\n      const centerB = data.getCenterB();\r\n      const vectorX = data.getVectorX();\r\n      const vectorY = data.getVectorY();\r\n      const axisVector = Vector3d.createStartEnd(centerA, centerB);\r\n\r\n      if (Geometry.isSameCoordinate(radiusA, radiusB)\r\n        && vectorX.isPerpendicularTo(axisVector)\r\n        && vectorY.isPerpendicularTo(axisVector)\r\n        && Geometry.isSameCoordinate(vectorX.magnitude(), 1.0)\r\n        && Geometry.isSameCoordinate(vectorY.magnitude(), 1.0)) {\r\n        return {\r\n          \"cylinder\": {\r\n            \"capped\": data.capped,\r\n            \"start\": data.getCenterA().toJSON(),\r\n            \"end\": data.getCenterB().toJSON(),\r\n            \"radius\": radiusA,\r\n          },\r\n        };\r\n      } else {\r\n        const coneProps: ConeProps = {\r\n          \"capped\": data.capped,\r\n          \"start\": data.getCenterA().toJSON(),\r\n          \"end\": data.getCenterB().toJSON(),\r\n          \"startRadius\": data.getRadiusA(),\r\n          \"endRadius\": data.getRadiusB(),\r\n        };\r\n        Writer.insertOrientationFromXYVectors(coneProps, vectorX, vectorY, false);\r\n        return { \"cone\": coneProps };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleSphere(data: Sphere): any {\r\n      const xData = data.cloneVectorX().normalizeWithLength();\r\n      const yData = data.cloneVectorY().normalizeWithLength();\r\n      const zData = data.cloneVectorZ().normalizeWithLength();\r\n      const latitudeSweep = data.cloneLatitudeSweep();\r\n\r\n      const rX = xData.mag;\r\n      const rY = yData.mag;\r\n      const rZ = zData.mag;\r\n      if (xData.v && zData.v) {\r\n        const value: SphereProps = {\r\n          \"center\": data.cloneCenter().toJSON(),\r\n        };\r\n        if (!(data.getConstructiveFrame()!).matrix.isIdentity)\r\n          value.zxVectors = [zData.v.toJSON(), xData.v.toJSON()];\r\n        const fullSweep = latitudeSweep.isFullLatitudeSweep;\r\n\r\n        if (data.capped && !fullSweep)\r\n          value.capped = data.capped;\r\n\r\n        if (Geometry.isSameCoordinate(rX, rY) && Geometry.isSameCoordinate(rX, rZ))\r\n          value.radius = rX;\r\n        else {\r\n          value.radiusX = rX;\r\n          value.radiusY = rY;\r\n          value.radiusZ = rZ;\r\n        }\r\n        if (!fullSweep)\r\n          value.latitudeStartEnd = latitudeSweep.toJSON();\r\n        return { \"sphere\": value };\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleTorusPipe(data: TorusPipe): any {\r\n\r\n      const vectorX = data.cloneVectorX();\r\n      const vectorY = data.cloneVectorY();\r\n      const radiusA = data.getMajorRadius();\r\n      const radiusB = data.getMinorRadius();\r\n      const sweep = data.getSweepAngle();\r\n      if (data.getIsReversed()) {\r\n        vectorY.scaleInPlace(-1.0);\r\n        sweep.setRadians(-sweep.radians);\r\n      }\r\n      const value: TorusPipeProps = {\r\n        \"center\": data.cloneCenter().toJSON(),\r\n        \"majorRadius\": radiusA,\r\n        \"minorRadius\": radiusB,\r\n        \"xyVectors\": [vectorX.toJSON(), vectorY.toJSON()],\r\n      };\r\n      if (!sweep.isFullCircle) {\r\n        value.sweepAngle = sweep.degrees;\r\n        value.capped = data.capped;\r\n      }\r\n      return { \"torusPipe\": value };\r\n\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLineString3d(data: LineString3d): any {\r\n      const pointsA = data.points;\r\n      const pointsB = [];\r\n      if (pointsA)\r\n        for (const p of pointsA) pointsB.push(p.toJSON());\r\n      return { \"lineString\": pointsB };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handlePointString3d(data: PointString3d): any {\r\n      const pointsA = data.points;\r\n      const pointsB = [];\r\n      if (pointsA)\r\n        for (const p of pointsA) pointsB.push(p.toJSON());\r\n      return { \"pointString\": pointsB };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handlePath(data: Path): any {\r\n      return { \"path\": this.collectChildren(data) };\r\n    }\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLoop(data: Loop): any {\r\n      return { \"loop\": this.collectChildren(data) };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleParityRegion(data: ParityRegion): any {\r\n      return { \"parityRegion\": this.collectChildren(data) };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleUnionRegion(data: UnionRegion): any {\r\n      return { \"unionRegion\": this.collectChildren(data) };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBagOfCurves(data: BagOfCurves): any {\r\n      return { \"bagOfCurves\": this.collectChildren(data) };\r\n    }\r\n\r\n    private collectChildren(data: CurveCollection): any[] {\r\n      const children = [];\r\n      if (data.children && Array.isArray(data.children)) {\r\n        for (const child of data.children) {\r\n          const cdata = child.dispatchToGeometryHandler(this);\r\n          if (cdata)\r\n            children.push(cdata);\r\n        }\r\n      }\r\n      return children;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleLinearSweep(data: LinearSweep): any {\r\n      const extrusionVector = data.cloneSweepVector();\r\n      const curves = data.getCurvesRef();\r\n      const capped = data.capped;\r\n      if (extrusionVector\r\n        && curves\r\n        && capped !== undefined) {\r\n        return {\r\n          \"linearSweep\": {\r\n            \"contour\": curves.dispatchToGeometryHandler(this),\r\n            \"capped\": capped,\r\n            \"vector\": extrusionVector.toJSON(),\r\n          },\r\n        };\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleRuledSweep(data: RuledSweep): any {\r\n      const contours = data.cloneContours();\r\n      const capped = data.capped;\r\n      if (contours\r\n        && contours.length > 1\r\n        && capped !== undefined) {\r\n        const jsonContours = [];\r\n        for (const c of contours) {\r\n          jsonContours.push(this.emit(c));\r\n        }\r\n        return {\r\n          \"ruledSweep\": {\r\n            \"contour\": jsonContours,\r\n            \"capped\": capped,\r\n          },\r\n        };\r\n      }\r\n      return undefined;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleRotationalSweep(data: RotationalSweep): any {\r\n      const axisRay = data.cloneAxisRay();\r\n      const curves = data.getCurves();\r\n      const capped = data.capped;\r\n      const sweepAngle = data.getSweep();\r\n      return {\r\n        \"rotationalSweep\": {\r\n          \"axis\": axisRay.direction.toJSON(),\r\n          \"contour\": curves.dispatchToGeometryHandler(this),\r\n          \"capped\": capped,\r\n          \"center\": axisRay.origin.toJSON(),\r\n          \"sweepAngle\": sweepAngle.degrees,\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBox(box: Box): any {\r\n      const out: any = {\r\n        \"box\": {\r\n          \"baseOrigin\": box.getBaseOrigin().toJSON(),\r\n          \"baseX\": box.getBaseX(),\r\n          \"baseY\": box.getBaseY(),\r\n          \"capped\": box.capped,\r\n          \"topOrigin\": box.getTopOrigin().toJSON(),\r\n        },\r\n      };\r\n      Writer.insertXYOrientation(out.box, box.getVectorX(), box.getVectorY(), true);\r\n      if (!Geometry.isSameCoordinate(box.getTopX(), box.getBaseX()))\r\n        out.box.topX = box.getTopX();\r\n      if (!Geometry.isSameCoordinate(box.getTopY(), box.getBaseY()))\r\n        out.box.topY = box.getTopY();\r\n\r\n      return out;\r\n    }\r\n\r\n    private handlePolyfaceAuxData(auxData: PolyfaceAuxData, pf: IndexedPolyface): any {\r\n      const contents: { [k: string]: any } = {};\r\n      contents.indices = [];\r\n      const visitor = pf.createVisitor(0);\r\n      if (!visitor.auxData) return;\r\n\r\n      while (visitor.moveToNextFacet()) {\r\n        for (let i = 0; i < visitor.indexCount; i++) {\r\n          contents.indices.push(visitor.auxData.indices[i] + 1);\r\n        }\r\n        contents.indices.push(0);  // facet terminator.\r\n      }\r\n      contents.channels = [];\r\n      for (const inChannel of auxData.channels) {\r\n        const outChannel: { [k: string]: any } = {};\r\n        outChannel.dataType = inChannel.dataType;\r\n        outChannel.name = inChannel.name;\r\n        outChannel.inputName = inChannel.inputName;\r\n        outChannel.data = [];\r\n        for (const inData of inChannel.data) {\r\n          const outData: { [k: string]: any } = {};\r\n          outData.input = inData.input;\r\n          outData.values = inData.values.slice(0);\r\n          outChannel.data.push(outData);\r\n        }\r\n\r\n        contents.channels.push(outChannel);\r\n      }\r\n      return contents;\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleIndexedPolyface(pf: IndexedPolyface): any {\r\n      const points = [];\r\n      const pointIndex: number[] = [];\r\n      const normals = [];\r\n      const params = [];\r\n      const colors = [];\r\n      {\r\n        const p = Point3d.create();\r\n        for (let i = 0; pf.data.point.getPoint3dAtCheckedPointIndex(i, p); i++)\r\n          points.push(p.toJSON());\r\n      }\r\n      if (pf.data.normal) {\r\n        const numNormal = pf.data.normal.length;\r\n        const normal = Vector3d.create();\r\n        for (let i = 0; i < numNormal; i++) {\r\n          pf.data.normal.getVector3dAtCheckedVectorIndex(i, normal);\r\n          normals.push(normal.toJSON());\r\n        }\r\n\r\n      }\r\n\r\n      if (pf.data.param) {\r\n        const uv = Point2d.create();\r\n        for (let i = 0; pf.data.param.getPoint2dAtCheckedPointIndex(i, uv); i++)\r\n          params.push(uv.toJSON());\r\n      }\r\n\r\n      if (pf.data.color) {\r\n        for (const value of pf.data.color) colors.push(value);\r\n      }\r\n\r\n      const visitor = pf.createVisitor(0);\r\n      let indexCounter = 0;\r\n\r\n      const normalIndex = [];\r\n      const paramIndex = [];\r\n      const colorIndex = [];\r\n\r\n      let n;\r\n      while (visitor.moveToNextFacet()) {\r\n        n = visitor.indexCount;\r\n        // All meshes have point and point index ...\r\n        for (let i = 0; i < n; i++) {\r\n          // Change sign of value to be pushed based on whether or not the edge was originally visible or not\r\n          const toPush = pf.data.edgeVisible[indexCounter + i] ? visitor.pointIndex[i] + 1 : - (visitor.clientPointIndex(i) + 1);\r\n          pointIndex.push(toPush);\r\n        }\r\n        pointIndex.push(0);  // facet terminator.\r\n        indexCounter += visitor.indexCount;\r\n\r\n        if (visitor.normalIndex) {\r\n          for (let i = 0; i < n; i++) normalIndex.push(1 + visitor.clientNormalIndex(i));\r\n          normalIndex.push(0);\r\n        }\r\n        if (visitor.paramIndex) {\r\n          for (let i = 0; i < n; i++) paramIndex.push(1 + visitor.clientParamIndex(i));\r\n          paramIndex.push(0);\r\n        }\r\n        if (visitor.colorIndex) {\r\n          for (let i = 0; i < n; i++) colorIndex.push(1 + visitor.clientColorIndex(i));\r\n          colorIndex.push(0);\r\n        }\r\n      }\r\n      // assemble the contents in alphabetical order.\r\n      const contents: { [k: string]: any } = {};\r\n\r\n      if (pf.data.auxData)\r\n        contents.auxData = this.handlePolyfaceAuxData(pf.data.auxData, pf);\r\n\r\n      if (pf.data.color) contents.color = colors;\r\n      if (pf.data.colorIndex) contents.colorIndex = colorIndex;\r\n\r\n      if (pf.data.normal) contents.normal = normals;\r\n      if (pf.data.normalIndex) contents.normalIndex = normalIndex;\r\n\r\n      if (pf.data.param) contents.param = params;\r\n      if (pf.data.paramIndex) contents.paramIndex = paramIndex;\r\n\r\n      contents.point = points;\r\n      contents.pointIndex = pointIndex;\r\n\r\n      return { \"indexedMesh\": contents };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineCurve3d(curve: BSplineCurve3d): any {\r\n      // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\r\n      // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\r\n      const wrapMode = curve.isClosable;\r\n      if (wrapMode === BSplineWrapMode.OpenByAddingControlPoints) {\r\n        const knots = curve.copyKnots(true);\r\n        const poles = curve.copyPoints();\r\n        const degree = curve.degree;\r\n        for (let i = 0; i < degree; i++) poles.pop();\r\n        // knots have replicated first and last.  Change the values to be periodic.\r\n        const leftIndex = degree;\r\n        const rightIndex = knots.length - degree - 1;\r\n        const knotPeriod = knots[rightIndex] - knots[leftIndex];\r\n        knots[0] = knots[rightIndex - degree] - knotPeriod;\r\n        knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": poles,\r\n            \"knots\": knots,\r\n            \"closed\": true,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      } else if (curve.isClosable === BSplineWrapMode.OpenByRemovingKnots) {\r\n        // special case to re-close the case that originated as :    a a0 a0 .. a0 knot0 knot1 knot2 ... b1 b1 .. b1 b\r\n        // with (order) copies of a0 and b1 (usually 0 and 1)\r\n        // and a,b are related to the interior knots\r\n        // (This is the \"bezier saturated arc\")\r\n        const rawKnots = curve.copyKnots(false); // unchanged knots . . .\r\n        const poles = curve.copyPoints();\r\n        const degree = curve.degree;\r\n        const leftIndex = degree - 1;\r\n        const rightIndex = rawKnots.length - degree;\r\n        const leftKnot = rawKnots[leftIndex];\r\n        const rightKnot = rawKnots[rightIndex];\r\n        const knotPeriod = rightKnot - leftKnot;\r\n        const knots = [];\r\n        knots.push(rawKnots[rightIndex - 1] - knotPeriod);\r\n        knots.push(leftKnot);\r\n        for (const k of rawKnots) knots.push(k);\r\n        knots.push(rightKnot);\r\n        knots.push(rawKnots[leftIndex + 1] + knotPeriod);\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": poles,\r\n            \"knots\": knots,\r\n            \"closed\": true,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": curve.copyPoints(),\r\n            \"knots\": curve.copyKnots(true),\r\n            \"closed\": false,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBezierCurve3d(curve: BezierCurve3d): any {\r\n      const knots = [];\r\n      const order = curve.order;\r\n      for (let i = 0; i < order; i++) knots.push(0.0);\r\n      for (let i = 0; i < order; i++) knots.push(1.0);\r\n      return {\r\n        \"bcurve\": {\r\n          \"points\": curve.copyPolesAsJsonArray(),\r\n          \"knots\": knots,\r\n          \"closed\": false,\r\n          \"order\": curve.order,\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineCurve3dH(curve: BSplineCurve3dH): any {\r\n      // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\r\n      // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\r\n      if (curve.isClosable) {\r\n        const knots = curve.copyKnots(true);\r\n        const poles = curve.copyPoints();\r\n        const degree = curve.degree;\r\n        for (let i = 0; i < degree; i++) poles.pop();\r\n        // knots have replicated first and last.  Change the values to be periodic.\r\n        const leftIndex = degree;\r\n        const rightIndex = knots.length - degree - 1;\r\n        const knotPeriod = knots[rightIndex] - knots[leftIndex];\r\n        knots[0] = knots[rightIndex - degree] - knotPeriod;\r\n        knots[knots.length - 1] = knots[leftIndex + degree] + knotPeriod;\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": poles,\r\n            \"knots\": knots,\r\n            \"closed\": true,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          \"bcurve\": {\r\n            \"points\": curve.copyPoints(),\r\n            \"knots\": curve.copyKnots(true),\r\n            \"closed\": false,\r\n            \"order\": curve.order,\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineSurface3d(surface: BSplineSurface3d): any {\r\n      // ASSUME -- if the curve originated \"closed\" the knot and pole replication are unchanged,\r\n      // so first and last knots can be re-assigned, and last (degree - 1) poles can be deleted.\r\n      const periodicU = surface.isClosable(0);\r\n      const periodicV = surface.isClosable(1);\r\n      if (periodicU || periodicV) {\r\n        let numUPoles = surface.numPolesUV(0);\r\n        let numVPoles = surface.numPolesUV(1);\r\n        if (periodicU) numUPoles -= surface.degreeUV(0);\r\n        if (periodicV) numVPoles -= surface.degreeUV(1);\r\n        const xyz = Point3d.create();\r\n        const grid = [];\r\n        for (let j = 0; j < numVPoles; j++) {\r\n          const stringer = [];\r\n          for (let i = 0; i < numUPoles; i++) {\r\n            surface.getPoint3dPole(i, j, xyz)!;\r\n            stringer.push([xyz.x, xyz.y, xyz.z]);\r\n          }\r\n          grid.push(stringer);\r\n        }\r\n        return {\r\n          \"bsurf\": {\r\n            \"points\": grid,\r\n            \"uKnots\": surface.copyKnots(0, true),\r\n            \"vKnots\": surface.copyKnots(1, true),\r\n            \"orderU\": surface.orderUV(0),\r\n            \"orderV\": surface.orderUV(1),\r\n            \"closedU\": periodicU,\r\n            \"closedV\": periodicV,\r\n          },\r\n        };\r\n      } else {\r\n        return {\r\n          \"bsurf\": {\r\n            \"points\": surface.getPointArray(false),\r\n            \"uKnots\": surface.copyKnots(0, true),\r\n            \"vKnots\": surface.copyKnots(1, true),\r\n            \"orderU\": surface.orderUV(0),\r\n            \"orderV\": surface.orderUV(1),\r\n          },\r\n        };\r\n      }\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBezierCurve3dH(curve: BezierCurve3dH): any {\r\n      const knots = [];\r\n      const order = curve.order;\r\n      for (let i = 0; i < order; i++) knots.push(0.0);\r\n      for (let i = 0; i < order; i++) knots.push(1.0);\r\n      return {\r\n        \"bcurve\": {\r\n          \"points\": curve.copyPolesAsJsonArray(),\r\n          \"knots\": knots,\r\n          \"closed\": false,\r\n          \"order\": curve.order,\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert strongly typed instance to tagged json */\r\n    public handleBSplineSurface3dH(surface: BSplineSurface3dH): any {\r\n      const data = surface.getPointGridJSON();\r\n      return {\r\n        \"bsurf\": {\r\n          \"points\": data.points,\r\n          \"uKnots\": surface.copyKnots(0, true),\r\n          \"vKnots\": surface.copyKnots(1, true),\r\n          \"orderU\": surface.orderUV(0),\r\n          \"orderV\": surface.orderUV(1),\r\n        },\r\n      };\r\n    }\r\n\r\n    /** Convert an array of strongly typed instances to an array of tagged json */\r\n    public emitArray(data: object[]): any {\r\n      const members = [];\r\n      for (const c of data) {\r\n        const toPush = this.emit(c);\r\n        members.push(toPush);\r\n      }\r\n      return members;\r\n    }\r\n    /** Convert GeomeryQuery data (array or single instance) to instance to tagged json */\r\n    public emit(data: any): any {\r\n      if (Array.isArray(data))\r\n        return this.emitArray(data);\r\n\r\n      if (data instanceof GeometryQuery) {\r\n        return data.dispatchToGeometryHandler(this);\r\n      }\r\n      return undefined;\r\n    }\r\n    /** One-step static method to create a writer and emit a json object */\r\n    public static toIModelJson(data: any): any {\r\n      const writer = new Writer();\r\n      return writer.emit(data);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\n/**\r\n * A box-like solid defined by\r\n * * A local coordinate frame\r\n *   * (0,0,0) is left lower rear corner of box (considering \"left\" to reference x, \"lower\" to reference y, \"rear and front\" to reference z=0 and z=1)\r\n *   * (0,0,1) is left lower front corner.\r\n *   * (baseX,baseY,z) is right upper corner at z\r\n *   * note that the frame x and y columns are usually unit vectors in local space, but z is full rear to front vector\r\n * * The separate values for base and top x and y allow the box to be a \"view frustum\" with parallel back and front planes but independent x and y bellows effects.\r\n * @public\r\n */\r\nexport class Box extends SolidPrimitive {\r\n  private _localToWorld: Transform;\r\n  private _baseX: number;\r\n  private _baseY: number;\r\n  private _topX: number;\r\n  private _topY: number;\r\n\r\n  protected constructor(map: Transform,\r\n    baseX: number, baseY: number, topX: number, topY: number, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = map;\r\n    this._baseX = baseX;\r\n    this._baseY = baseY;\r\n    this._topX = topX;\r\n    this._topY = topY;\r\n  }\r\n  /** Return a clone */\r\n  public clone(): Box {\r\n    return new Box(this._localToWorld.clone(), this._baseX, this._baseY, this._topX, this._topY, this.capped);\r\n  }\r\n\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin lower left of box\r\n   * * x direction on base rectangle x edge\r\n   * * y direction in base rectangle\r\n   * * z direction perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Apply the transform to the box's `localToWorld` frame.\r\n   * * Note that this may make the frame nonrigid.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /** Clone the box and immediately apply `transform` to the local frame of the clone. */\r\n  public cloneTransformed(transform: Transform): Box | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Create a new box from vector and size daa.\r\n   * @param baseOrigin Origin of base rectangle\r\n   * @param vectorX  Direction for base rectangle\r\n   * @param vectorY Direction for base rectangle\r\n   * @param topOrigin origin of top rectangle\r\n   * @param baseX size factor for base rectangle (multiplies vectorX)\r\n   * @param baseY size factor for base rectangle (multiplies vectorY)\r\n   * @param topX size factor for top rectangle (multiplies vectorX)\r\n   * @param topY size factor for top rectangle (multiplies vectorY)\r\n   * @param capped true to define top and bottom closure caps\r\n   */\r\n  public static createDgnBox(baseOrigin: Point3d, vectorX: Vector3d, vectorY: Vector3d,\r\n    topOrigin: Point3d,\r\n    baseX: number, baseY: number, topX: number, topY: number,\r\n    capped: boolean): Box | undefined {\r\n    const vectorZ = baseOrigin.vectorTo(topOrigin);\r\n    const localToWorld = Transform.createOriginAndMatrixColumns(baseOrigin, vectorX, vectorY, vectorZ);\r\n    return new Box(localToWorld, baseX, baseY, topX, topY, capped);\r\n  }\r\n\r\n  /**\r\n   * Create a new box with xy directions taken from columns of the `axes` matrix.\r\n   * @param baseOrigin Origin of base rectangle\r\n   * @param axes  Direction for base rectangle\r\n   * @param topOrigin origin of top rectangle\r\n   * @param baseX size factor for base rectangle (multiplies vectorX)\r\n   * @param baseY size factor for base rectangle (multiplies vectorY)\r\n   * @param topX size factor for top rectangle (multiplies vectorX)\r\n   * @param topY size factor for top rectangle (multiplies vectorY)\r\n   * @param capped true to define top and bottom closure caps\r\n   */\r\n  public static createDgnBoxWithAxes(baseOrigin: Point3d, axes: Matrix3d,\r\n    topOrigin: Point3d,\r\n    baseX: number, baseY: number, topX: number, topY: number,\r\n    capped: boolean): Box | undefined {\r\n    return Box.createDgnBox(baseOrigin, axes.columnX(), axes.columnY(), topOrigin,\r\n      baseX, baseY, topX, topY, capped);\r\n  }\r\n\r\n  /**\r\n   * Create an axis-aligned `Box` primitive for a range.\r\n   * @param range range corners Origin of base rectangle\r\n   * @param capped true to define top and bottom closure caps\r\n   */\r\n  public static createRange(range: Range3d, capped: boolean): Box | undefined {\r\n    if (!range.isNull) {\r\n      const lowPoint = range.low;\r\n      const xSize = range.xLength();\r\n      const ySize = range.yLength();\r\n      const zPoint = range.low.clone();\r\n      zPoint.z = zPoint.z + range.zLength();\r\n      return Box.createDgnBox(\r\n        lowPoint,\r\n        Vector3d.unitX(), Vector3d.unitY(),\r\n        zPoint,\r\n        xSize, ySize, xSize, ySize, capped);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** (property accessor) return the x length at z = 0 */\r\n  public getBaseX(): number { return this._baseX; }\r\n  /** (property accessor) return the y length at z = 0 */\r\n  public getBaseY(): number { return this._baseY; }\r\n  /** (property accessor) return the x length at z = 1 */\r\n  public getTopX(): number { return this._topX; }\r\n  /** (property accessor) return the x length at z = 1 */\r\n  public getTopY(): number { return this._topY; }\r\n  /** (property accessor) return the local coordinates point (0,0,0) to world */\r\n  public getBaseOrigin(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 0); }\r\n  /** (property accessor) return the local coordinates point (0,0,1) to world */\r\n  public getTopOrigin(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 1); }\r\n  /** (property accessor) return the local coordinate frame x vector */\r\n  public getVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** (property accessor) return the local coordinate frame y vector */\r\n  public getVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** (property accessor) return the local coordinate frame z vector */\r\n  public getVectorZ(): Vector3d { return this._localToWorld.matrix.columnZ(); }\r\n  /** Test of `other` is also of class `Box` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof Box; }\r\n  /** test for near equality */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof Box) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return Geometry.isSameCoordinate(this._baseX, other._baseX)\r\n        && Geometry.isSameCoordinate(this._baseY, other._baseY)\r\n        && Geometry.isSameCoordinate(this._topX, other._topX)\r\n        && Geometry.isSameCoordinate(this._topY, other._topY);\r\n    }\r\n    return false;\r\n  }\r\n  /** Second step of double dispatch:  call `handler.handleBox(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleBox(this);\r\n  }\r\n  /** Return strokes of the cross-section rectangle at local z coordinate */\r\n  public strokeConstantVSection(zFraction: number): LineString3d {\r\n    const ax = Geometry.interpolate(this._baseX, zFraction, this._topX);\r\n    const ay = Geometry.interpolate(this._baseY, zFraction, this._topY);\r\n    const result = LineString3d.create();\r\n    const transform = this._localToWorld;\r\n    const workPoint = Point3d.create();\r\n    transform.multiplyXYZ(0, 0, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(ax, 0, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(ax, ay, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(0, ay, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    transform.multiplyXYZ(0, 0, zFraction, workPoint);\r\n    result.addPoint(workPoint);\r\n    return result;\r\n  }\r\n  /**\r\n   * Returns the 8 corners in x fastest, then y, finally z lexical order.\r\n   */\r\n  public getCorners(): Point3d[] {\r\n    const transform = this._localToWorld;\r\n    const ax = this._baseX;\r\n    const ay = this._baseY;\r\n    const bx = this._topX;\r\n    const by = this._topY;\r\n    return [transform.multiplyXYZ(0, 0, 0),\r\n    transform.multiplyXYZ(ax, 0, 0),\r\n    transform.multiplyXYZ(0, ay, 0),\r\n    transform.multiplyXYZ(ax, ay, 0),\r\n    transform.multiplyXYZ(0, 0, 1),\r\n    transform.multiplyXYZ(bx, 0, 1),\r\n    transform.multiplyXYZ(0, by, 1),\r\n    transform.multiplyXYZ(bx, by, 1)];\r\n  }\r\n\r\n  /**\r\n   * Consider the box sides (not top and bottom) as a (u,v) surface with\r\n   * * v = 0 as the z=0 local plane\r\n   * * v = 1 as the z=1 local plane\r\n   * Return the (rectangular) section at fractional v\r\n   */\r\n  public constantVSection(zFraction: number): CurveCollection {\r\n    const ls = this.strokeConstantVSection(zFraction);\r\n    return Loop.create(ls);\r\n  }\r\n  /** Extend  `rangeToExtend` by each of the 8 corners */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const boxTransform = this._localToWorld;\r\n    const ax = this._baseX;\r\n    const ay = this._baseY;\r\n    const bx = this._topX;\r\n    const by = this._topY;\r\n    if (transform) {\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, 0, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, ay, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, ax, ay, 0);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, 0, 1);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, 0, 1);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, 0, by, 1);\r\n      rangeToExtend.extendTransformTransformedXYZ(transform, boxTransform, bx, by, 1);\r\n    } else {\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, ax, 0, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, ay, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, ax, ay, 0);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, 0, 1);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, bx, 0, 1);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, 0, by, 1);\r\n      rangeToExtend.extendTransformedXYZ(boxTransform, bx, by, 1);\r\n    }\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler, UVSurface, UVSurfaceIsoParametricDistance } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\n\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n/**\r\n * A cone with axis along the z axis of a (possibly skewed) local coordinate system.\r\n *\r\n * * In local coordinates, the sections at z=0 and z=1 are circles of radius r0 and r1.\r\n * * Either one individually  may be zero, but they may not both be zero.\r\n * * The stored matrix has unit vectors in the xy columns, and full-length z column.\r\n * @public\r\n */\r\nexport class Cone extends SolidPrimitive implements UVSurface, UVSurfaceIsoParametricDistance {\r\n  private _localToWorld: Transform;       // Transform from local to global.\r\n  private _radiusA: number;    // nominal radius at z=0.  skewed axes may make it an ellipse\r\n  private _radiusB: number;    // radius at z=1.  skewed axes may make it an ellipse\r\n  private _maxRadius: number; // maximum radius anywhere on the cone.\r\n  protected constructor(map: Transform, radiusA: number, radiusB: number, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = map;\r\n    this._radiusA = radiusA;\r\n    this._radiusB = radiusB;\r\n    this._maxRadius = Math.max(this._radiusA, this._radiusB);  // um... should resolve elliptical sections\r\n  }\r\n  /** Return a clone of this Cone. */\r\n  public clone(): Cone {\r\n    return new Cone(this._localToWorld.clone(), this._radiusA, this._radiusB, this.capped);\r\n  }\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin at center of the base circle.\r\n   * * base circle in the xy plane\r\n   * * z axis by right hand rule.\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Apply the transform to this cone's locla to world coordinates.\r\n   * * Note that the radii are not changed.  Scaling is absorbed into the frame.\r\n   * * This fails if the transformation is singular.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /**\r\n   * Create a clone and immediately transform the clone.\r\n   */\r\n  public cloneTransformed(transform: Transform): Cone | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\r\n    return result;\r\n  }\r\n  /** create a cylinder or cone from two endpoints and their radii.   The circular cross sections are perpendicular to the axis line\r\n   * from start to end point.\r\n   * * both radii must be of the same sign.\r\n   * * negative radius is accepted to create interior surface.    Downstream effects of that combined with capping may be a problem.\r\n   */\r\n  public static createAxisPoints(centerA: Point3d, centerB: Point3d, radiusA: number, radiusB: number, capped: boolean): Cone | undefined {\r\n    const zDirection = centerA.vectorTo(centerB);\r\n    const a = zDirection.magnitude();\r\n    if (Geometry.isSmallMetricDistance(a)) return undefined;\r\n    // force near-zero radii to true zero\r\n    radiusA = Geometry.correctSmallMetricDistance(radiusA);\r\n    radiusB = Geometry.correctSmallMetricDistance(radiusB);\r\n    // cone tip may not be \"within\" the z range.\r\n    if (radiusA * radiusB < 0.0) return undefined;\r\n    // at least one must be nonzero.\r\n    if (radiusA + radiusB === 0.0) return undefined;\r\n    const matrix = Matrix3d.createRigidHeadsUp(zDirection);\r\n    matrix.scaleColumns(1.0, 1.0, a, matrix);\r\n    const localToWorld = Transform.createOriginAndMatrix(centerA, matrix);\r\n    return new Cone(localToWorld, radiusA, radiusB, capped);\r\n  }\r\n  /** create a cylinder or cone from axis start and end with cross section defined by vectors that do not need to be perpendicular to each other or\r\n   * to the axis.\r\n   */\r\n  public static createBaseAndTarget(centerA: Point3d, centerB: Point3d, vectorX: Vector3d, vectorY: Vector3d, radiusA: number, radiusB: number, capped: boolean) {\r\n    radiusA = Math.abs(Geometry.correctSmallMetricDistance(radiusA));\r\n    radiusB = Math.abs(Geometry.correctSmallMetricDistance(radiusB));\r\n    const vectorZ = centerA.vectorTo(centerB);\r\n    const localToWorld = Transform.createOriginAndMatrixColumns(centerA, vectorX, vectorY, vectorZ);\r\n    return new Cone(localToWorld, radiusA, radiusB, capped);\r\n  }\r\n/** (Property accessor) Return the center point at the base plane */\r\n  public getCenterA(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 0); }\r\n  /** (Property accessor) */\r\n  public getCenterB(): Point3d { return this._localToWorld.multiplyXYZ(0, 0, 1); }\r\n  /** (Property accessor) Return the x vector in the local frame */\r\n  public getVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** (Property accessor) Return the y vector in the local frame */\r\n  public getVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** (Property accessor) return the radius at the base plane */\r\n  public getRadiusA(): number { return this._radiusA; }\r\n  /** (Property accessor) return the radius at the top plane */\r\n  public getRadiusB(): number { return this._radiusB; }\r\n  /** (Property accessor) return the larger of the base and top plane radii */\r\n  public getMaxRadius(): number { return this._maxRadius; }\r\n  /** (Property accessor) return the radius at fraction `v` along the axis */\r\n  public vFractionToRadius(v: number): number { return Geometry.interpolate(this._radiusA, v, this._radiusB); }\r\n  /** (Property accessor) test if `other` is an instance of `Cone` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof Cone; }\r\n  /** (Property accessor) Test for nearly equal coordinate data. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof Cone) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return Geometry.isSameCoordinate(this._radiusA, other._radiusA)\r\n        && Geometry.isSameCoordinate(this._radiusB, other._radiusB);\r\n    }\r\n    return false;\r\n  }\r\n/** Second step of double dispatch:   call `handler.handleCone(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleCone(this);\r\n  }\r\n\r\n  /**\r\n   *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.\r\n   * * fixedStrokeCount takes priority over stroke options.\r\n   * * The linestring is created by LineString3d.createForStrokes (fixedStrokeCount, options), which sets up property according to the options:\r\n   *   * optional fractions member\r\n   *   * optional uvParams.  uvParams are installed as full-scale distance parameters.\r\n   *   * optional derivatives.\r\n   * @param v fractional position along the cone axis\r\n   * @param fixedStrokeCount optional stroke count.\r\n   * @param options optional stroke options.\r\n   */\r\n  public strokeConstantVSection(v: number, fixedStrokeCount: number | undefined, options: StrokeOptions | undefined): LineString3d {\r\n    let strokeCount = 16;\r\n    if (fixedStrokeCount !== undefined)\r\n      strokeCount = fixedStrokeCount;\r\n    else if (options !== undefined)\r\n      strokeCount = options.defaultCircleStrokes;   // NEEDS WORK -- get circle stroke count with this.maxRadius !!!\r\n    else {\r\n      // accept the local default\r\n    }\r\n    strokeCount = Geometry.clampToStartEnd(strokeCount, 4, 64);\r\n    const r = this.vFractionToRadius(v);\r\n    const result = LineString3d.createForStrokes(fixedStrokeCount, options);\r\n    const twoPi = Math.PI * 2.0;\r\n    const deltaRadians = twoPi / strokeCount;\r\n    let radians = 0;\r\n    const fractions = result.fractions;     // possibly undefined !!!\r\n    const derivatives = result.packedDerivatives; // possibly undefined !!!\r\n    const uvParams = result.packedUVParams; // possibly undefined !!\r\n    const surfaceNormals = result.packedSurfaceNormals;\r\n    const xyz = Point3d.create();\r\n    const dXdu = Vector3d.create();\r\n    const dXdv = Vector3d.create();\r\n    const normal = Vector3d.create();\r\n    const transform = this._localToWorld;\r\n    let rc, rs, cc, ss;\r\n    for (let i = 0; i <= strokeCount; i++) {\r\n      if (i * 2 <= strokeCount)\r\n        radians = i * deltaRadians;\r\n      else\r\n        radians = (i - strokeCount) * deltaRadians;\r\n      cc = Math.cos(radians);\r\n      ss = Math.sin(radians);\r\n      rc = r * cc;\r\n      rs = r * ss;\r\n\r\n      transform.multiplyXYZ(rc, rs, v, xyz);\r\n      result.addPoint(xyz);\r\n      if (fractions)\r\n        fractions.push(i / strokeCount);\r\n      if (derivatives) {\r\n        transform.matrix.multiplyXYZ(-rs * twoPi, rc * twoPi, 0.0, dXdu);\r\n        derivatives.push(dXdu);\r\n      }\r\n      if (surfaceNormals) {\r\n        // the along-hoop vector does not need to be scaled by radius -- just need the direction for a cross product.\r\n        transform.matrix.multiplyXYZ(-ss, cc, 0.0, dXdu);\r\n        transform.matrix.multiplyXYZ(0, 0, 1, dXdv);\r\n        dXdu.unitCrossProduct(dXdv, normal);\r\n        surfaceNormals.push(normal);\r\n      }\r\n      if (uvParams) {\r\n        uvParams.pushXY(i / strokeCount, v);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n  /**\r\n   * Return the Arc3d section at vFraction\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const r = this.vFractionToRadius(vFraction);\r\n    const transform = this._localToWorld;\r\n    const center = transform.multiplyXYZ(0, 0, vFraction);\r\n    const vector0 = transform.matrix.multiplyXYZ(r, 0, 0);\r\n    const vector90 = transform.matrix.multiplyXYZ(0, r, 0);\r\n    return Loop.create(Arc3d.create(center, vector0, vector90) as Arc3d);\r\n  }\r\n  /** Extend `rangeToExtend` so it includes this `Cone` instance. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    const arc0 = this.constantVSection(0.0)!;\r\n    const arc1 = this.constantVSection(1.0)!;\r\n    arc0.extendRange(rangeToExtend, transform);\r\n    arc1.extendRange(rangeToExtend, transform);\r\n  }\r\n/** Evaluate a point on the Cone surfaces, with\r\n * * v = 0 is the base plane.\r\n * * v = 1 is the top plane\r\n * * u = 0 to u = 1 wraps the angular range.\r\n */\r\n  public uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d {\r\n    const theta = uFraction * Math.PI * 2.0;\r\n    const r = Geometry.interpolate(this._radiusA, vFraction, this._radiusB);\r\n    const cosTheta = Math.cos(theta);\r\n    const sinTheta = Math.sin(theta);\r\n    return this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction, result);\r\n  }\r\n/** Evaluate a point tangent plane on the Cone surfaces, with\r\n * * v = 0 is the base plane.\r\n * * v = 1 is the top plane\r\n * * u = 0 to u = 1 wraps the angular range.\r\n */\r\npublic uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const theta = uFraction * Math.PI * 2.0;\r\n    const r = Geometry.interpolate(this._radiusA, vFraction, this._radiusB);\r\n    const drdv = this._radiusB - this._radiusA;\r\n    const cosTheta = Math.cos(theta);\r\n    const sinTheta = Math.sin(theta);\r\n    const fTheta = 2.0 * Math.PI;\r\n    return Plane3dByOriginAndVectors.createOriginAndVectors(\r\n      this._localToWorld.multiplyXYZ(r * cosTheta, r * sinTheta, vFraction),\r\n      this._localToWorld.multiplyVectorXYZ(-r * sinTheta * fTheta, r * cosTheta * fTheta, 0),\r\n      this._localToWorld.multiplyVectorXYZ(drdv * cosTheta, drdv * sinTheta, 1.0),\r\n      result);\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped;\r\n  }\r\n  /**\r\n   * Directional distance query\r\n   * * u direction is around longitude circle at maximum distance from axis.\r\n   * * v direction is on a line of longitude between the latitude limits.\r\n   */\r\n  public maxIsoParametricDistance(): Vector2d {\r\n    const vectorX = this._localToWorld.matrix.columnX();\r\n    const vectorY = this._localToWorld.matrix.columnY();\r\n    const columnZ = this._localToWorld.matrix.columnZ();\r\n\r\n    const xyNormal = vectorX.unitCrossProduct(vectorY)!;\r\n    const hZ = xyNormal.dotProduct(columnZ);\r\n    const zSkewVector = columnZ.plusScaled(xyNormal, hZ);\r\n    const zSkewDistance = zSkewVector.magnitudeXY();\r\n    return Vector2d.create(Math.PI * 2 * Math.max(this._radiusA, this._radiusB),\r\n      Geometry.hypotenuseXY(Math.abs(this._radiusB - this._radiusA) + zSkewDistance, hZ));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { XAndY } from \"../geometry3d/XYZProps\";\r\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { SweepContour } from \"./SweepContour\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\n/**\r\n * A LinearSweep is a `SolidPrimitive` defined by\r\n * * A set of curves (any Loop, Path, or parityRegion)\r\n * * A sweep vector\r\n * If the object is \"capped\", the curves must be planar.\r\n * @public\r\n */\r\nexport class LinearSweep extends SolidPrimitive {\r\n  private _contour: SweepContour;\r\n  private _direction: Vector3d;\r\n\r\n  private constructor(contour: SweepContour, direction: Vector3d, capped: boolean) {\r\n    super(capped);\r\n    this._contour = contour;\r\n    this._direction = direction;\r\n  }\r\n  /**\r\n   * Create a sweep of a starting contour.\r\n   * @param contour contour to be swept\r\n   * @param direction sweep vector.  The contour is swept the full length of the vector.\r\n   * @param capped true to include end caps\r\n   */\r\n  public static create(contour: CurveCollection, direction: Vector3d, capped: boolean): LinearSweep | undefined {\r\n    const sweepable = SweepContour.createForLinearSweep(contour, direction);\r\n    if (!sweepable)\r\n      return undefined;\r\n    return new LinearSweep(sweepable, direction, capped);\r\n  }\r\n  /** Create a z-direction sweep of the polyline or polygon given as xy linestring values.\r\n   * * If not capped, the xyPoints array is always used unchanged.\r\n   * * If capped but the xyPoints array does not close, exact closure will be enforced by one of these:\r\n   * * * If the final point is almost equal to the first, it is replaced by the exact first point.\r\n   * * * if the final point is not close to the first an extra point is added.\r\n   * * If capped, the point order will be reversed if necessary to produce positive volume.\r\n   * @param xyPoints array of xy coordinates\r\n   * @param z z value to be used for all coordinates\r\n   * @param zSweep the sweep distance in the z direction.\r\n   * @param capped true if caps are to be added.\r\n   */\r\n  public static createZSweep(xyPoints: XAndY[], z: number, zSweep: number, capped: boolean): LinearSweep | undefined {\r\n    const xyz = LineString3d.createXY(xyPoints, z, capped);\r\n    if (capped) {\r\n      xyz.addClosurePoint();\r\n      const area = PolygonOps.areaXY(xyz.points);\r\n      if (area * zSweep < 0.0)\r\n        xyz.points.reverse();\r\n    }\r\n    const contour: CurveCollection = capped ? Loop.create(xyz) : Path.create(xyz);\r\n    return LinearSweep.create(contour, Vector3d.create(0, 0, zSweep), capped);\r\n  }\r\n  /** get a reference to the swept curves */\r\n  public getCurvesRef(): CurveCollection { return this._contour.curves; }\r\n  /** Get a reference to the `SweepContour` carrying the plane of the curves */\r\n  public getSweepContourRef(): SweepContour { return this._contour; }\r\n  /** return a clone of the sweep vector */\r\n  public cloneSweepVector(): Vector3d { return this._direction.clone(); }\r\n  /** Test if `other` is also an instance of `LinearSweep` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof LinearSweep; }\r\n  /** Return a deep clone */\r\n  public clone(): LinearSweep {\r\n    return new LinearSweep(this._contour.clone(), this._direction.clone(), this.capped);\r\n  }\r\n  /** apply a transform to the curves and sweep vector */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    if (this._contour.tryTransformInPlace(transform)) {\r\n      transform.multiplyVector(this._direction, this._direction);\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin on base contour\r\n   * * x, y directions from base contour.\r\n   * * z direction perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._contour.localToWorld.cloneRigid();\r\n  }\r\n  /** Return a transformed clone */\r\n  public cloneTransformed(transform: Transform): LinearSweep {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Test for near-equality of coordinates in `other` */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof LinearSweep) {\r\n      return this._contour.isAlmostEqual(other._contour)\r\n        && this._direction.isAlmostEqual(other._direction)\r\n        && this.capped === other.capped;\r\n    }\r\n    return false;\r\n  }\r\n  /** Invoke strongly typed `handler.handleLinearSweep(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleLinearSweep(this);\r\n  }\r\n  /**\r\n   * Return the curves at a fraction along the sweep direction.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const section = this._contour.curves.clone();\r\n    if (section && vFraction !== 0.0)\r\n      section.tryTransformInPlace(Transform.createTranslation(this._direction.scale(vFraction)));\r\n    return section;\r\n  }\r\n  /** Extend `rangeToExtend` to include this geometry. */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const contourRange = this._contour.curves.range(transform);\r\n    rangeToExtend.extendRange(contourRange);\r\n    if (transform) {\r\n      const transformedDirection = transform.multiplyVector(this._direction);\r\n      contourRange.low.addInPlace(transformedDirection);\r\n      contourRange.high.addInPlace(transformedDirection);\r\n    } else {\r\n      contourRange.low.addInPlace(this._direction);\r\n      contourRange.high.addInPlace(this._direction);\r\n    }\r\n    rangeToExtend.extendRange(contourRange);\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped && this._contour.curves.isAnyRegionType;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { Geometry, AxisOrder } from \"../Geometry\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { SweepContour } from \"./SweepContour\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\n\r\n/**\r\n * A LinearSweep is\r\n * * A planar contour (any Loop, Path, or parityRegion)\r\n * * An axis vector.\r\n *   * The planar contour is expected to be in the plane of the axis vector\r\n *   * The contour may have points and/or lines that are on the axis, but otherwise is entirely on one side of the axis.\r\n * * A sweep angle.\r\n * @public\r\n */\r\nexport class RotationalSweep extends SolidPrimitive {\r\n  private _contour: SweepContour;\r\n  private _normalizedAxis: Ray3d;\r\n  private _sweepAngle: Angle;\r\n  private constructor(contour: SweepContour, normalizedAxis: Ray3d, sweepAngle: Angle, capped: boolean) {\r\n    super(capped);\r\n    this._contour = contour;\r\n    this._normalizedAxis = normalizedAxis;\r\n    this.capped = capped;\r\n    this._sweepAngle = sweepAngle;\r\n  }\r\n  /** Create a rotational sweep. */\r\n  public static create(contour: CurveCollection, axis: Ray3d, sweepAngle: Angle, capped: boolean): RotationalSweep | undefined {\r\n    if (!axis.direction.normalizeInPlace()) return undefined;\r\n    const sweepable = SweepContour.createForRotation(contour, axis);\r\n    if (!sweepable)\r\n      return undefined;\r\n    return new RotationalSweep(sweepable, axis, sweepAngle.clone(), capped);\r\n  }\r\n\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin at origin of rotation ray\r\n   * * z direction along the rotation ray.\r\n   * * y direction perpendicular to the base contour plane\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    const contourPerpendicular = this._contour.localToWorld.matrix.columnZ();\r\n    const axes = Matrix3d.createRigidFromColumns(contourPerpendicular, this._normalizedAxis.direction, AxisOrder.YZX);\r\n    if (axes) {\r\n      return Transform.createOriginAndMatrix(this._normalizedAxis.origin, axes);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** return clone of (not reference to) the axis vector. */\r\n  public cloneAxisRay(): Ray3d { return this._normalizedAxis.clone(); }\r\n  /** Return (REFERENCE TO) the swept curves. */\r\n  public getCurves(): CurveCollection { return this._contour.curves; }\r\n  /** Return (REFERENCE TO) the swept curves with containing plane markup. */\r\n  public getSweepContourRef(): SweepContour { return this._contour; }\r\n  /** Return the sweep angle. */\r\n  public getSweep(): Angle { return this._sweepAngle.clone(); }\r\n/** Test if `other` is a `RotationalSweep` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof RotationalSweep; }\r\n  /** Test for same axis, capping, and swept geometry. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof RotationalSweep) {\r\n      return this._contour.isAlmostEqual(other._contour)\r\n        && this._normalizedAxis.isAlmostEqual(other._normalizedAxis)\r\n        && this.capped === other.capped;\r\n    }\r\n    return false;\r\n  }\r\n/** return a deep clone */\r\n  public clone(): RotationalSweep {\r\n    return new RotationalSweep(this._contour.clone(), this._normalizedAxis.clone(), this._sweepAngle.clone(), this.capped);\r\n  }\r\n  /** Transform the contour and axis */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (!transform.matrix.isSingular()\r\n      && this._contour.tryTransformInPlace(transform)) {\r\n      this._normalizedAxis.transformInPlace(transform);\r\n      return this._normalizedAxis.direction.normalizeInPlace();\r\n    }\r\n    return false;\r\n  }\r\n  /** return a cloned transform. */\r\n  public cloneTransformed(transform: Transform): RotationalSweep {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n/** Dispatch to strongly typed handler  `handler.handleRotationalSweep(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleRotationalSweep(this);\r\n  }\r\n/** Return a transform that rotates around the rotational axis by a fraction of the total sweep. */\r\n  public getFractionalRotationTransform(vFraction: number, result?: Transform): Transform {\r\n    const radians = this._sweepAngle.radians * vFraction;\r\n    const rotation = Transform.createFixedPointAndMatrix(this._normalizedAxis.origin,\r\n      Matrix3d.createRotationAroundVector(this._normalizedAxis.direction, Angle.createRadians(radians),\r\n        result ? result.matrix : undefined) as Matrix3d);\r\n    return rotation;\r\n  }\r\n  /**\r\n   * Return the curves of a constant-v section of the solid.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const section = this._contour.curves.clone();\r\n    if (section) {\r\n      section.tryTransformInPlace(this.getFractionalRotationTransform(vFraction));\r\n    }\r\n    return section;\r\n  }\r\n/** Extend range using sampled points on the surface. */\r\n  public extendRange(range: Range3d, transform?: Transform) {\r\n    const degreeStep = 360 / 32;\r\n    const options = StrokeOptions.createForCurves();\r\n    options.angleTol = Angle.createDegrees(degreeStep);\r\n    const strokes = this._contour.curves.cloneStroked(options);\r\n    const numStep = Geometry.stepCount(degreeStep, this._sweepAngle.degrees, 4, 32);\r\n    const stepTransform = Transform.createIdentity();\r\n    if (transform) {\r\n      const compositeTransform = Transform.createIdentity();\r\n      for (let i = 0; i <= numStep; i++) {\r\n        transform.multiplyTransformTransform(this.getFractionalRotationTransform(i / numStep, stepTransform), compositeTransform);\r\n        strokes.extendRange(range, compositeTransform);\r\n      }\r\n\r\n    } else {\r\n      for (let i = 0; i <= numStep; i++)\r\n        strokes.extendRange(range, this.getFractionalRotationTransform(i / numStep, stepTransform));\r\n    }\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped || this._sweepAngle.isFullCircle;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { CurveCollection, CurveChain } from \"../curve/CurveCollection\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { CurvePrimitive } from \"../curve/CurvePrimitive\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { GeometryHandler } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { SweepContour } from \"./SweepContour\";\r\nimport { ConstructCurveBetweenCurves } from \"../curve/ConstructCurveBetweenCurves\";\r\n\r\n/**\r\n * * type for a function argument taking 2 curves and returning another curve or failing with undefined.\r\n * * This is used (for instance) by `RuleSweep.mutatePartners`\r\n * @public\r\n */\r\nexport type CurvePrimitiveMutator = (primitiveA: CurvePrimitive, primitiveB: CurvePrimitive) => CurvePrimitive | undefined;\r\n/**\r\n * A ruled sweep (surface) is a collection of 2 or more contours.\r\n * * All contours must have identical number and type of geometry. (paths, loops, parity regions, lines, arcs, other curves)\r\n * @public\r\n */\r\nexport class RuledSweep extends SolidPrimitive {\r\n  private _contours: SweepContour[];\r\n  private constructor(contours: SweepContour[], capped: boolean) {\r\n    super(capped);\r\n    this._contours = contours;\r\n  }\r\n  /**\r\n   * Create a ruled sweep from an array of contours.\r\n   *  * the contours are CAPTURED (not cloned)\r\n   */\r\n  public static create(contours: CurveCollection[], capped: boolean): RuledSweep | undefined {\r\n    const sweepContours = [];\r\n    for (const contour of contours) {\r\n      const sweepable = SweepContour.createForLinearSweep(contour);\r\n      if (sweepable === undefined) return undefined;\r\n      sweepContours.push(sweepable);\r\n    }\r\n    return new RuledSweep(sweepContours, capped);\r\n  }\r\n  /** Return a reference to the array of SweepContour. */\r\n  public sweepContoursRef(): SweepContour[] { return this._contours; }\r\n  /** Return clones of all the sweep contours\r\n   * * See also cloneContours, which returns the spatial contours without their local coordinate system definitions)\r\n   */\r\n  public cloneSweepContours(): SweepContour[] {\r\n    const result = [];\r\n    for (const sweepable of this._contours) {\r\n      result.push(sweepable.clone());\r\n    }\r\n    return result;\r\n  }\r\n  /** Return clones of all the contours\r\n   * * See also cloneContours, which returns the contours in their local coordinate systems\r\n   */\r\n  public cloneContours(): CurveCollection[] {\r\n    const result = [];\r\n    for (const sweepable of this._contours) {\r\n      result.push(sweepable.curves.clone() as CurveCollection);\r\n    }\r\n    return result;\r\n  }\r\n  /** Return a deep clone */\r\n  public clone(): RuledSweep {\r\n    return new RuledSweep(this.cloneSweepContours(), this.capped);\r\n  }\r\n  /** Transform all contours in place. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    for (const contour of this._contours) {\r\n      contour.tryTransformInPlace(transform);\r\n    }\r\n    return true;\r\n  }\r\n  /** Return a cloned transform. */\r\n  public cloneTransformed(transform: Transform): RuledSweep {\r\n    const result = this.clone();\r\n    result.tryTransformInPlace(transform);\r\n    return result;\r\n  }\r\n  /** Return a coordinate frame (right handed unit vectors)\r\n   * * origin on base contour\r\n   * * x, y directions from base contour.\r\n   * * z direction perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    if (this._contours.length === 0) return undefined;\r\n    return this._contours[0].localToWorld.cloneRigid();\r\n  }\r\n  /** Test if `other` is an instance of a `RuledSweep` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof RuledSweep; }\r\n  /** test same contour geometry and capping. */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof RuledSweep) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (this._contours.length !== other._contours.length) return false;\r\n      for (let i = 0; i < this._contours.length; i++) {\r\n        if (!this._contours[i].isAlmostEqual(other._contours[i]))\r\n          return false;\r\n      }\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** dispatch to strongly typed `handler.handleRuledSweep(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleRuledSweep(this);\r\n  }\r\n  /**\r\n   * Return the section curves at a fraction of the sweep\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const numSection = this._contours.length;\r\n    if (numSection < 2)\r\n      return undefined;\r\n    const q = vFraction * numSection;\r\n    let section0 = 0;\r\n    if (vFraction >= 1.0)\r\n      section0 = numSection - 1;\r\n    else\r\n      section0 = Math.floor(q);\r\n    if (section0 + 1 >= numSection)\r\n      section0 = numSection - 2;\r\n    const section1 = section0 + 1;\r\n    const localFraction = Geometry.clampToStartEnd(q - section0, 0, 1);\r\n    return RuledSweep.mutatePartners(this._contours[section0].curves, this._contours[section1].curves,\r\n      (primitive0: CurvePrimitive, primitive1: CurvePrimitive): CurvePrimitive | undefined => {\r\n        const newPrimitive = ConstructCurveBetweenCurves.interpolateBetween(primitive0, localFraction, primitive1);\r\n        if (newPrimitive instanceof CurvePrimitive) return newPrimitive;\r\n        return undefined;\r\n      });\r\n  }\r\n  /** Pass each contour to `extendRange` */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform): void {\r\n    for (const contour of this._contours)\r\n      contour.curves.extendRange(rangeToExtend, transform);\r\n  }\r\n\r\n  /** Construct a CurveCollection with the same structure as collectionA and collectionB, with primitives constructed by the caller-supplied primitiveMutator function.\r\n   * @returns Returns undefined if there is any type mismatch between the two collections.\r\n   */\r\n  public static mutatePartners(collectionA: CurveCollection, collectionB: CurveCollection, primitiveMutator: CurvePrimitiveMutator): CurveCollection | undefined {\r\n    if (!collectionA.isSameGeometryClass(collectionB))\r\n      return undefined;\r\n    if (collectionA instanceof CurveChain && collectionB instanceof CurveChain) {\r\n      const chainA = collectionA as CurveChain;\r\n      const chainB = collectionB as CurveChain;\r\n      const chainC = chainA.cloneEmptyPeer() as CurveChain;\r\n      const childrenA = chainA.children;\r\n      const childrenB = chainB.children;\r\n      if (childrenA.length !== childrenB.length)\r\n        return undefined;\r\n      for (let i = 0; i < childrenA.length; i++) {\r\n        const newChild = primitiveMutator(childrenA[i], childrenB[i]);\r\n        if (!newChild)\r\n          return undefined;\r\n        chainC.children.push(newChild);\r\n      }\r\n      return chainC;\r\n    } else if (collectionA instanceof CurveCollection && collectionB instanceof CurveCollection) {\r\n      const collectionC = collectionA.cloneEmptyPeer();\r\n      const childrenA = collectionA.children;\r\n      const childrenB = collectionB.children;\r\n      const childrenC = collectionC.children;\r\n      if (childrenA === undefined || childrenB === undefined || childrenC === undefined || childrenA.length !== childrenB.length)\r\n        return undefined;\r\n      for (let i = 0; i < childrenA.length; i++) {\r\n        const childA = childrenA[i];\r\n        const childB = childrenB[i];\r\n        if (childA instanceof CurvePrimitive && childB instanceof CurvePrimitive) {\r\n          const newPrimitive = primitiveMutator(childA, childB);\r\n          if (!newPrimitive)\r\n            return undefined;\r\n          childrenC.push(newPrimitive);\r\n        } else if (childA instanceof CurveCollection && childB instanceof CurveCollection) {\r\n          const newChild = this.mutatePartners(childA, childB, primitiveMutator);\r\n          if (!newChild)\r\n            return undefined;\r\n          if (newChild instanceof CurveCollection)\r\n            childrenC.push(newChild);\r\n        }\r\n      }\r\n      return collectionC;\r\n    }\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return true if this is a closed volume, as observed by\r\n   * * cap flag\r\n   * identical first and last contours.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    const n = this._contours.length;\r\n    return n > 1 && (this.capped || this._contours[0].isAlmostEqual(this._contours[n - 1]));\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n/**\r\n * Base class for SolidPrimitive variants.\r\n *\r\n * * The base class holds capped flag for all derived classes.\r\n * @public\r\n */\r\nexport abstract class SolidPrimitive extends GeometryQuery {\r\n  /** flag indicating whether cap region is considered closed (i.e. a planar region, rather than just a wire in space) */\r\n  protected _capped: boolean;\r\n  protected constructor(capped: boolean) { super(); this._capped = capped; }\r\n  /** Ask if this is a capped solid */\r\n  public get capped(): boolean { return this._capped; }\r\n  /** Set the capped flag */\r\n  public set capped(capped: boolean) { this._capped = capped; }\r\n  /** Return a cross section at specified vFraction. */\r\n  public abstract constantVSection(_vFraction: number): CurveCollection | undefined;\r\n  /** Return a Transform from the local system of the solid to world.\r\n   * * The particulars of origin and orientation are specific to each SolidPrimitive type.\r\n   */\r\n  public abstract getConstructiveFrame(): Transform | undefined;\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   * * LinearSweep, Box, Cone only depend on capped.\r\n   * * Sphere affected by capped and latitude sweep\r\n   * * TorusPipe and RotationalSweep affected by capped and sweep\r\n   * * RuledSweep is affected by capped and match of first, last contour\r\n   */\r\n  public abstract get isClosedVolume(): boolean;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\nimport { Matrix3d } from \"../geometry3d/Matrix3d\";\r\n\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\n\r\nimport { Geometry } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { GeometryHandler, UVSurface } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n/**\r\n * A Sphere is\r\n *\r\n * * A unit sphere (but read on ....)\r\n * * mapped by an arbitrary (possibly skewed, non-uniform scaled) transform\r\n * * hence possibly the final geometry is ellipsoidal\r\n * @public\r\n */\r\nexport class Sphere extends SolidPrimitive implements UVSurface {\r\n  private _localToWorld: Transform;  // unit sphere maps to world through the transform0 part of this map.\r\n  private _latitudeSweep: AngleSweep;\r\n  /** Return the latitude (in radians) all fractional v. */\r\n  public vFractionToRadians(v: number): number {\r\n    return this._latitudeSweep.fractionToRadians(v);\r\n  }\r\n  /** Return the longitude (in radians) all fractional u. */\r\n  public uFractionToRadians(u: number): number {\r\n    return u * Math.PI * 2.0;\r\n  }\r\n\r\n  private constructor(localToWorld: Transform, latitudeSweep: AngleSweep, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = localToWorld;\r\n    this._latitudeSweep = latitudeSweep ? latitudeSweep : AngleSweep.createFullLatitude();\r\n  }\r\n  /** return a deep clone */\r\n  public clone(): Sphere {\r\n    return new Sphere(this._localToWorld.clone(), this._latitudeSweep.clone(), this.capped);\r\n  }\r\n  /** Transform the sphere in place.\r\n   * * Fails if the transform is singular.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /** Return a transformed clone. */\r\n  public cloneTransformed(transform: Transform): Sphere | undefined {\r\n    const sphere1 = this.clone();\r\n    transform.multiplyTransformTransform(sphere1._localToWorld, sphere1._localToWorld);\r\n    return sphere1;\r\n  }\r\n  /** Return a coordinate frame (right handed, unit axes)\r\n   * * origin at sphere center\r\n   * * equator in xy plane\r\n   * * z axis perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Return the latitude sweep as fraction of south pole to north pole. */\r\n  public get latitudeSweepFraction(): number { return this._latitudeSweep.sweepRadians / Math.PI; }\r\n  /** Create from center and radius, with optional restricted latitudes. */\r\n  public static createCenterRadius(center: Point3d, radius: number, latitudeSweep?: AngleSweep): Sphere {\r\n    const localToWorld = Transform.createOriginAndMatrix(center, Matrix3d.createUniformScale(radius));\r\n    return new Sphere(localToWorld,\r\n      latitudeSweep ? latitudeSweep : AngleSweep.createFullLatitude(), false);\r\n  }\r\n  /** Create an ellipsoid which is a unit sphere mapped to position by an (arbitrary, possibly skewed and scaled) transform. */\r\n  public static createEllipsoid(localToWorld: Transform, latitudeSweep: AngleSweep, capped: boolean): Sphere | undefined {\r\n    return new Sphere(localToWorld, latitudeSweep, capped);\r\n  }\r\n\r\n  /** Create a sphere from the typical parameters of the Dgn file */\r\n  public static createDgnSphere(center: Point3d, vectorX: Vector3d, vectorZ: Vector3d, radiusXY: number, radiusZ: number,\r\n    latitudeSweep: AngleSweep,\r\n    capped: boolean): Sphere | undefined {\r\n    const vectorY = vectorX.rotate90Around(vectorZ);\r\n    if (vectorY && !vectorX.isParallelTo(vectorZ)) {\r\n      const matrix = Matrix3d.createColumns(vectorX, vectorY, vectorZ);\r\n      matrix.scaleColumns(radiusXY, radiusXY, radiusZ, matrix);\r\n      const frame = Transform.createOriginAndMatrix(center, matrix);\r\n      return new Sphere(frame, latitudeSweep.clone(), capped);\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  /** Create a sphere from the typical parameters of the Dgn file */\r\n  public static createFromAxesAndScales(center: Point3d, axes: undefined | Matrix3d, radiusX: number, radiusY: number, radiusZ: number,\r\n    latitudeSweep: AngleSweep | undefined,\r\n    capped: boolean): Sphere | undefined {\r\n    const localToWorld = Transform.createOriginAndMatrix(center, axes);\r\n    localToWorld.matrix.scaleColumnsInPlace(radiusX, radiusY, radiusZ);\r\n    return new Sphere(localToWorld, latitudeSweep ? latitudeSweep.clone() : AngleSweep.createFullLatitude(), capped);\r\n  }\r\n\r\n  /** return (copy of) sphere center */\r\n  public cloneCenter(): Point3d { return this._localToWorld.getOrigin(); }\r\n  /** return the (full length, i.e. scaled by radius) X vector from the sphere transform */\r\n  public cloneVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** return the (full length, i.e. scaled by radius) Y vector from the sphere transform */\r\n  public cloneVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** return the (full length, i.e. scaled by radius) Z vector from the sphere transform */\r\n  public cloneVectorZ(): Vector3d { return this._localToWorld.matrix.columnZ(); }\r\n  /** return (a copy of) the sphere's angle sweep. */\r\n  public cloneLatitudeSweep(): AngleSweep { return this._latitudeSweep.clone(); }\r\n  /** Test if the geometry is a true sphere taking the transform (which might have nonuniform scaling) is applied. */\r\n  public trueSphereRadius(): number | undefined {\r\n    const factors = this._localToWorld.matrix.factorRigidWithSignedScale();\r\n    if (!factors) return undefined;\r\n    if (factors && factors.scale > 0)\r\n      return factors.scale;\r\n    return undefined;\r\n  }\r\n  /**\r\n   * Return a (clone of) the sphere's local to world transformation.\r\n   */\r\n  public cloneLocalToWorld(): Transform { return this._localToWorld.clone(); }\r\n  /** Test if `other` is a `Sphere` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof Sphere; }\r\n/** Test for same geometry in `other` */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof Sphere) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /**\r\n   *  return strokes for a cross-section (elliptic arc) at specified fraction v along the axis.\r\n   * * if strokeOptions is supplied, it is applied to the equator radii.\r\n   * @param v fractional position along the cone axis\r\n   * @param strokes stroke count or options.\r\n   */\r\n  public strokeConstantVSection(v: number, fixedStrokeCount: number | undefined,\r\n    options?: StrokeOptions): LineString3d {\r\n    let strokeCount = 16;\r\n    if (fixedStrokeCount !== undefined && Number.isFinite(fixedStrokeCount)) {\r\n      strokeCount = fixedStrokeCount as number;\r\n    } else if (options instanceof StrokeOptions) {\r\n      strokeCount = options.applyTolerancesToArc(Geometry.maxXY(this._localToWorld.matrix.columnXMagnitude(), this._localToWorld.matrix.columnYMagnitude()));\r\n    }\r\n    strokeCount = Geometry.clampToStartEnd(strokeCount, 4, 64);\r\n    const transform = this._localToWorld;\r\n    const phi = this.vFractionToRadians(v);\r\n    const c1 = Math.cos(phi);\r\n    const s1 = Math.sin(phi);\r\n    let c0, s0;\r\n    const result = LineString3d.createForStrokes(fixedStrokeCount, options);\r\n    const deltaRadians = Math.PI * 2.0 / strokeCount;\r\n    const fractions = result.fractions;     // possibly undefined !!!\r\n    const derivatives = result.packedDerivatives; // possibly undefined !!!\r\n    const uvParams = result.packedUVParams; // possibly undefined !!\r\n    const surfaceNormals = result.packedSurfaceNormals;\r\n    const dXdu = Vector3d.create();\r\n    const dXdv = Vector3d.create();\r\n    const normal = Vector3d.create();\r\n    let radians = 0;\r\n    for (let i = 0; i <= strokeCount; i++) {\r\n      if (i * 2 <= strokeCount)\r\n        radians = i * deltaRadians;\r\n      else\r\n        radians = (i - strokeCount) * deltaRadians;\r\n      c0 = Math.cos(radians);\r\n      s0 = Math.sin(radians);\r\n      const xyz = transform.multiplyXYZ(c1 * c0, c1 * s0, s1);\r\n      result.addPoint(xyz);\r\n\r\n      if (fractions)\r\n        fractions.push(i / strokeCount);\r\n\r\n      if (derivatives) {\r\n        transform.matrix.multiplyXYZ(-c1 * s0, c1 * c0, 0.0, dXdu);\r\n        derivatives.push(dXdu);\r\n      }\r\n      if (uvParams) {\r\n        uvParams.pushXY(i / strokeCount, v);\r\n      }\r\n      if (surfaceNormals) {\r\n        transform.matrix.multiplyXYZ(-s0, c0, 0, dXdu);\r\n        transform.matrix.multiplyXYZ(-s1 * c0, -s1 * s0, c1, dXdv);\r\n        dXdu.unitCrossProduct(dXdv, normal);\r\n        surfaceNormals.push(normal);\r\n      }\r\n    }\r\n    return result;\r\n  }\r\n\r\n  /** Second step of double dispatch:  call `handler.handleSphere(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleSphere(this);\r\n  }\r\n  /**\r\n   * Return the Arc3d section at vFraction.  For the sphere, this is a latitude circle.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(vFraction: number): CurveCollection | undefined {\r\n    const phi = this._latitudeSweep.fractionToRadians(vFraction);\r\n    const s1 = Math.sin(phi);\r\n    const c1 = Math.cos(phi);\r\n    const transform = this._localToWorld;\r\n    const center = transform.multiplyXYZ(0, 0, s1);\r\n    const vector0 = transform.matrix.multiplyXYZ(c1, 0, 0);\r\n    const vector90 = transform.matrix.multiplyXYZ(0, c1, 0);\r\n    return Loop.create(Arc3d.create(center, vector0, vector90) as Arc3d);\r\n  }\r\n/** Extend a range to contain this sphere. */\r\n  public extendRange(range: Range3d, transform?: Transform): void {\r\n    let placement = this._localToWorld;\r\n    if (transform) {\r\n      placement = transform.multiplyTransformTransform(placement);\r\n    }\r\n\r\n    range.extendTransformedXYZ(placement, -1, -1, -1);\r\n    range.extendTransformedXYZ(placement, 1, -1, -1);\r\n    range.extendTransformedXYZ(placement, -1, 1, -1);\r\n    range.extendTransformedXYZ(placement, 1, 1, -1);\r\n\r\n    range.extendTransformedXYZ(placement, -1, -1, 1);\r\n    range.extendTransformedXYZ(placement, 1, -1, 1);\r\n    range.extendTransformedXYZ(placement, -1, 1, 1);\r\n    range.extendTransformedXYZ(placement, 1, 1, 1);\r\n\r\n  }\r\n  /** Evaluate as a uv surface\r\n   * @param uFraction fractional position in minor (phi)\r\n   * @param vFraction fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPoint(uFraction: number, vFraction: number, result?: Point3d): Point3d {\r\n    // sphere with radius 1 . . .\r\n    const thetaRadians = this.uFractionToRadians(uFraction);\r\n    const phiRadians = this.vFractionToRadians(vFraction);\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    return this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi, result);\r\n  }\r\n  /** Evaluate as a uv surface, returning point and two vectors.\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPointAndTangents(uFraction: number, vFraction: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const thetaRadians = this.uFractionToRadians(uFraction);\r\n    const phiRadians = this.vFractionToRadians(vFraction);\r\n    const fTheta = Math.PI * 2.0;\r\n    const fPhi = this._latitudeSweep.sweepRadians;\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    return Plane3dByOriginAndVectors.createOriginAndVectors(\r\n      this._localToWorld.multiplyXYZ(cosTheta * cosPhi, sinTheta * cosPhi, sinPhi),\r\n      this._localToWorld.matrix.multiplyXYZ(-fTheta * sinTheta, fTheta * cosTheta, 0),   // !!! note cosTheta term is omitted -- scale is wrong, but remains non-zero at poles.\r\n      this._localToWorld.matrix.multiplyXYZ(-fPhi * cosTheta * sinPhi, -fPhi * sinTheta * sinPhi, fPhi * cosPhi),\r\n      result);\r\n  }\r\n  /**\r\n   * * A sphere is can be closed two ways:\r\n   *   * full sphere (no caps needed for closure)\r\n   *   * incomplete but with caps\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped || this._latitudeSweep.isFullLatitudeSweep;\r\n  }\r\n  /**\r\n   * Directional distance query\r\n   * * u direction is around longitude circle at maximum distance from axis.\r\n   * * v direction is on a line of longitude between the latitude limits.\r\n   */\r\n  public maxIsoParametricDistance(): Vector2d {\r\n    // approximate radius at equator .. if elliptic, this is not exact . . .\r\n    const rX = this._localToWorld.matrix.columnXMagnitude();\r\n    const rY = this._localToWorld.matrix.columnYMagnitude();\r\n    const rZ = this._localToWorld.matrix.columnZMagnitude();\r\n    const rMaxU = Math.max(rX, rY);\r\n    let dMaxU = Math.PI * 2.0 * rMaxU;\r\n    if (!this._latitudeSweep.isRadiansInSweep(0.0))\r\n      dMaxU *= Math.max(Math.cos(Math.abs(this._latitudeSweep.startRadians)), Math.cos(Math.abs(this._latitudeSweep.endRadians)));\r\n    const dMaxV = Math.max(rMaxU, rZ) * Math.abs(this._latitudeSweep.sweepRadians);\r\n\r\n    return Vector2d.create(dMaxU, dMaxV);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { FrameBuilder } from \"../geometry3d/FrameBuilder\";\r\nimport { Ray3d } from \"../geometry3d/Ray3d\";\r\nimport { IndexedPolyface } from \"../polyface/Polyface\";\r\nimport { PolyfaceBuilder } from \"../polyface/PolyfaceBuilder\";\r\nimport { Triangulator } from \"../topology/Triangulation\";\r\nimport { LineString3d } from \"../curve/LineString3d\";\r\nimport { AnyCurve } from \"../curve/CurveChain\";\r\nimport { ParityRegion } from \"../curve/ParityRegion\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { StrokeOptions } from \"../curve/StrokeOptions\";\r\nimport { PolygonOps } from \"../geometry3d/PolygonOps\";\r\n\r\n/**\r\n * Sweepable contour with Transform for local to world interaction.\r\n * * The surface/solid classes `LinearSweep`, `RotationalSweep`, `RuledSweep` use this for their swept contours.\r\n * @public\r\n */\r\nexport class SweepContour {\r\n  /** The underlying curve collection, in its world coordinates position. */\r\n  public curves: CurveCollection;\r\n  /** coordinate frame that in which the curves are all in the xy plane. */\r\n  public localToWorld: Transform;\r\n  /** Axis used only in rotational case. */\r\n  public axis: Ray3d | undefined;\r\n\r\n  private constructor(contour: CurveCollection, map: Transform, axis: Ray3d | undefined) {\r\n    this.curves = contour;\r\n    this.localToWorld = map;\r\n    this.axis = axis;\r\n  }\r\n  /** Create for linear sweep.\r\n   * * The optional default normal may be useful for guiding coordinate frame setup.\r\n   * * the contour is CAPTURED.\r\n   */\r\n  public static createForLinearSweep(contour: CurveCollection, defaultNormal?: Vector3d): SweepContour | undefined {\r\n    const localToWorld = FrameBuilder.createRightHandedFrame(defaultNormal, contour);\r\n    if (localToWorld) {\r\n      return new SweepContour(contour, localToWorld, undefined);\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Create for rotational sweep.\r\n   * * The axis ray is retained.\r\n   * * the contour is CAPTURED.\r\n   */\r\n  public static createForRotation(contour: CurveCollection, axis: Ray3d): SweepContour | undefined {\r\n    // createRightHandedFrame -- the axis is a last-gasp resolver for in-plane vectors.\r\n    const localToWorld = FrameBuilder.createRightHandedFrame(undefined, contour, axis);\r\n    if (localToWorld) {\r\n      return new SweepContour(contour, localToWorld, axis.clone());\r\n    }\r\n    return undefined;\r\n  }\r\n  /** Return (Reference to) the curves */\r\n  public getCurves(): CurveCollection { return this.curves; }\r\n  /** Apply `transform` to the curves, axis.\r\n   * * The local to world frame is reconstructed for the transformed curves.\r\n   */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (this.curves.tryTransformInPlace(transform)) {\r\n      if (this.axis)\r\n        this.axis.transformInPlace(transform);\r\n\r\n      const localToWorld = this.axis !== undefined\r\n        ? FrameBuilder.createRightHandedFrame(undefined, this.curves, this.axis)\r\n        : FrameBuilder.createRightHandedFrame(undefined, this.curves);\r\n      if (localToWorld) {\r\n        this.localToWorld.setFrom(localToWorld);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n  /** Return a deep clone. */\r\n  public clone(): SweepContour {\r\n    return new SweepContour(this.curves.clone() as CurveCollection, this.localToWorld.clone(), this.axis);\r\n  }\r\n  /** Return a transformed clone. */\r\n  public cloneTransformed(transform: Transform): SweepContour | undefined {\r\n    const newContour = this.clone();\r\n    if (newContour.tryTransformInPlace(transform))\r\n      return newContour;\r\n    return undefined;\r\n  }\r\n  /** Test for near equality of cures and local frame. */\r\n  public isAlmostEqual(other: any): boolean {\r\n    if (other instanceof SweepContour) {\r\n      return this.curves.isAlmostEqual(other.curves) && this.localToWorld.isAlmostEqual(other.localToWorld);\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private _xyStrokes?: AnyCurve;\r\n  private _facets?: IndexedPolyface;\r\n\r\n  /**\r\n   * build the (cached) internal facets.\r\n   * @param _builder (NOT USED -- an internal builder is constructed for the triangulation)\r\n   * @param options options for stroking the curves.\r\n   */\r\n  public buildFacets(_builder: PolyfaceBuilder, options: StrokeOptions | undefined): void {\r\n    if (!this._facets) {\r\n      if (this.curves instanceof Loop) {\r\n        this._xyStrokes = this.curves.cloneStroked(options);\r\n        if (this._xyStrokes instanceof Loop && this._xyStrokes.children.length === 1) {\r\n          const children = this._xyStrokes.children;\r\n          const linestring = children[0] as LineString3d;\r\n          const points = linestring.points;\r\n          this.localToWorld.multiplyInversePoint3dArrayInPlace(points);\r\n          if (PolygonOps.sumTriangleAreasXY(points) < 0)\r\n            points.reverse();\r\n          const graph = Triangulator.createTriangulatedGraphFromSingleLoop(points);\r\n          const unflippedPoly = PolyfaceBuilder.graphToPolyface(graph, options);\r\n          this._facets = unflippedPoly;\r\n          this._facets.tryTransformInPlace(this.localToWorld);\r\n        }\r\n      } else if (this.curves instanceof ParityRegion) {\r\n        this._xyStrokes = this.curves.cloneStroked(options);\r\n        if (this._xyStrokes instanceof (ParityRegion)) {\r\n          const worldToLocal = this.localToWorld.inverse()!;\r\n          this._xyStrokes.tryTransformInPlace(worldToLocal);\r\n          const strokes = [];\r\n          for (const childLoop of this._xyStrokes.children) {\r\n            const loopCurves = childLoop.children;\r\n            if (loopCurves.length === 1) {\r\n              const c = loopCurves[0];\r\n              if (c instanceof LineString3d)\r\n                strokes.push(c.packedPoints);\r\n            }\r\n          }\r\n          const graph = Triangulator.createTriangulatedGraphFromLoops(strokes);\r\n          if (graph) {\r\n            const unflippedPoly = PolyfaceBuilder.graphToPolyface(graph, options);\r\n            this._facets = unflippedPoly;\r\n            this._facets.tryTransformInPlace(this.localToWorld);\r\n          }\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** delete existing facets.\r\n   * * This protects against PolyfaceBuilder reusing facets constructed with different options settings.\r\n   */\r\n  public purgeFacets() {\r\n    this._facets = undefined;\r\n  }\r\n\r\n  /** Emit facets to a builder.\r\n   * This method may cache and reuse facets over multiple calls.\r\n   */\r\n  public emitFacets(builder: PolyfaceBuilder, reverse: boolean, transform?: Transform) {\r\n    this.buildFacets(builder, builder.options);\r\n    if (this._facets)\r\n      builder.addIndexedPolyface(this._facets, reverse, transform);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Solid */\r\n\r\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\r\nimport { Range3d } from \"../geometry3d/Range\";\r\nimport { Transform } from \"../geometry3d/Transform\";\r\n\r\nimport { GeometryQuery } from \"../curve/GeometryQuery\";\r\nimport { Geometry } from \"../Geometry\";\r\nimport { AngleSweep } from \"../geometry3d/AngleSweep\";\r\nimport { Angle } from \"../geometry3d/Angle\";\r\nimport { GeometryHandler, UVSurface, UVSurfaceIsoParametricDistance } from \"../geometry3d/GeometryHandler\";\r\nimport { SolidPrimitive } from \"./SolidPrimitive\";\r\nimport { Loop } from \"../curve/Loop\";\r\nimport { Path } from \"../curve/Path\";\r\nimport { CurveCollection } from \"../curve/CurveCollection\";\r\nimport { Arc3d } from \"../curve/Arc3d\";\r\nimport { Plane3dByOriginAndVectors } from \"../geometry3d/Plane3dByOriginAndVectors\";\r\nimport { Vector2d } from \"../geometry3d/Point2dVector2d\";\r\n/**\r\n * A torus pipe is a partial torus (donut).  In a local coordinate system\r\n * * The z axis passes through the hole.\r\n * * The \"major hoop\" arc has\r\n *   * vectorTheta0 = (radiusA,0,0)\r\n *   * vectorTheta90 = (0, radiusA,0)\r\n *   * The major arc point at angle theta is `C(theta) = vectorTheta0 * cos(theta) + vectorTheta90 * sin(theta)\r\n * * The minor hoop at theta various with phi \"around the minor hoop\"\r\n *    * (x,y,z) = C(theta) + (radiusB *cos(theta), radiusB * sin(theta)) * cos(phi) + (0,radiusB,0) * sin(phi)\r\n * * The stored form of the torus pipe is oriented for positive volume:\r\n *   * Both radii are positive, with r0 >= r1 > 0\r\n *   * The sweep is positive\r\n *   * The coordinate system has positive determinant.\r\n * * For uv parameterization,\r\n *   * u is around the minor hoop, with (0..1) mapping to phi of (0 degrees ..360 degrees)\r\n *   * v is along the major hoop with (0..1) mapping to theta of (0 .. sweep)\r\n *   * a constant v section is a full circle\r\n *   * a constant u section is an arc with sweep angle matching the torusPipe sweep angle.\r\n * @public\r\n */\r\nexport class TorusPipe extends SolidPrimitive implements UVSurface, UVSurfaceIsoParametricDistance {\r\n  private _localToWorld: Transform;\r\n  private _radiusA: number;  // radius of (large) circle in xy plane\r\n  private _radiusB: number;  // radius of (small) circle in xz plane.\r\n  private _sweep: Angle;\r\n  private _isReversed: boolean;\r\n\r\n  protected constructor(map: Transform, radiusA: number, radiusB: number, sweep: Angle, capped: boolean) {\r\n    super(capped);\r\n    this._localToWorld = map;\r\n    this._radiusA = radiusA;\r\n    this._radiusB = radiusB;\r\n    this._sweep = sweep;\r\n    this._isReversed = false;\r\n  }\r\n  /** return a copy of the TorusPipe */\r\n  public clone(): TorusPipe {\r\n    const result = new TorusPipe(this._localToWorld.clone(), this._radiusA, this._radiusB, this._sweep.clone(), this.capped);\r\n    result._isReversed = this._isReversed;\r\n    return result;\r\n  }\r\n  /** Apply `transform` to the local coordinate system. */\r\n  public tryTransformInPlace(transform: Transform): boolean {\r\n    if (transform.matrix.isSingular())\r\n      return false;\r\n    transform.multiplyTransformTransform(this._localToWorld, this._localToWorld);\r\n    return true;\r\n  }\r\n  /** Clone this TorusPipe and transform the clone */\r\n  public cloneTransformed(transform: Transform): TorusPipe | undefined {\r\n    const result = this.clone();\r\n    transform.multiplyTransformTransform(result._localToWorld, result._localToWorld);\r\n    return result;\r\n  }\r\n  /** Create a new `TorusPipe`\r\n   * @param frame local to world transformation\r\n   * @param majorRadius major hoop radius\r\n   * @param minorRadius minor hoop radius\r\n   * @param sweep sweep angle for major circle, with positive sweep from x axis towards y axis.\r\n   * @param capped true for circular caps\r\n   */\r\n  public static createInFrame(frame: Transform, majorRadius: number, minorRadius: number, sweep: Angle, capped: boolean): TorusPipe | undefined {\r\n    // force near-zero radii to true zero\r\n    majorRadius = Math.abs(Geometry.correctSmallMetricDistance(majorRadius));\r\n    minorRadius = Math.abs(Geometry.correctSmallMetricDistance(minorRadius));\r\n    if (majorRadius < minorRadius) return undefined;\r\n    if (majorRadius === 0.0) return undefined;\r\n    if (minorRadius === 0.0) return undefined;\r\n\r\n    if (sweep.isAlmostZero) return undefined;\r\n    const xScale = 1.0;\r\n    let yScale = 1.0;\r\n    let zScale = 1.0;\r\n    if (frame.matrix.determinant() < 0.0) zScale *= -1.0;\r\n    let isReversed = false;\r\n    const sweep1 = sweep.clone();\r\n    if (sweep.radians < 0.0) {\r\n      sweep1.setRadians(-sweep.radians);\r\n      zScale *= -1.0;\r\n      yScale *= -1.0;\r\n      isReversed = true;\r\n    }\r\n    const frame1 = frame.clone();\r\n    frame1.matrix.scaleColumns(xScale, yScale, zScale, frame1.matrix);\r\n    const result = new TorusPipe(frame1, majorRadius, minorRadius, sweep1, capped);\r\n    result._isReversed = isReversed;\r\n    return result;\r\n  }\r\n\r\n  /** Create a TorusPipe from the typical parameters of the Dgn file */\r\n  public static createDgnTorusPipe(center: Point3d, vectorX: Vector3d, vectorY: Vector3d, majorRadius: number, minorRadius: number,\r\n    sweep: Angle, capped: boolean) {\r\n    const vectorZ = vectorX.crossProduct(vectorY);\r\n    vectorZ.scaleToLength(vectorX.magnitude(), vectorZ);\r\n    const frame = Transform.createOriginAndMatrixColumns(center, vectorX, vectorY, vectorZ);\r\n    return TorusPipe.createInFrame(frame, majorRadius, minorRadius, sweep, capped);\r\n  }\r\n  /** Return a coordinate frame (right handed, unit axes)\r\n   * * origin at center of major circle\r\n   * * major circle in xy plane\r\n   * * z axis perpendicular\r\n   */\r\n  public getConstructiveFrame(): Transform | undefined {\r\n    return this._localToWorld.cloneRigid();\r\n  }\r\n  /** Return the center of the torus pipe (inside the donut hole) */\r\n  public cloneCenter(): Point3d { return this._localToWorld.getOrigin(); }\r\n  /** return the vector along the x axis (in the major hoops plane) */\r\n  public cloneVectorX(): Vector3d { return this._localToWorld.matrix.columnX(); }\r\n  /** return the vector along the y axis (in the major hoop plane) */\r\n  public cloneVectorY(): Vector3d { return this._localToWorld.matrix.columnY(); }\r\n  /** get the minor hoop radius (`radiusA`) */\r\n  public getMinorRadius(): number { return this._radiusB; }\r\n  /** get the major hoop radius (`radiusB`) */\r\n  public getMajorRadius(): number { return this._radiusA; }\r\n  /** get the sweep angle along the major circle. */\r\n  public getSweepAngle(): Angle { return this._sweep.clone(); }\r\n  /** Ask if this TorusPipe is labeled as reversed */\r\n  public getIsReversed(): boolean { return this._isReversed; }\r\n  /** Return the sweep angle as a fraction of full 360 degrees (2PI radians) */\r\n  public getThetaFraction(): number { return this._sweep.radians / (Math.PI * 2.0); }\r\n  /** ask if `other` is an instance of `TorusPipe` */\r\n  public isSameGeometryClass(other: any): boolean { return other instanceof TorusPipe; }\r\n  /** test if `this` and `other` have nearly equal geometry */\r\n  public isAlmostEqual(other: GeometryQuery): boolean {\r\n    if (other instanceof TorusPipe) {\r\n      if (this.capped !== other.capped) return false;\r\n      if (!this._localToWorld.isAlmostEqual(other._localToWorld)) return false;\r\n      return Geometry.isSameCoordinate(this._radiusA, other._radiusA)\r\n        && Geometry.isSameCoordinate(this._radiusB, other._radiusB)\r\n        && this._sweep.isAlmostEqualNoPeriodShift(other._sweep);\r\n    }\r\n    return false;\r\n  }\r\n  /** Return the angle (in radians) for given fractional position around the major hoop.\r\n   */\r\n  public vFractionToRadians(v: number): number { return this._sweep.radians * v; }\r\n  /** Second step of double dispatch:  call `handler.handleTorusPipe(this)` */\r\n  public dispatchToGeometryHandler(handler: GeometryHandler): any {\r\n    return handler.handleTorusPipe(this);\r\n  }\r\n\r\n  /**\r\n   * Return the Arc3d section at vFraction.  For the TorusPipe, this is a minor circle.\r\n   * @param vFraction fractional position along the sweep direction\r\n   */\r\n  public constantVSection(v: number): CurveCollection | undefined {\r\n    const thetaRadians = this.vFractionToRadians(v);\r\n    const c0 = Math.cos(thetaRadians);\r\n    const s0 = Math.sin(thetaRadians);\r\n    const majorRadius = this.getMajorRadius();\r\n    const minorRadius = this.getMinorRadius();\r\n\r\n    const center = this._localToWorld.multiplyXYZ(majorRadius * c0, majorRadius * s0, 0);\r\n    const vector0 = this._localToWorld.multiplyVectorXYZ(minorRadius * c0, minorRadius * s0, 0);\r\n    const vector90 = this._localToWorld.multiplyVectorXYZ(0, 0, minorRadius);\r\n    return Loop.create(Arc3d.create(center, vector0, vector90) as Arc3d);\r\n  }\r\n  /** Return an arc at constant u, and arc sweep  matching this TorusPipe sweep. */\r\n  public constantUSection(uFraction: number): CurveCollection | undefined {\r\n    const theta1Radians = this._sweep.radians;\r\n    const phiRadians = uFraction * Math.PI;\r\n\r\n    const majorRadius = this.getMajorRadius();\r\n    const minorRadius = this.getMinorRadius();\r\n    const transform = this._localToWorld;\r\n    const axes = transform.matrix;\r\n    const center = this._localToWorld.multiplyXYZ(0, 0, minorRadius * Math.sin(phiRadians));\r\n    const rxy = majorRadius + minorRadius * Math.cos(phiRadians);\r\n    const vector0 = axes.multiplyXYZ(rxy, 0, 0);\r\n    const vector90 = axes.multiplyXYZ(0, rxy, 0);\r\n    return Path.create(Arc3d.create(center, vector0, vector90, AngleSweep.createStartEndRadians(0.0, theta1Radians)) as Arc3d);\r\n  }\r\n  /** extend `rangeToExtend` to include this `TorusPipe` */\r\n  public extendRange(rangeToExtend: Range3d, transform?: Transform) {\r\n    const theta1Radians = this._sweep.radians;\r\n    const majorRadius = this.getMajorRadius();\r\n    const minorRadius = this.getMinorRadius();\r\n    const transform0 = this._localToWorld;\r\n    const numThetaSample = Math.ceil(theta1Radians / (Math.PI / 16.0));\r\n    const numHalfPhiSample = 16;\r\n    let phi0 = 0;\r\n    let dphi = 0;\r\n    let numPhiSample = 0;\r\n    let theta = 0;\r\n    let cosTheta = 0;\r\n    let sinTheta = 0;\r\n    let rxy = 0;\r\n    let phi = 0;\r\n    let j = 0;\r\n    const dTheta = theta1Radians / numThetaSample;\r\n    for (let i = 0; i <= numThetaSample; i++) {\r\n      theta = i * dTheta;\r\n      cosTheta = Math.cos(theta);\r\n      sinTheta = Math.sin(theta);\r\n      // At the ends, do the entire phi circle.\r\n      // Otherwise only do the outer half\r\n      if (i === 0 || i === numThetaSample) {\r\n        phi0 = -Math.PI;\r\n        dphi = 2.0 * Math.PI / numHalfPhiSample;\r\n        numPhiSample = numHalfPhiSample;\r\n      } else {\r\n        phi0 = -0.5 * Math.PI;\r\n        dphi = Math.PI / numHalfPhiSample;\r\n        numPhiSample = 2 * numHalfPhiSample - 1;\r\n      }\r\n      if (transform) {\r\n        for (j = 0; j <= numPhiSample; j++) {\r\n          phi = phi0 + j * dphi;\r\n          rxy = majorRadius + minorRadius * Math.cos(phi);\r\n          rangeToExtend.extendTransformTransformedXYZ(transform, transform0,\r\n            cosTheta * rxy, sinTheta * rxy,\r\n            Math.sin(phi) * minorRadius);\r\n        }\r\n      } else {\r\n        for (j = 0; j <= numPhiSample; j++) {\r\n          phi = phi0 + j * dphi;\r\n          rxy = majorRadius + minorRadius * Math.sin(phi);\r\n          rangeToExtend.extendTransformedXYZ(transform0,\r\n            cosTheta * rxy, sinTheta * rxy,\r\n            Math.sin(phi) * minorRadius);\r\n        }\r\n      }\r\n    }\r\n  }\r\n  /** Evaluate as a uv surface\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPoint(u: number, v: number, result?: Point3d): Point3d {\r\n    const thetaRadians = v * this._sweep.radians;\r\n    const phiRadians = u * Math.PI * 2.0;\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const minorRadius = this.getMinorRadius();\r\n    const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;\r\n    return this._localToWorld.multiplyXYZ(rxy * cosTheta, rxy * sinTheta, minorRadius * Math.sin(phiRadians), result);\r\n  }\r\n  /** Evaluate as a uv surface, returning point and two vectors.\r\n   * @param u fractional position in minor (phi)\r\n   * @param v fractional position on major (theta) arc\r\n   */\r\n  public uvFractionToPointAndTangents(u: number, v: number, result?: Plane3dByOriginAndVectors): Plane3dByOriginAndVectors {\r\n    const thetaRadians = v * this._sweep.radians;\r\n    const phiRadians = u * Math.PI * 2.0;\r\n    const fTheta = this._sweep.radians;\r\n    const fPhi = Math.PI * 2.0;\r\n    const cosTheta = Math.cos(thetaRadians);\r\n    const sinTheta = Math.sin(thetaRadians);\r\n    const sinPhi = Math.sin(phiRadians);\r\n    const cosPhi = Math.cos(phiRadians);\r\n    const minorRadius = this.getMinorRadius();\r\n    const rxy = this.getMajorRadius() + Math.cos(phiRadians) * minorRadius;\r\n    const rSinPhi = minorRadius * sinPhi;\r\n    const rCosPhi = minorRadius * cosPhi;   // appears only as derivative of rSinPhi.\r\n    return Plane3dByOriginAndVectors.createOriginAndVectors(\r\n      this._localToWorld.multiplyXYZ(cosTheta * rxy, sinTheta * rxy, rSinPhi),\r\n      this._localToWorld.multiplyVectorXYZ(-cosTheta * rSinPhi * fPhi, -sinTheta * rSinPhi * fPhi, rCosPhi * fPhi),\r\n      this._localToWorld.multiplyVectorXYZ(-rxy * sinTheta * fTheta, rxy * cosTheta * fTheta, 0),\r\n      result);\r\n  }\r\n  /**\r\n   * Directional distance query\r\n   * * u direction is around the (full) minor hoop\r\n   * * v direction is around the outer radius, sum of (absolute values of) major and minor radii.\r\n   */\r\n  public maxIsoParametricDistance(): Vector2d {\r\n    const a = Math.abs(this.getMajorRadius());\r\n    const b = Math.abs(this.getMinorRadius());\r\n    return Vector2d.create(b * Math.PI * 2.0, (a + b) * this._sweep.radians);\r\n  }\r\n  /**\r\n   * @return true if this is a closed volume.\r\n   */\r\n  public get isClosedVolume(): boolean {\r\n    return this.capped || this._sweep.isFullCircle;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { Vector2d, Point2d } from \"../geometry3d/Point2dVector2d\";\nimport { Point3d, Vector3d } from \"../geometry3d/Point3dVector3d\";\nimport { LineSegment3d } from \"../curve/LineSegment3d\";\nimport { Geometry } from \"../Geometry\";\nimport { SmallSystem } from \"../numerics/Polynomials\";\n/** function signature for function of one node with no return type restrictions\n * @internal\n */\nexport type NodeFunction = (node: HalfEdge) => any;\n/** function signature for function of one node, returning a number\n * @internal\n */\nexport type NodeToNumberFunction = (node: HalfEdge) => number;\n/** function signature for function of one node, returning a boolean\n * @internal\n */\nexport type HalfEdgeToBooleanFunction = (node: HalfEdge) => boolean;\n/** function signature for function of a node and a mask, returning a number\n * @internal\n */\nexport type HalfEdgeAndMaskToBooleanFunction = (node: HalfEdge, mask: HalfEdgeMask) => boolean;\n/** function signature for function of a graph and a node, returning a boolean\n * @internal\n */\nexport type GraphNodeFunction = (graph: HalfEdgeGraph, node: HalfEdge) => boolean;\n/**\n *\n * * A HalfEdge is \"one side of an edge\" in a structure of faces, edges and vertices.  From a node there are navigational links to:\n * ** \"faceSuccessor\" -- the next half edge in a loop around a face.\n * ** \"facePredecessor\" -- the previous half edge in a loop around a face.\n * ** \"edgeMate\"  -- the node's partner on the other side of the edge.\n * * The next, prev, and mate are the essential connectivity.  Additional node content is for application-specific\n *     uses.  The most useful ones are:\n * ** x,y -- coordinates in the xy plane\n * ** z -- z coordinate.  This is normally ignored during planar setup, but used for output.\n * ** buffer -- a integer value manipulated as individual bits.\n * * In properly connected planar graph, interior face loops are counterclockwise.  But that property (along with\n *      expected masking) is a result of extensive validation of inputs, and is not true in intermediate phases\n *      of graph manipulation.\n * @internal\n */\nexport class HalfEdge {\n  /** Vertex index in some parent object's numbering. */\n  public i: number;\n  /** bitmask bits, used to mark nodes as part of a triangle(idx 0) or visited when flipping(idx 1) */\n  public maskBits: number;\n  /** Vertex x coordinate */\n  public x: number;\n  /** Vertex y coordinate */\n  public y: number;\n  /** Vertex z coordinate */\n  public z: number;\n  /** angle used for sort-around-vertex */\n  public sortAngle?: number;  // used in sorting around vertex.\n\n  private _id: any;   // immutable id useful for debugging.\n  /** id assigned sequentially during construction --- useful for debugging. */\n  public get id() { return this._id; }\n\n  private _facePredecessor!: HalfEdge;\n  private _faceSuccessor!: HalfEdge;\n  private _edgeMate!: HalfEdge;\n  /** previous half edge \"around the face\"\n   */\n  public get facePredecessor(): HalfEdge { return this._facePredecessor; }\n  /** next half edge \"around the face\" */\n  public get faceSuccessor(): HalfEdge { return this._faceSuccessor; }\n  /** Half edge on the other side of this edge.\n   */\n  public get edgeMate(): HalfEdge { return this._edgeMate; }\n  /** Take numStep face steps and return y coordinate\n   * * positive steps are through faceSuccessor\n   * * negative steps are through facePredecessor\n   */\n  public faceStepY(numStep: number): number {\n    let node: HalfEdge = this;\n    if (numStep > 0)\n      for (let i = 0; i < numStep; i++) node = node.faceSuccessor;\n    else if (numStep < 0)\n      for (let i = 0; i > numStep; i++) node = node.facePredecessor;\n    return node.y;\n  }\n  /**\n   * * Create 2 half edges.\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * @returns Returns the reference to the first half edge created\n   */\n  public static createHalfEdgePair(heArray: HalfEdge[] | undefined): HalfEdge {\n    const a = new HalfEdge();\n    const b = new HalfEdge();\n    if (heArray) {\n      heArray.push(a);\n      heArray.push(b);\n    }\n\n    HalfEdge.setFaceLinks(a, b);\n    HalfEdge.setFaceLinks(b, a);\n    HalfEdge.setEdgeMates(a, b);\n    return a;\n  }\n\n  /**\n   * * Create 2 half edges.\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * * Properties x,y,z,i are inserted in each\n   * @returns Returns the reference to the first half edge created\n   */\n  public static createHalfEdgePairWithCoordinates(\n    xA: number = 0,\n    yA: number = 0,\n    zA: number = 0,\n    iA: number = 0,\n    xB: number = 0,\n    yB: number = 0,\n    zB: number = 0,\n    iB: number = 0,\n    heArray: HalfEdge[] | undefined): HalfEdge {\n    const a = HalfEdge.createHalfEdgePair(heArray);\n    const b = a._edgeMate;\n    a.x = xA; a.y = yA; a.z = zA; a.i = iA;\n    b.x = xB; b.y = yB; b.z = zB; b.i = iB;\n    return a;\n  }\n  /**\n   * * set heA <==> heB pointer relation through heA._faceSuccessor and heB._facePredecessor\n   * * This changes heA._faceSuccessor and heB._facePredecessor, but not heA._facePredecessor and heB._faceSuccessor.\n   * * this must always be done with another call to restablish the entire double-linked list.\n   */\n  private static setFaceLinks(heA: HalfEdge, heB: HalfEdge) {\n    heA._faceSuccessor = heB;\n    heB._facePredecessor = heA;\n  }\n  /**\n   * * set heA <==> heB pointer relation edgeMate\n   */\n  private static setEdgeMates(heA: HalfEdge, heB: HalfEdge) {\n    heA._edgeMate = heB;\n    heB._edgeMate = heA;\n  }\n\n  /**\n   * * Create a new vertex within the edge from base.\n   * * Insert it \"within\" the base edge.\n   * * This requires two new half edges.\n   * * if the base is undefined, create a single-edge loop.\n   * * This (unlike pinch) breaks the edgeMate pairing of the base edge.\n   * * This preserves xyzi properties at all existing vertices.\n   * @returns Returns the reference to the half edge created.\n   */\n  public static splitEdge(base: undefined | HalfEdge,\n    xA: number = 0, yA: number = 0, zA: number = 0, iA: number = 0, heArray: HalfEdge[] | undefined): HalfEdge {\n    const newA = new HalfEdge(xA, yA, zA, iA);\n    const newB = new HalfEdge(xA, yA, zA, iA);\n    if (heArray) {\n      heArray.push(newA);\n      heArray.push(newB);\n    }\n\n    if (base === undefined) {\n      newA._faceSuccessor = newA._facePredecessor = newA;\n      newB._faceSuccessor = newB._facePredecessor = newB;\n      HalfEdge.setEdgeMates(newA, newB);\n    } else {\n      const nextA = base._faceSuccessor;\n      const mateA = base._edgeMate;\n      const vpredA = mateA._faceSuccessor;\n      HalfEdge.setFaceLinks(newA, nextA);\n      HalfEdge.setFaceLinks(base, newA);\n      HalfEdge.setFaceLinks(mateA, newB);\n      HalfEdge.setFaceLinks(newB, vpredA);\n      HalfEdge.setEdgeMates(newA, mateA);\n      HalfEdge.setEdgeMates(newB, base);\n    }\n    return newA;\n  }\n\n  private static _totalNodesCreated = 0;\n  public constructor(x: number = 0, y: number = 0, z: number = 0, i: number = 0) {\n    this._id = HalfEdge._totalNodesCreated++;\n    this.i = i;\n    this.maskBits = 0x00000000;\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    // Other variables are by default undefined\n  }\n\n  /**\n   * Return the next outbound half edge around this vertex in the CCW direction\n   */\n  get vertexSuccessor(): HalfEdge { return this.facePredecessor.edgeMate; }\n  /**\n   * Return the next outbound half edge around this vertex in the CW direction\n   */\n  get vertexPredecessor(): HalfEdge { return this.edgeMate.faceSuccessor; }\n  /**\n   * Set mask bits on this HalfEdge\n   * @param mask mask to apply\n   */\n  public setMask(mask: HalfEdgeMask) { this.maskBits |= mask; }\n  /**\n   * Get mask bits from this HalfEdge\n   * @param mask mask to query\n   */\n  public getMask(mask: HalfEdgeMask): number { return (this.maskBits & mask); }\n\n  /**\n   * Clear mask bits from this HalfEdge\n   * @param mask mask to clear\n   */\n  public clearMask(mask: HalfEdgeMask) { this.maskBits &= ~mask; }\n  /**\n   * Set a mask at all nodes around a vertex.\n   * @param mask mask to apply to the half edges around this HalfEdge's vertex loop\n   */\n  public setMaskAroundVertex(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.setMask(mask);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n  }\n\n  /**\n   * Apply a mask to all edges around a face.\n   * @param mask mask to apply to the half edges around this HalfEdge's face loop\n   */\n  public setMaskAroundFace(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.setMask(mask);\n      node = node.faceSuccessor;\n    } while (node !== this);\n  }\n\n  /** Returns the number of edges around this face. */\n  public countEdgesAroundFace(): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    do {\n      count++;\n      node = node.faceSuccessor;\n    } while (node !== this);\n    return count;\n  }\n\n  /** Returns the number of edges around vertex. */\n  public countEdgesAroundVertex(): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    do {\n      count++;\n      node = node.vertexSuccessor;\n    } while (node !== this);\n    return count;\n  }\n\n  /** Returns the number of nodes found with the given mask value around this vertex loop. */\n  public countMaskAroundFace(mask: HalfEdgeMask, value: boolean = true): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    if (value) {\n      do {\n        if (node.isMaskSet(mask)) count++;\n        node = node.faceSuccessor;\n      } while (node !== this);\n    } else {\n      do {\n        if (!node.isMaskSet(mask)) count++;\n        node = node.faceSuccessor;\n      } while (node !== this);\n    }\n    return count;\n  }\n\n  /** Returns the number of nodes found with the given mask value around this vertex loop.   */\n  public countMaskAroundVertex(mask: HalfEdgeMask, value: boolean = true): number {\n    let count = 0;\n    let node: HalfEdge = this;\n    if (value) {\n      do {\n        if (node.isMaskSet(mask)) count++;\n        node = node.vertexSuccessor;\n      } while (node !== this);\n    } else {\n      do {\n        if (!node.isMaskSet(mask)) count++;\n        node = node.vertexSuccessor;\n      } while (node !== this);\n    }\n    return count;\n  }\n\n  /** Set a mask, and return prior value.\n   * @param mask mask to apply\n   */\n  public testAndSetMask(mask: HalfEdgeMask): number {\n    const oldMask = this.maskBits & mask;\n    this.maskBits |= mask;\n    return oldMask;\n  }\n  /**\n   * Test if mask bits are set in the node's bitMask.\n   * @return Return true (as a simple boolean, not a mask) if any bits of the mask parameter match bits of the node's bitMask\n   */\n  public isMaskSet(mask: HalfEdgeMask): boolean { return (this.maskBits & mask) !== 0; }\n\n  /** (static!) method to test if a mask is set on a node.\n   * This is used as filter in searches.\n   * @returns true iff `node.isMaskSet (mask)`\n   */\n  public static filterIsMaskOn(node: HalfEdge, mask: HalfEdgeMask): boolean {\n    return node.isMaskSet(mask);\n  }\n  /** (static!) method to test if a mask is set on a node.\n   * This is used as filter in searches.\n   * @returns true iff `!node.isMaskSet (mask)`\n   */\n  public static filterIsMaskOff(node: HalfEdge, mask: HalfEdgeMask): boolean {\n    return !node.isMaskSet(mask);\n  }\n\n  /**\n   * Create an edge with initial id,x,y at each end.\n   * @param id0 id for first node\n   * @param x0  x coordinate for first node\n   * @param y0  y coordinate for first node\n   * @param id1 id for second node\n   * @param x1 x coordinate for second node\n   * @param y1 y coordinate for second node\n   */\n  public static createEdgeXYXY(id0: any, x0: number, y0: number, id1: any, x1: number, y1: number): HalfEdge {\n    const node0 = new HalfEdge(x0, y0);\n    const node1 = new HalfEdge(x1, y1);\n    node0._faceSuccessor = node0._facePredecessor = node0._edgeMate = node1;\n    node1._faceSuccessor = node1._facePredecessor = node1._edgeMate = node0;\n    node0._id = id0;\n    node1._id = id1;\n    return node0;\n  }\n\n  /** \"pinch\" ...\n   *\n   * * is the universal manipulator for manipulating a node's next and prev pointers\n   * * swaps face predecessors of nodeA and nodeB.\n   * *  is its own inverse.\n   * *  if nodeA, nodeB are in different face loops, the loops join to one loop.\n   * *  if nodeA, nodeB are in the same face loop, the loop splits into two loops.\n   */\n  public static pinch(nodeA: HalfEdge, nodeB: HalfEdge) {\n    if (nodeA !== nodeB) {\n      const predA = nodeA._facePredecessor;\n      const predB = nodeB._facePredecessor;\n      nodeB._facePredecessor = predA;\n      nodeA._facePredecessor = predB;\n      predB._faceSuccessor = nodeA;\n      predA._faceSuccessor = nodeB;\n    }\n  }\n\n  /** Turn all pointers to undefined so garbage collector can reuse the object.\n   *  This is to be called only by a Graph object that is being decommissioned.\n   */\n  public decommission() {\n    (this._facePredecessor as any) = undefined;\n    (this._faceSuccessor as any) = undefined;\n    (this._edgeMate as any) = undefined;\n  }\n\n  /** Return the node. This identity function is useful as the NodeFunction in collector methods. */\n  public static nodeToSelf(node: HalfEdge): any { return node; }\n  /** Return the id of a node.  Useful for collector methods. */\n  public static nodeToId(node: HalfEdge): any { return node.id; }\n  /** Return the id of a node.Useful for collector methods. */\n  public static nodeToIdString(node: HalfEdge): any { return node.id.toString(); }\n\n  /** Return the [id, [x,y]] of a node.  Useful for collector methods. */\n  public static nodeToIdMaskXY(node: HalfEdge): { id: any, mask: any, xy: number[] } {\n    return { id: node.id, mask: HalfEdge.nodeToMaskString(node), xy: [node.x, node.y] };\n  }\n\n  /** Return the [id, [x,y]] of a node.  Useful for collector methods. */\n  public static nodeToIdXYString(node: HalfEdge): string {\n    const s = node.id.toString() + \" \" +\n      HalfEdge.nodeToMaskString(node) + \" [\" + node.x + \",\" + node.y + \"]\";\n    return s;\n  }\n\n  /** Create a string representation of the mask\n   * * Null mask is empty string.\n   * * Appended characters B,P,X for Boundary, Primary, Exterior mask bits.\n   */\n  public static nodeToMaskString(node: HalfEdge): string {\n    let s = \"\";\n    if (node.isMaskSet(HalfEdgeMask.BOUNDARY_EDGE)) s += \"B\";\n    if (node.isMaskSet(HalfEdgeMask.PRIMARY_EDGE)) s += \"P\";\n    if (node.isMaskSet(HalfEdgeMask.EXTERIOR)) s += \"X\";\n    return s;\n  }\n  /** Return [x,y] with coordinates of node */\n  public static nodeToXY(node: HalfEdge): number[] { return [node.x, node.y]; }\n  /** Return Vector2d to face successor, with only xy coordinates */\n  public vectorToFaceSuccessorXY(result?: Vector2d): Vector2d {\n    return Vector2d.create(this.faceSuccessor.x - this.x, this.faceSuccessor.y - this.y, result);\n  }\n  /** Return Vector3d to face successor */\n  public vectorToFaceSuccessor(result?: Vector3d): Vector3d {\n    return Vector3d.create(\n      this.faceSuccessor.x - this.x,\n      this.faceSuccessor.y - this.y,\n      this.faceSuccessor.z - this.z,\n      result);\n  }\n\n  /** Returns true if the node does NOT have Mask.EXTERIOR_MASK set. */\n  public static testNodeMaskNotExterior(node: HalfEdge) { return !node.isMaskSet(HalfEdgeMask.EXTERIOR); }\n\n  /** Return true if x and y coordinates of this and other are exactly equal */\n  public isEqualXY(other: HalfEdge): boolean {\n    return this.x === other.x && this.y === other.y;\n  }\n\n  /** Return true if x and y coordinates of this and other are exactly equal */\n  public distanceXY(other: HalfEdge): number {\n    return Geometry.distanceXYXY(this.x, this.y, other.x, other.y);\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each node around a face loop.\n   * * Collect the function values.\n   * @returns Return the array of function values.\n   */\n  public collectAroundFace(f?: NodeFunction): any[] {\n    const nodes = [];\n    let node: HalfEdge = this;\n    do {\n      nodes.push(f ? f(node) : node);\n      node = node.faceSuccessor;\n    } while (node !== this);\n    return nodes;\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each outbound node around this node's vertex loop.\n   * * Collect the function values.\n   * @returns Return the array of function values.\n   */\n  public collectAroundVertex(f?: NodeFunction): any[] {\n    const nodes = [];\n    let node: HalfEdge = this;\n    do {\n      nodes.push(f ? f(node) : node);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n    return nodes;\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each node around a face loop.\n   * * Sum the function values\n   * @returns Return the sum\n   */\n  public sumAroundFace(f: NodeToNumberFunction): number {\n    let node: HalfEdge = this;\n    let sum = 0;\n    do {\n      sum += f(node);\n      node = node.faceSuccessor;\n    } while (node !== this);\n    return sum;\n  }\n\n  /**\n   *\n   * * Evaluate f(node) at each outbound node around this node's vertex loop.\n   * * Sum the function values\n   * @returns Return the sum\n   */\n  public sumAroundVertex(f: NodeToNumberFunction): number {\n    let node: HalfEdge = this;\n    let sum = 0;\n    do {\n      sum += f(node);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n    return sum;\n  }\n  /** For all the nodes in the face loop of the given node, clear out the mask given */\n  public clearMaskAroundFace(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.clearMask(mask);\n      node = node.faceSuccessor;\n    } while (node !== this);\n  }\n\n  /** For all the nodes in the vertex loop of the given node, clear out the mask given */\n  public clearMaskAroundVertex(mask: HalfEdgeMask) {\n    let node: HalfEdge = this;\n    do {\n      node.clearMask(mask);\n      node = node.vertexSuccessor;\n    } while (node !== this);\n  }\n  /** Returns the signed sum of xy areas of triangles from first node to edges.\n   *\n   * * A positive area is counterclockwise.\n   * * A negative area is clockwise.\n   */\n  public signedFaceArea(): number {\n    let sum = 0;\n    // sum area of trapezoids.\n    // * the formula in the loop gives twice the area (because it does nto average the y values).\n    // * this is fixed up at the end by a single multiply by 0.5\n    // * individual trapezoid heights are measured from y at the start node to keep area values numerical smaller.\n    const y0 = this.y;\n    let dy0 = 0.0;\n    let dy1 = 0.0;\n    let x0 = this.x;\n    let x1 = x0;\n    let node1: HalfEdge = this;  // just to initialize -- reassigned in each loop pass.\n    let node0: HalfEdge = this;\n    do {\n      node1 = node0.faceSuccessor;\n      x1 = node1.x;\n      dy1 = node1.y - y0;\n      sum += (x0 - x1) * (dy0 + dy1);\n      x0 = x1;\n      dy0 = dy1;\n      node0 = node1;\n      node0 = node1;\n    } while (node0 !== this);\n    return 0.5 * sum;\n  }\n  /**\n   * interpolate xy coordinates between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   * @param result xy coordinates\n   */\n  public fractionToPoint2d(fraction: number, result?: Point2d): Point2d {\n    const node1 = this.faceSuccessor;\n    return Point2d.create(\n      this.x + (node1.x - this.x) * fraction,\n      this.y + (node1.y - this.y) * fraction,\n      result);\n  }\n  /**\n   * * interpolate xy coordinates at fractionAlong between this node and its face successor.\n   * * shift to left by fractionPerpendicular\n   * @param fraction fractional position along this edge.\n   * @param result xy coordinates\n   */\n  public fractionAlongAndPerpendicularToPoint2d(fractionAlong: number, fractionPerpendicular: number, result?: Point2d): Point2d {\n    const node1 = this.faceSuccessor;\n    const dx = node1.x - this.x;\n    const dy = node1.y - this.y;\n    return Point2d.create(\n      this.x + dx * fractionAlong - dy * fractionPerpendicular,\n      this.y + dy * fractionAlong + dx * fractionPerpendicular,\n      result);\n  }\n\n  /**\n   * Return the interpolated x coordinate between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   */\n  public fractionToX(fraction: number): number {\n    const node1 = this.faceSuccessor;\n    return this.x + (node1.x - this.x) * fraction;\n  }\n  /**\n   * Return the interpolated x coordinate between this node and its face successor.\n   * @param fraction fractional position along this edge.\n   */\n  public fractionToY(fraction: number): number {\n    const node1 = this.faceSuccessor;\n    return this.y + (node1.y - this.y) * fraction;\n  }\n\n  /**\n   * * Compute fractional coordinates of the intersection of edges from given base nodes\n   * * If parallel or colinear, return undefined.\n   * * If (possibly extended) lines intersect, return the fractions of intersection as x,y in the result.\n   * @param nodeA0 Base node of edge A\n   * @param nodeB0 Base node of edge B\n   * @param result optional preallocated result\n   */\n  public static transverseIntersectionFractions(nodeA0: HalfEdge, nodeB0: HalfEdge, result?: Vector2d): Vector2d | undefined {\n    const nodeA1 = nodeA0.faceSuccessor;\n    const nodeB1 = nodeB0.faceSuccessor;\n    if (!result)\n      result = Vector2d.create();\n    if (SmallSystem.linearSystem2d(\n      nodeA1.x - nodeA0.x, nodeB0.x - nodeB1.x,\n      nodeA1.y - nodeA0.y, nodeB0.y - nodeB1.y,\n      nodeB0.x - nodeA0.x, nodeB0.y - nodeA0.y,\n      result))\n      return result;\n    return undefined;\n  }\n  /**\n   * * Compute fractional coordinates of the intersection of a horizontal line with an edge.\n   * * If the edge is horizontal with (approximate) identical y, return the node.\n   * * If the edge is horizontal with different y, return undefined.\n   * * If the edge is not horizontal, return the fractional position (possibly outside 0..1) of the intersection.\n   * @param nodeA Base node of edge\n   * @param result optional preallocated result\n   */\n  public static horizontalScanFraction(node0: HalfEdge, y: number): number | undefined | HalfEdge {\n    const node1 = node0.faceSuccessor;\n    const dy = node1.y - node0.y;\n    if (Geometry.isSameCoordinate(y, node0.y) && Geometry.isSameCoordinate(y, node1.y))\n      return node0;\n    if (Geometry.isSameCoordinate(dy, 0.0))\n      return undefined;\n    return Geometry.conditionalDivideFraction(y - node0.y, dy);\n  }\n\n  /**\n   * * Compute fractional coordinates of the intersection of a horizontal line with an edge.\n   * * If the edge is horizontal return undefined (no test for horizontal at y!!!)\n   * * If the edge is not horizontal and y is between its end y's, return the fraction\n   * @param nodeA Base node of edge\n   * @param result optional preallocated result\n   */\n  public static horizontalScanFraction01(node0: HalfEdge, y: number): number | undefined {\n    const node1 = node0.faceSuccessor;\n    const dy = node1.y - node0.y;\n    if (Geometry.isSameCoordinate(y, node0.y) && Geometry.isSameCoordinate(y, node1.y))\n      return undefined;\n    if (Geometry.isSameCoordinate(dy, 0.0))\n      return undefined;\n    const fraction = Geometry.conditionalDivideFraction(y - node0.y, dy);\n    if (fraction !== undefined && fraction >= 0.0 && fraction <= 1.0)\n      return fraction;\n    return undefined;\n  }\n}\n/**\n * A HalfEdgeGraph has:\n * * An array of (pointers to ) HalfEdge objects.\n * @internal\n */\nexport class HalfEdgeGraph {\n  /** Simple array with pointers to all the half edges in the graph. */\n  public allHalfEdges: HalfEdge[];\n  private _numNodesCreated = 0;\n  public constructor() {\n    this.allHalfEdges = [];\n  }\n  /**\n   * * Create 2 half edges forming 2 vertices, 1 edge, and 1 face\n   * * The two edges are joined as edgeMate pair.\n   * * The two edges are a 2-half-edge face loop in both the faceSuccessor and facePredecessor directions.\n   * * The two edges are added to the graph's HalfEdge set\n   * @returns Return pointer to the first half edge created.\n   */\n  public createEdgeXYZXYZ(\n    xA: number = 0,\n    yA: number = 0,\n    zA: number = 0,\n    iA: number = 0,\n    xB: number = 0,\n    yB: number = 0,\n    zB: number = 0,\n    iB: number = 0): HalfEdge {\n    const a = HalfEdge.createHalfEdgePairWithCoordinates(xA, yA, zA, iA, xB, yB, zB, iB, this.allHalfEdges);\n    return a;\n  }\n\n  /**\n   * * Insert a vertex in the edge beginning at base.\n   * * this creates two half edges.\n   * * The base of the new edge is 'after' the (possibly undefined) start node in its face loop.\n   * * The existing mate retains its base xyzi properties but is no longer the mate of base.\n   * * The base and existing mate each become mates with a new half edge.\n   * @returns Returns the reference to the half edge created.\n   */\n  public splitEdge(base: undefined | HalfEdge,\n    xA: number = 0, yA: number = 0, zA: number = 0, iA: number = 0): HalfEdge {\n    const he = HalfEdge.splitEdge(base, xA, yA, zA, iA, this.allHalfEdges);\n    return he;\n  }\n  /** This is a destructor-like action that eliminates all interconnection among the graph's nodes.\n   * After this is called the graph is unusable.\n   */\n  public decommission() {\n    for (const node of this.allHalfEdges) { node.decommission(); }\n    this.allHalfEdges.length = 0;\n    (this.allHalfEdges as any) = undefined;\n  }\n  /** create two nodes of a new edge.\n   * @returns Return one of the two nodes, which the caller may consider as the start of the edge.\n   */\n  public addEdgeXY(x0: number, y0: number, x1: number, y1: number): HalfEdge {\n    const baseNode = HalfEdge.createEdgeXYXY(this._numNodesCreated, x0, y0, this._numNodesCreated + 1, x1, y1);\n    this._numNodesCreated += 2;\n    this.allHalfEdges.push(baseNode);\n    this.allHalfEdges.push(baseNode.faceSuccessor);\n    return baseNode;\n\n  }\n  /** Clear selected bits in all nodes of the graph. */\n  public clearMask(mask: HalfEdgeMask) {\n    for (const node of this.allHalfEdges)\n      node.maskBits &= ~mask;\n  }\n  /** Set selected bits in all nodes of the graph. */\n  public setMask(mask: HalfEdgeMask) {\n    for (const node of this.allHalfEdges)\n      node.maskBits |= mask;\n  }\n  /** toggle selected bits in all nodes of the graph. */\n  public reverseMask(mask: HalfEdgeMask) {\n    for (const node of this.allHalfEdges) {\n      node.maskBits ^= mask;\n    }\n  }\n  /**\n   * Return the number of nodes that have a specified mask bit set.\n   * @param mask mask to count\n   */\n  public countMask(mask: HalfEdgeMask): number {\n    let n = 0;\n    for (const node of this.allHalfEdges)\n      if (node.isMaskSet(mask))\n        n++;\n    return n;\n  }\n  /** Return an array LineSegment3d.\n   * * The array has one segment per edge\n   * * The coordinates are taken from a node and its face successor.\n   * * On each edge, the line segment start at the HalfEdge with lower id than its edgeMate.\n   */\n  public collectSegments(): LineSegment3d[] {\n    const segments: LineSegment3d[] = [];\n    for (const node of this.allHalfEdges) {\n      if (node.id < node.edgeMate.id)\n        segments.push(LineSegment3d.create(Point3d.create(node.x, node.y), Point3d.create(node.faceSuccessor.x, node.faceSuccessor.y)));\n    }\n    return segments;\n  }\n\n  /** Returns the number of vertex loops in a graph structure */\n  public countVertexLoops(): number {\n    this.clearMask(HalfEdgeMask.VISITED);\n    let count = 0;\n    this.announceVertexLoops((_graph: HalfEdgeGraph, _seed: HalfEdge) => { count++; return true; });\n    return count;\n  }\n\n  /** Returns the number of face loops */\n  public countFaceLoops(): number {\n    this.clearMask(HalfEdgeMask.VISITED);\n    let count = 0;\n    this.announceFaceLoops((_graph: HalfEdgeGraph, _seed: HalfEdge) => { count++; return true; });\n    return count;\n  }\n  /**\n   * Returns the number of face loops satisfying a filter function with mask argument.\n   *\n   */\n  public countFaceLoopsWithMaskFilter(filter: HalfEdgeAndMaskToBooleanFunction, mask: HalfEdgeMask): number {\n    this.clearMask(HalfEdgeMask.VISITED);\n    let count = 0;\n    this.announceFaceLoops((_graph: HalfEdgeGraph, seed: HalfEdge) => {\n      if (filter(seed, mask))\n        count++;\n      return true;\n    });\n    return count;\n  }\n\n  /** Returns an array of nodes, where each node represents a starting point of a face loop.\n   */\n  public collectFaceLoops(): HalfEdge[] {\n    const returnArray: HalfEdge[] = [];\n    this.announceFaceLoops(\n      (_graph: HalfEdgeGraph, node: HalfEdge) => { returnArray.push(node); return true; });\n    return returnArray;\n  }\n\n  /** Returns an array of nodes, where each node represents a starting point of a vertex loop.\n   */\n  public collectVertexLoops(): HalfEdge[] {\n    this.clearMask(HalfEdgeMask.VISITED);\n    const returnArray: HalfEdge[] = [];\n\n    for (const node of this.allHalfEdges) {\n      if (node.getMask(HalfEdgeMask.VISITED))\n        continue;\n      returnArray.push(node);\n      node.setMaskAroundVertex(HalfEdgeMask.VISITED);\n    }\n    return returnArray;\n  }\n\n  /**\n   * * Visit each facet of the graph once.\n   * * Call the announceFace function\n   * * continue search if announceFace(graph, node) returns true\n   * * terminate search if announce face (graph, node) returns false\n   * @param  announceFace function to apply at one node of each face.\n   */\n  public announceFaceLoops(announceFace: GraphNodeFunction) {\n    this.clearMask(HalfEdgeMask.VISITED);\n    for (const node of this.allHalfEdges) {\n      if (node.getMask(HalfEdgeMask.VISITED))\n        continue;\n      node.setMaskAroundFace(HalfEdgeMask.VISITED);\n      if (!announceFace(this, node))\n        break;\n    }\n  }\n\n  /**\n   * * Visit each vertex loop of the graph once.\n   * * Call the announceVertex function\n   * * continue search if announceFace(graph, node) returns true\n   * * terminate search if announce face (graph, node) returns false\n   * @param  announceVertex function to apply at one node of each face.\n   */\n  public announceVertexLoops(announceVertex: GraphNodeFunction) {\n    this.clearMask(HalfEdgeMask.VISITED);\n    for (const node of this.allHalfEdges) {\n      if (node.getMask(HalfEdgeMask.VISITED))\n        continue;\n      node.setMaskAroundVertex(HalfEdgeMask.VISITED);\n      if (!announceVertex(this, node))\n        break;\n    }\n  }\n  /** Return the number of nodes in the graph */\n  public countNodes(): number { return this.allHalfEdges.length; }\n}\n/**\n * * Each node of the graph has a mask member.\n * * The mask member is a number which is used as set of single bit boolean values.\n * * Particular meanings of the various bits are HIGHLY application dependent.\n *   * The EXTERIOR mask bit is widely used to mark nodes that are \"outside\" the active areas\n *   * The PRIMARY_EDGE bit is widely used to indicate linework created directly from input data, hence protected from triangle edge flipping.\n *   * The BOUNDARY bit is widely used to indicate that crossing this edge is a transition from outside to inside.\n *   * VISITED is used locally in many searches.\n *      * Never use VISITED unless the search logic is highy self contained.\n * @internal\n */\nexport enum HalfEdgeMask {\n  /**  Mask commonly set consistently around exterior faces.\n   * * A boundary edge with interior to one side, exterior to the other will have EXTERIOR only on the outside.\n   * * An an edge inserted \"within a purely exterior face\" can yaver EXTERIOR on both MediaStreamAudioDestinationNode[Symbol]\n   * * An interior edges (such as added during triangulation) will have no EXTERIOR bits.\n   */\n  EXTERIOR = 0x00000001,\n  /** Mask commonly set (on both sides) of original geometry edges that are transition from outside from to inside.\n   * * At the moment of creating an edge from primary user boundary loop coordinates, the fact that an edge is BOUNDARY is often clear even though\n   *  there is uncertainty about which side should be EXTERIOR.\n   */\n  BOUNDARY_EDGE = 0x00000002,\n  // REMARK: Various mask names are COMMENTED here for reference to native legacy code.\n  // CONSTU_MASK = 0x00000004,\n  // CONSTV_MASK = 0x00000008,\n  // USEAM_MASK = 0x00000010,\n  // VSEAM_MASK = 0x00000020,\n  // BOUNDARY_VERTEX_MASK = 0x00000040,\n  // PRIMARY_VERTEX_MASK = 0x00000080,\n  /** Mask for use by algorithms. Only use this mask if the graph life cycle is under your control. */\n  WORK_MASK0 = 0x00000040,\n  /** Mask for use by algorithms.  Only use this mask if the graph life cycle is under your control. */\n  WORK_MASK1 = 0x00000080,\n  // DIRECTED_EDGE_MASK = 0x00000100,\n  /** Mask commonly set (on both sides) of original geometry edges, but NOT indicating that the edge is certainly a boundary between outside and inside.\n   * * For instance, if geometry is provided as stray sticks (not loops), it can be marked PRIMARY_EDGE but neither BOUNDARY_EDGE nor EXTERIOR_EDGE\n   */\n  PRIMARY_EDGE = 0x00000200,\n  // HULL_MASK = 0x00000400,\n  // SECTION_EDGE_MASK = 0x00000800,\n  // POLAR_LOOP_MASK = 0x00001000,\n  /** Mask used for low level searches to identify previously-visited nodes */\n  VISITED = 0x00002000,\n  /** Mask applied to triangles by earcut triangulator */\n  TRIANGULATED_FACE = 0x00004000,\n  /** no mask bits */\n  NULL_MASK = 0x00000000,\n  /** all mask bits */\n  ALL_MASK = 0xFFFFFFFF,\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** @module Topology */\n\nimport { HalfEdgeMask, HalfEdge, HalfEdgeGraph } from \"./Graph\";\nimport { XAndY } from \"../geometry3d/XYZProps\";\nimport { Point3d } from \"../geometry3d/Point3dVector3d\";\nimport { Geometry } from \"../Geometry\";\nimport { GrowableXYZArray } from \"../geometry3d/GrowableXYZArray\";\nimport { IndexedXYZCollection } from \"../geometry3d/IndexedXYZCollection\";\n/**\n * (static) mehods for triangulating polygons\n * * @internal\n */\nexport class Triangulator {\n\n  /** Given the six nodes that make up two bordering triangles, \"pinch\" and relocate the nodes to flip them\n   * * The shared edge mates are a and d.\n   * * (abc) are a triangle in CCW order\n   * * (dfe) are a triangle in CCW order. (!! node dfe instead of def.)\n   */\n  private static flipEdgeBetweenTriangles(a: HalfEdge, b: HalfEdge, c: HalfEdge, d: HalfEdge, e: HalfEdge, f: HalfEdge) {\n    // Reassign all of the pointers\n    HalfEdge.pinch(a, e);\n    HalfEdge.pinch(c, d);\n    HalfEdge.pinch(f, c);\n    HalfEdge.pinch(e, b);\n\n    // Move alpha and beta into the xy coordinates of their predecessors\n    e.x = b.x;\n    e.y = b.y;\n    e.z = b.z;\n    e.i = b.i;\n    c.i = f.i;\n    c.x = f.x;\n    c.y = f.y;\n    c.z = f.z;\n  }\n  /**\n   * * nodeA is a given node\n   * * nodeA1 is its nodeA.faceSuccessor\n   * * nodeA2 is nodeA1.faceSuccessor, i.e. 3rd node of triangle A\n   * * nodeB  is nodeA.edgeMate, i.e. a node in the \"other\" triangle at nodeA's edge\n   * * nodeB1 is nodeB.faceSucessor\n   * * nodeB2 is nodeB1.faceSuccessor, i.e the 3rd node of triangle B\n   * Construct (as simple doubles, to avoid object creation) xy vectors from:\n   * * (ux,uy): nodeA to nodeA1, i.e. the shared edge\n   * * (vx,vy): nodeA to ndoeA2,\n   * * (wx,wy): nodeA to nodeB2\n   * * this determinant is positive if nodeA is \"in the circle\" of nodeB2, nodeA1, nodeA2\n   * @param nodeA node on the diagonal edge of candidate for edge flip.\n   * @param if true, divide the determinant by the sum of absolute values of the cubic terms of the determinant.\n   * @return the determinant (but undefined if the faces are not triangles as expected.)\n   */\n  private static computeInCircleDeterminant(nodeA: HalfEdge, normalize: boolean): number | undefined {\n    const nodeA1 = nodeA.faceSuccessor;\n    const nodeA2 = nodeA1.faceSuccessor;\n    if (nodeA2.faceSuccessor !== nodeA)\n      return undefined;\n    const nodeB = nodeA.edgeMate;\n    const nodeB1 = nodeB.faceSuccessor;\n    const nodeB2 = nodeB1.faceSuccessor;\n    if (nodeB2.faceSuccessor !== nodeB)\n      return undefined;\n    const ux = nodeA1.x - nodeA.x;\n    const uy = nodeA1.y - nodeA.y;\n    const vx = nodeA2.x - nodeA.x;\n    const vy = nodeA2.y - nodeA.y;\n    if (Geometry.crossProductXYXY(ux, uy, vx, vy) < 0)\n      return undefined;\n    // we assume identical coordinates in pairs (nodeA, nodeB1)  and (nodeA1, nodeB)\n    const wx = nodeB2.x - nodeA.x;\n    const wy = nodeB2.y - nodeA.y;\n    const tx = wx * wx + wy * wy;\n    const ty = vx * vx + vy * vy;\n    const tz = ux * ux + uy * uy;\n    const q = Geometry.tripleProduct(\n      wx, wy, tx,\n      vx, vy, ty,\n      ux, uy, tz);\n    if (!normalize) return q;\n    const denom = Math.abs(wx * vy * tz) + Math.abs(wx * ty * ux) + Math.abs(tx * vx * uy)\n      + Math.abs(wx * ty * uy) + Math.abs(wy * vx * tz) + Math.abs(tx * vy * ux);\n    return q / denom;   // divide by zero?  only if collapsed to a point.\n  }\n  /**\n   *  *  Visit each node of the graph array\n   *  *  If a flip would be possible, test the results of flipping using incircle condition\n   *  *  If revealed to be an improvement, conduct the flip, mark involved nodes as unvisited, and repeat until all nodes are visited\n   */\n  public static flipTriangles(graph: HalfEdgeGraph) {\n    const nodeArray = graph.allHalfEdges;\n    graph.clearMask(HalfEdgeMask.VISITED);\n    let foundNonVisited = false;\n\n    for (let i = 0; i < nodeArray.length; i++) {\n      const node = nodeArray[i];\n\n      // HalfEdge has already been visited or is exterior node\n      if (node.isMaskSet(HalfEdgeMask.VISITED))\n        continue;\n\n      node.setMask(HalfEdgeMask.VISITED);\n\n      if (node.edgeMate === undefined || node.isMaskSet(HalfEdgeMask.EXTERIOR) || node.isMaskSet(HalfEdgeMask.PRIMARY_EDGE)) // Flip not allowed\n        continue;\n\n      foundNonVisited = true;\n      const incircle = Triangulator.computeInCircleDeterminant(node, false);\n      if (incircle !== undefined && incircle > 0.0) {\n        // Mark all nodes involved in flip as needing to be buffer (other than alpha and beta node we started with)\n        node.facePredecessor.clearMask(HalfEdgeMask.VISITED);\n        node.faceSuccessor.clearMask(HalfEdgeMask.VISITED);\n        node.edgeMate.facePredecessor.clearMask(HalfEdgeMask.VISITED);\n        node.edgeMate.faceSuccessor.clearMask(HalfEdgeMask.VISITED);\n        // Flip the triangles\n        Triangulator.flipEdgeBetweenTriangles(node.edgeMate.faceSuccessor, node.edgeMate.facePredecessor, node.edgeMate, node.faceSuccessor, node, node.facePredecessor);\n      }\n\n      // If at the end of the loop, check if we found an unvisited node we tried to flip.. if so, restart loop\n      if (i === nodeArray.length - 1 && foundNonVisited) {\n        i = -1;\n        foundNonVisited = false;\n      }\n    }\n\n    graph.clearMask(HalfEdgeMask.VISITED);\n  }\n  /**\n   * * Only one outer loop permitted.\n   * * Largest area loop is assumed outer.\n   * @param loops an array of loops as GrowableXYZArray or XAndY[]\n   * @returns triangulated graph, or undefined if bad data.\n   */\n  public static createTriangulatedGraphFromLoops(loops: GrowableXYZArray[] | XAndY[][]): HalfEdgeGraph | undefined {\n    if (loops.length < 1)\n      return undefined;\n    const mask = HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE;\n    const graph = new HalfEdgeGraph();\n    const holeSeeds: HalfEdge[] = [];\n    let maxArea = -10000.0;\n    let maxAreaIndex = -1;\n    // collect all the loops with pointers to the positive (inside)\n    // remember which one has largest area.\n    for (let i = 0; i < loops.length; i++) {\n      let seed = Triangulator.directCreateFaceLoopFromCoordinates(graph, loops[i]);\n      if (seed) {\n        seed = seed.faceSuccessor;  // directCreate returns tail\n        const mate = seed.vertexSuccessor;\n        seed.setMaskAroundFace(mask);\n        mate.setMaskAroundFace(mask);\n        const signedFaceArea = seed.signedFaceArea();\n        const area = Math.abs(signedFaceArea);\n        holeSeeds.push(signedFaceArea >= 0 ? seed : mate);\n        if (i === 0 || area > maxArea) {\n          maxArea = area;\n          maxAreaIndex = i;\n        }\n      }\n    }\n    if (holeSeeds.length === 0)\n      return undefined;\n    // extract the max area seed ...\n    const maxAreaFace = holeSeeds[maxAreaIndex];\n    holeSeeds[maxAreaIndex] = holeSeeds[holeSeeds.length - 1];\n    holeSeeds.pop();\n    maxAreaFace.vertexSuccessor.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n    // The hole seeds all have inside nodes.  Set mask there and jump to outside.\n    for (let i = 0; i < holeSeeds.length; i++) {\n      const seed = holeSeeds[i];\n      seed.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n      holeSeeds[i] = this.getLeftmost(seed.vertexSuccessor);\n    }\n\n    const startingNode = Triangulator.spliceLeftMostNodesOfHoles(graph, maxAreaFace, holeSeeds, false);\n    Triangulator.triangulateSingleFace(graph, startingNode);\n    return graph;\n  }\n  /**\n   * Triangulate all positive area faces of a graph.\n   */\n  public triangulateAllPositiveAreaFaces(graph: HalfEdgeGraph) {\n    const seeds = graph.collectFaceLoops();\n    for (const face of seeds) {\n      if (face.countEdgesAroundFace() > 3) {\n        const area = face.signedFaceArea();\n        if (area > 0.0)\n          Triangulator.triangulateSingleFace(graph, face);\n      }\n    }\n\n  }\n\n  /**\n   * Triangulate the polygon made up of by a series of points.\n   * * The loop may be either CCW or CW -- CCW order will be used for triangles.\n   * * To triangulate a polygon with holes, use createTriangulatedGraphFromLoops\n   */\n  public static createTriangulatedGraphFromSingleLoop(data: XAndY[] | GrowableXYZArray): HalfEdgeGraph {\n    const graph = new HalfEdgeGraph();\n    const startingNode = Triangulator.createFaceLoopFromCoordinates(graph, data, true, true);\n\n    if (!startingNode) return graph;\n\n    Triangulator.triangulateSingleFace(graph, startingNode, undefined);\n    return graph;\n  }\n\n  /**\n   * cautiously split the edge starting at baseNode.\n   * * If baseNode is null, create a trivial loop with the single vertex at xy\n   * * if xy is distinct from the coordinates at both baseNode and its successor, insert xy as a new node within that edge.\n   * * also include z coordinate if present.\n   */\n  private static interiorEdgeSplit(graph: HalfEdgeGraph, baseNode: HalfEdge | undefined, xy: XAndY): HalfEdge | undefined {\n    const z = (xy as any).hasOwnProperty(\"z\") ? (xy as any).z : 0.0;\n    if (!baseNode)\n      return graph.splitEdge(baseNode, xy.x, xy.y, z);\n    if (Triangulator.equalXAndY(baseNode, xy))\n      return baseNode;\n    if (Triangulator.equalXAndY(baseNode.faceSuccessor, xy))\n      return baseNode;\n    return graph.splitEdge(baseNode, xy.x, xy.y, z);\n  }\n\n  private static directCreateFaceLoopFromCoordinates(graph: HalfEdgeGraph, data: XAndY[] | IndexedXYZCollection): HalfEdge | undefined {\n    // Add the starting nodes as the boundary, and apply initial masks to the primary edge and exteriors\n    let baseNode: HalfEdge | undefined;\n    if (data instanceof IndexedXYZCollection) {\n      const xyz = Point3d.create();\n      for (let i = 0; i < data.length; i++) {\n        data.getPoint3dAtCheckedPointIndex(i, xyz);\n        baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xyz);\n      }\n    } else {\n      for (const xy of data) {\n        baseNode = Triangulator.interiorEdgeSplit(graph, baseNode, xy);\n      }\n    }\n    return baseNode;\n  }\n\n  /**\n   * @param graph the containing graph\n   * @param base The last node of a newly created loop.  (i.e. its `faceSuccessor` has the start xy)\n   * @param returnPositiveAreaLoop if true, return the start node on the side with positive area.  otherwise return the left side as given.\n   * @param markExterior\n   * @return the loop's start node or its vertex sucessor, chosen to be the positive or negative loop per request.\n   */\n  private static maskAndOrientNewFaceLoop(_graph: HalfEdgeGraph, base: HalfEdge | undefined, returnPositiveAreaLoop: boolean, markExterior: boolean): HalfEdge | undefined {\n    // base is the final coordinates\n    if (base) {\n      base = base.faceSuccessor; // because typical construction process leaves the \"live\" edge at the end of the loop.\n      const area = base.signedFaceArea();\n      const mate = base.edgeMate;\n      base.setMaskAroundFace(HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE);\n      mate.setMaskAroundFace(HalfEdgeMask.BOUNDARY_EDGE | HalfEdgeMask.PRIMARY_EDGE);\n\n      let preferredNode = base;\n      if (returnPositiveAreaLoop === (area < 0))\n        preferredNode = mate;\n      const otherNode = preferredNode.vertexSuccessor;\n\n      if (markExterior)\n        otherNode.setMaskAroundFace(HalfEdgeMask.EXTERIOR);\n      return preferredNode;\n    }\n    return undefined;   // caller should not be calling with start <= end\n  }\n  /**\n   * create a circular doubly linked list of internal and external nodes from polygon points in the specified winding order\n   * * If start and end are both zero, use the whole array.\n   */\n  public static createFaceLoopFromCoordinates(graph: HalfEdgeGraph, data: XAndY[] | GrowableXYZArray, returnPositiveAreaLoop: boolean, markExterior: boolean): HalfEdge | undefined {\n    const base = Triangulator.directCreateFaceLoopFromCoordinates(graph, data);\n    return Triangulator.maskAndOrientNewFaceLoop(graph, base, returnPositiveAreaLoop, markExterior);\n  }\n\n  /** eliminate colinear or duplicate points using starting and ending nodes */\n  private static filterPoints(graph: HalfEdgeGraph, start?: HalfEdge, end?: HalfEdge): HalfEdge | undefined {\n    if (!start) return start;\n    if (!end) end = start;\n\n    let p = start;\n    let again;\n    do {\n      again = false;\n\n      if (Triangulator.equalXAndY(p, p.faceSuccessor) || Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) === 0) {\n        Triangulator.joinNeighborsOfEar(graph, p);\n        p = end = p.facePredecessor;\n        if (p === p.faceSuccessor) return undefined;\n        again = true;\n\n      } else {\n        p = p.faceSuccessor;\n      }\n    } while (again || p !== end);\n\n    return end;\n  }\n\n  /** Cut off an ear, forming a new face loop of nodes\n   * @param ear the vertex being cut off.\n   * *  Form two new nodes, alpha and beta, which have the coordinates one step away from the ear vertex.\n   * *  Reassigns the pointers such that beta is left behind with the new face created\n   * *  Reassigns the pointers such that alpha becomes the resulting missing node from the remaining polygon\n   * * Reassigns prevZ and nextZ pointers\n   */\n  private static joinNeighborsOfEar(graph: HalfEdgeGraph, ear: HalfEdge) {\n    const alpha = graph.createEdgeXYZXYZ(\n      ear.facePredecessor.x, ear.facePredecessor.y, ear.facePredecessor.z, ear.facePredecessor.i,\n      ear.faceSuccessor.x, ear.faceSuccessor.y, ear.faceSuccessor.z, ear.faceSuccessor.i);\n    const beta = alpha.edgeMate;\n\n    // Add two nodes alpha and beta and reassign pointers (also mark triangle nodes as part of triangle)\n    HalfEdge.pinch(ear.faceSuccessor, beta);\n    HalfEdge.pinch(ear.facePredecessor, alpha);\n    ear.setMaskAroundFace(HalfEdgeMask.TRIANGULATED_FACE);\n  }\n  private static isInteriorTriangle(a: HalfEdge) {\n    if (!a.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE))\n      return false;\n    const b = a.faceSuccessor;\n    if (!b.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE))\n      return false;\n    const c = b.faceSuccessor;\n    if (!c.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE))\n      return false;\n    return c.faceSuccessor === a;\n  }\n\n  /**\n   * Perform 0, 1, or more edge flips to improve aspect ratio just behind an that was just cut.\n   * @param ear the triangle corner which just served as the ear node.\n   * @returns the node at the back corner after flipping.\"appropriately positioned\" node for the usual advance to ear.faceSuccessor.edgeMate.faceSuccessor.\n   */\n  private static doPostCutFlips(ear: HalfEdge) {\n    //    B is the ear -- inside a (probably newly created) triangle ABC\n    //    CA is the recently added cut edge.\n    //    AB is the candidate to be flipped.\n    //    triangle B1 A1 D is on the other side of AB\n    //    The condition for flipping is:\n    //           ! both triangles must be TRIANGULATED_NODE_MASK\n    //           ! incircle condition flags D as in the circle of ABC\n    //     after flip, node A moves to the vertex of D, and is the effective \"ear\",  with the cap edge C A1\n    //      after flip, consider the A1 D (whose nodes are A1 and flipped A!!!)\n    //\n    //\n    //                                   . C0|\n    //                              .        |\n    //                           .           |\n    //                       .              ^|\n    //                   .  A0 ---->       B0|\n    //               *=======================*\n    //                 \\ A1     <----   B1/\n    //                   \\             /\n    //                     \\         /\n    //                       \\  D1 /\n    //                          *\n    let b0 = ear;\n    let a0 = b0.facePredecessor;\n    let b1 = a0.edgeMate;\n    while (Triangulator.isInteriorTriangle(a0) && Triangulator.isInteriorTriangle(b1)) {\n      const detA = Triangulator.computeInCircleDeterminant(a0, true);\n      if (detA === undefined || detA < 1.0e-10)\n        break;\n      // Flip the triangles\n      const a1 = b1.faceSuccessor;\n      Triangulator.flipEdgeBetweenTriangles(a1, a1.faceSuccessor, a1.facePredecessor, b0, b0.facePredecessor, b0.faceSuccessor);\n      b0 = a0;\n      a0 = b0.facePredecessor;\n      b1 = a0.edgeMate;\n    }\n    return b0;\n  }\n\n  /**\n   * main ear slicing loop which triangulates a polygon (given as a linked list)\n   * While there still exists ear nodes that have not yet been triangulated...\n   *\n   * *  Check if the ear is hashed, and can easily be split off. If so, \"join\" that ear.\n   * *  If not hashed, move on to a seperate ear.\n   * *  If no ears are currently hashed, attempt to cure self intersections or split the polygon into two before continuing\n   */\n  private static triangulateSingleFace(graph: HalfEdgeGraph, ear?: HalfEdge, pass?: number) {\n    if (!ear) return;\n\n    let next;\n    let numFail = 0;\n    let maxFail = (ear as HalfEdge).countEdgesAroundFace();\n    // iterate through ears, slicing them one by one\n    while (!ear.isMaskSet(HalfEdgeMask.TRIANGULATED_FACE)) {\n      next = ear.faceSuccessor;\n\n      if (Triangulator.isEar(ear)) {\n        // skipping the next vertice leads to less sliver triangles\n\n        // If we already have a seperated triangle, do not join\n        if (ear.faceSuccessor.faceSuccessor !== ear.facePredecessor) {\n          Triangulator.joinNeighborsOfEar(graph, ear);\n          ear = Triangulator.doPostCutFlips(ear);\n          ear = ear.faceSuccessor.edgeMate.faceSuccessor;\n          // another step?   Nate's 2017 code went one more.\n        } else {\n          ear.setMask(HalfEdgeMask.TRIANGULATED_FACE);\n          ear.faceSuccessor.setMask(HalfEdgeMask.TRIANGULATED_FACE);\n          ear.facePredecessor.setMask(HalfEdgeMask.TRIANGULATED_FACE);\n          ear = next.faceSuccessor;\n        }\n        numFail = 0;\n        maxFail--;\n        continue;\n      }\n      numFail++;\n      ear = next;\n\n      // if we looped through the whole remaining polygon and can't find any more ears\n      if (numFail >= maxFail) {\n        numFail = 0;\n        // try filtering points and slicing again\n        // if (!pass) {\n        //  Triangulator.earcutLinked(Triangulator.filterPoints(ear), minX, minY, size, 1);\n        // }\n        // if this didn't work, try curing all small self-intersections locally\n        if (!pass) {\n          ear = Triangulator.cureLocalIntersections(graph, ear);\n          Triangulator.triangulateSingleFace(graph, ear, 2);\n\n          // as a last resort, try splitting the remaining polygon into two\n        } else if (pass === 2) {\n          Triangulator.splitEarcut(graph, ear);\n        }\n\n        break;\n      }\n    }\n  }\n\n  /** Check whether a polygon node forms a valid ear with adjacent nodes */\n  private static isEar(ear: HalfEdge) {\n    const a = ear.facePredecessor;\n    const b = ear;\n    const c = ear.faceSuccessor;\n\n    if (Triangulator.signedTriangleArea(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    let p = ear.faceSuccessor.faceSuccessor;\n\n    while (p !== ear.facePredecessor) {\n      if (Triangulator.pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n        Triangulator.signedTriangleArea(p.facePredecessor, p, p.faceSuccessor) >= 0) return false;\n      p = p.faceSuccessor;\n    }\n\n    return true;\n  }\n\n  /** Go through all polygon nodes and cure small local self-intersections */\n  private static cureLocalIntersections(graph: HalfEdgeGraph, start: HalfEdge) {\n    let p = start;\n    do {\n      const a = p.facePredecessor;\n      const b = p.faceSuccessor.faceSuccessor;\n\n      if (!Triangulator.equalXAndY(a, b) && Triangulator.intersects(a, p, p.faceSuccessor, b) &&\n        Triangulator.locallyInside(a, b) && Triangulator.locallyInside(b, a)) {\n\n        // remove two nodes involved\n        Triangulator.joinNeighborsOfEar(graph, p);\n        Triangulator.joinNeighborsOfEar(graph, p.faceSuccessor);\n\n        p = start = b;\n      }\n      p = p.faceSuccessor;\n    } while (p !== start);\n\n    return p;\n  }\n\n  /** try splitting face into two and triangulate them independently */\n  private static splitEarcut(graph: HalfEdgeGraph, start: HalfEdge) {\n    // look for a valid diagonal that divides the polygon into two\n    let a: HalfEdge | undefined = start;\n    do {\n      let b = a.faceSuccessor.faceSuccessor;\n      while (b !== a.facePredecessor) {\n        if (a.i !== b.i && Triangulator.isValidDiagonal(a, b)) {\n          // split the polygon in two by the diagonal\n          let c: HalfEdge | undefined = Triangulator.splitPolygon(graph, a, b);\n\n          // filter colinear points around the cuts\n          a = Triangulator.filterPoints(graph, a, a.faceSuccessor);\n          c = Triangulator.filterPoints(graph, c, c.faceSuccessor);\n\n          // run earcut on each half\n          Triangulator.triangulateSingleFace(graph, a);\n          Triangulator.triangulateSingleFace(graph, c);\n          return;\n        }\n        b = b.faceSuccessor;\n      }\n      a = a.faceSuccessor;\n    } while (a !== start);\n  }\n\n  /** link holeLoopNodes[1], holeLoopNodes[2] etc into the outer loop, producing a single-ring polygon without holes\n   *\n   */\n  private static spliceLeftMostNodesOfHoles(graph: HalfEdgeGraph, outerNode: HalfEdge, leftMostHoleLoopNode: HalfEdge[], applyFilter: boolean = true) {\n\n    leftMostHoleLoopNode.sort(Triangulator.compareX);\n\n    // process holes from left to right\n    for (const holeStart of leftMostHoleLoopNode) {\n      Triangulator.eliminateHole(graph, holeStart, outerNode, applyFilter);\n      if (applyFilter)\n        outerNode = Triangulator.filterPoints(graph, outerNode, (outerNode) ? outerNode.faceSuccessor : undefined) as HalfEdge;\n    }\n\n    return outerNode;\n  }\n  /** For use in sorting -- return (signed) difference (a.x - b.x) */\n  private static compareX(a: HalfEdge, b: HalfEdge) {\n    return a.x - b.x;\n  }\n\n  /** find a bridge between vertices that connects hole with an outer ring and and link it */\n  private static eliminateHole(graph: HalfEdgeGraph, hole: HalfEdge, outerNode: HalfEdge, applyFilter: boolean) {\n    const outerNodeA = Triangulator.findHoleBridge(hole, outerNode);\n    if (outerNodeA) {\n      const b = Triangulator.splitPolygon(graph, outerNodeA, hole);\n      if (applyFilter)\n        Triangulator.filterPoints(graph, b, b.faceSuccessor);\n    }\n  }\n\n  /**\n   *  David Eberly's algorithm for finding a bridge between hole and outer polygon:\n   *  https://www.geometrictools.com/Documentation/TriangulationByEarClipping.pdf\n   */\n  private static findHoleBridge(hole: HalfEdge, outerNode?: HalfEdge): HalfEdge | undefined {\n    let p = outerNode;\n\n    if (!p)\n      return undefined;\n\n    const hx = hole.x;\n    const hy = hole.y;\n    let qx = -Infinity;\n    let m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n      if (hy <= p.y && hy >= p.faceSuccessor.y && p.faceSuccessor.y !== p.y) {\n        const x = p.x + (hy - p.y) * (p.faceSuccessor.x - p.x) / (p.faceSuccessor.y - p.y);\n        if (x <= hx && x > qx) {\n          qx = x;\n          if (x === hx) {\n            if (hy === p.y) return p;\n            if (hy === p.faceSuccessor.y) return p.faceSuccessor;\n          }\n          m = p.x < p.faceSuccessor.x ? p : p.faceSuccessor;\n        }\n      }\n      p = p.faceSuccessor;\n    } while (p !== outerNode);\n\n    if (!m) return undefined;\n\n    if (hx === qx) return m.facePredecessor; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    const stop = m;\n    const mx = m.x;\n    const my = m.y;\n    let tanMin = Infinity;\n    let tan;\n\n    p = m.faceSuccessor;\n\n    while (p !== stop) {\n      if (hx >= p.x && p.x >= mx && hx !== p.x &&\n        Triangulator.pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n        tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n        if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && Triangulator.locallyInside(p, hole)) {\n          m = p;\n          tanMin = tan;\n        }\n      }\n\n      p = p.faceSuccessor;\n    }\n\n    return m;\n  }\n\n  // find the leftmost node of a polygon ring\n  private static getLeftmost(start: HalfEdge) {\n    let p = start;\n    let leftmost = start;\n    do {\n      if (p.x < leftmost.x) leftmost = p;\n      p = p.faceSuccessor;\n    } while (p !== start);\n\n    return leftmost;\n  }\n\n  /** check if a point lies within a convex triangle */\n  private static pointInTriangle(ax: number, ay: number, bx: number, by: number, cx: number, cy: number, px: number, py: number) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n      (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n      (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n  }\n\n  /** check if a diagonal between two polygon nodes is valid (lies in polygon interior) */\n  private static isValidDiagonal(a: HalfEdge, b: HalfEdge) {\n    return a.faceSuccessor.i !== b.i && a.facePredecessor.i !== b.i && !Triangulator.intersectsPolygon(a, b) &&\n      Triangulator.locallyInside(a, b) && Triangulator.locallyInside(b, a) && Triangulator.middleInside(a, b);\n  }\n\n  /** signed area of a triangle */\n  private static signedTriangleArea(p: HalfEdge, q: HalfEdge, r: HalfEdge) {\n    return 0.5 * ((q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y));\n  }\n\n  /** check if two points are equal */\n  private static equalXAndY(p1: XAndY, p2: XAndY) {\n    return Geometry.isSameCoordinate(p1.x, p2.x) && Geometry.isSameCoordinate(p1.y, p2.y);\n  }\n\n  /** check if two segments intersect */\n  private static intersects(p1: HalfEdge, q1: HalfEdge, p2: HalfEdge, q2: HalfEdge) {\n    if ((Triangulator.equalXAndY(p1, q1) && Triangulator.equalXAndY(p2, q2)) ||\n      (Triangulator.equalXAndY(p1, q2) && Triangulator.equalXAndY(p2, q1))) return true;\n    return Triangulator.signedTriangleArea(p1, q1, p2) > 0 !== Triangulator.signedTriangleArea(p1, q1, q2) > 0 &&\n      Triangulator.signedTriangleArea(p2, q2, p1) > 0 !== Triangulator.signedTriangleArea(p2, q2, q1) > 0;\n  }\n\n  /** check if a polygon diagonal intersects any polygon segments */\n  private static intersectsPolygon(a: HalfEdge, b: HalfEdge) {\n    let p = a;\n    do {\n      if (p.i !== a.i && p.faceSuccessor.i !== a.i && p.i !== b.i && p.faceSuccessor.i !== b.i &&\n        Triangulator.intersects(p, p.faceSuccessor, a, b)) return true;\n      p = p.faceSuccessor;\n    } while (p !== a);\n\n    return false;\n  }\n\n  /** check if a polygon diagonal is locally inside the polygon */\n  private static locallyInside(a: HalfEdge, b: HalfEdge) {\n    return Triangulator.signedTriangleArea(a.facePredecessor, a, a.faceSuccessor) < 0 ?\n      Triangulator.signedTriangleArea(a, b, a.faceSuccessor) >= 0 && Triangulator.signedTriangleArea(a, a.facePredecessor, b) >= 0 :\n      Triangulator.signedTriangleArea(a, b, a.facePredecessor) < 0 || Triangulator.signedTriangleArea(a, a.faceSuccessor, b) < 0;\n  }\n\n  /** check if the middle point of a polygon diagonal is inside the polygon */\n  private static middleInside(a: HalfEdge, b: HalfEdge) {\n    let p = a;\n    let inside = false;\n    const px = (a.x + b.x) / 2;\n    const py = (a.y + b.y) / 2;\n    do {\n      if (((p.y > py) !== (p.faceSuccessor.y > py)) && p.faceSuccessor.y !== p.y &&\n        (px < (p.faceSuccessor.x - p.x) * (py - p.y) / (p.faceSuccessor.y - p.y) + p.x))\n        inside = !inside;\n      p = p.faceSuccessor;\n    } while (p !== a);\n\n    return inside;\n  }\n\n  /**\n   * link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n   * if one belongs to the outer ring and another to a hole, it merges it into a single ring\n   * * Returns the base of the new edge at the \"a\" end.\n   * * \"a\" and \"b\" still represent the same physical pieces of edges\n   * @returns Returns the (base of) the new half edge, at the \"a\" end.\n   */\n  private static splitPolygon(graph: HalfEdgeGraph, a: HalfEdge, b: HalfEdge): HalfEdge {\n    const a2 = graph.createEdgeXYZXYZ(a.x, a.y, a.z, a.i, b.x, b.y, b.z, b.i);\n    const b2 = a2.faceSuccessor;\n\n    HalfEdge.pinch(a, a2);\n    HalfEdge.pinch(b, b2);\n\n    return a2;\n  }\n\n  // Methods below were originally properties of the Earcut function itself (was not originally a class), but were not used for\n  // actual triangulation process\n\n  /*\n  // return a percentage difference between the polygon area and its triangulation area;\n  // used to verify correctness of triangulation\n  private static deviation(data: number[], holeIndices: number[], dim: number, triangles: number[][]) {\n    const hasHoles = holeIndices && holeIndices.length;\n    const outerLen = holeIndices ? holeIndices[0] * dim : data.length;\n\n    let polygonArea = Math.abs(Triangulator.signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (let i = 0, len = holeIndices.length; i < len; i++) {\n            const start = holeIndices[i] * dim;\n            const end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(Triangulator.signedArea(data, start, end, dim));\n        }\n    }\n\n    let trianglesArea = 0;\n    for (const triangle of triangles) {\n        const a = triangle[0] * dim;\n        const b = triangle[1] * dim;\n        const c = triangle[2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n  }\n\n  // turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\n  private static flatten(data: number[][][]) {\n    const dim = data[0][0].length;\n    const result: {vertices: number[], holes: number[], dimensions: number} = {vertices: [], holes: [], dimensions: dim};\n    let holeIndex = 0;\n\n    for (let i = 0; i < data.length; i++) {\n        const len = data[i].length;\n        for (let j = 0; j < len; j++) {\n            for (let d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n  }\n  */\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n/** @module Topology */\r\n\r\n/**\r\n * * XYParitySerachContext is an internal class for callers that can feed points (without extracting to array structures)\r\n * * Most will be via static methods which handle a specific data source.\r\n *   * PolygonOps.classifyPointInPolygon (x,y,points: XAndY[])\r\n *   * HalfEdgeGraphSearch.pointInOrOnFaceXY (halfEdgeOnFace, x, y)\r\n * Use pattern:\r\n * * Caller must be able walk around polygon producing x,y coordinates (possibly transformed from actual polygon)\r\n * * Caller announce edges to tryStartEdge until finding one acceptable to the search.\r\n * * Caller then passes additional points upto and including both x0,y0 and x1, y1 of the accepted start edge.\r\n * Call sequence is:\r\n *    `context = new XYParitySearchContext`\r\n *    `repeat {  acquire edge (x0,y0) (x1,y1)} until context.tryStartEdge (x0,y0,x1,y1);`\r\n *    `for each (x,y) beginning AFTER x1,y1 and ending with (x1,y1) context.advance (x,y)`\r\n *  `return context.classifyCounts ();`\r\n */\r\nexport class XYParitySearchContext {\r\n  public xTest: number;\r\n  public yTest: number;\r\n  public u0: number; // local coordinates of recent point with nonzero v.  Usually \"second last point\" but points can be skipped if y1 is zero\r\n  public v0: number;\r\n  public u1: number; // local coordinates of most recent point\r\n  public v1: number;\r\n  public numLeftCrossing: number;\r\n  public numRightCrossing: number;\r\n  public numHit: number;\r\n  /**\r\n   * Create a new searcher for specified test point.\r\n   * @param xTest x coordinate of test point\r\n   * @param yTest y coordinate of test point\r\n   */\r\n  public constructor(xTest: number, yTest: number) {\r\n    this.xTest = xTest;\r\n    this.yTest = yTest;\r\n    this.u0 = this.v0 = this.u1 = this.v1 = 0; // Not valid for search -- caller must satisfy tryStartEdge !!!\r\n    this.numLeftCrossing = this.numRightCrossing = 0;\r\n    this.numHit = 0;\r\n  }\r\n  /**\r\n   * test if x,y is a safe first coordinate to start the search.\r\n   * * safe start must have non-zero y so that final point test (return to x0,y0) does not need lookback for exact crossing logic.\r\n   * @param x\r\n   * @param y\r\n   */\r\n  public tryStartEdge(x0: number, y0: number, x1: number, y1: number): boolean {\r\n    if (y0 !== this.yTest) {\r\n      this.u0 = x0 - this.xTest;\r\n      this.v0 = y0 - this.yTest;\r\n      this.u1 = x1 - this.xTest;\r\n      this.v1 = y1 - this.yTest;\r\n      return true;\r\n    }\r\n    return false;\r\n  }\r\n  /** Return true if parity accumulation proceeded normally.\r\n   * Return false if interupted for exact hit.\r\n   */\r\n  public advance(x: number, y: number): boolean {\r\n    const u = x - this.xTest;\r\n    const v = y - this.yTest;\r\n    const p = v * this.v1;\r\n    if (p > 0) {\r\n      // The commonn case -- skittering along above or below the x axis . . .\r\n      this.u0 = this.u1;\r\n      this.v0 = this.v1;\r\n      this.u1 = u;\r\n      this.v1 = v;\r\n      return true;\r\n    }\r\n    if (p < 0) {\r\n      // crossing within (u1,v1) to (u,v)\r\n      // both v values are nonzero and of opposite sign, so this divisiion is safe . . .\r\n      const fraction = -this.v1 / (v - this.v1);\r\n      const uCross = this.u1 + fraction * (u - this.u1);\r\n      if (uCross === 0.0) {\r\n        this.numHit++;\r\n        return false;\r\n      }\r\n      if (uCross > 0)\r\n        this.numRightCrossing++;\r\n      else\r\n        this.numLeftCrossing++;\r\n      this.u0 = this.u1;\r\n      this.v0 = this.v1;\r\n      this.u1 = u;\r\n      this.v1 = v;\r\n      return true;\r\n    }\r\n    // hard stuff -- one or more exact hits . . .\r\n    if (v === 0.0) {\r\n      if (this.v1 === 0.0) {\r\n        // uh oh -- moving along x axis.  Does it pass through xTest:\r\n        if (u * this.u1 <= 0.0) {\r\n          this.numHit++;\r\n          return false;\r\n        }\r\n        // quietly moving along the scan line, both xy and x1y1 to same side of test point ...\r\n        // u0 and u1 remain unchanged !!!\r\n        this.u1 = u;\r\n        this.v1 = v;\r\n        return true;\r\n      }\r\n      // just moved onto the scan line ...\r\n      this.u0 = this.u1;\r\n      this.v0 = this.v1;\r\n      this.u1 = u;\r\n      this.v1 = v;\r\n      return true;\r\n    }\r\n    // fall out with v1 = 0\r\n    // both v0 and v are nonzero.\r\n    // any along-0 v values that have passed through are on the same side of xTest, so u1 determins crossing\r\n    const q = this.v0 * v;\r\n    if (this.u1 > 0) {\r\n      if (q < 0)\r\n        this.numRightCrossing++;\r\n    } else {\r\n      if (q < 0)\r\n        this.numLeftCrossing++;\r\n    }\r\n    this.u0 = this.u1;\r\n    this.v0 = this.v1;\r\n    this.u1 = u;\r\n    this.v1 = v;\r\n    return true;\r\n  }\r\n  /**\r\n   * Return classificatyion as ON, IN, or OUT according to hit and crossing counts.\r\n   * * Any nonzero hit count is ON\r\n   * * Otherwise IN if left crossing count is odd.\r\n   * @return 0 if ON, 1 if IN, -1 if OUT\r\n   */\r\n  public classifyCounts(): number | undefined {\r\n    if (this.numHit > 0)\r\n      return 0;\r\n    const parity = this.numLeftCrossing & 0x01;\r\n    return (parity === 1) ? 1 : -1;\r\n  }\r\n}\r\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;;;AAGA;;AAEA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;;;;;;;;;;;;;;ACVA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AAIA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6EA;;;;;;;AAOA;AACA;AAeA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AAIA;AAEA;;AAEA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;;AArgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAQA;AACA;AAvBA;;;;;;;;;;;;;;ACjKA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAcA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA9LA;;;;;;;;;;;;;;ACnBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4CA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAhNA;AAiNA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AA9VA;;;;;;;;;;;;;;ACtSA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAOA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAjUA;;;;;;;;;;;;;;ACjCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;AAQA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AAwGA;;;AAGA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AASA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5UA;AA8UA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;AAiBA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAvOA;AAyOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;;;AAGA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AASA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAnPA;;;;;;;;;;;;;;ACruBA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;AA7JA;AAxKA;;;;;;;;;;;;;;ACnBA;;;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3NA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhYA;;;;;;;;;;;;;;AC1BA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAIA;AAOA;AACA;AACA;;;;;;;;;AASA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AA5JA;;;;;;;;;;;;;;AChCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;AAcA;AACA;AA2BA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAyBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;;AAzWA;AACA;AAVA;;;;;;;;;;;;;;AC/CA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;AAWA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AApoBA;AACA;AAwRA;AA1RA;;;;;;;;;;;;;;ACnCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAKA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzKA;AA2KA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/WA;;;;;;;;;;;;;;;ACvPA;;;AAGA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6BA;;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/UA;AADA;;;;;;;;;;;;;;ACxEA;;;AAGA;;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AAWA;AATA;;;AAGA;AACA;AAMA;AACA;AALA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7BA;AA5SA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvlBA;AACA;AAmUA;AArUA;;;;;;;;;;;;;;AC3BA;;;AAGA;AACA;;AAGA;AACA;AAEA;AAIA;AAEA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AALA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1EA;AA5LA;;;;;;;;;;;;;;AC3BA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AAmCA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;;AAEA;AACA;AAMA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AASA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAIA;AACA;AACA;;;;;;AAMA;AACA;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;;AAnrBA;AACA;AAyQA;AACA;AACA;AACA;AArRA;;;;;;;;;;;;;;AC/CA;;;AAGA;;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AA3GA;;;;;;;;;;;;;;;AChBA;AAIA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;;;;;;;;;;;;;;ACfA;;;AAGA;;AAEA;AAEA;AACA;AAIA;AACA;AAEA;AAMA;AACA;;;;;;AAMA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AA/EA;AAgFA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvUA;;;;;;;;;;;;;;AChLA;;;AAGA;;AAIA;AAGA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AAAA;;AACA;AACA;AACA;AAoEA;AAnEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvEA;AAwEA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AArEA;AAuEA;;;;AAIA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5DA;;;;;;;;;;;;;;AClUA;;;AAGA;;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAEA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;;;;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AATA;AAUA;;;;AAIA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AACA;AACA;AAiBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAMA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAkBA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAIA;AAAA;AACA;AAIA;AAAA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAQA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AAAA;AACA;AAGA;AAAA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;AAlwBA;AAsFA;AACA;AACA;AACA;AA2eA;AACA;AACA;AACA;AAqEA;AACA;AACA;AACA;AAsHA;;;AAGA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AA5BA;;;;;;;;;;;;;;;ACn4BA;;;AAGA;AACA;AACA;AAGA;AACA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AA7OA;AA8OA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/BA;;;;;;;;;;;;;;;ACvTA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAgBA;;;;;;;;;;;;;AAaA;AACA;AACA;AAoBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAaA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAIA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAeA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAhZA;AAkZA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAuBA;AACA;AApBA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AAfA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AAXA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AC5zBA;;;AAGA;AACA;AACA;AAOA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAjDA;AAmDA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAnEA;;;;;;;;;;;;;;;AC3EA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AAMA;;;AAGA;AACA;AAGA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAvEA;;;;;;;;;;;;;;ACbA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAIA;AACA;AAGA;AAEA;AACA;AAEA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AA1RA;;;;;;;;;;;;;;;AClCA;;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AAEA;AAEA;;;;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AA4CA;AACA;AACA;AACA;AA1CA;AACA;AACA;;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AA3nCA;AACA;AACA;AACA;AA8gCA;AAlhCA;AA8nCA;;;AAGA;AACA;AASA;AATA;AAUA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACryCA;;;AAGA;;AAEA;AACA;AAOA;AACA;AAIA;;;AAGA;AACA;AAKA;AAAA;AAJA;AACA;AAGA;AAFA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9DA;;;;;;;;;;;;;;ACtBA;;;AAGA;;AAQA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnEA;;;;;;;;;;;;;;ACpBA;;;AAGA;;AAKA;AAIA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAvJA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAKA;AAGA;AACA;AAEA;AAKA;;;AAGA;AACA;AAKA;AACA;AACA;AAKA;AACA;AALA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArGA;;;;;;;;;;;;;;;ACvBA;;;AAGA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;AAyBA;AACA;AACA;;;;;;AAMA;AACA;AAeA;;;AAGA;AACA;AAEA;AA7BA;AA8BA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAlCA;AAmCA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAlCA;AAmCA;;;;;;AAMA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAvEA;AAyEA;;;;;AAKA;AACA;AAGA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjOA;;;;;;;;;;;;;;;ACzOA;AAEA;AACA;;;;;;;;;;;;AAYA;AACA;AAeA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AApIA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AAAA;AAYA;AACA;AAaA;AACA;AA6FA;AAxGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAxHA;;;;;;;;;;;;;;AChCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAWA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnHA;AAoHA;;;;AAIA;AACA;AA6DA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjFA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA2CA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAMA;AACA;;;;;;;;;;AAUA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AApQA;AACA;AAtFA;AA4VA;AACA;;;;;;;;;;;;;;AC5fA;;;AAGA;;AAOA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxDA;;;;;;;;;;;;;;ACpBA;;;AAGA;;;;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AACA;AACA;;;;;;;;;AASA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACzOA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AAiBA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;AAhVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;;;;;;;;;;;;;;;ACNA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AA5QA;;;;;;;;;;;;;;ACpBA;;;AAGA;;AAEA;AAEA;AAKA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;AAKA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AACA;AAIA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA3IA;;;;;;;;;;;;;;ACzCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAKA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA9OA;;;;;;;;;;;;;;ACrCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AAOA;AACA;AACA;AACA;AAIA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlGA;;;;;;;;;;;;;;AClCA;;;AAGA;;AAmCA;;;;;AAKA;AACA;AAOA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqBA;AAxDA;AAyDA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1DA;AA2DA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlEA;;;;;;;;;;;;;;;AC3KA;AAEA;;;;AAIA;AACA;AASA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvJA;;;;;;;;;;;;;;ACZA;;;AAGA;;AAcA;;;;;;;;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA1OA;;;;;;;;;;;;;;AC1BA;;;AAGA;;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;;AAEA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAllBA;;;;;;;;;;;;;;ACpBA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;;AAEA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AA3xBA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AASA;;;;;;;;AAQA;AACA;AAuDA;AAvDA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AASA;;;;;;;;AAQA;AACA;AAgEA;AAhEA;;;;;;;;;;;;;;;ACrBA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAUA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAUA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAUA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;;;;;AAKA;AACA;AAAA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAwCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AA5BA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAUA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AAKA;AAAA;AACA;AAKA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;AAEA;AACA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AAMA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAMA;AAEA;;;;;AAKA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAMA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAIA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAj/DA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;AC3JA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AAAA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;;AAxOA;AALA;;;;;;;;;;;;;;ACnBA;;;AAGA;;AAEA;AACA;AAEA;AAEA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1JA;;;;;;;;;;;;;;ACjBA;;;AAGA;;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlLA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;AAEA;AACA;AAEA;AAEA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA/FA;;;;;;;;;;;;;;AClBA;;;AAGA;;AAEA;AAEA;AACA;AAGA;;;;;;AAMA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAhGA;AAiGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAIA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApJA;AAqJA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAzQA;;;;;;;;;;;;;;;AC9QA;;;AAGA;AACA;AACA;AACA;AAGA;;;;;;;AAOA;AACA;AAOA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AA/MA;AAgNA;;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzNA;AA0NA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;;;;;AAKA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArrBA;;;;;;;;;;;;;;ACjcA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AArGA;AAsGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAvCA;AAyCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AApBA;AAsBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnDA;AA7CA;AAmGA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAtRA;AACA;AACA;AACA;AAlFA;AAyWA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAhHA;;;;;;;;;;;;;;AC9pBA;;;AAGA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlPA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlEA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/CA;AACA;AACA;AACA;AAJA;AAkDA;;;;;;AAMA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAMA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAKA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhpBA;AAipBA;;;;;;AAMA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAAA;;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAGA;AACA;AAxRA;AA0RA;;;AAGA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAKA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAGA;AACA;AA9UA;;;;;;;;;;;;;;ACjgCA;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;AAKA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AA5RA;;;;;;;;;;;;;;ACrBA;;;AAGA;;AAEA;AAEA;AACA;;;;;;;;;;;;;;AAcA;AACA;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnGA;;;;;;;;;;;;;;ACvBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AASA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;;;;AAKA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA9gBA;;;;;;;;;;;;;;AC3BA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AAeA;;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxKA;;;;;;;;;;;;;;;ACvBA;AACA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AApIA;;;;;;;;;;;;;;ACZA;;;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;AAcA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjjBA;;;;;;;;;;;;;;ACjCA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3HA;;;;;;;;;;;;;;AC1BA;;;AAGA;;AAKA;AACA;;;;;;AAMA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;;;;;;;;;;;;;;AChBA;;;AAGA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAOA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAIA;AACA;;;;;AAKA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApeA;;;;;;;;;;;;;;AC1CA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA4BA;;;AAGA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5JA;AA6JA;;;AAGA;AACA;AACA;;;;;;AAMA;AACA;AASA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAzIA;AA0IA;;;;;;;;;;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3XA;AA4XA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnFA;AAqFA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAjGA;AAmGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA5IA;AA6IA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtKA;;;;;;;;;;;;;;AC1hCA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAcA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAjBA;AACA;AACA;AACA;AAAA;AACA;AACA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/VA;AACA;AACA;AACA;AACA;AAiGA;AACA;AAvGA;AAkWA;;;;;AAKA;AACA;AAUA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;;AA3BA;AACA;;;;;;;;;;;;;;;ACjYA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AApHA;;;;;;;;;;;;;;ACXA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7FA;AA8FA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA7NA;;;;;;;;;;;;;;AChHA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAYA;;;;;;;;;;AAUA;AACA;AAQA;AACA;AAOA;AACA;AAbA;AACA;AACA;AACA;AAWA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzEA;AA0EA;;;AAGA;AACA;AAOA;AAPA;AAQA;;;AAGA;AACA;AAKA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCA;AAuCA;;AAEA;AACA;AAKA;AALA;AAOA;;AAEA;AACA;AAUA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7CA;AA+CA;;AAEA;AACA;AAOA;;;AAGA;AACA;AACA;AACA;AACA;AAdA;AAgBA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AAzCA;;;;;;;;;;;;;;;ACpOA;;;AAGA;AACA;;;AAGA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjFA;AADA;;;;;;;;;;;;;;ACRA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAxFA;AAyFA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AA1CA;AA2CA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAEA;AAtCA;AAuCA;;;;;;;;;;AAUA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAuBA;AA1IA;AA2IA;;;;;AAKA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;AA5GA;AA6GA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7bA;AACA;AAFA;AAgcA;;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AA0CA;;;AAGA;AACA;AAyBA;;;;;;;;;;;;;;;AAeA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;;;;;;;AAOA;AAEA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgFA;AAvGA;AAoOA;;;AAGA;AACA;AACA;;;;;;;;AAQA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AAMA;AACA;;;;AAIA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA9PA;;;;;;;;;;;;;;AC/qCA;;;AAGA;;AAEA;AAEA;;;;;;;;AAQA;AACA;AA0BA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;;AA7HA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAxBA;;;;;;;;;;;;;;AChBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AASA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3VA;AA6VA;;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AANA;;;;;;;;;;;;;;AC9WA;;;AAGA;;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhSA;;;;;;;;;;;;;;ACpBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AA1BA;AA2BA;;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnDA;AAoDA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AA1DA;;;;;;;;;;;;;;ACtHA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAnEA;;;;;;;;;;;;;;;ACvBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7HA;;;;;;;;;;;;;;ACdA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAmEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAvFA;;;;;;;;;;;;;;ACvFA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AA5CA;AA6CA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAncA;AAkeA;;;;AAIA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArGA;;;;;;;;;;;;;;ACzjBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBA;AAwBA;;;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7CA;AA8CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AACA;AAgBA;AACA;AACA;AACA;AAEA;AACA;AAnBA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;;AArpCA;AACA;AACA;AArIA;;;;;;;;;;;;;;ACzOA;;;AAGA;;AAQA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7CA;;;;;;;;;;;;;;ACnBA;;;AAGA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AAsCA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAbA;;;;;;;;;;;;;;AC1BA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AA7KA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAEA;AAEA;AAEA;;;AAGA;AACA;AAiBA;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAvKA;;;;;;;;;;;;;;ACbA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;AAGA;AACA;AAoBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAuCA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAmBA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAIA;AAGA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAKA;AAKA;AAKA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AASA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAIA;AAIA;AAIA;AAIA;AAKA;AACA;AACA;;;AAGA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAEA;AAKA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA58DA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AA+OA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAoBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAzYA;;;;;;;;;;;;;;AC/DA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;;;AAGA;AACA;AAAA;AAqbA;;;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AACA;AACA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAjrBA;AAkrBA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhqBA;AAiqBA;;;;;;;;;;;;;;AC50DA;;;AAGA;;AAEA;AAEA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;;;;;;;;;AASA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAIA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA/NA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AArPA;;;;;;;;;;;;;;AC/BA;;;AAGA;;AAKA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;;;;;;AAMA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AA3HA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAKA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAxHA;;;;;;;;;;;;;;AC7BA;;;AAGA;;AAOA;AAEA;AACA;AAEA;AACA;AACA;AAQA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAjLA;;;;;;;;;;;;;;AC9BA;;;AAGA;;AAKA;AAEA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AAeA;AAtBA;;;;;;;;;;;;;;AChBA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA7QA;;;;;;;;;;;;;;ACjCA;;;AAGA;;AAQA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAEA;;;;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA1IA;;;;;;;;;;;;;;AC5BA;;;AAGA;;AAMA;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAlQA;;;;;;;;;;;;;;AC3CA;;;AAGA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAqBA;;;;;;;;;;;;;;;AAeA;AACA;AA0IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnIA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAUA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAaA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAIA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/cA;AAzIA;AA0lBA;;;;AAIA;AACA;AAIA;AADA;AAEA;AACA;AACA;;;;;;AAMA;AACA;AASA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/LA;AAgMA;;;;;;;;;;AAUA;AACA;AAAA;AACA;;;;AAIA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACj4BA;;;AAGA;;AAEA;AAEA;AAEA;AACA;AAEA;AACA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAsDA;AAjuBA;;;;;;;;;;;;;;ACjBA;;;AAGA;;AAEA;AAEA;;;;;;;;;;;;;;AAcA;AACA;AAUA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1HA;;;;;;A","sourceRoot":""}