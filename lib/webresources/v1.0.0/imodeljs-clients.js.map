{"version":3,"file":"imodeljs-clients.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\base64-js\\1.3.0\\node_modules\\base64-js\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\buffer\\4.9.1\\node_modules\\buffer\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\builtin-status-codes\\3.0.0\\node_modules\\builtin-status-codes\\browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\component-emitter\\1.3.0\\node_modules\\component-emitter\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\core-util-is\\1.0.2\\node_modules\\core-util-is\\lib\\util.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\deep-assign\\2.0.0\\node_modules\\deep-assign\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\events\\3.0.0\\node_modules\\events\\events.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\https-browserify\\1.0.0\\node_modules\\https-browserify\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\ieee754\\1.1.13\\node_modules\\ieee754\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\inherits\\2.0.3\\node_modules\\inherits\\inherits_browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\is-obj\\1.0.1\\node_modules\\is-obj\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\isarray\\1.0.0\\node_modules\\isarray\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\js-base64\\2.5.1\\node_modules\\js-base64\\base64.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\process-nextick-args\\2.0.0\\node_modules\\process-nextick-args\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\process\\0.11.10\\node_modules\\process\\browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\punycode\\1.4.1\\node_modules\\punycode\\punycode.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\qs\\6.7.0\\node_modules\\qs\\lib\\formats.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\qs\\6.7.0\\node_modules\\qs\\lib\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\qs\\6.7.0\\node_modules\\qs\\lib\\parse.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\qs\\6.7.0\\node_modules\\qs\\lib\\stringify.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\qs\\6.7.0\\node_modules\\qs\\lib\\utils.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\querystring-es3\\0.2.1\\node_modules\\querystring-es3\\decode.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\querystring-es3\\0.2.1\\node_modules\\querystring-es3\\encode.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\querystring-es3\\0.2.1\\node_modules\\querystring-es3\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\_stream_duplex.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\_stream_passthrough.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\_stream_readable.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\_stream_transform.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\_stream_writable.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\internal\\streams\\BufferList.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\internal\\streams\\destroy.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\internal\\streams\\stream-browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\readable-browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\safe-buffer\\5.1.2\\node_modules\\safe-buffer\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\setimmediate\\1.0.5\\node_modules\\setimmediate\\setImmediate.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\stream-http\\2.8.3\\node_modules\\stream-http\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\stream-http\\2.8.3\\node_modules\\stream-http\\lib\\capability.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\stream-http\\2.8.3\\node_modules\\stream-http\\lib\\request.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\stream-http\\2.8.3\\node_modules\\stream-http\\lib\\response.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\string_decoder\\1.2.0\\node_modules\\string_decoder\\lib\\string_decoder.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\superagent\\3.8.3\\node_modules\\superagent\\lib\\agent-base.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\superagent\\3.8.3\\node_modules\\superagent\\lib\\client.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\superagent\\3.8.3\\node_modules\\superagent\\lib\\is-object.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\superagent\\3.8.3\\node_modules\\superagent\\lib\\request-base.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\superagent\\3.8.3\\node_modules\\superagent\\lib\\response-base.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\superagent\\3.8.3\\node_modules\\superagent\\lib\\utils.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\timers-browserify\\2.0.10\\node_modules\\timers-browserify\\main.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\to-arraybuffer\\1.0.1\\node_modules\\to-arraybuffer\\index.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\url\\0.11.0\\node_modules\\url\\url.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\url\\0.11.0\\node_modules\\url\\util.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\util-deprecate\\1.0.2\\node_modules\\util-deprecate\\browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\webpack\\4.32.2\\node_modules\\webpack\\buildin\\global.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\webpack\\4.32.2\\node_modules\\webpack\\buildin\\module.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\xmldom\\0.1.27\\node_modules\\xmldom\\dom-parser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\xmldom\\0.1.27\\node_modules\\xmldom\\dom.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\xmldom\\0.1.27\\node_modules\\xmldom\\sax.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\xpath\\0.0.27\\node_modules\\xpath\\xpath.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\xtend\\4.0.1\\node_modules\\xtend\\immutable.js","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\AuthorizedClientRequestContext.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\Client.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\ClientsLoggerCategory.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\Config.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\ConnectClients.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\ECJsonTypeMap.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\IModelClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\ImsClients.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\RealityDataServicesClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\Request.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\SettingsAdmin.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\SettingsClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\Token.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\UserInfo.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\WsgClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelbank\\IModelBankClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelbank\\IModelBankFileSystemContextClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelbank\\IModelBankHandler.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\BaseHandler.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Briefcases.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\ChangeSets.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Checkpoints.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Client.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Codes.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\CustomRequestOptions.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Errors.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Events.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\EventsBase.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\GlobalEvents.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Locks.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Query.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Thumbnails.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Users.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\Versions.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodelhub\\iModels.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\imodeljs-clients.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\oidc\\OidcClient.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\ulas\\LogEntryConverter.ts","file:///D:\\vsts_b\\5\\s\\core\\clients\\src\\ulas\\UlasClient.ts","file:///ignored D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib util","file:///ignored D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\readable-stream\\2.3.6\\node_modules\\readable-stream\\lib\\internal\\streams util","file:///external \"bentleyjs_core\"","file:///external \"geometry_core\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bentleyjs_core\"), require(\"geometry_core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"imodeljs_clients\", [\"bentleyjs_core\", \"geometry_core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"imodeljs_clients\"] = factory(require(\"bentleyjs_core\"), require(\"geometry_core\"));\n\telse\n\t\troot[\"imodeljs_clients\"] = factory(root[\"bentleyjs_core\"], root[\"geometry_core\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__, __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__) {\nreturn ","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  for (var i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(\n      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)\n    ))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","module.exports = {\n  \"100\": \"Continue\",\n  \"101\": \"Switching Protocols\",\n  \"102\": \"Processing\",\n  \"200\": \"OK\",\n  \"201\": \"Created\",\n  \"202\": \"Accepted\",\n  \"203\": \"Non-Authoritative Information\",\n  \"204\": \"No Content\",\n  \"205\": \"Reset Content\",\n  \"206\": \"Partial Content\",\n  \"207\": \"Multi-Status\",\n  \"208\": \"Already Reported\",\n  \"226\": \"IM Used\",\n  \"300\": \"Multiple Choices\",\n  \"301\": \"Moved Permanently\",\n  \"302\": \"Found\",\n  \"303\": \"See Other\",\n  \"304\": \"Not Modified\",\n  \"305\": \"Use Proxy\",\n  \"307\": \"Temporary Redirect\",\n  \"308\": \"Permanent Redirect\",\n  \"400\": \"Bad Request\",\n  \"401\": \"Unauthorized\",\n  \"402\": \"Payment Required\",\n  \"403\": \"Forbidden\",\n  \"404\": \"Not Found\",\n  \"405\": \"Method Not Allowed\",\n  \"406\": \"Not Acceptable\",\n  \"407\": \"Proxy Authentication Required\",\n  \"408\": \"Request Timeout\",\n  \"409\": \"Conflict\",\n  \"410\": \"Gone\",\n  \"411\": \"Length Required\",\n  \"412\": \"Precondition Failed\",\n  \"413\": \"Payload Too Large\",\n  \"414\": \"URI Too Long\",\n  \"415\": \"Unsupported Media Type\",\n  \"416\": \"Range Not Satisfiable\",\n  \"417\": \"Expectation Failed\",\n  \"418\": \"I'm a teapot\",\n  \"421\": \"Misdirected Request\",\n  \"422\": \"Unprocessable Entity\",\n  \"423\": \"Locked\",\n  \"424\": \"Failed Dependency\",\n  \"425\": \"Unordered Collection\",\n  \"426\": \"Upgrade Required\",\n  \"428\": \"Precondition Required\",\n  \"429\": \"Too Many Requests\",\n  \"431\": \"Request Header Fields Too Large\",\n  \"451\": \"Unavailable For Legal Reasons\",\n  \"500\": \"Internal Server Error\",\n  \"501\": \"Not Implemented\",\n  \"502\": \"Bad Gateway\",\n  \"503\": \"Service Unavailable\",\n  \"504\": \"Gateway Timeout\",\n  \"505\": \"HTTP Version Not Supported\",\n  \"506\": \"Variant Also Negotiates\",\n  \"507\": \"Insufficient Storage\",\n  \"508\": \"Loop Detected\",\n  \"509\": \"Bandwidth Limit Exceeded\",\n  \"510\": \"Not Extended\",\n  \"511\": \"Network Authentication Required\"\n}\n","\r\n/**\r\n * Expose `Emitter`.\r\n */\r\n\r\nif (typeof module !== 'undefined') {\r\n  module.exports = Emitter;\r\n}\r\n\r\n/**\r\n * Initialize a new `Emitter`.\r\n *\r\n * @api public\r\n */\r\n\r\nfunction Emitter(obj) {\r\n  if (obj) return mixin(obj);\r\n};\r\n\r\n/**\r\n * Mixin the emitter properties.\r\n *\r\n * @param {Object} obj\r\n * @return {Object}\r\n * @api private\r\n */\r\n\r\nfunction mixin(obj) {\r\n  for (var key in Emitter.prototype) {\r\n    obj[key] = Emitter.prototype[key];\r\n  }\r\n  return obj;\r\n}\r\n\r\n/**\r\n * Listen on the given `event` with `fn`.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.on =\r\nEmitter.prototype.addEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])\r\n    .push(fn);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Adds an `event` listener that will be invoked a single\r\n * time then automatically removed.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.once = function(event, fn){\r\n  function on() {\r\n    this.off(event, on);\r\n    fn.apply(this, arguments);\r\n  }\r\n\r\n  on.fn = fn;\r\n  this.on(event, on);\r\n  return this;\r\n};\r\n\r\n/**\r\n * Remove the given callback for `event` or all\r\n * registered callbacks.\r\n *\r\n * @param {String} event\r\n * @param {Function} fn\r\n * @return {Emitter}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.off =\r\nEmitter.prototype.removeListener =\r\nEmitter.prototype.removeAllListeners =\r\nEmitter.prototype.removeEventListener = function(event, fn){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  // all\r\n  if (0 == arguments.length) {\r\n    this._callbacks = {};\r\n    return this;\r\n  }\r\n\r\n  // specific event\r\n  var callbacks = this._callbacks['$' + event];\r\n  if (!callbacks) return this;\r\n\r\n  // remove all handlers\r\n  if (1 == arguments.length) {\r\n    delete this._callbacks['$' + event];\r\n    return this;\r\n  }\r\n\r\n  // remove specific handler\r\n  var cb;\r\n  for (var i = 0; i < callbacks.length; i++) {\r\n    cb = callbacks[i];\r\n    if (cb === fn || cb.fn === fn) {\r\n      callbacks.splice(i, 1);\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Remove event specific arrays for event types that no\r\n  // one is subscribed for to avoid memory leak.\r\n  if (callbacks.length === 0) {\r\n    delete this._callbacks['$' + event];\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Emit `event` with the given args.\r\n *\r\n * @param {String} event\r\n * @param {Mixed} ...\r\n * @return {Emitter}\r\n */\r\n\r\nEmitter.prototype.emit = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n\r\n  var args = new Array(arguments.length - 1)\r\n    , callbacks = this._callbacks['$' + event];\r\n\r\n  for (var i = 1; i < arguments.length; i++) {\r\n    args[i - 1] = arguments[i];\r\n  }\r\n\r\n  if (callbacks) {\r\n    callbacks = callbacks.slice(0);\r\n    for (var i = 0, len = callbacks.length; i < len; ++i) {\r\n      callbacks[i].apply(this, args);\r\n    }\r\n  }\r\n\r\n  return this;\r\n};\r\n\r\n/**\r\n * Return array of callbacks for `event`.\r\n *\r\n * @param {String} event\r\n * @return {Array}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.listeners = function(event){\r\n  this._callbacks = this._callbacks || {};\r\n  return this._callbacks['$' + event] || [];\r\n};\r\n\r\n/**\r\n * Check if this emitter has `event` handlers.\r\n *\r\n * @param {String} event\r\n * @return {Boolean}\r\n * @api public\r\n */\r\n\r\nEmitter.prototype.hasListeners = function(event){\r\n  return !! this.listeners(event).length;\r\n};\r\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n","'use strict';\nvar isObj = require('is-obj');\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar propIsEnumerable = Object.prototype.propertyIsEnumerable;\n\nfunction toObject(val) {\n\tif (val === null || val === undefined) {\n\t\tthrow new TypeError('Sources cannot be null or undefined');\n\t}\n\n\treturn Object(val);\n}\n\nfunction assignKey(to, from, key) {\n\tvar val = from[key];\n\n\tif (val === undefined || val === null) {\n\t\treturn;\n\t}\n\n\tif (hasOwnProperty.call(to, key)) {\n\t\tif (to[key] === undefined || to[key] === null) {\n\t\t\tthrow new TypeError('Cannot convert undefined or null to object (' + key + ')');\n\t\t}\n\t}\n\n\tif (!hasOwnProperty.call(to, key) || !isObj(val)) {\n\t\tto[key] = val;\n\t} else {\n\t\tto[key] = assign(Object(to[key]), from[key]);\n\t}\n}\n\nfunction assign(to, from) {\n\tif (to === from) {\n\t\treturn to;\n\t}\n\n\tfrom = Object(from);\n\n\tfor (var key in from) {\n\t\tif (hasOwnProperty.call(from, key)) {\n\t\t\tassignKey(to, from, key);\n\t\t}\n\t}\n\n\tif (Object.getOwnPropertySymbols) {\n\t\tvar symbols = Object.getOwnPropertySymbols(from);\n\n\t\tfor (var i = 0; i < symbols.length; i++) {\n\t\t\tif (propIsEnumerable.call(from, symbols[i])) {\n\t\t\t\tassignKey(to, from, symbols[i]);\n\t\t\t}\n\t\t}\n\t}\n\n\treturn to;\n}\n\nmodule.exports = function deepAssign(target) {\n\ttarget = toObject(target);\n\n\tfor (var s = 1; s < arguments.length; s++) {\n\t\tassign(target, arguments[s]);\n\t}\n\n\treturn target;\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar R = typeof Reflect === 'object' ? Reflect : null\nvar ReflectApply = R && typeof R.apply === 'function'\n  ? R.apply\n  : function ReflectApply(target, receiver, args) {\n    return Function.prototype.apply.call(target, receiver, args);\n  }\n\nvar ReflectOwnKeys\nif (R && typeof R.ownKeys === 'function') {\n  ReflectOwnKeys = R.ownKeys\n} else if (Object.getOwnPropertySymbols) {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target)\n      .concat(Object.getOwnPropertySymbols(target));\n  };\n} else {\n  ReflectOwnKeys = function ReflectOwnKeys(target) {\n    return Object.getOwnPropertyNames(target);\n  };\n}\n\nfunction ProcessEmitWarning(warning) {\n  if (console && console.warn) console.warn(warning);\n}\n\nvar NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {\n  return value !== value;\n}\n\nfunction EventEmitter() {\n  EventEmitter.init.call(this);\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._eventsCount = 0;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nvar defaultMaxListeners = 10;\n\nObject.defineProperty(EventEmitter, 'defaultMaxListeners', {\n  enumerable: true,\n  get: function() {\n    return defaultMaxListeners;\n  },\n  set: function(arg) {\n    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {\n      throw new RangeError('The value of \"defaultMaxListeners\" is out of range. It must be a non-negative number. Received ' + arg + '.');\n    }\n    defaultMaxListeners = arg;\n  }\n});\n\nEventEmitter.init = function() {\n\n  if (this._events === undefined ||\n      this._events === Object.getPrototypeOf(this)._events) {\n    this._events = Object.create(null);\n    this._eventsCount = 0;\n  }\n\n  this._maxListeners = this._maxListeners || undefined;\n};\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {\n  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {\n    throw new RangeError('The value of \"n\" is out of range. It must be a non-negative number. Received ' + n + '.');\n  }\n  this._maxListeners = n;\n  return this;\n};\n\nfunction $getMaxListeners(that) {\n  if (that._maxListeners === undefined)\n    return EventEmitter.defaultMaxListeners;\n  return that._maxListeners;\n}\n\nEventEmitter.prototype.getMaxListeners = function getMaxListeners() {\n  return $getMaxListeners(this);\n};\n\nEventEmitter.prototype.emit = function emit(type) {\n  var args = [];\n  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);\n  var doError = (type === 'error');\n\n  var events = this._events;\n  if (events !== undefined)\n    doError = (doError && events.error === undefined);\n  else if (!doError)\n    return false;\n\n  // If there is no 'error' event listener then throw.\n  if (doError) {\n    var er;\n    if (args.length > 0)\n      er = args[0];\n    if (er instanceof Error) {\n      // Note: The comments on the `throw` lines are intentional, they show\n      // up in Node's output if this results in an unhandled exception.\n      throw er; // Unhandled 'error' event\n    }\n    // At least give some kind of context to the user\n    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));\n    err.context = er;\n    throw err; // Unhandled 'error' event\n  }\n\n  var handler = events[type];\n\n  if (handler === undefined)\n    return false;\n\n  if (typeof handler === 'function') {\n    ReflectApply(handler, this, args);\n  } else {\n    var len = handler.length;\n    var listeners = arrayClone(handler, len);\n    for (var i = 0; i < len; ++i)\n      ReflectApply(listeners[i], this, args);\n  }\n\n  return true;\n};\n\nfunction _addListener(target, type, listener, prepend) {\n  var m;\n  var events;\n  var existing;\n\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n\n  events = target._events;\n  if (events === undefined) {\n    events = target._events = Object.create(null);\n    target._eventsCount = 0;\n  } else {\n    // To avoid recursion in the case that type === \"newListener\"! Before\n    // adding it to the listeners, first emit \"newListener\".\n    if (events.newListener !== undefined) {\n      target.emit('newListener', type,\n                  listener.listener ? listener.listener : listener);\n\n      // Re-assign `events` because a newListener handler could have caused the\n      // this._events to be assigned to a new object\n      events = target._events;\n    }\n    existing = events[type];\n  }\n\n  if (existing === undefined) {\n    // Optimize the case of one listener. Don't need the extra array object.\n    existing = events[type] = listener;\n    ++target._eventsCount;\n  } else {\n    if (typeof existing === 'function') {\n      // Adding the second element, need to change to array.\n      existing = events[type] =\n        prepend ? [listener, existing] : [existing, listener];\n      // If we've already got an array, just append.\n    } else if (prepend) {\n      existing.unshift(listener);\n    } else {\n      existing.push(listener);\n    }\n\n    // Check for listener leak\n    m = $getMaxListeners(target);\n    if (m > 0 && existing.length > m && !existing.warned) {\n      existing.warned = true;\n      // No error code for this since it is a Warning\n      // eslint-disable-next-line no-restricted-syntax\n      var w = new Error('Possible EventEmitter memory leak detected. ' +\n                          existing.length + ' ' + String(type) + ' listeners ' +\n                          'added. Use emitter.setMaxListeners() to ' +\n                          'increase limit');\n      w.name = 'MaxListenersExceededWarning';\n      w.emitter = target;\n      w.type = type;\n      w.count = existing.length;\n      ProcessEmitWarning(w);\n    }\n  }\n\n  return target;\n}\n\nEventEmitter.prototype.addListener = function addListener(type, listener) {\n  return _addListener(this, type, listener, false);\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.prependListener =\n    function prependListener(type, listener) {\n      return _addListener(this, type, listener, true);\n    };\n\nfunction onceWrapper() {\n  var args = [];\n  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);\n  if (!this.fired) {\n    this.target.removeListener(this.type, this.wrapFn);\n    this.fired = true;\n    ReflectApply(this.listener, this.target, args);\n  }\n}\n\nfunction _onceWrap(target, type, listener) {\n  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };\n  var wrapped = onceWrapper.bind(state);\n  wrapped.listener = listener;\n  state.wrapFn = wrapped;\n  return wrapped;\n}\n\nEventEmitter.prototype.once = function once(type, listener) {\n  if (typeof listener !== 'function') {\n    throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n  }\n  this.on(type, _onceWrap(this, type, listener));\n  return this;\n};\n\nEventEmitter.prototype.prependOnceListener =\n    function prependOnceListener(type, listener) {\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n      this.prependListener(type, _onceWrap(this, type, listener));\n      return this;\n    };\n\n// Emits a 'removeListener' event if and only if the listener was removed.\nEventEmitter.prototype.removeListener =\n    function removeListener(type, listener) {\n      var list, events, position, i, originalListener;\n\n      if (typeof listener !== 'function') {\n        throw new TypeError('The \"listener\" argument must be of type Function. Received type ' + typeof listener);\n      }\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      list = events[type];\n      if (list === undefined)\n        return this;\n\n      if (list === listener || list.listener === listener) {\n        if (--this._eventsCount === 0)\n          this._events = Object.create(null);\n        else {\n          delete events[type];\n          if (events.removeListener)\n            this.emit('removeListener', type, list.listener || listener);\n        }\n      } else if (typeof list !== 'function') {\n        position = -1;\n\n        for (i = list.length - 1; i >= 0; i--) {\n          if (list[i] === listener || list[i].listener === listener) {\n            originalListener = list[i].listener;\n            position = i;\n            break;\n          }\n        }\n\n        if (position < 0)\n          return this;\n\n        if (position === 0)\n          list.shift();\n        else {\n          spliceOne(list, position);\n        }\n\n        if (list.length === 1)\n          events[type] = list[0];\n\n        if (events.removeListener !== undefined)\n          this.emit('removeListener', type, originalListener || listener);\n      }\n\n      return this;\n    };\n\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\n\nEventEmitter.prototype.removeAllListeners =\n    function removeAllListeners(type) {\n      var listeners, events, i;\n\n      events = this._events;\n      if (events === undefined)\n        return this;\n\n      // not listening for removeListener, no need to emit\n      if (events.removeListener === undefined) {\n        if (arguments.length === 0) {\n          this._events = Object.create(null);\n          this._eventsCount = 0;\n        } else if (events[type] !== undefined) {\n          if (--this._eventsCount === 0)\n            this._events = Object.create(null);\n          else\n            delete events[type];\n        }\n        return this;\n      }\n\n      // emit removeListener for all listeners on all events\n      if (arguments.length === 0) {\n        var keys = Object.keys(events);\n        var key;\n        for (i = 0; i < keys.length; ++i) {\n          key = keys[i];\n          if (key === 'removeListener') continue;\n          this.removeAllListeners(key);\n        }\n        this.removeAllListeners('removeListener');\n        this._events = Object.create(null);\n        this._eventsCount = 0;\n        return this;\n      }\n\n      listeners = events[type];\n\n      if (typeof listeners === 'function') {\n        this.removeListener(type, listeners);\n      } else if (listeners !== undefined) {\n        // LIFO order\n        for (i = listeners.length - 1; i >= 0; i--) {\n          this.removeListener(type, listeners[i]);\n        }\n      }\n\n      return this;\n    };\n\nfunction _listeners(target, type, unwrap) {\n  var events = target._events;\n\n  if (events === undefined)\n    return [];\n\n  var evlistener = events[type];\n  if (evlistener === undefined)\n    return [];\n\n  if (typeof evlistener === 'function')\n    return unwrap ? [evlistener.listener || evlistener] : [evlistener];\n\n  return unwrap ?\n    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);\n}\n\nEventEmitter.prototype.listeners = function listeners(type) {\n  return _listeners(this, type, true);\n};\n\nEventEmitter.prototype.rawListeners = function rawListeners(type) {\n  return _listeners(this, type, false);\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  if (typeof emitter.listenerCount === 'function') {\n    return emitter.listenerCount(type);\n  } else {\n    return listenerCount.call(emitter, type);\n  }\n};\n\nEventEmitter.prototype.listenerCount = listenerCount;\nfunction listenerCount(type) {\n  var events = this._events;\n\n  if (events !== undefined) {\n    var evlistener = events[type];\n\n    if (typeof evlistener === 'function') {\n      return 1;\n    } else if (evlistener !== undefined) {\n      return evlistener.length;\n    }\n  }\n\n  return 0;\n}\n\nEventEmitter.prototype.eventNames = function eventNames() {\n  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];\n};\n\nfunction arrayClone(arr, n) {\n  var copy = new Array(n);\n  for (var i = 0; i < n; ++i)\n    copy[i] = arr[i];\n  return copy;\n}\n\nfunction spliceOne(list, index) {\n  for (; index + 1 < list.length; index++)\n    list[index] = list[index + 1];\n  list.pop();\n}\n\nfunction unwrapListeners(arr) {\n  var ret = new Array(arr.length);\n  for (var i = 0; i < ret.length; ++i) {\n    ret[i] = arr[i].listener || arr[i];\n  }\n  return ret;\n}\n","var http = require('http')\nvar url = require('url')\n\nvar https = module.exports\n\nfor (var key in http) {\n  if (http.hasOwnProperty(key)) https[key] = http[key]\n}\n\nhttps.request = function (params, cb) {\n  params = validateParams(params)\n  return http.request.call(this, params, cb)\n}\n\nhttps.get = function (params, cb) {\n  params = validateParams(params)\n  return http.get.call(this, params, cb)\n}\n\nfunction validateParams (params) {\n  if (typeof params === 'string') {\n    params = url.parse(params)\n  }\n  if (!params.protocol) {\n    params.protocol = 'https:'\n  }\n  if (params.protocol !== 'https:') {\n    throw new Error('Protocol \"' + params.protocol + '\" not supported. Expected \"https:\"')\n  }\n  return params\n}\n","exports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","if (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n","'use strict';\nmodule.exports = function (x) {\n\tvar type = typeof x;\n\treturn x !== null && (type === 'object' || type === 'function');\n};\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","/*\n *  base64.js\n *\n *  Licensed under the BSD 3-Clause License.\n *    http://opensource.org/licenses/BSD-3-Clause\n *\n *  References:\n *    http://en.wikipedia.org/wiki/Base64\n */\n;(function (global, factory) {\n    typeof exports === 'object' && typeof module !== 'undefined'\n        ? module.exports = factory(global)\n        : typeof define === 'function' && define.amd\n        ? define(factory) : factory(global)\n}((\n    typeof self !== 'undefined' ? self\n        : typeof window !== 'undefined' ? window\n        : typeof global !== 'undefined' ? global\n: this\n), function(global) {\n    'use strict';\n    // existing version for noConflict()\n    global = global || {};\n    var _Base64 = global.Base64;\n    var version = \"2.5.1\";\n    // if node.js and NOT React Native, we use Buffer\n    var buffer;\n    if (typeof module !== 'undefined' && module.exports) {\n        try {\n            buffer = eval(\"require('buffer').Buffer\");\n        } catch (err) {\n            buffer = undefined;\n        }\n    }\n    // constants\n    var b64chars\n        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var b64tab = function(bin) {\n        var t = {};\n        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;\n        return t;\n    }(b64chars);\n    var fromCharCode = String.fromCharCode;\n    // encoder stuff\n    var cb_utob = function(c) {\n        if (c.length < 2) {\n            var cc = c.charCodeAt(0);\n            return cc < 0x80 ? c\n                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))\n                                + fromCharCode(0x80 | (cc & 0x3f)))\n                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))\n                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                   + fromCharCode(0x80 | ( cc         & 0x3f)));\n        } else {\n            var cc = 0x10000\n                + (c.charCodeAt(0) - 0xD800) * 0x400\n                + (c.charCodeAt(1) - 0xDC00);\n            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))\n                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))\n                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))\n                    + fromCharCode(0x80 | ( cc         & 0x3f)));\n        }\n    };\n    var re_utob = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFFF]|[^\\x00-\\x7F]/g;\n    var utob = function(u) {\n        return u.replace(re_utob, cb_utob);\n    };\n    var cb_encode = function(ccc) {\n        var padlen = [0, 2, 1][ccc.length % 3],\n        ord = ccc.charCodeAt(0) << 16\n            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)\n            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),\n        chars = [\n            b64chars.charAt( ord >>> 18),\n            b64chars.charAt((ord >>> 12) & 63),\n            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),\n            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)\n        ];\n        return chars.join('');\n    };\n    var btoa = global.btoa ? function(b) {\n        return global.btoa(b);\n    } : function(b) {\n        return b.replace(/[\\s\\S]{1,3}/g, cb_encode);\n    };\n    var _encode = buffer ?\n        buffer.from && Uint8Array && buffer.from !== Uint8Array.from\n        ? function (u) {\n            return (u.constructor === buffer.constructor ? u : buffer.from(u))\n                .toString('base64')\n        }\n        :  function (u) {\n            return (u.constructor === buffer.constructor ? u : new  buffer(u))\n                .toString('base64')\n        }\n        : function (u) { return btoa(utob(u)) }\n    ;\n    var encode = function(u, urisafe) {\n        return !urisafe\n            ? _encode(String(u))\n            : _encode(String(u)).replace(/[+\\/]/g, function(m0) {\n                return m0 == '+' ? '-' : '_';\n            }).replace(/=/g, '');\n    };\n    var encodeURI = function(u) { return encode(u, true) };\n    // decoder stuff\n    var re_btou = new RegExp([\n        '[\\xC0-\\xDF][\\x80-\\xBF]',\n        '[\\xE0-\\xEF][\\x80-\\xBF]{2}',\n        '[\\xF0-\\xF7][\\x80-\\xBF]{3}'\n    ].join('|'), 'g');\n    var cb_btou = function(cccc) {\n        switch(cccc.length) {\n        case 4:\n            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)\n                |    ((0x3f & cccc.charCodeAt(1)) << 12)\n                |    ((0x3f & cccc.charCodeAt(2)) <<  6)\n                |     (0x3f & cccc.charCodeAt(3)),\n            offset = cp - 0x10000;\n            return (fromCharCode((offset  >>> 10) + 0xD800)\n                    + fromCharCode((offset & 0x3FF) + 0xDC00));\n        case 3:\n            return fromCharCode(\n                ((0x0f & cccc.charCodeAt(0)) << 12)\n                    | ((0x3f & cccc.charCodeAt(1)) << 6)\n                    |  (0x3f & cccc.charCodeAt(2))\n            );\n        default:\n            return  fromCharCode(\n                ((0x1f & cccc.charCodeAt(0)) << 6)\n                    |  (0x3f & cccc.charCodeAt(1))\n            );\n        }\n    };\n    var btou = function(b) {\n        return b.replace(re_btou, cb_btou);\n    };\n    var cb_decode = function(cccc) {\n        var len = cccc.length,\n        padlen = len % 4,\n        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)\n            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)\n            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)\n            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),\n        chars = [\n            fromCharCode( n >>> 16),\n            fromCharCode((n >>>  8) & 0xff),\n            fromCharCode( n         & 0xff)\n        ];\n        chars.length -= [0, 0, 2, 1][padlen];\n        return chars.join('');\n    };\n    var _atob = global.atob ? function(a) {\n        return global.atob(a);\n    } : function(a){\n        return a.replace(/\\S{1,4}/g, cb_decode);\n    };\n    var atob = function(a) {\n        return _atob(String(a).replace(/[^A-Za-z0-9\\+\\/]/g, ''));\n    };\n    var _decode = buffer ?\n        buffer.from && Uint8Array && buffer.from !== Uint8Array.from\n        ? function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : buffer.from(a, 'base64')).toString();\n        }\n        : function(a) {\n            return (a.constructor === buffer.constructor\n                    ? a : new buffer(a, 'base64')).toString();\n        }\n        : function(a) { return btou(_atob(a)) };\n    var decode = function(a){\n        return _decode(\n            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })\n                .replace(/[^A-Za-z0-9\\+\\/]/g, '')\n        );\n    };\n    var noConflict = function() {\n        var Base64 = global.Base64;\n        global.Base64 = _Base64;\n        return Base64;\n    };\n    // export Base64\n    global.Base64 = {\n        VERSION: version,\n        atob: atob,\n        btoa: btoa,\n        fromBase64: decode,\n        toBase64: encode,\n        utob: utob,\n        encode: encode,\n        encodeURI: encodeURI,\n        btou: btou,\n        decode: decode,\n        noConflict: noConflict,\n        __buffer__: buffer\n    };\n    // if ES5 is available, make Base64.extendString() available\n    if (typeof Object.defineProperty === 'function') {\n        var noEnum = function(v){\n            return {value:v,enumerable:false,writable:true,configurable:true};\n        };\n        global.Base64.extendString = function () {\n            Object.defineProperty(\n                String.prototype, 'fromBase64', noEnum(function () {\n                    return decode(this)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64', noEnum(function (urisafe) {\n                    return encode(this, urisafe)\n                }));\n            Object.defineProperty(\n                String.prototype, 'toBase64URI', noEnum(function () {\n                    return encode(this, true)\n                }));\n        };\n    }\n    //\n    // export Base64 to the namespace\n    //\n    if (global['Meteor']) { // Meteor.js\n        Base64 = global.Base64;\n    }\n    // module.exports and AMD are mutually exclusive.\n    // module.exports has precedence.\n    if (typeof module !== 'undefined' && module.exports) {\n        module.exports.Base64 = global.Base64;\n    }\n    else if (typeof define === 'function' && define.amd) {\n        // AMD. Register as an anonymous module.\n        define([], function(){ return global.Base64 });\n    }\n    // that's it!\n    return {Base64: global.Base64}\n}));\n","'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = { nextTick: nextTick };\n} else {\n  module.exports = process\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","/*! https://mths.be/punycode v1.4.1 by @mathias */\n;(function(root) {\n\n\t/** Detect free variables */\n\tvar freeExports = typeof exports == 'object' && exports &&\n\t\t!exports.nodeType && exports;\n\tvar freeModule = typeof module == 'object' && module &&\n\t\t!module.nodeType && module;\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (\n\t\tfreeGlobal.global === freeGlobal ||\n\t\tfreeGlobal.window === freeGlobal ||\n\t\tfreeGlobal.self === freeGlobal\n\t) {\n\t\troot = freeGlobal;\n\t}\n\n\t/**\n\t * The `punycode` object.\n\t * @name punycode\n\t * @type Object\n\t */\n\tvar punycode,\n\n\t/** Highest positive signed 32-bit float value */\n\tmaxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1\n\n\t/** Bootstring parameters */\n\tbase = 36,\n\ttMin = 1,\n\ttMax = 26,\n\tskew = 38,\n\tdamp = 700,\n\tinitialBias = 72,\n\tinitialN = 128, // 0x80\n\tdelimiter = '-', // '\\x2D'\n\n\t/** Regular expressions */\n\tregexPunycode = /^xn--/,\n\tregexNonASCII = /[^\\x20-\\x7E]/, // unprintable ASCII chars + non-ASCII chars\n\tregexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g, // RFC 3490 separators\n\n\t/** Error messages */\n\terrors = {\n\t\t'overflow': 'Overflow: input needs wider integers to process',\n\t\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t\t'invalid-input': 'Invalid input'\n\t},\n\n\t/** Convenience shortcuts */\n\tbaseMinusTMin = base - tMin,\n\tfloor = Math.floor,\n\tstringFromCharCode = String.fromCharCode,\n\n\t/** Temporary variable */\n\tkey;\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/**\n\t * A generic error utility function.\n\t * @private\n\t * @param {String} type The error type.\n\t * @returns {Error} Throws a `RangeError` with the applicable error message.\n\t */\n\tfunction error(type) {\n\t\tthrow new RangeError(errors[type]);\n\t}\n\n\t/**\n\t * A generic `Array#map` utility function.\n\t * @private\n\t * @param {Array} array The array to iterate over.\n\t * @param {Function} callback The function that gets called for every array\n\t * item.\n\t * @returns {Array} A new array of values returned by the callback function.\n\t */\n\tfunction map(array, fn) {\n\t\tvar length = array.length;\n\t\tvar result = [];\n\t\twhile (length--) {\n\t\t\tresult[length] = fn(array[length]);\n\t\t}\n\t\treturn result;\n\t}\n\n\t/**\n\t * A simple `Array#map`-like wrapper to work with domain name strings or email\n\t * addresses.\n\t * @private\n\t * @param {String} domain The domain name or email address.\n\t * @param {Function} callback The function that gets called for every\n\t * character.\n\t * @returns {Array} A new string of characters returned by the callback\n\t * function.\n\t */\n\tfunction mapDomain(string, fn) {\n\t\tvar parts = string.split('@');\n\t\tvar result = '';\n\t\tif (parts.length > 1) {\n\t\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t\t// the local part (i.e. everything up to `@`) intact.\n\t\t\tresult = parts[0] + '@';\n\t\t\tstring = parts[1];\n\t\t}\n\t\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\t\tstring = string.replace(regexSeparators, '\\x2E');\n\t\tvar labels = string.split('.');\n\t\tvar encoded = map(labels, fn).join('.');\n\t\treturn result + encoded;\n\t}\n\n\t/**\n\t * Creates an array containing the numeric code points of each Unicode\n\t * character in the string. While JavaScript uses UCS-2 internally,\n\t * this function will convert a pair of surrogate halves (each of which\n\t * UCS-2 exposes as separate characters) into a single code point,\n\t * matching UTF-16.\n\t * @see `punycode.ucs2.encode`\n\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t * @memberOf punycode.ucs2\n\t * @name decode\n\t * @param {String} string The Unicode input string (UCS-2).\n\t * @returns {Array} The new array of code points.\n\t */\n\tfunction ucs2decode(string) {\n\t\tvar output = [],\n\t\t    counter = 0,\n\t\t    length = string.length,\n\t\t    value,\n\t\t    extra;\n\t\twhile (counter < length) {\n\t\t\tvalue = string.charCodeAt(counter++);\n\t\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t\t// high surrogate, and there is a next character\n\t\t\t\textra = string.charCodeAt(counter++);\n\t\t\t\tif ((extra & 0xFC00) == 0xDC00) { // low surrogate\n\t\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t\t} else {\n\t\t\t\t\t// unmatched surrogate; only append this code unit, in case the next\n\t\t\t\t\t// code unit is the high surrogate of a surrogate pair\n\t\t\t\t\toutput.push(value);\n\t\t\t\t\tcounter--;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\toutput.push(value);\n\t\t\t}\n\t\t}\n\t\treturn output;\n\t}\n\n\t/**\n\t * Creates a string based on an array of numeric code points.\n\t * @see `punycode.ucs2.decode`\n\t * @memberOf punycode.ucs2\n\t * @name encode\n\t * @param {Array} codePoints The array of numeric code points.\n\t * @returns {String} The new Unicode string (UCS-2).\n\t */\n\tfunction ucs2encode(array) {\n\t\treturn map(array, function(value) {\n\t\t\tvar output = '';\n\t\t\tif (value > 0xFFFF) {\n\t\t\t\tvalue -= 0x10000;\n\t\t\t\toutput += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);\n\t\t\t\tvalue = 0xDC00 | value & 0x3FF;\n\t\t\t}\n\t\t\toutput += stringFromCharCode(value);\n\t\t\treturn output;\n\t\t}).join('');\n\t}\n\n\t/**\n\t * Converts a basic code point into a digit/integer.\n\t * @see `digitToBasic()`\n\t * @private\n\t * @param {Number} codePoint The basic numeric code point value.\n\t * @returns {Number} The numeric value of a basic code point (for use in\n\t * representing integers) in the range `0` to `base - 1`, or `base` if\n\t * the code point does not represent a value.\n\t */\n\tfunction basicToDigit(codePoint) {\n\t\tif (codePoint - 48 < 10) {\n\t\t\treturn codePoint - 22;\n\t\t}\n\t\tif (codePoint - 65 < 26) {\n\t\t\treturn codePoint - 65;\n\t\t}\n\t\tif (codePoint - 97 < 26) {\n\t\t\treturn codePoint - 97;\n\t\t}\n\t\treturn base;\n\t}\n\n\t/**\n\t * Converts a digit/integer into a basic code point.\n\t * @see `basicToDigit()`\n\t * @private\n\t * @param {Number} digit The numeric value of a basic code point.\n\t * @returns {Number} The basic code point whose value (when used for\n\t * representing integers) is `digit`, which needs to be in the range\n\t * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n\t * used; else, the lowercase form is used. The behavior is undefined\n\t * if `flag` is non-zero and `digit` has no uppercase form.\n\t */\n\tfunction digitToBasic(digit, flag) {\n\t\t//  0..25 map to ASCII a..z or A..Z\n\t\t// 26..35 map to ASCII 0..9\n\t\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n\t}\n\n\t/**\n\t * Bias adaptation function as per section 3.4 of RFC 3492.\n\t * https://tools.ietf.org/html/rfc3492#section-3.4\n\t * @private\n\t */\n\tfunction adapt(delta, numPoints, firstTime) {\n\t\tvar k = 0;\n\t\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\t\tdelta += floor(delta / numPoints);\n\t\tfor (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\t\tdelta = floor(delta / baseMinusTMin);\n\t\t}\n\t\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n\t}\n\n\t/**\n\t * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n\t * symbols.\n\t * @memberOf punycode\n\t * @param {String} input The Punycode string of ASCII-only symbols.\n\t * @returns {String} The resulting string of Unicode symbols.\n\t */\n\tfunction decode(input) {\n\t\t// Don't use UCS-2\n\t\tvar output = [],\n\t\t    inputLength = input.length,\n\t\t    out,\n\t\t    i = 0,\n\t\t    n = initialN,\n\t\t    bias = initialBias,\n\t\t    basic,\n\t\t    j,\n\t\t    index,\n\t\t    oldi,\n\t\t    w,\n\t\t    k,\n\t\t    digit,\n\t\t    t,\n\t\t    /** Cached calculation results */\n\t\t    baseMinusT;\n\n\t\t// Handle the basic code points: let `basic` be the number of input code\n\t\t// points before the last delimiter, or `0` if there is none, then copy\n\t\t// the first basic code points to the output.\n\n\t\tbasic = input.lastIndexOf(delimiter);\n\t\tif (basic < 0) {\n\t\t\tbasic = 0;\n\t\t}\n\n\t\tfor (j = 0; j < basic; ++j) {\n\t\t\t// if it's not a basic code point\n\t\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\t\terror('not-basic');\n\t\t\t}\n\t\t\toutput.push(input.charCodeAt(j));\n\t\t}\n\n\t\t// Main decoding loop: start just after the last delimiter if any basic code\n\t\t// points were copied; start at the beginning otherwise.\n\n\t\tfor (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {\n\n\t\t\t// `index` is the index of the next character to be consumed.\n\t\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t\t// which gets added to `i`. The overflow checking is easier\n\t\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t\t// value at the end to obtain `delta`.\n\t\t\tfor (oldi = i, w = 1, k = base; /* no condition */; k += base) {\n\n\t\t\t\tif (index >= inputLength) {\n\t\t\t\t\terror('invalid-input');\n\t\t\t\t}\n\n\t\t\t\tdigit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\ti += digit * w;\n\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\n\t\t\t\tif (digit < t) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tbaseMinusT = base - t;\n\t\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tw *= baseMinusT;\n\n\t\t\t}\n\n\t\t\tout = output.length + 1;\n\t\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t\t// incrementing `n` each time, so we'll fix that now:\n\t\t\tif (floor(i / out) > maxInt - n) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tn += floor(i / out);\n\t\t\ti %= out;\n\n\t\t\t// Insert `n` at position `i` of the output\n\t\t\toutput.splice(i++, 0, n);\n\n\t\t}\n\n\t\treturn ucs2encode(output);\n\t}\n\n\t/**\n\t * Converts a string of Unicode symbols (e.g. a domain name label) to a\n\t * Punycode string of ASCII-only symbols.\n\t * @memberOf punycode\n\t * @param {String} input The string of Unicode symbols.\n\t * @returns {String} The resulting Punycode string of ASCII-only symbols.\n\t */\n\tfunction encode(input) {\n\t\tvar n,\n\t\t    delta,\n\t\t    handledCPCount,\n\t\t    basicLength,\n\t\t    bias,\n\t\t    j,\n\t\t    m,\n\t\t    q,\n\t\t    k,\n\t\t    t,\n\t\t    currentValue,\n\t\t    output = [],\n\t\t    /** `inputLength` will hold the number of code points in `input`. */\n\t\t    inputLength,\n\t\t    /** Cached calculation results */\n\t\t    handledCPCountPlusOne,\n\t\t    baseMinusT,\n\t\t    qMinusT;\n\n\t\t// Convert the input in UCS-2 to Unicode\n\t\tinput = ucs2decode(input);\n\n\t\t// Cache the length\n\t\tinputLength = input.length;\n\n\t\t// Initialize the state\n\t\tn = initialN;\n\t\tdelta = 0;\n\t\tbias = initialBias;\n\n\t\t// Handle the basic code points\n\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\tcurrentValue = input[j];\n\t\t\tif (currentValue < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(currentValue));\n\t\t\t}\n\t\t}\n\n\t\thandledCPCount = basicLength = output.length;\n\n\t\t// `handledCPCount` is the number of code points that have been handled;\n\t\t// `basicLength` is the number of basic code points.\n\n\t\t// Finish the basic string - if it is not empty - with a delimiter\n\t\tif (basicLength) {\n\t\t\toutput.push(delimiter);\n\t\t}\n\n\t\t// Main encoding loop:\n\t\twhile (handledCPCount < inputLength) {\n\n\t\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t\t// larger one:\n\t\t\tfor (m = maxInt, j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow\n\t\t\thandledCPCountPlusOne = handledCPCount + 1;\n\t\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\t\terror('overflow');\n\t\t\t}\n\n\t\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\t\tn = m;\n\n\t\t\tfor (j = 0; j < inputLength; ++j) {\n\t\t\t\tcurrentValue = input[j];\n\n\t\t\t\tif (currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror('overflow');\n\t\t\t\t}\n\n\t\t\t\tif (currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer\n\t\t\t\t\tfor (q = delta, k = base; /* no condition */; k += base) {\n\t\t\t\t\t\tt = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tqMinusT = q - t;\n\t\t\t\t\t\tbaseMinusT = base - t;\n\t\t\t\t\t\toutput.push(\n\t\t\t\t\t\t\tstringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))\n\t\t\t\t\t\t);\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t++delta;\n\t\t\t++n;\n\n\t\t}\n\t\treturn output.join('');\n\t}\n\n\t/**\n\t * Converts a Punycode string representing a domain name or an email address\n\t * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n\t * it doesn't matter if you call it on a string that has already been\n\t * converted to Unicode.\n\t * @memberOf punycode\n\t * @param {String} input The Punycoded domain name or email address to\n\t * convert to Unicode.\n\t * @returns {String} The Unicode representation of the given Punycode\n\t * string.\n\t */\n\tfunction toUnicode(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexPunycode.test(string)\n\t\t\t\t? decode(string.slice(4).toLowerCase())\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/**\n\t * Converts a Unicode string representing a domain name or an email address to\n\t * Punycode. Only the non-ASCII parts of the domain name will be converted,\n\t * i.e. it doesn't matter if you call it with a domain that's already in\n\t * ASCII.\n\t * @memberOf punycode\n\t * @param {String} input The domain name or email address to convert, as a\n\t * Unicode string.\n\t * @returns {String} The Punycode representation of the given domain name or\n\t * email address.\n\t */\n\tfunction toASCII(input) {\n\t\treturn mapDomain(input, function(string) {\n\t\t\treturn regexNonASCII.test(string)\n\t\t\t\t? 'xn--' + encode(string)\n\t\t\t\t: string;\n\t\t});\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t/** Define the public API */\n\tpunycode = {\n\t\t/**\n\t\t * A string representing the current Punycode.js version number.\n\t\t * @memberOf punycode\n\t\t * @type String\n\t\t */\n\t\t'version': '1.4.1',\n\t\t/**\n\t\t * An object of methods to convert from JavaScript's internal character\n\t\t * representation (UCS-2) to Unicode code points, and back.\n\t\t * @see <https://mathiasbynens.be/notes/javascript-encoding>\n\t\t * @memberOf punycode\n\t\t * @type Object\n\t\t */\n\t\t'ucs2': {\n\t\t\t'decode': ucs2decode,\n\t\t\t'encode': ucs2encode\n\t\t},\n\t\t'decode': decode,\n\t\t'encode': encode,\n\t\t'toASCII': toASCII,\n\t\t'toUnicode': toUnicode\n\t};\n\n\t/** Expose `punycode` */\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\ttypeof define == 'function' &&\n\t\ttypeof define.amd == 'object' &&\n\t\tdefine.amd\n\t) {\n\t\tdefine('punycode', function() {\n\t\t\treturn punycode;\n\t\t});\n\t} else if (freeExports && freeModule) {\n\t\tif (module.exports == freeExports) {\n\t\t\t// in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = punycode;\n\t\t} else {\n\t\t\t// in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (key in punycode) {\n\t\t\t\tpunycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);\n\t\t\t}\n\t\t}\n\t} else {\n\t\t// in Rhino or a web browser\n\t\troot.punycode = punycode;\n\t}\n\n}(this));\n","'use strict';\n\nvar replace = String.prototype.replace;\nvar percentTwenties = /%20/g;\n\nmodule.exports = {\n    'default': 'RFC3986',\n    formatters: {\n        RFC1738: function (value) {\n            return replace.call(value, percentTwenties, '+');\n        },\n        RFC3986: function (value) {\n            return value;\n        }\n    },\n    RFC1738: 'RFC1738',\n    RFC3986: 'RFC3986'\n};\n","'use strict';\n\nvar stringify = require('./stringify');\nvar parse = require('./parse');\nvar formats = require('./formats');\n\nmodule.exports = {\n    formats: formats,\n    parse: parse,\n    stringify: stringify\n};\n","'use strict';\n\nvar utils = require('./utils');\n\nvar has = Object.prototype.hasOwnProperty;\n\nvar defaults = {\n    allowDots: false,\n    allowPrototypes: false,\n    arrayLimit: 20,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    comma: false,\n    decoder: utils.decode,\n    delimiter: '&',\n    depth: 5,\n    ignoreQueryPrefix: false,\n    interpretNumericEntities: false,\n    parameterLimit: 1000,\n    parseArrays: true,\n    plainObjects: false,\n    strictNullHandling: false\n};\n\nvar interpretNumericEntities = function (str) {\n    return str.replace(/&#(\\d+);/g, function ($0, numberStr) {\n        return String.fromCharCode(parseInt(numberStr, 10));\n    });\n};\n\n// This is what browsers will submit when the ✓ character occurs in an\n// application/x-www-form-urlencoded body and the encoding of the page containing\n// the form is iso-8859-1, or when the submitted form has an accept-charset\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\n// the ✓ character, such as us-ascii.\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\n\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')\n\nvar parseValues = function parseQueryStringValues(str, options) {\n    var obj = {};\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\?/, '') : str;\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\n    var parts = cleanStr.split(options.delimiter, limit);\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\n    var i;\n\n    var charset = options.charset;\n    if (options.charsetSentinel) {\n        for (i = 0; i < parts.length; ++i) {\n            if (parts[i].indexOf('utf8=') === 0) {\n                if (parts[i] === charsetSentinel) {\n                    charset = 'utf-8';\n                } else if (parts[i] === isoSentinel) {\n                    charset = 'iso-8859-1';\n                }\n                skipIndex = i;\n                i = parts.length; // The eslint settings do not allow break;\n            }\n        }\n    }\n\n    for (i = 0; i < parts.length; ++i) {\n        if (i === skipIndex) {\n            continue;\n        }\n        var part = parts[i];\n\n        var bracketEqualsPos = part.indexOf(']=');\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\n\n        var key, val;\n        if (pos === -1) {\n            key = options.decoder(part, defaults.decoder, charset);\n            val = options.strictNullHandling ? null : '';\n        } else {\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);\n            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);\n        }\n\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\n            val = interpretNumericEntities(val);\n        }\n\n        if (val && options.comma && val.indexOf(',') > -1) {\n            val = val.split(',');\n        }\n\n        if (has.call(obj, key)) {\n            obj[key] = utils.combine(obj[key], val);\n        } else {\n            obj[key] = val;\n        }\n    }\n\n    return obj;\n};\n\nvar parseObject = function (chain, val, options) {\n    var leaf = val;\n\n    for (var i = chain.length - 1; i >= 0; --i) {\n        var obj;\n        var root = chain[i];\n\n        if (root === '[]' && options.parseArrays) {\n            obj = [].concat(leaf);\n        } else {\n            obj = options.plainObjects ? Object.create(null) : {};\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\n            var index = parseInt(cleanRoot, 10);\n            if (!options.parseArrays && cleanRoot === '') {\n                obj = { 0: leaf };\n            } else if (\n                !isNaN(index)\n                && root !== cleanRoot\n                && String(index) === cleanRoot\n                && index >= 0\n                && (options.parseArrays && index <= options.arrayLimit)\n            ) {\n                obj = [];\n                obj[index] = leaf;\n            } else {\n                obj[cleanRoot] = leaf;\n            }\n        }\n\n        leaf = obj;\n    }\n\n    return leaf;\n};\n\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options) {\n    if (!givenKey) {\n        return;\n    }\n\n    // Transform dot notation to bracket notation\n    var key = options.allowDots ? givenKey.replace(/\\.([^.[]+)/g, '[$1]') : givenKey;\n\n    // The regex chunks\n\n    var brackets = /(\\[[^[\\]]*])/;\n    var child = /(\\[[^[\\]]*])/g;\n\n    // Get the parent\n\n    var segment = brackets.exec(key);\n    var parent = segment ? key.slice(0, segment.index) : key;\n\n    // Stash the parent if it exists\n\n    var keys = [];\n    if (parent) {\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n\n        keys.push(parent);\n    }\n\n    // Loop through children appending to the array until we hit depth\n\n    var i = 0;\n    while ((segment = child.exec(key)) !== null && i < options.depth) {\n        i += 1;\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\n            if (!options.allowPrototypes) {\n                return;\n            }\n        }\n        keys.push(segment[1]);\n    }\n\n    // If there's a remainder, just add whatever is left\n\n    if (segment) {\n        keys.push('[' + key.slice(segment.index) + ']');\n    }\n\n    return parseObject(keys, val, options);\n};\n\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\n        throw new TypeError('Decoder has to be a function.');\n    }\n\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\n\n    return {\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\n        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\n        parseArrays: opts.parseArrays !== false,\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (str, opts) {\n    var options = normalizeParseOptions(opts);\n\n    if (str === '' || str === null || typeof str === 'undefined') {\n        return options.plainObjects ? Object.create(null) : {};\n    }\n\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\n    var obj = options.plainObjects ? Object.create(null) : {};\n\n    // Iterate over the keys and setup the new object\n\n    var keys = Object.keys(tempObj);\n    for (var i = 0; i < keys.length; ++i) {\n        var key = keys[i];\n        var newObj = parseKeys(key, tempObj[key], options);\n        obj = utils.merge(obj, newObj, options);\n    }\n\n    return utils.compact(obj);\n};\n","'use strict';\n\nvar utils = require('./utils');\nvar formats = require('./formats');\nvar has = Object.prototype.hasOwnProperty;\n\nvar arrayPrefixGenerators = {\n    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching\n        return prefix + '[]';\n    },\n    comma: 'comma',\n    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching\n        return prefix + '[' + key + ']';\n    },\n    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching\n        return prefix;\n    }\n};\n\nvar isArray = Array.isArray;\nvar push = Array.prototype.push;\nvar pushToArray = function (arr, valueOrArray) {\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\n};\n\nvar toISO = Date.prototype.toISOString;\n\nvar defaults = {\n    addQueryPrefix: false,\n    allowDots: false,\n    charset: 'utf-8',\n    charsetSentinel: false,\n    delimiter: '&',\n    encode: true,\n    encoder: utils.encode,\n    encodeValuesOnly: false,\n    formatter: formats.formatters[formats['default']],\n    // deprecated\n    indices: false,\n    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching\n        return toISO.call(date);\n    },\n    skipNulls: false,\n    strictNullHandling: false\n};\n\nvar stringify = function stringify( // eslint-disable-line func-name-matching\n    object,\n    prefix,\n    generateArrayPrefix,\n    strictNullHandling,\n    skipNulls,\n    encoder,\n    filter,\n    sort,\n    allowDots,\n    serializeDate,\n    formatter,\n    encodeValuesOnly,\n    charset\n) {\n    var obj = object;\n    if (typeof filter === 'function') {\n        obj = filter(prefix, obj);\n    } else if (obj instanceof Date) {\n        obj = serializeDate(obj);\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\n        obj = obj.join(',');\n    }\n\n    if (obj === null) {\n        if (strictNullHandling) {\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;\n        }\n\n        obj = '';\n    }\n\n    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {\n        if (encoder) {\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];\n        }\n        return [formatter(prefix) + '=' + formatter(String(obj))];\n    }\n\n    var values = [];\n\n    if (typeof obj === 'undefined') {\n        return values;\n    }\n\n    var objKeys;\n    if (isArray(filter)) {\n        objKeys = filter;\n    } else {\n        var keys = Object.keys(obj);\n        objKeys = sort ? keys.sort(sort) : keys;\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (skipNulls && obj[key] === null) {\n            continue;\n        }\n\n        if (isArray(obj)) {\n            pushToArray(values, stringify(\n                obj[key],\n                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        } else {\n            pushToArray(values, stringify(\n                obj[key],\n                prefix + (allowDots ? '.' + key : '[' + key + ']'),\n                generateArrayPrefix,\n                strictNullHandling,\n                skipNulls,\n                encoder,\n                filter,\n                sort,\n                allowDots,\n                serializeDate,\n                formatter,\n                encodeValuesOnly,\n                charset\n            ));\n        }\n    }\n\n    return values;\n};\n\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\n    if (!opts) {\n        return defaults;\n    }\n\n    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {\n        throw new TypeError('Encoder has to be a function.');\n    }\n\n    var charset = opts.charset || defaults.charset;\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\n    }\n\n    var format = formats['default'];\n    if (typeof opts.format !== 'undefined') {\n        if (!has.call(formats.formatters, opts.format)) {\n            throw new TypeError('Unknown format option provided.');\n        }\n        format = opts.format;\n    }\n    var formatter = formats.formatters[format];\n\n    var filter = defaults.filter;\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\n        filter = opts.filter;\n    }\n\n    return {\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\n        charset: charset,\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\n        filter: filter,\n        formatter: formatter,\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\n    };\n};\n\nmodule.exports = function (object, opts) {\n    var obj = object;\n    var options = normalizeStringifyOptions(opts);\n\n    var objKeys;\n    var filter;\n\n    if (typeof options.filter === 'function') {\n        filter = options.filter;\n        obj = filter('', obj);\n    } else if (isArray(options.filter)) {\n        filter = options.filter;\n        objKeys = filter;\n    }\n\n    var keys = [];\n\n    if (typeof obj !== 'object' || obj === null) {\n        return '';\n    }\n\n    var arrayFormat;\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\n        arrayFormat = opts.arrayFormat;\n    } else if (opts && 'indices' in opts) {\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\n    } else {\n        arrayFormat = 'indices';\n    }\n\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\n\n    if (!objKeys) {\n        objKeys = Object.keys(obj);\n    }\n\n    if (options.sort) {\n        objKeys.sort(options.sort);\n    }\n\n    for (var i = 0; i < objKeys.length; ++i) {\n        var key = objKeys[i];\n\n        if (options.skipNulls && obj[key] === null) {\n            continue;\n        }\n        pushToArray(keys, stringify(\n            obj[key],\n            key,\n            generateArrayPrefix,\n            options.strictNullHandling,\n            options.skipNulls,\n            options.encode ? options.encoder : null,\n            options.filter,\n            options.sort,\n            options.allowDots,\n            options.serializeDate,\n            options.formatter,\n            options.encodeValuesOnly,\n            options.charset\n        ));\n    }\n\n    var joined = keys.join(options.delimiter);\n    var prefix = options.addQueryPrefix === true ? '?' : '';\n\n    if (options.charsetSentinel) {\n        if (options.charset === 'iso-8859-1') {\n            // encodeURIComponent('&#10003;'), the \"numeric entity\" representation of a checkmark\n            prefix += 'utf8=%26%2310003%3B&';\n        } else {\n            // encodeURIComponent('✓')\n            prefix += 'utf8=%E2%9C%93&';\n        }\n    }\n\n    return joined.length > 0 ? prefix + joined : '';\n};\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty;\nvar isArray = Array.isArray;\n\nvar hexTable = (function () {\n    var array = [];\n    for (var i = 0; i < 256; ++i) {\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\n    }\n\n    return array;\n}());\n\nvar compactQueue = function compactQueue(queue) {\n    while (queue.length > 1) {\n        var item = queue.pop();\n        var obj = item.obj[item.prop];\n\n        if (isArray(obj)) {\n            var compacted = [];\n\n            for (var j = 0; j < obj.length; ++j) {\n                if (typeof obj[j] !== 'undefined') {\n                    compacted.push(obj[j]);\n                }\n            }\n\n            item.obj[item.prop] = compacted;\n        }\n    }\n};\n\nvar arrayToObject = function arrayToObject(source, options) {\n    var obj = options && options.plainObjects ? Object.create(null) : {};\n    for (var i = 0; i < source.length; ++i) {\n        if (typeof source[i] !== 'undefined') {\n            obj[i] = source[i];\n        }\n    }\n\n    return obj;\n};\n\nvar merge = function merge(target, source, options) {\n    if (!source) {\n        return target;\n    }\n\n    if (typeof source !== 'object') {\n        if (isArray(target)) {\n            target.push(source);\n        } else if (target && typeof target === 'object') {\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\n                target[source] = true;\n            }\n        } else {\n            return [target, source];\n        }\n\n        return target;\n    }\n\n    if (!target || typeof target !== 'object') {\n        return [target].concat(source);\n    }\n\n    var mergeTarget = target;\n    if (isArray(target) && !isArray(source)) {\n        mergeTarget = arrayToObject(target, options);\n    }\n\n    if (isArray(target) && isArray(source)) {\n        source.forEach(function (item, i) {\n            if (has.call(target, i)) {\n                var targetItem = target[i];\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\n                    target[i] = merge(targetItem, item, options);\n                } else {\n                    target.push(item);\n                }\n            } else {\n                target[i] = item;\n            }\n        });\n        return target;\n    }\n\n    return Object.keys(source).reduce(function (acc, key) {\n        var value = source[key];\n\n        if (has.call(acc, key)) {\n            acc[key] = merge(acc[key], value, options);\n        } else {\n            acc[key] = value;\n        }\n        return acc;\n    }, mergeTarget);\n};\n\nvar assign = function assignSingleSource(target, source) {\n    return Object.keys(source).reduce(function (acc, key) {\n        acc[key] = source[key];\n        return acc;\n    }, target);\n};\n\nvar decode = function (str, decoder, charset) {\n    var strWithoutPlus = str.replace(/\\+/g, ' ');\n    if (charset === 'iso-8859-1') {\n        // unescape never throws, no try...catch needed:\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\n    }\n    // utf-8\n    try {\n        return decodeURIComponent(strWithoutPlus);\n    } catch (e) {\n        return strWithoutPlus;\n    }\n};\n\nvar encode = function encode(str, defaultEncoder, charset) {\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\n    // It has been adapted here for stricter adherence to RFC 3986\n    if (str.length === 0) {\n        return str;\n    }\n\n    var string = typeof str === 'string' ? str : String(str);\n\n    if (charset === 'iso-8859-1') {\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\n        });\n    }\n\n    var out = '';\n    for (var i = 0; i < string.length; ++i) {\n        var c = string.charCodeAt(i);\n\n        if (\n            c === 0x2D // -\n            || c === 0x2E // .\n            || c === 0x5F // _\n            || c === 0x7E // ~\n            || (c >= 0x30 && c <= 0x39) // 0-9\n            || (c >= 0x41 && c <= 0x5A) // a-z\n            || (c >= 0x61 && c <= 0x7A) // A-Z\n        ) {\n            out += string.charAt(i);\n            continue;\n        }\n\n        if (c < 0x80) {\n            out = out + hexTable[c];\n            continue;\n        }\n\n        if (c < 0x800) {\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        if (c < 0xD800 || c >= 0xE000) {\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\n            continue;\n        }\n\n        i += 1;\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\n        out += hexTable[0xF0 | (c >> 18)]\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\n            + hexTable[0x80 | (c & 0x3F)];\n    }\n\n    return out;\n};\n\nvar compact = function compact(value) {\n    var queue = [{ obj: { o: value }, prop: 'o' }];\n    var refs = [];\n\n    for (var i = 0; i < queue.length; ++i) {\n        var item = queue[i];\n        var obj = item.obj[item.prop];\n\n        var keys = Object.keys(obj);\n        for (var j = 0; j < keys.length; ++j) {\n            var key = keys[j];\n            var val = obj[key];\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\n                queue.push({ obj: obj, prop: key });\n                refs.push(val);\n            }\n        }\n    }\n\n    compactQueue(queue);\n\n    return value;\n};\n\nvar isRegExp = function isRegExp(obj) {\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\n};\n\nvar isBuffer = function isBuffer(obj) {\n    if (!obj || typeof obj !== 'object') {\n        return false;\n    }\n\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\n};\n\nvar combine = function combine(a, b) {\n    return [].concat(a, b);\n};\n\nmodule.exports = {\n    arrayToObject: arrayToObject,\n    assign: assign,\n    combine: combine,\n    compact: compact,\n    decode: decode,\n    encode: encode,\n    isBuffer: isBuffer,\n    isRegExp: isRegExp,\n    merge: merge\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n// If obj.hasOwnProperty has been overridden, then calling\n// obj.hasOwnProperty(prop) will break.\n// See: https://github.com/joyent/node/issues/1707\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\nmodule.exports = function(qs, sep, eq, options) {\n  sep = sep || '&';\n  eq = eq || '=';\n  var obj = {};\n\n  if (typeof qs !== 'string' || qs.length === 0) {\n    return obj;\n  }\n\n  var regexp = /\\+/g;\n  qs = qs.split(sep);\n\n  var maxKeys = 1000;\n  if (options && typeof options.maxKeys === 'number') {\n    maxKeys = options.maxKeys;\n  }\n\n  var len = qs.length;\n  // maxKeys <= 0 means that we should not limit keys count\n  if (maxKeys > 0 && len > maxKeys) {\n    len = maxKeys;\n  }\n\n  for (var i = 0; i < len; ++i) {\n    var x = qs[i].replace(regexp, '%20'),\n        idx = x.indexOf(eq),\n        kstr, vstr, k, v;\n\n    if (idx >= 0) {\n      kstr = x.substr(0, idx);\n      vstr = x.substr(idx + 1);\n    } else {\n      kstr = x;\n      vstr = '';\n    }\n\n    k = decodeURIComponent(kstr);\n    v = decodeURIComponent(vstr);\n\n    if (!hasOwnProperty(obj, k)) {\n      obj[k] = v;\n    } else if (isArray(obj[k])) {\n      obj[k].push(v);\n    } else {\n      obj[k] = [obj[k], v];\n    }\n  }\n\n  return obj;\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar stringifyPrimitive = function(v) {\n  switch (typeof v) {\n    case 'string':\n      return v;\n\n    case 'boolean':\n      return v ? 'true' : 'false';\n\n    case 'number':\n      return isFinite(v) ? v : '';\n\n    default:\n      return '';\n  }\n};\n\nmodule.exports = function(obj, sep, eq, name) {\n  sep = sep || '&';\n  eq = eq || '=';\n  if (obj === null) {\n    obj = undefined;\n  }\n\n  if (typeof obj === 'object') {\n    return map(objectKeys(obj), function(k) {\n      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;\n      if (isArray(obj[k])) {\n        return map(obj[k], function(v) {\n          return ks + encodeURIComponent(stringifyPrimitive(v));\n        }).join(sep);\n      } else {\n        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));\n      }\n    }).join(sep);\n\n  }\n\n  if (!name) return '';\n  return encodeURIComponent(stringifyPrimitive(name)) + eq +\n         encodeURIComponent(stringifyPrimitive(obj));\n};\n\nvar isArray = Array.isArray || function (xs) {\n  return Object.prototype.toString.call(xs) === '[object Array]';\n};\n\nfunction map (xs, f) {\n  if (xs.map) return xs.map(f);\n  var res = [];\n  for (var i = 0; i < xs.length; i++) {\n    res.push(f(xs[i], i));\n  }\n  return res;\n}\n\nvar objectKeys = Object.keys || function (obj) {\n  var res = [];\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);\n  }\n  return res;\n};\n","'use strict';\n\nexports.decode = exports.parse = require('./decode');\nexports.encode = exports.stringify = require('./encode');\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\n{\n  // avoid scope creep, the keys array can then be collected\n  var keys = objectKeys(Writable.prototype);\n  for (var v = 0; v < keys.length; v++) {\n    var method = keys[v];\n    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n  }\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\nObject.defineProperty(Duplex.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  pna.nextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  pna.nextTick(cb, err);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);\n\n  // This is a hack to make sure that our error handler is attached before any\n  // userland ones.  NEVER DO THIS. This is here only because this code needs\n  // to continue to work with older versions of Node.js that do not include\n  // the prependListener() method. The goal is to eventually remove this hack.\n  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var readableHwm = options.readableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    pna.nextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        pna.nextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    pna.nextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var _this = this;\n\n  var state = this._readableState;\n  var paused = false;\n\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) _this.push(chunk);\n    }\n\n    _this.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = _this.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  this._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return this;\n};\n\nObject.defineProperty(Readable.prototype, 'readableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._readableState.highWaterMark;\n  }\n});\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    pna.nextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction afterTransform(er, data) {\n  var ts = this._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return this.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    this.push(data);\n\n  cb(er);\n\n  var rs = this._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    this._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = {\n    afterTransform: afterTransform.bind(this),\n    needTransform: false,\n    transforming: false,\n    writecb: null,\n    writechunk: null,\n    writeencoding: null\n  };\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.on('prefinish', prefinish);\n}\n\nfunction prefinish() {\n  var _this = this;\n\n  if (typeof this._flush === 'function') {\n    this._flush(function (er, data) {\n      done(_this, er, data);\n    });\n  } else {\n    done(this, null, null);\n  }\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this2 = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this2.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data != null) // single equals check for both `null` and `undefined`\n    stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // Duplex streams are both readable and writable, but share\n  // the same options object.\n  // However, some cases require setting options to different\n  // values for the readable and the writable sides of the duplex stream.\n  // These options can be provided separately as readableXXX and writableXXX.\n  var isDuplex = stream instanceof Duplex;\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var writableHwm = options.writableHighWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n\n  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n      if (this !== Writable) return false;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  pna.nextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    pna.nextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = !state.objectMode && _isUint8Array(chunk);\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\nObject.defineProperty(Writable.prototype, 'writableHighWaterMark', {\n  // making it explicit this property is not enumerable\n  // because otherwise some prototype manipulation in\n  // userland will fail\n  enumerable: false,\n  get: function () {\n    return this._writableState.highWaterMark;\n  }\n});\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    pna.nextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    pna.nextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n    state.bufferedRequestCount = 0;\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      state.bufferedRequestCount--;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      pna.nextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};","'use strict';\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\nvar util = require('util');\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n\nif (util && util.inspect && util.inspect.custom) {\n  module.exports.prototype[util.inspect.custom] = function () {\n    var obj = util.inspect({ length: this.length });\n    return this.constructor.name + ' ' + obj;\n  };\n}","'use strict';\n\n/*<replacement>*/\n\nvar pna = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      pna.nextTick(emitErrorNT, this, err);\n    }\n    return this;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      pna.nextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n\n  return this;\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};","module.exports = require('events').EventEmitter;\n","exports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n","/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n","(function (global, undefined) {\n    \"use strict\";\n\n    if (global.setImmediate) {\n        return;\n    }\n\n    var nextHandle = 1; // Spec says greater than zero\n    var tasksByHandle = {};\n    var currentlyRunningATask = false;\n    var doc = global.document;\n    var registerImmediate;\n\n    function setImmediate(callback) {\n      // Callback can either be a function or a string\n      if (typeof callback !== \"function\") {\n        callback = new Function(\"\" + callback);\n      }\n      // Copy function arguments\n      var args = new Array(arguments.length - 1);\n      for (var i = 0; i < args.length; i++) {\n          args[i] = arguments[i + 1];\n      }\n      // Store and register the task\n      var task = { callback: callback, args: args };\n      tasksByHandle[nextHandle] = task;\n      registerImmediate(nextHandle);\n      return nextHandle++;\n    }\n\n    function clearImmediate(handle) {\n        delete tasksByHandle[handle];\n    }\n\n    function run(task) {\n        var callback = task.callback;\n        var args = task.args;\n        switch (args.length) {\n        case 0:\n            callback();\n            break;\n        case 1:\n            callback(args[0]);\n            break;\n        case 2:\n            callback(args[0], args[1]);\n            break;\n        case 3:\n            callback(args[0], args[1], args[2]);\n            break;\n        default:\n            callback.apply(undefined, args);\n            break;\n        }\n    }\n\n    function runIfPresent(handle) {\n        // From the spec: \"Wait until any invocations of this algorithm started before this one have completed.\"\n        // So if we're currently running a task, we'll need to delay this invocation.\n        if (currentlyRunningATask) {\n            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a\n            // \"too much recursion\" error.\n            setTimeout(runIfPresent, 0, handle);\n        } else {\n            var task = tasksByHandle[handle];\n            if (task) {\n                currentlyRunningATask = true;\n                try {\n                    run(task);\n                } finally {\n                    clearImmediate(handle);\n                    currentlyRunningATask = false;\n                }\n            }\n        }\n    }\n\n    function installNextTickImplementation() {\n        registerImmediate = function(handle) {\n            process.nextTick(function () { runIfPresent(handle); });\n        };\n    }\n\n    function canUsePostMessage() {\n        // The test against `importScripts` prevents this implementation from being installed inside a web worker,\n        // where `global.postMessage` means something completely different and can't be used for this purpose.\n        if (global.postMessage && !global.importScripts) {\n            var postMessageIsAsynchronous = true;\n            var oldOnMessage = global.onmessage;\n            global.onmessage = function() {\n                postMessageIsAsynchronous = false;\n            };\n            global.postMessage(\"\", \"*\");\n            global.onmessage = oldOnMessage;\n            return postMessageIsAsynchronous;\n        }\n    }\n\n    function installPostMessageImplementation() {\n        // Installs an event handler on `global` for the `message` event: see\n        // * https://developer.mozilla.org/en/DOM/window.postMessage\n        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages\n\n        var messagePrefix = \"setImmediate$\" + Math.random() + \"$\";\n        var onGlobalMessage = function(event) {\n            if (event.source === global &&\n                typeof event.data === \"string\" &&\n                event.data.indexOf(messagePrefix) === 0) {\n                runIfPresent(+event.data.slice(messagePrefix.length));\n            }\n        };\n\n        if (global.addEventListener) {\n            global.addEventListener(\"message\", onGlobalMessage, false);\n        } else {\n            global.attachEvent(\"onmessage\", onGlobalMessage);\n        }\n\n        registerImmediate = function(handle) {\n            global.postMessage(messagePrefix + handle, \"*\");\n        };\n    }\n\n    function installMessageChannelImplementation() {\n        var channel = new MessageChannel();\n        channel.port1.onmessage = function(event) {\n            var handle = event.data;\n            runIfPresent(handle);\n        };\n\n        registerImmediate = function(handle) {\n            channel.port2.postMessage(handle);\n        };\n    }\n\n    function installReadyStateChangeImplementation() {\n        var html = doc.documentElement;\n        registerImmediate = function(handle) {\n            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted\n            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.\n            var script = doc.createElement(\"script\");\n            script.onreadystatechange = function () {\n                runIfPresent(handle);\n                script.onreadystatechange = null;\n                html.removeChild(script);\n                script = null;\n            };\n            html.appendChild(script);\n        };\n    }\n\n    function installSetTimeoutImplementation() {\n        registerImmediate = function(handle) {\n            setTimeout(runIfPresent, 0, handle);\n        };\n    }\n\n    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.\n    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);\n    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;\n\n    // Don't get fooled by e.g. browserify environments.\n    if ({}.toString.call(global.process) === \"[object process]\") {\n        // For Node.js before 0.9\n        installNextTickImplementation();\n\n    } else if (canUsePostMessage()) {\n        // For non-IE10 modern browsers\n        installPostMessageImplementation();\n\n    } else if (global.MessageChannel) {\n        // For web workers, where supported\n        installMessageChannelImplementation();\n\n    } else if (doc && \"onreadystatechange\" in doc.createElement(\"script\")) {\n        // For IE 6–8\n        installReadyStateChangeImplementation();\n\n    } else {\n        // For older browsers\n        installSetTimeoutImplementation();\n    }\n\n    attachTo.setImmediate = setImmediate;\n    attachTo.clearImmediate = clearImmediate;\n}(typeof self === \"undefined\" ? typeof global === \"undefined\" ? this : global : self));\n","var ClientRequest = require('./lib/request')\nvar response = require('./lib/response')\nvar extend = require('xtend')\nvar statusCodes = require('builtin-status-codes')\nvar url = require('url')\n\nvar http = exports\n\nhttp.request = function (opts, cb) {\n\tif (typeof opts === 'string')\n\t\topts = url.parse(opts)\n\telse\n\t\topts = extend(opts)\n\n\t// Normally, the page is loaded from http or https, so not specifying a protocol\n\t// will result in a (valid) protocol-relative url. However, this won't work if\n\t// the protocol is something else, like 'file:'\n\tvar defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''\n\n\tvar protocol = opts.protocol || defaultProtocol\n\tvar host = opts.hostname || opts.host\n\tvar port = opts.port\n\tvar path = opts.path || '/'\n\n\t// Necessary for IPv6 addresses\n\tif (host && host.indexOf(':') !== -1)\n\t\thost = '[' + host + ']'\n\n\t// This may be a relative url. The browser should always be able to interpret it correctly.\n\topts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path\n\topts.method = (opts.method || 'GET').toUpperCase()\n\topts.headers = opts.headers || {}\n\n\t// Also valid opts.auth, opts.mode\n\n\tvar req = new ClientRequest(opts)\n\tif (cb)\n\t\treq.on('response', cb)\n\treturn req\n}\n\nhttp.get = function get (opts, cb) {\n\tvar req = http.request(opts, cb)\n\treq.end()\n\treturn req\n}\n\nhttp.ClientRequest = ClientRequest\nhttp.IncomingMessage = response.IncomingMessage\n\nhttp.Agent = function () {}\nhttp.Agent.defaultMaxSockets = 4\n\nhttp.globalAgent = new http.Agent()\n\nhttp.STATUS_CODES = statusCodes\n\nhttp.METHODS = [\n\t'CHECKOUT',\n\t'CONNECT',\n\t'COPY',\n\t'DELETE',\n\t'GET',\n\t'HEAD',\n\t'LOCK',\n\t'M-SEARCH',\n\t'MERGE',\n\t'MKACTIVITY',\n\t'MKCOL',\n\t'MOVE',\n\t'NOTIFY',\n\t'OPTIONS',\n\t'PATCH',\n\t'POST',\n\t'PROPFIND',\n\t'PROPPATCH',\n\t'PURGE',\n\t'PUT',\n\t'REPORT',\n\t'SEARCH',\n\t'SUBSCRIBE',\n\t'TRACE',\n\t'UNLOCK',\n\t'UNSUBSCRIBE'\n]","exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)\n\nexports.writableStream = isFunction(global.WritableStream)\n\nexports.abortController = isFunction(global.AbortController)\n\nexports.blobConstructor = false\ntry {\n\tnew Blob([new ArrayBuffer(1)])\n\texports.blobConstructor = true\n} catch (e) {}\n\n// The xhr request to example.com may violate some restrictive CSP configurations,\n// so if we're running in a browser that supports `fetch`, avoid calling getXHR()\n// and assume support for certain features below.\nvar xhr\nfunction getXHR () {\n\t// Cache the xhr value\n\tif (xhr !== undefined) return xhr\n\n\tif (global.XMLHttpRequest) {\n\t\txhr = new global.XMLHttpRequest()\n\t\t// If XDomainRequest is available (ie only, where xhr might not work\n\t\t// cross domain), use the page location. Otherwise use example.com\n\t\t// Note: this doesn't actually make an http request.\n\t\ttry {\n\t\t\txhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')\n\t\t} catch(e) {\n\t\t\txhr = null\n\t\t}\n\t} else {\n\t\t// Service workers don't have XHR\n\t\txhr = null\n\t}\n\treturn xhr\n}\n\nfunction checkTypeSupport (type) {\n\tvar xhr = getXHR()\n\tif (!xhr) return false\n\ttry {\n\t\txhr.responseType = type\n\t\treturn xhr.responseType === type\n\t} catch (e) {}\n\treturn false\n}\n\n// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.\n// Safari 7.1 appears to have fixed this bug.\nvar haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'\nvar haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)\n\n// If fetch is supported, then arraybuffer will be supported too. Skip calling\n// checkTypeSupport(), since that calls getXHR().\nexports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))\n\n// These next two tests unavoidably show warnings in Chrome. Since fetch will always\n// be used if it's available, just return false for these to avoid the warnings.\nexports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')\nexports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&\n\tcheckTypeSupport('moz-chunked-arraybuffer')\n\n// If fetch is supported, then overrideMimeType will be supported too. Skip calling\n// getXHR().\nexports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)\n\nexports.vbArray = isFunction(global.VBArray)\n\nfunction isFunction (value) {\n\treturn typeof value === 'function'\n}\n\nxhr = null // Help gc\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar response = require('./response')\nvar stream = require('readable-stream')\nvar toArrayBuffer = require('to-arraybuffer')\n\nvar IncomingMessage = response.IncomingMessage\nvar rStates = response.readyStates\n\nfunction decideMode (preferBinary, useFetch) {\n\tif (capability.fetch && useFetch) {\n\t\treturn 'fetch'\n\t} else if (capability.mozchunkedarraybuffer) {\n\t\treturn 'moz-chunked-arraybuffer'\n\t} else if (capability.msstream) {\n\t\treturn 'ms-stream'\n\t} else if (capability.arraybuffer && preferBinary) {\n\t\treturn 'arraybuffer'\n\t} else if (capability.vbArray && preferBinary) {\n\t\treturn 'text:vbarray'\n\t} else {\n\t\treturn 'text'\n\t}\n}\n\nvar ClientRequest = module.exports = function (opts) {\n\tvar self = this\n\tstream.Writable.call(self)\n\n\tself._opts = opts\n\tself._body = []\n\tself._headers = {}\n\tif (opts.auth)\n\t\tself.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))\n\tObject.keys(opts.headers).forEach(function (name) {\n\t\tself.setHeader(name, opts.headers[name])\n\t})\n\n\tvar preferBinary\n\tvar useFetch = true\n\tif (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {\n\t\t// If the use of XHR should be preferred. Not typically needed.\n\t\tuseFetch = false\n\t\tpreferBinary = true\n\t} else if (opts.mode === 'prefer-streaming') {\n\t\t// If streaming is a high priority but binary compatibility and\n\t\t// the accuracy of the 'content-type' header aren't\n\t\tpreferBinary = false\n\t} else if (opts.mode === 'allow-wrong-content-type') {\n\t\t// If streaming is more important than preserving the 'content-type' header\n\t\tpreferBinary = !capability.overrideMimeType\n\t} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {\n\t\t// Use binary if text streaming may corrupt data or the content-type header, or for speed\n\t\tpreferBinary = true\n\t} else {\n\t\tthrow new Error('Invalid value for opts.mode')\n\t}\n\tself._mode = decideMode(preferBinary, useFetch)\n\tself._fetchTimer = null\n\n\tself.on('finish', function () {\n\t\tself._onFinish()\n\t})\n}\n\ninherits(ClientRequest, stream.Writable)\n\nClientRequest.prototype.setHeader = function (name, value) {\n\tvar self = this\n\tvar lowerName = name.toLowerCase()\n\t// This check is not necessary, but it prevents warnings from browsers about setting unsafe\n\t// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but\n\t// http-browserify did it, so I will too.\n\tif (unsafeHeaders.indexOf(lowerName) !== -1)\n\t\treturn\n\n\tself._headers[lowerName] = {\n\t\tname: name,\n\t\tvalue: value\n\t}\n}\n\nClientRequest.prototype.getHeader = function (name) {\n\tvar header = this._headers[name.toLowerCase()]\n\tif (header)\n\t\treturn header.value\n\treturn null\n}\n\nClientRequest.prototype.removeHeader = function (name) {\n\tvar self = this\n\tdelete self._headers[name.toLowerCase()]\n}\n\nClientRequest.prototype._onFinish = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\tvar opts = self._opts\n\n\tvar headersObj = self._headers\n\tvar body = null\n\tif (opts.method !== 'GET' && opts.method !== 'HEAD') {\n\t\tif (capability.arraybuffer) {\n\t\t\tbody = toArrayBuffer(Buffer.concat(self._body))\n\t\t} else if (capability.blobConstructor) {\n\t\t\tbody = new global.Blob(self._body.map(function (buffer) {\n\t\t\t\treturn toArrayBuffer(buffer)\n\t\t\t}), {\n\t\t\t\ttype: (headersObj['content-type'] || {}).value || ''\n\t\t\t})\n\t\t} else {\n\t\t\t// get utf8 string\n\t\t\tbody = Buffer.concat(self._body).toString()\n\t\t}\n\t}\n\n\t// create flattened list of headers\n\tvar headersList = []\n\tObject.keys(headersObj).forEach(function (keyName) {\n\t\tvar name = headersObj[keyName].name\n\t\tvar value = headersObj[keyName].value\n\t\tif (Array.isArray(value)) {\n\t\t\tvalue.forEach(function (v) {\n\t\t\t\theadersList.push([name, v])\n\t\t\t})\n\t\t} else {\n\t\t\theadersList.push([name, value])\n\t\t}\n\t})\n\n\tif (self._mode === 'fetch') {\n\t\tvar signal = null\n\t\tvar fetchTimer = null\n\t\tif (capability.abortController) {\n\t\t\tvar controller = new AbortController()\n\t\t\tsignal = controller.signal\n\t\t\tself._fetchAbortController = controller\n\n\t\t\tif ('requestTimeout' in opts && opts.requestTimeout !== 0) {\n\t\t\t\tself._fetchTimer = global.setTimeout(function () {\n\t\t\t\t\tself.emit('requestTimeout')\n\t\t\t\t\tif (self._fetchAbortController)\n\t\t\t\t\t\tself._fetchAbortController.abort()\n\t\t\t\t}, opts.requestTimeout)\n\t\t\t}\n\t\t}\n\n\t\tglobal.fetch(self._opts.url, {\n\t\t\tmethod: self._opts.method,\n\t\t\theaders: headersList,\n\t\t\tbody: body || undefined,\n\t\t\tmode: 'cors',\n\t\t\tcredentials: opts.withCredentials ? 'include' : 'same-origin',\n\t\t\tsignal: signal\n\t\t}).then(function (response) {\n\t\t\tself._fetchResponse = response\n\t\t\tself._connect()\n\t\t}, function (reason) {\n\t\t\tglobal.clearTimeout(self._fetchTimer)\n\t\t\tif (!self._destroyed)\n\t\t\t\tself.emit('error', reason)\n\t\t})\n\t} else {\n\t\tvar xhr = self._xhr = new global.XMLHttpRequest()\n\t\ttry {\n\t\t\txhr.open(self._opts.method, self._opts.url, true)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\n\t\t// Can't set responseType on really old browsers\n\t\tif ('responseType' in xhr)\n\t\t\txhr.responseType = self._mode.split(':')[0]\n\n\t\tif ('withCredentials' in xhr)\n\t\t\txhr.withCredentials = !!opts.withCredentials\n\n\t\tif (self._mode === 'text' && 'overrideMimeType' in xhr)\n\t\t\txhr.overrideMimeType('text/plain; charset=x-user-defined')\n\n\t\tif ('requestTimeout' in opts) {\n\t\t\txhr.timeout = opts.requestTimeout\n\t\t\txhr.ontimeout = function () {\n\t\t\t\tself.emit('requestTimeout')\n\t\t\t}\n\t\t}\n\n\t\theadersList.forEach(function (header) {\n\t\t\txhr.setRequestHeader(header[0], header[1])\n\t\t})\n\n\t\tself._response = null\n\t\txhr.onreadystatechange = function () {\n\t\t\tswitch (xhr.readyState) {\n\t\t\t\tcase rStates.LOADING:\n\t\t\t\tcase rStates.DONE:\n\t\t\t\t\tself._onXHRProgress()\n\t\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\t// Necessary for streaming in Firefox, since xhr.response is ONLY defined\n\t\t// in onprogress, not in onreadystatechange with xhr.readyState = 3\n\t\tif (self._mode === 'moz-chunked-arraybuffer') {\n\t\t\txhr.onprogress = function () {\n\t\t\t\tself._onXHRProgress()\n\t\t\t}\n\t\t}\n\n\t\txhr.onerror = function () {\n\t\t\tif (self._destroyed)\n\t\t\t\treturn\n\t\t\tself.emit('error', new Error('XHR error'))\n\t\t}\n\n\t\ttry {\n\t\t\txhr.send(body)\n\t\t} catch (err) {\n\t\t\tprocess.nextTick(function () {\n\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t\treturn\n\t\t}\n\t}\n}\n\n/**\n * Checks if xhr.status is readable and non-zero, indicating no error.\n * Even though the spec says it should be available in readyState 3,\n * accessing it throws an exception in IE8\n */\nfunction statusValid (xhr) {\n\ttry {\n\t\tvar status = xhr.status\n\t\treturn (status !== null && status !== 0)\n\t} catch (e) {\n\t\treturn false\n\t}\n}\n\nClientRequest.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tif (!statusValid(self._xhr) || self._destroyed)\n\t\treturn\n\n\tif (!self._response)\n\t\tself._connect()\n\n\tself._response._onXHRProgress()\n}\n\nClientRequest.prototype._connect = function () {\n\tvar self = this\n\n\tif (self._destroyed)\n\t\treturn\n\n\tself._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)\n\tself._response.on('error', function(err) {\n\t\tself.emit('error', err)\n\t})\n\n\tself.emit('response', self._response)\n}\n\nClientRequest.prototype._write = function (chunk, encoding, cb) {\n\tvar self = this\n\n\tself._body.push(chunk)\n\tcb()\n}\n\nClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {\n\tvar self = this\n\tself._destroyed = true\n\tglobal.clearTimeout(self._fetchTimer)\n\tif (self._response)\n\t\tself._response._destroyed = true\n\tif (self._xhr)\n\t\tself._xhr.abort()\n\telse if (self._fetchAbortController)\n\t\tself._fetchAbortController.abort()\n}\n\nClientRequest.prototype.end = function (data, encoding, cb) {\n\tvar self = this\n\tif (typeof data === 'function') {\n\t\tcb = data\n\t\tdata = undefined\n\t}\n\n\tstream.Writable.prototype.end.call(self, data, encoding, cb)\n}\n\nClientRequest.prototype.flushHeaders = function () {}\nClientRequest.prototype.setTimeout = function () {}\nClientRequest.prototype.setNoDelay = function () {}\nClientRequest.prototype.setSocketKeepAlive = function () {}\n\n// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method\nvar unsafeHeaders = [\n\t'accept-charset',\n\t'accept-encoding',\n\t'access-control-request-headers',\n\t'access-control-request-method',\n\t'connection',\n\t'content-length',\n\t'cookie',\n\t'cookie2',\n\t'date',\n\t'dnt',\n\t'expect',\n\t'host',\n\t'keep-alive',\n\t'origin',\n\t'referer',\n\t'te',\n\t'trailer',\n\t'transfer-encoding',\n\t'upgrade',\n\t'via'\n]\n","var capability = require('./capability')\nvar inherits = require('inherits')\nvar stream = require('readable-stream')\n\nvar rStates = exports.readyStates = {\n\tUNSENT: 0,\n\tOPENED: 1,\n\tHEADERS_RECEIVED: 2,\n\tLOADING: 3,\n\tDONE: 4\n}\n\nvar IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {\n\tvar self = this\n\tstream.Readable.call(self)\n\n\tself._mode = mode\n\tself.headers = {}\n\tself.rawHeaders = []\n\tself.trailers = {}\n\tself.rawTrailers = []\n\n\t// Fake the 'close' event, but only once 'end' fires\n\tself.on('end', function () {\n\t\t// The nextTick is necessary to prevent the 'request' module from causing an infinite loop\n\t\tprocess.nextTick(function () {\n\t\t\tself.emit('close')\n\t\t})\n\t})\n\n\tif (mode === 'fetch') {\n\t\tself._fetchResponse = response\n\n\t\tself.url = response.url\n\t\tself.statusCode = response.status\n\t\tself.statusMessage = response.statusText\n\t\t\n\t\tresponse.headers.forEach(function (header, key){\n\t\t\tself.headers[key.toLowerCase()] = header\n\t\t\tself.rawHeaders.push(key, header)\n\t\t})\n\n\t\tif (capability.writableStream) {\n\t\t\tvar writable = new WritableStream({\n\t\t\t\twrite: function (chunk) {\n\t\t\t\t\treturn new Promise(function (resolve, reject) {\n\t\t\t\t\t\tif (self._destroyed) {\n\t\t\t\t\t\t\treject()\n\t\t\t\t\t\t} else if(self.push(new Buffer(chunk))) {\n\t\t\t\t\t\t\tresolve()\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tself._resumeFetch = resolve\n\t\t\t\t\t\t}\n\t\t\t\t\t})\n\t\t\t\t},\n\t\t\t\tclose: function () {\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.push(null)\n\t\t\t\t},\n\t\t\t\tabort: function (err) {\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t}\n\t\t\t})\n\n\t\t\ttry {\n\t\t\t\tresponse.body.pipeTo(writable).catch(function (err) {\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\t\tif (!self._destroyed)\n\t\t\t\t\t\tself.emit('error', err)\n\t\t\t\t})\n\t\t\t\treturn\n\t\t\t} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this\n\t\t}\n\t\t// fallback for when writableStream or pipeTo aren't available\n\t\tvar reader = response.body.getReader()\n\t\tfunction read () {\n\t\t\treader.read().then(function (result) {\n\t\t\t\tif (self._destroyed)\n\t\t\t\t\treturn\n\t\t\t\tif (result.done) {\n\t\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\t\tself.push(null)\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t\tself.push(new Buffer(result.value))\n\t\t\t\tread()\n\t\t\t}).catch(function (err) {\n\t\t\t\tglobal.clearTimeout(fetchTimer)\n\t\t\t\tif (!self._destroyed)\n\t\t\t\t\tself.emit('error', err)\n\t\t\t})\n\t\t}\n\t\tread()\n\t} else {\n\t\tself._xhr = xhr\n\t\tself._pos = 0\n\n\t\tself.url = xhr.responseURL\n\t\tself.statusCode = xhr.status\n\t\tself.statusMessage = xhr.statusText\n\t\tvar headers = xhr.getAllResponseHeaders().split(/\\r?\\n/)\n\t\theaders.forEach(function (header) {\n\t\t\tvar matches = header.match(/^([^:]+):\\s*(.*)/)\n\t\t\tif (matches) {\n\t\t\t\tvar key = matches[1].toLowerCase()\n\t\t\t\tif (key === 'set-cookie') {\n\t\t\t\t\tif (self.headers[key] === undefined) {\n\t\t\t\t\t\tself.headers[key] = []\n\t\t\t\t\t}\n\t\t\t\t\tself.headers[key].push(matches[2])\n\t\t\t\t} else if (self.headers[key] !== undefined) {\n\t\t\t\t\tself.headers[key] += ', ' + matches[2]\n\t\t\t\t} else {\n\t\t\t\t\tself.headers[key] = matches[2]\n\t\t\t\t}\n\t\t\t\tself.rawHeaders.push(matches[1], matches[2])\n\t\t\t}\n\t\t})\n\n\t\tself._charset = 'x-user-defined'\n\t\tif (!capability.overrideMimeType) {\n\t\t\tvar mimeType = self.rawHeaders['mime-type']\n\t\t\tif (mimeType) {\n\t\t\t\tvar charsetMatch = mimeType.match(/;\\s*charset=([^;])(;|$)/)\n\t\t\t\tif (charsetMatch) {\n\t\t\t\t\tself._charset = charsetMatch[1].toLowerCase()\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!self._charset)\n\t\t\t\tself._charset = 'utf-8' // best guess\n\t\t}\n\t}\n}\n\ninherits(IncomingMessage, stream.Readable)\n\nIncomingMessage.prototype._read = function () {\n\tvar self = this\n\n\tvar resolve = self._resumeFetch\n\tif (resolve) {\n\t\tself._resumeFetch = null\n\t\tresolve()\n\t}\n}\n\nIncomingMessage.prototype._onXHRProgress = function () {\n\tvar self = this\n\n\tvar xhr = self._xhr\n\n\tvar response = null\n\tswitch (self._mode) {\n\t\tcase 'text:vbarray': // For IE9\n\t\t\tif (xhr.readyState !== rStates.DONE)\n\t\t\t\tbreak\n\t\t\ttry {\n\t\t\t\t// This fails in IE8\n\t\t\t\tresponse = new global.VBArray(xhr.responseBody).toArray()\n\t\t\t} catch (e) {}\n\t\t\tif (response !== null) {\n\t\t\t\tself.push(new Buffer(response))\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// Falls through in IE8\t\n\t\tcase 'text':\n\t\t\ttry { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4\n\t\t\t\tresponse = xhr.responseText\n\t\t\t} catch (e) {\n\t\t\t\tself._mode = 'text:vbarray'\n\t\t\t\tbreak\n\t\t\t}\n\t\t\tif (response.length > self._pos) {\n\t\t\t\tvar newData = response.substr(self._pos)\n\t\t\t\tif (self._charset === 'x-user-defined') {\n\t\t\t\t\tvar buffer = new Buffer(newData.length)\n\t\t\t\t\tfor (var i = 0; i < newData.length; i++)\n\t\t\t\t\t\tbuffer[i] = newData.charCodeAt(i) & 0xff\n\n\t\t\t\t\tself.push(buffer)\n\t\t\t\t} else {\n\t\t\t\t\tself.push(newData, self._charset)\n\t\t\t\t}\n\t\t\t\tself._pos = response.length\n\t\t\t}\n\t\t\tbreak\n\t\tcase 'arraybuffer':\n\t\t\tif (xhr.readyState !== rStates.DONE || !xhr.response)\n\t\t\t\tbreak\n\t\t\tresponse = xhr.response\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'moz-chunked-arraybuffer': // take whole\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING || !response)\n\t\t\t\tbreak\n\t\t\tself.push(new Buffer(new Uint8Array(response)))\n\t\t\tbreak\n\t\tcase 'ms-stream':\n\t\t\tresponse = xhr.response\n\t\t\tif (xhr.readyState !== rStates.LOADING)\n\t\t\t\tbreak\n\t\t\tvar reader = new global.MSStreamReader()\n\t\t\treader.onprogress = function () {\n\t\t\t\tif (reader.result.byteLength > self._pos) {\n\t\t\t\t\tself.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))\n\t\t\t\t\tself._pos = reader.result.byteLength\n\t\t\t\t}\n\t\t\t}\n\t\t\treader.onload = function () {\n\t\t\t\tself.push(null)\n\t\t\t}\n\t\t\t// reader.onerror = ??? // TODO: this\n\t\t\treader.readAsArrayBuffer(response)\n\t\t\tbreak\n\t}\n\n\t// The ms-stream case handles end separately in reader.onload()\n\tif (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {\n\t\tself.push(null)\n\t}\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte. If an invalid byte is detected, -2 is returned.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return byte >> 6 === 0x02 ? -1 : -2;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i || nb === -2) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// a single UTF-8 replacement character ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd';\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd';\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd';\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character is added when ending on a partial\n// character.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd';\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}","function Agent() {\n  this._defaults = [];\n}\n\n[\"use\", \"on\", \"once\", \"set\", \"query\", \"type\", \"accept\", \"auth\", \"withCredentials\", \"sortQuery\", \"retry\", \"ok\", \"redirects\",\n \"timeout\", \"buffer\", \"serialize\", \"parse\", \"ca\", \"key\", \"pfx\", \"cert\"].forEach(function(fn) {\n  /** Default setting for all requests from this agent */\n  Agent.prototype[fn] = function(/*varargs*/) {\n    this._defaults.push({fn:fn, arguments:arguments});\n    return this;\n  }\n});\n\nAgent.prototype._setDefaults = function(req) {\n    this._defaults.forEach(function(def) {\n      req[def.fn].apply(req, def.arguments);\n    });\n};\n\nmodule.exports = Agent;\n","/**\n * Root reference for iframes.\n */\n\nvar root;\nif (typeof window !== 'undefined') { // Browser window\n  root = window;\n} else if (typeof self !== 'undefined') { // Web Worker\n  root = self;\n} else { // Other environments\n  console.warn(\"Using browser-only version of superagent in non-browser environment\");\n  root = this;\n}\n\nvar Emitter = require('component-emitter');\nvar RequestBase = require('./request-base');\nvar isObject = require('./is-object');\nvar ResponseBase = require('./response-base');\nvar Agent = require('./agent-base');\n\n/**\n * Noop.\n */\n\nfunction noop(){};\n\n/**\n * Expose `request`.\n */\n\nvar request = exports = module.exports = function(method, url) {\n  // callback\n  if ('function' == typeof url) {\n    return new exports.Request('GET', method).end(url);\n  }\n\n  // url first\n  if (1 == arguments.length) {\n    return new exports.Request('GET', method);\n  }\n\n  return new exports.Request(method, url);\n}\n\nexports.Request = Request;\n\n/**\n * Determine XHR.\n */\n\nrequest.getXHR = function () {\n  if (root.XMLHttpRequest\n      && (!root.location || 'file:' != root.location.protocol\n          || !root.ActiveXObject)) {\n    return new XMLHttpRequest;\n  } else {\n    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}\n    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}\n  }\n  throw Error(\"Browser-only version of superagent could not find XHR\");\n};\n\n/**\n * Removes leading and trailing whitespace, added to support IE.\n *\n * @param {String} s\n * @return {String}\n * @api private\n */\n\nvar trim = ''.trim\n  ? function(s) { return s.trim(); }\n  : function(s) { return s.replace(/(^\\s*|\\s*$)/g, ''); };\n\n/**\n * Serialize the given `obj`.\n *\n * @param {Object} obj\n * @return {String}\n * @api private\n */\n\nfunction serialize(obj) {\n  if (!isObject(obj)) return obj;\n  var pairs = [];\n  for (var key in obj) {\n    pushEncodedKeyValuePair(pairs, key, obj[key]);\n  }\n  return pairs.join('&');\n}\n\n/**\n * Helps 'serialize' with serializing arrays.\n * Mutates the pairs array.\n *\n * @param {Array} pairs\n * @param {String} key\n * @param {Mixed} val\n */\n\nfunction pushEncodedKeyValuePair(pairs, key, val) {\n  if (val != null) {\n    if (Array.isArray(val)) {\n      val.forEach(function(v) {\n        pushEncodedKeyValuePair(pairs, key, v);\n      });\n    } else if (isObject(val)) {\n      for(var subkey in val) {\n        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);\n      }\n    } else {\n      pairs.push(encodeURIComponent(key)\n        + '=' + encodeURIComponent(val));\n    }\n  } else if (val === null) {\n    pairs.push(encodeURIComponent(key));\n  }\n}\n\n/**\n * Expose serialization method.\n */\n\nrequest.serializeObject = serialize;\n\n/**\n  * Parse the given x-www-form-urlencoded `str`.\n  *\n  * @param {String} str\n  * @return {Object}\n  * @api private\n  */\n\nfunction parseString(str) {\n  var obj = {};\n  var pairs = str.split('&');\n  var pair;\n  var pos;\n\n  for (var i = 0, len = pairs.length; i < len; ++i) {\n    pair = pairs[i];\n    pos = pair.indexOf('=');\n    if (pos == -1) {\n      obj[decodeURIComponent(pair)] = '';\n    } else {\n      obj[decodeURIComponent(pair.slice(0, pos))] =\n        decodeURIComponent(pair.slice(pos + 1));\n    }\n  }\n\n  return obj;\n}\n\n/**\n * Expose parser.\n */\n\nrequest.parseString = parseString;\n\n/**\n * Default MIME type map.\n *\n *     superagent.types.xml = 'application/xml';\n *\n */\n\nrequest.types = {\n  html: 'text/html',\n  json: 'application/json',\n  xml: 'text/xml',\n  urlencoded: 'application/x-www-form-urlencoded',\n  'form': 'application/x-www-form-urlencoded',\n  'form-data': 'application/x-www-form-urlencoded'\n};\n\n/**\n * Default serialization map.\n *\n *     superagent.serialize['application/xml'] = function(obj){\n *       return 'generated xml here';\n *     };\n *\n */\n\nrequest.serialize = {\n  'application/x-www-form-urlencoded': serialize,\n  'application/json': JSON.stringify\n};\n\n/**\n  * Default parsers.\n  *\n  *     superagent.parse['application/xml'] = function(str){\n  *       return { object parsed from str };\n  *     };\n  *\n  */\n\nrequest.parse = {\n  'application/x-www-form-urlencoded': parseString,\n  'application/json': JSON.parse\n};\n\n/**\n * Parse the given header `str` into\n * an object containing the mapped fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nfunction parseHeader(str) {\n  var lines = str.split(/\\r?\\n/);\n  var fields = {};\n  var index;\n  var line;\n  var field;\n  var val;\n\n  for (var i = 0, len = lines.length; i < len; ++i) {\n    line = lines[i];\n    index = line.indexOf(':');\n    if (index === -1) { // could be empty line, just skip it\n      continue;\n    }\n    field = line.slice(0, index).toLowerCase();\n    val = trim(line.slice(index + 1));\n    fields[field] = val;\n  }\n\n  return fields;\n}\n\n/**\n * Check if `mime` is json or has +json structured syntax suffix.\n *\n * @param {String} mime\n * @return {Boolean}\n * @api private\n */\n\nfunction isJSON(mime) {\n  // should match /json or +json\n  // but not /json-seq\n  return /[\\/+]json($|[^-\\w])/.test(mime);\n}\n\n/**\n * Initialize a new `Response` with the given `xhr`.\n *\n *  - set flags (.ok, .error, etc)\n *  - parse header\n *\n * Examples:\n *\n *  Aliasing `superagent` as `request` is nice:\n *\n *      request = superagent;\n *\n *  We can use the promise-like API, or pass callbacks:\n *\n *      request.get('/').end(function(res){});\n *      request.get('/', function(res){});\n *\n *  Sending data can be chained:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' })\n *        .end(function(res){});\n *\n *  Or passed to `.send()`:\n *\n *      request\n *        .post('/user')\n *        .send({ name: 'tj' }, function(res){});\n *\n *  Or passed to `.post()`:\n *\n *      request\n *        .post('/user', { name: 'tj' })\n *        .end(function(res){});\n *\n * Or further reduced to a single call for simple cases:\n *\n *      request\n *        .post('/user', { name: 'tj' }, function(res){});\n *\n * @param {XMLHTTPRequest} xhr\n * @param {Object} options\n * @api private\n */\n\nfunction Response(req) {\n  this.req = req;\n  this.xhr = this.req.xhr;\n  // responseText is accessible only if responseType is '' or 'text' and on older browsers\n  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')\n     ? this.xhr.responseText\n     : null;\n  this.statusText = this.req.xhr.statusText;\n  var status = this.xhr.status;\n  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request\n  if (status === 1223) {\n    status = 204;\n  }\n  this._setStatusProperties(status);\n  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());\n  // getAllResponseHeaders sometimes falsely returns \"\" for CORS requests, but\n  // getResponseHeader still works. so we get content-type even if getting\n  // other headers fails.\n  this.header['content-type'] = this.xhr.getResponseHeader('content-type');\n  this._setHeaderProperties(this.header);\n\n  if (null === this.text && req._responseType) {\n    this.body = this.xhr.response;\n  } else {\n    this.body = this.req.method != 'HEAD'\n      ? this._parseBody(this.text ? this.text : this.xhr.response)\n      : null;\n  }\n}\n\nResponseBase(Response.prototype);\n\n/**\n * Parse the given body `str`.\n *\n * Used for auto-parsing of bodies. Parsers\n * are defined on the `superagent.parse` object.\n *\n * @param {String} str\n * @return {Mixed}\n * @api private\n */\n\nResponse.prototype._parseBody = function(str) {\n  var parse = request.parse[this.type];\n  if (this.req._parser) {\n    return this.req._parser(this, str);\n  }\n  if (!parse && isJSON(this.type)) {\n    parse = request.parse['application/json'];\n  }\n  return parse && str && (str.length || str instanceof Object)\n    ? parse(str)\n    : null;\n};\n\n/**\n * Return an `Error` representative of this response.\n *\n * @return {Error}\n * @api public\n */\n\nResponse.prototype.toError = function(){\n  var req = this.req;\n  var method = req.method;\n  var url = req.url;\n\n  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';\n  var err = new Error(msg);\n  err.status = this.status;\n  err.method = method;\n  err.url = url;\n\n  return err;\n};\n\n/**\n * Expose `Response`.\n */\n\nrequest.Response = Response;\n\n/**\n * Initialize a new `Request` with the given `method` and `url`.\n *\n * @param {String} method\n * @param {String} url\n * @api public\n */\n\nfunction Request(method, url) {\n  var self = this;\n  this._query = this._query || [];\n  this.method = method;\n  this.url = url;\n  this.header = {}; // preserves header name case\n  this._header = {}; // coerces header names to lowercase\n  this.on('end', function(){\n    var err = null;\n    var res = null;\n\n    try {\n      res = new Response(self);\n    } catch(e) {\n      err = new Error('Parser is unable to parse the response');\n      err.parse = true;\n      err.original = e;\n      // issue #675: return the raw response if the response parsing fails\n      if (self.xhr) {\n        // ie9 doesn't have 'response' property\n        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;\n        // issue #876: return the http status code if the response parsing fails\n        err.status = self.xhr.status ? self.xhr.status : null;\n        err.statusCode = err.status; // backwards-compat only\n      } else {\n        err.rawResponse = null;\n        err.status = null;\n      }\n\n      return self.callback(err);\n    }\n\n    self.emit('response', res);\n\n    var new_err;\n    try {\n      if (!self._isResponseOK(res)) {\n        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');\n      }\n    } catch(custom_err) {\n      new_err = custom_err; // ok() callback can throw\n    }\n\n    // #1000 don't catch errors from the callback to avoid double calling it\n    if (new_err) {\n      new_err.original = err;\n      new_err.response = res;\n      new_err.status = res.status;\n      self.callback(new_err, res);\n    } else {\n      self.callback(null, res);\n    }\n  });\n}\n\n/**\n * Mixin `Emitter` and `RequestBase`.\n */\n\nEmitter(Request.prototype);\nRequestBase(Request.prototype);\n\n/**\n * Set Content-Type to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.xml = 'application/xml';\n *\n *      request.post('/')\n *        .type('xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n *      request.post('/')\n *        .type('application/xml')\n *        .send(xmlstring)\n *        .end(callback);\n *\n * @param {String} type\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.type = function(type){\n  this.set('Content-Type', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Accept to `type`, mapping values from `request.types`.\n *\n * Examples:\n *\n *      superagent.types.json = 'application/json';\n *\n *      request.get('/agent')\n *        .accept('json')\n *        .end(callback);\n *\n *      request.get('/agent')\n *        .accept('application/json')\n *        .end(callback);\n *\n * @param {String} accept\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.accept = function(type){\n  this.set('Accept', request.types[type] || type);\n  return this;\n};\n\n/**\n * Set Authorization field value with `user` and `pass`.\n *\n * @param {String} user\n * @param {String} [pass] optional in case of using 'bearer' as type\n * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.auth = function(user, pass, options){\n  if (1 === arguments.length) pass = '';\n  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options\n    options = pass;\n    pass = '';\n  }\n  if (!options) {\n    options = {\n      type: 'function' === typeof btoa ? 'basic' : 'auto',\n    };\n  }\n\n  var encoder = function(string) {\n    if ('function' === typeof btoa) {\n      return btoa(string);\n    }\n    throw new Error('Cannot use basic auth, btoa is not a function');\n  };\n\n  return this._auth(user, pass, options, encoder);\n};\n\n/**\n * Add query-string `val`.\n *\n * Examples:\n *\n *   request.get('/shoes')\n *     .query('size=10')\n *     .query({ color: 'blue' })\n *\n * @param {Object|String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.query = function(val){\n  if ('string' != typeof val) val = serialize(val);\n  if (val) this._query.push(val);\n  return this;\n};\n\n/**\n * Queue the given `file` as an attachment to the specified `field`,\n * with optional `options` (or filename).\n *\n * ``` js\n * request.post('/upload')\n *   .attach('content', new Blob(['<a id=\"a\"><b id=\"b\">hey!</b></a>'], { type: \"text/html\"}))\n *   .end(callback);\n * ```\n *\n * @param {String} field\n * @param {Blob|File} file\n * @param {String|Object} options\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.attach = function(field, file, options){\n  if (file) {\n    if (this._data) {\n      throw Error(\"superagent can't mix .send() and .attach()\");\n    }\n\n    this._getFormData().append(field, file, options || file.name);\n  }\n  return this;\n};\n\nRequest.prototype._getFormData = function(){\n  if (!this._formData) {\n    this._formData = new root.FormData();\n  }\n  return this._formData;\n};\n\n/**\n * Invoke the callback with `err` and `res`\n * and handle arity check.\n *\n * @param {Error} err\n * @param {Response} res\n * @api private\n */\n\nRequest.prototype.callback = function(err, res){\n  if (this._shouldRetry(err, res)) {\n    return this._retry();\n  }\n\n  var fn = this._callback;\n  this.clearTimeout();\n\n  if (err) {\n    if (this._maxRetries) err.retries = this._retries - 1;\n    this.emit('error', err);\n  }\n\n  fn(err, res);\n};\n\n/**\n * Invoke callback with x-domain error.\n *\n * @api private\n */\n\nRequest.prototype.crossDomainError = function(){\n  var err = new Error('Request has been terminated\\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');\n  err.crossDomain = true;\n\n  err.status = this.status;\n  err.method = this.method;\n  err.url = this.url;\n\n  this.callback(err);\n};\n\n// This only warns, because the request is still likely to work\nRequest.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){\n  console.warn(\"This is not supported in browser version of superagent\");\n  return this;\n};\n\n// This throws, because it can't send/receive data as expected\nRequest.prototype.pipe = Request.prototype.write = function(){\n  throw Error(\"Streaming is not supported in browser version of superagent\");\n};\n\n/**\n * Check if `obj` is a host object,\n * we don't want to serialize these :)\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\nRequest.prototype._isHost = function _isHost(obj) {\n  // Native objects stringify to [object File], [object Blob], [object FormData], etc.\n  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';\n}\n\n/**\n * Initiate request, invoking callback `fn(res)`\n * with an instanceof `Response`.\n *\n * @param {Function} fn\n * @return {Request} for chaining\n * @api public\n */\n\nRequest.prototype.end = function(fn){\n  if (this._endCalled) {\n    console.warn(\"Warning: .end() was called twice. This is not supported in superagent\");\n  }\n  this._endCalled = true;\n\n  // store callback\n  this._callback = fn || noop;\n\n  // querystring\n  this._finalizeQueryString();\n\n  return this._end();\n};\n\nRequest.prototype._end = function() {\n  var self = this;\n  var xhr = (this.xhr = request.getXHR());\n  var data = this._formData || this._data;\n\n  this._setTimeouts();\n\n  // state change\n  xhr.onreadystatechange = function(){\n    var readyState = xhr.readyState;\n    if (readyState >= 2 && self._responseTimeoutTimer) {\n      clearTimeout(self._responseTimeoutTimer);\n    }\n    if (4 != readyState) {\n      return;\n    }\n\n    // In IE9, reads to any property (e.g. status) off of an aborted XHR will\n    // result in the error \"Could not complete the operation due to error c00c023f\"\n    var status;\n    try { status = xhr.status } catch(e) { status = 0; }\n\n    if (!status) {\n      if (self.timedout || self._aborted) return;\n      return self.crossDomainError();\n    }\n    self.emit('end');\n  };\n\n  // progress\n  var handleProgress = function(direction, e) {\n    if (e.total > 0) {\n      e.percent = e.loaded / e.total * 100;\n    }\n    e.direction = direction;\n    self.emit('progress', e);\n  };\n  if (this.hasListeners('progress')) {\n    try {\n      xhr.onprogress = handleProgress.bind(null, 'download');\n      if (xhr.upload) {\n        xhr.upload.onprogress = handleProgress.bind(null, 'upload');\n      }\n    } catch(e) {\n      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.\n      // Reported here:\n      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context\n    }\n  }\n\n  // initiate request\n  try {\n    if (this.username && this.password) {\n      xhr.open(this.method, this.url, true, this.username, this.password);\n    } else {\n      xhr.open(this.method, this.url, true);\n    }\n  } catch (err) {\n    // see #1149\n    return this.callback(err);\n  }\n\n  // CORS\n  if (this._withCredentials) xhr.withCredentials = true;\n\n  // body\n  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {\n    // serialize stuff\n    var contentType = this._header['content-type'];\n    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];\n    if (!serialize && isJSON(contentType)) {\n      serialize = request.serialize['application/json'];\n    }\n    if (serialize) data = serialize(data);\n  }\n\n  // set header fields\n  for (var field in this.header) {\n    if (null == this.header[field]) continue;\n\n    if (this.header.hasOwnProperty(field))\n      xhr.setRequestHeader(field, this.header[field]);\n  }\n\n  if (this._responseType) {\n    xhr.responseType = this._responseType;\n  }\n\n  // send stuff\n  this.emit('request', this);\n\n  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)\n  // We need null here if data is undefined\n  xhr.send(typeof data !== 'undefined' ? data : null);\n  return this;\n};\n\nrequest.agent = function() {\n  return new Agent();\n};\n\n[\"GET\", \"POST\", \"OPTIONS\", \"PATCH\", \"PUT\", \"DELETE\"].forEach(function(method) {\n  Agent.prototype[method.toLowerCase()] = function(url, fn) {\n    var req = new request.Request(method, url);\n    this._setDefaults(req);\n    if (fn) {\n      req.end(fn);\n    }\n    return req;\n  };\n});\n\nAgent.prototype.del = Agent.prototype['delete'];\n\n/**\n * GET `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.get = function(url, data, fn) {\n  var req = request('GET', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * HEAD `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.head = function(url, data, fn) {\n  var req = request('HEAD', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.query(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * OPTIONS query to `url` with optional callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.options = function(url, data, fn) {\n  var req = request('OPTIONS', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * DELETE `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nfunction del(url, data, fn) {\n  var req = request('DELETE', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n}\n\nrequest['del'] = del;\nrequest['delete'] = del;\n\n/**\n * PATCH `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.patch = function(url, data, fn) {\n  var req = request('PATCH', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * POST `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed} [data]\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.post = function(url, data, fn) {\n  var req = request('POST', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n\n/**\n * PUT `url` with optional `data` and callback `fn(res)`.\n *\n * @param {String} url\n * @param {Mixed|Function} [data] or fn\n * @param {Function} [fn]\n * @return {Request}\n * @api public\n */\n\nrequest.put = function(url, data, fn) {\n  var req = request('PUT', url);\n  if ('function' == typeof data) (fn = data), (data = null);\n  if (data) req.send(data);\n  if (fn) req.end(fn);\n  return req;\n};\n","'use strict';\n\n/**\n * Check if `obj` is an object.\n *\n * @param {Object} obj\n * @return {Boolean}\n * @api private\n */\n\nfunction isObject(obj) {\n  return null !== obj && 'object' === typeof obj;\n}\n\nmodule.exports = isObject;\n","'use strict';\n\n/**\n * Module of mixed-in functions shared between node and client code\n */\nvar isObject = require('./is-object');\n\n/**\n * Expose `RequestBase`.\n */\n\nmodule.exports = RequestBase;\n\n/**\n * Initialize a new `RequestBase`.\n *\n * @api public\n */\n\nfunction RequestBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in RequestBase.prototype) {\n    obj[key] = RequestBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Clear previous timeout.\n *\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.clearTimeout = function _clearTimeout(){\n  clearTimeout(this._timer);\n  clearTimeout(this._responseTimeoutTimer);\n  delete this._timer;\n  delete this._responseTimeoutTimer;\n  return this;\n};\n\n/**\n * Override default response body parser\n *\n * This function will be called to convert incoming data into request.body\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.parse = function parse(fn){\n  this._parser = fn;\n  return this;\n};\n\n/**\n * Set format of binary response body.\n * In browser valid formats are 'blob' and 'arraybuffer',\n * which return Blob and ArrayBuffer, respectively.\n *\n * In Node all values result in Buffer.\n *\n * Examples:\n *\n *      req.get('/')\n *        .responseType('blob')\n *        .end(callback);\n *\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.responseType = function(val){\n  this._responseType = val;\n  return this;\n};\n\n/**\n * Override default request body serializer\n *\n * This function will be called to convert data set via .send or .attach into payload to send\n *\n * @param {Function}\n * @api public\n */\n\nRequestBase.prototype.serialize = function serialize(fn){\n  this._serializer = fn;\n  return this;\n};\n\n/**\n * Set timeouts.\n *\n * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.\n * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.\n *\n * Value of 0 or false means no timeout.\n *\n * @param {Number|Object} ms or {response, deadline}\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.timeout = function timeout(options){\n  if (!options || 'object' !== typeof options) {\n    this._timeout = options;\n    this._responseTimeout = 0;\n    return this;\n  }\n\n  for(var option in options) {\n    switch(option) {\n      case 'deadline':\n        this._timeout = options.deadline;\n        break;\n      case 'response':\n        this._responseTimeout = options.response;\n        break;\n      default:\n        console.warn(\"Unknown timeout option\", option);\n    }\n  }\n  return this;\n};\n\n/**\n * Set number of retry attempts on error.\n *\n * Failed requests will be retried 'count' times if timeout or err.code >= 500.\n *\n * @param {Number} count\n * @param {Function} [fn]\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.retry = function retry(count, fn){\n  // Default to 1 if no count passed or true\n  if (arguments.length === 0 || count === true) count = 1;\n  if (count <= 0) count = 0;\n  this._maxRetries = count;\n  this._retries = 0;\n  this._retryCallback = fn;\n  return this;\n};\n\nvar ERROR_CODES = [\n  'ECONNRESET',\n  'ETIMEDOUT',\n  'EADDRINFO',\n  'ESOCKETTIMEDOUT'\n];\n\n/**\n * Determine if a request should be retried.\n * (Borrowed from segmentio/superagent-retry)\n *\n * @param {Error} err\n * @param {Response} [res]\n * @returns {Boolean}\n */\nRequestBase.prototype._shouldRetry = function(err, res) {\n  if (!this._maxRetries || this._retries++ >= this._maxRetries) {\n    return false;\n  }\n  if (this._retryCallback) {\n    try {\n      var override = this._retryCallback(err, res);\n      if (override === true) return true;\n      if (override === false) return false;\n      // undefined falls back to defaults\n    } catch(e) {\n      console.error(e);\n    }\n  }\n  if (res && res.status && res.status >= 500 && res.status != 501) return true;\n  if (err) {\n    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;\n    // Superagent timeout\n    if (err.timeout && err.code == 'ECONNABORTED') return true;\n    if (err.crossDomain) return true;\n  }\n  return false;\n};\n\n/**\n * Retry request\n *\n * @return {Request} for chaining\n * @api private\n */\n\nRequestBase.prototype._retry = function() {\n\n  this.clearTimeout();\n\n  // node\n  if (this.req) {\n    this.req = null;\n    this.req = this.request();\n  }\n\n  this._aborted = false;\n  this.timedout = false;\n\n  return this._end();\n};\n\n/**\n * Promise support\n *\n * @param {Function} resolve\n * @param {Function} [reject]\n * @return {Request}\n */\n\nRequestBase.prototype.then = function then(resolve, reject) {\n  if (!this._fullfilledPromise) {\n    var self = this;\n    if (this._endCalled) {\n      console.warn(\"Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises\");\n    }\n    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {\n      self.end(function(err, res) {\n        if (err) innerReject(err);\n        else innerResolve(res);\n      });\n    });\n  }\n  return this._fullfilledPromise.then(resolve, reject);\n};\n\nRequestBase.prototype['catch'] = function(cb) {\n  return this.then(undefined, cb);\n};\n\n/**\n * Allow for extension\n */\n\nRequestBase.prototype.use = function use(fn) {\n  fn(this);\n  return this;\n};\n\nRequestBase.prototype.ok = function(cb) {\n  if ('function' !== typeof cb) throw Error(\"Callback required\");\n  this._okCallback = cb;\n  return this;\n};\n\nRequestBase.prototype._isResponseOK = function(res) {\n  if (!res) {\n    return false;\n  }\n\n  if (this._okCallback) {\n    return this._okCallback(res);\n  }\n\n  return res.status >= 200 && res.status < 300;\n};\n\n/**\n * Get request header `field`.\n * Case-insensitive.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nRequestBase.prototype.get = function(field){\n  return this._header[field.toLowerCase()];\n};\n\n/**\n * Get case-insensitive header `field` value.\n * This is a deprecated internal API. Use `.get(field)` instead.\n *\n * (getHeader is no longer used internally by the superagent code base)\n *\n * @param {String} field\n * @return {String}\n * @api private\n * @deprecated\n */\n\nRequestBase.prototype.getHeader = RequestBase.prototype.get;\n\n/**\n * Set header `field` to `val`, or multiple fields with one object.\n * Case-insensitive.\n *\n * Examples:\n *\n *      req.get('/')\n *        .set('Accept', 'application/json')\n *        .set('X-API-Key', 'foobar')\n *        .end(callback);\n *\n *      req.get('/')\n *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })\n *        .end(callback);\n *\n * @param {String|Object} field\n * @param {String} val\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.set = function(field, val){\n  if (isObject(field)) {\n    for (var key in field) {\n      this.set(key, field[key]);\n    }\n    return this;\n  }\n  this._header[field.toLowerCase()] = val;\n  this.header[field] = val;\n  return this;\n};\n\n/**\n * Remove header `field`.\n * Case-insensitive.\n *\n * Example:\n *\n *      req.get('/')\n *        .unset('User-Agent')\n *        .end(callback);\n *\n * @param {String} field\n */\nRequestBase.prototype.unset = function(field){\n  delete this._header[field.toLowerCase()];\n  delete this.header[field];\n  return this;\n};\n\n/**\n * Write the field `name` and `val`, or multiple fields with one object\n * for \"multipart/form-data\" request bodies.\n *\n * ``` js\n * request.post('/upload')\n *   .field('foo', 'bar')\n *   .end(callback);\n *\n * request.post('/upload')\n *   .field({ foo: 'bar', baz: 'qux' })\n *   .end(callback);\n * ```\n *\n * @param {String|Object} name\n * @param {String|Blob|File|Buffer|fs.ReadStream} val\n * @return {Request} for chaining\n * @api public\n */\nRequestBase.prototype.field = function(name, val) {\n  // name should be either a string or an object.\n  if (null === name || undefined === name) {\n    throw new Error('.field(name, val) name can not be empty');\n  }\n\n  if (this._data) {\n    console.error(\".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObject(name)) {\n    for (var key in name) {\n      this.field(key, name[key]);\n    }\n    return this;\n  }\n\n  if (Array.isArray(val)) {\n    for (var i in val) {\n      this.field(name, val[i]);\n    }\n    return this;\n  }\n\n  // val should be defined now\n  if (null === val || undefined === val) {\n    throw new Error('.field(name, val) val can not be empty');\n  }\n  if ('boolean' === typeof val) {\n    val = '' + val;\n  }\n  this._getFormData().append(name, val);\n  return this;\n};\n\n/**\n * Abort the request, and clear potential timeout.\n *\n * @return {Request}\n * @api public\n */\nRequestBase.prototype.abort = function(){\n  if (this._aborted) {\n    return this;\n  }\n  this._aborted = true;\n  this.xhr && this.xhr.abort(); // browser\n  this.req && this.req.abort(); // node\n  this.clearTimeout();\n  this.emit('abort');\n  return this;\n};\n\nRequestBase.prototype._auth = function(user, pass, options, base64Encoder) {\n  switch (options.type) {\n    case 'basic':\n      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));\n      break;\n\n    case 'auto':\n      this.username = user;\n      this.password = pass;\n      break;\n\n    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })\n      this.set('Authorization', 'Bearer ' + user);\n      break;\n  }\n  return this;\n};\n\n/**\n * Enable transmission of cookies with x-domain requests.\n *\n * Note that for this to work the origin must not be\n * using \"Access-Control-Allow-Origin\" with a wildcard,\n * and also must set \"Access-Control-Allow-Credentials\"\n * to \"true\".\n *\n * @api public\n */\n\nRequestBase.prototype.withCredentials = function(on) {\n  // This is browser-only functionality. Node side is no-op.\n  if (on == undefined) on = true;\n  this._withCredentials = on;\n  return this;\n};\n\n/**\n * Set the max redirects to `n`. Does noting in browser XHR implementation.\n *\n * @param {Number} n\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.redirects = function(n){\n  this._maxRedirects = n;\n  return this;\n};\n\n/**\n * Maximum size of buffered response body, in bytes. Counts uncompressed size.\n * Default 200MB.\n *\n * @param {Number} n\n * @return {Request} for chaining\n */\nRequestBase.prototype.maxResponseSize = function(n){\n  if ('number' !== typeof n) {\n    throw TypeError(\"Invalid argument\");\n  }\n  this._maxResponseSize = n;\n  return this;\n};\n\n/**\n * Convert to a plain javascript object (not JSON string) of scalar properties.\n * Note as this method is designed to return a useful non-this value,\n * it cannot be chained.\n *\n * @return {Object} describing method, url, and data of this request\n * @api public\n */\n\nRequestBase.prototype.toJSON = function() {\n  return {\n    method: this.method,\n    url: this.url,\n    data: this._data,\n    headers: this._header,\n  };\n};\n\n/**\n * Send `data` as the request body, defaulting the `.type()` to \"json\" when\n * an object is given.\n *\n * Examples:\n *\n *       // manual json\n *       request.post('/user')\n *         .type('json')\n *         .send('{\"name\":\"tj\"}')\n *         .end(callback)\n *\n *       // auto json\n *       request.post('/user')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // manual x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send('name=tj')\n *         .end(callback)\n *\n *       // auto x-www-form-urlencoded\n *       request.post('/user')\n *         .type('form')\n *         .send({ name: 'tj' })\n *         .end(callback)\n *\n *       // defaults to x-www-form-urlencoded\n *      request.post('/user')\n *        .send('name=tobi')\n *        .send('species=ferret')\n *        .end(callback)\n *\n * @param {String|Object} data\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.send = function(data){\n  var isObj = isObject(data);\n  var type = this._header['content-type'];\n\n  if (this._formData) {\n    console.error(\".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()\");\n  }\n\n  if (isObj && !this._data) {\n    if (Array.isArray(data)) {\n      this._data = [];\n    } else if (!this._isHost(data)) {\n      this._data = {};\n    }\n  } else if (data && this._data && this._isHost(this._data)) {\n    throw Error(\"Can't merge these send calls\");\n  }\n\n  // merge\n  if (isObj && isObject(this._data)) {\n    for (var key in data) {\n      this._data[key] = data[key];\n    }\n  } else if ('string' == typeof data) {\n    // default to x-www-form-urlencoded\n    if (!type) this.type('form');\n    type = this._header['content-type'];\n    if ('application/x-www-form-urlencoded' == type) {\n      this._data = this._data\n        ? this._data + '&' + data\n        : data;\n    } else {\n      this._data = (this._data || '') + data;\n    }\n  } else {\n    this._data = data;\n  }\n\n  if (!isObj || this._isHost(data)) {\n    return this;\n  }\n\n  // default to json\n  if (!type) this.type('json');\n  return this;\n};\n\n/**\n * Sort `querystring` by the sort function\n *\n *\n * Examples:\n *\n *       // default order\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery()\n *         .end(callback)\n *\n *       // customized sort function\n *       request.get('/user')\n *         .query('name=Nick')\n *         .query('search=Manny')\n *         .sortQuery(function(a, b){\n *           return a.length - b.length;\n *         })\n *         .end(callback)\n *\n *\n * @param {Function} sort\n * @return {Request} for chaining\n * @api public\n */\n\nRequestBase.prototype.sortQuery = function(sort) {\n  // _sort default to true but otherwise can be a function or boolean\n  this._sort = typeof sort === 'undefined' ? true : sort;\n  return this;\n};\n\n/**\n * Compose querystring to append to req.url\n *\n * @api private\n */\nRequestBase.prototype._finalizeQueryString = function(){\n  var query = this._query.join('&');\n  if (query) {\n    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;\n  }\n  this._query.length = 0; // Makes the call idempotent\n\n  if (this._sort) {\n    var index = this.url.indexOf('?');\n    if (index >= 0) {\n      var queryArr = this.url.substring(index + 1).split('&');\n      if ('function' === typeof this._sort) {\n        queryArr.sort(this._sort);\n      } else {\n        queryArr.sort();\n      }\n      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');\n    }\n  }\n};\n\n// For backwards compat only\nRequestBase.prototype._appendQueryString = function() {console.trace(\"Unsupported\");}\n\n/**\n * Invoke callback with timeout error.\n *\n * @api private\n */\n\nRequestBase.prototype._timeoutError = function(reason, timeout, errno){\n  if (this._aborted) {\n    return;\n  }\n  var err = new Error(reason + timeout + 'ms exceeded');\n  err.timeout = timeout;\n  err.code = 'ECONNABORTED';\n  err.errno = errno;\n  this.timedout = true;\n  this.abort();\n  this.callback(err);\n};\n\nRequestBase.prototype._setTimeouts = function() {\n  var self = this;\n\n  // deadline\n  if (this._timeout && !this._timer) {\n    this._timer = setTimeout(function(){\n      self._timeoutError('Timeout of ', self._timeout, 'ETIME');\n    }, this._timeout);\n  }\n  // response timeout\n  if (this._responseTimeout && !this._responseTimeoutTimer) {\n    this._responseTimeoutTimer = setTimeout(function(){\n      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');\n    }, this._responseTimeout);\n  }\n};\n","'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar utils = require('./utils');\n\n/**\n * Expose `ResponseBase`.\n */\n\nmodule.exports = ResponseBase;\n\n/**\n * Initialize a new `ResponseBase`.\n *\n * @api public\n */\n\nfunction ResponseBase(obj) {\n  if (obj) return mixin(obj);\n}\n\n/**\n * Mixin the prototype properties.\n *\n * @param {Object} obj\n * @return {Object}\n * @api private\n */\n\nfunction mixin(obj) {\n  for (var key in ResponseBase.prototype) {\n    obj[key] = ResponseBase.prototype[key];\n  }\n  return obj;\n}\n\n/**\n * Get case-insensitive `field` value.\n *\n * @param {String} field\n * @return {String}\n * @api public\n */\n\nResponseBase.prototype.get = function(field) {\n  return this.header[field.toLowerCase()];\n};\n\n/**\n * Set header related properties:\n *\n *   - `.type` the content type without params\n *\n * A response of \"Content-Type: text/plain; charset=utf-8\"\n * will provide you with a `.type` of \"text/plain\".\n *\n * @param {Object} header\n * @api private\n */\n\nResponseBase.prototype._setHeaderProperties = function(header){\n    // TODO: moar!\n    // TODO: make this a util\n\n    // content-type\n    var ct = header['content-type'] || '';\n    this.type = utils.type(ct);\n\n    // params\n    var params = utils.params(ct);\n    for (var key in params) this[key] = params[key];\n\n    this.links = {};\n\n    // links\n    try {\n        if (header.link) {\n            this.links = utils.parseLinks(header.link);\n        }\n    } catch (err) {\n        // ignore\n    }\n};\n\n/**\n * Set flags such as `.ok` based on `status`.\n *\n * For example a 2xx response will give you a `.ok` of __true__\n * whereas 5xx will be __false__ and `.error` will be __true__. The\n * `.clientError` and `.serverError` are also available to be more\n * specific, and `.statusType` is the class of error ranging from 1..5\n * sometimes useful for mapping respond colors etc.\n *\n * \"sugar\" properties are also defined for common cases. Currently providing:\n *\n *   - .noContent\n *   - .badRequest\n *   - .unauthorized\n *   - .notAcceptable\n *   - .notFound\n *\n * @param {Number} status\n * @api private\n */\n\nResponseBase.prototype._setStatusProperties = function(status){\n    var type = status / 100 | 0;\n\n    // status / class\n    this.status = this.statusCode = status;\n    this.statusType = type;\n\n    // basics\n    this.info = 1 == type;\n    this.ok = 2 == type;\n    this.redirect = 3 == type;\n    this.clientError = 4 == type;\n    this.serverError = 5 == type;\n    this.error = (4 == type || 5 == type)\n        ? this.toError()\n        : false;\n\n    // sugar\n    this.created = 201 == status;\n    this.accepted = 202 == status;\n    this.noContent = 204 == status;\n    this.badRequest = 400 == status;\n    this.unauthorized = 401 == status;\n    this.notAcceptable = 406 == status;\n    this.forbidden = 403 == status;\n    this.notFound = 404 == status;\n    this.unprocessableEntity = 422 == status;\n};\n","'use strict';\n\n/**\n * Return the mime type for the given `str`.\n *\n * @param {String} str\n * @return {String}\n * @api private\n */\n\nexports.type = function(str){\n  return str.split(/ *; */).shift();\n};\n\n/**\n * Return header field parameters.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.params = function(str){\n  return str.split(/ *; */).reduce(function(obj, str){\n    var parts = str.split(/ *= */);\n    var key = parts.shift();\n    var val = parts.shift();\n\n    if (key && val) obj[key] = val;\n    return obj;\n  }, {});\n};\n\n/**\n * Parse Link header fields.\n *\n * @param {String} str\n * @return {Object}\n * @api private\n */\n\nexports.parseLinks = function(str){\n  return str.split(/ *, */).reduce(function(obj, str){\n    var parts = str.split(/ *; */);\n    var url = parts[0].slice(1, -1);\n    var rel = parts[1].split(/ *= */)[1].slice(1, -1);\n    obj[rel] = url;\n    return obj;\n  }, {});\n};\n\n/**\n * Strip content related fields from `header`.\n *\n * @param {Object} header\n * @return {Object} header\n * @api private\n */\n\nexports.cleanHeader = function(header, changesOrigin){\n  delete header['content-type'];\n  delete header['content-length'];\n  delete header['transfer-encoding'];\n  delete header['host'];\n  // secuirty\n  if (changesOrigin) {\n    delete header['authorization'];\n    delete header['cookie'];\n  }\n  return header;\n};\n","var scope = (typeof global !== \"undefined\" && global) ||\n            (typeof self !== \"undefined\" && self) ||\n            window;\nvar apply = Function.prototype.apply;\n\n// DOM APIs, for completeness\n\nexports.setTimeout = function() {\n  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);\n};\nexports.setInterval = function() {\n  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);\n};\nexports.clearTimeout =\nexports.clearInterval = function(timeout) {\n  if (timeout) {\n    timeout.close();\n  }\n};\n\nfunction Timeout(id, clearFn) {\n  this._id = id;\n  this._clearFn = clearFn;\n}\nTimeout.prototype.unref = Timeout.prototype.ref = function() {};\nTimeout.prototype.close = function() {\n  this._clearFn.call(scope, this._id);\n};\n\n// Does not start the time, just sets up the members needed.\nexports.enroll = function(item, msecs) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = msecs;\n};\n\nexports.unenroll = function(item) {\n  clearTimeout(item._idleTimeoutId);\n  item._idleTimeout = -1;\n};\n\nexports._unrefActive = exports.active = function(item) {\n  clearTimeout(item._idleTimeoutId);\n\n  var msecs = item._idleTimeout;\n  if (msecs >= 0) {\n    item._idleTimeoutId = setTimeout(function onTimeout() {\n      if (item._onTimeout)\n        item._onTimeout();\n    }, msecs);\n  }\n};\n\n// setimmediate attaches itself to the global object\nrequire(\"setimmediate\");\n// On some exotic environments, it's not clear which object `setimmediate` was\n// able to install onto.  Search each possibility in the same order as the\n// `setimmediate` library.\nexports.setImmediate = (typeof self !== \"undefined\" && self.setImmediate) ||\n                       (typeof global !== \"undefined\" && global.setImmediate) ||\n                       (this && this.setImmediate);\nexports.clearImmediate = (typeof self !== \"undefined\" && self.clearImmediate) ||\n                         (typeof global !== \"undefined\" && global.clearImmediate) ||\n                         (this && this.clearImmediate);\n","var Buffer = require('buffer').Buffer\n\nmodule.exports = function (buf) {\n\t// If the buffer is backed by a Uint8Array, a faster version will work\n\tif (buf instanceof Uint8Array) {\n\t\t// If the buffer isn't a subarray, return the underlying ArrayBuffer\n\t\tif (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {\n\t\t\treturn buf.buffer\n\t\t} else if (typeof buf.buffer.slice === 'function') {\n\t\t\t// Otherwise we need to get a proper copy\n\t\t\treturn buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)\n\t\t}\n\t}\n\n\tif (Buffer.isBuffer(buf)) {\n\t\t// This is the slow version that will work with any Buffer\n\t\t// implementation (even in old browsers)\n\t\tvar arrayCopy = new Uint8Array(buf.length)\n\t\tvar len = buf.length\n\t\tfor (var i = 0; i < len; i++) {\n\t\t\tarrayCopy[i] = buf[i]\n\t\t}\n\t\treturn arrayCopy.buffer\n\t} else {\n\t\tthrow new Error('Argument must be a Buffer')\n\t}\n}\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\nvar punycode = require('punycode');\nvar util = require('./util');\n\nexports.parse = urlParse;\nexports.resolve = urlResolve;\nexports.resolveObject = urlResolveObject;\nexports.format = urlFormat;\n\nexports.Url = Url;\n\nfunction Url() {\n  this.protocol = null;\n  this.slashes = null;\n  this.auth = null;\n  this.host = null;\n  this.port = null;\n  this.hostname = null;\n  this.hash = null;\n  this.search = null;\n  this.query = null;\n  this.pathname = null;\n  this.path = null;\n  this.href = null;\n}\n\n// Reference: RFC 3986, RFC 1808, RFC 2396\n\n// define these here so at least they only have to be\n// compiled once on the first module load.\nvar protocolPattern = /^([a-z0-9.+-]+:)/i,\n    portPattern = /:[0-9]*$/,\n\n    // Special case for a simple path URL\n    simplePathPattern = /^(\\/\\/?(?!\\/)[^\\?\\s]*)(\\?[^\\s]*)?$/,\n\n    // RFC 2396: characters reserved for delimiting URLs.\n    // We actually just auto-escape these.\n    delims = ['<', '>', '\"', '`', ' ', '\\r', '\\n', '\\t'],\n\n    // RFC 2396: characters not allowed for various reasons.\n    unwise = ['{', '}', '|', '\\\\', '^', '`'].concat(delims),\n\n    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.\n    autoEscape = ['\\''].concat(unwise),\n    // Characters that are never ever allowed in a hostname.\n    // Note that any invalid chars are also handled, but these\n    // are the ones that are *expected* to be seen, so we fast-path\n    // them.\n    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),\n    hostEndingChars = ['/', '?', '#'],\n    hostnameMaxLen = 255,\n    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,\n    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,\n    // protocols that can allow \"unsafe\" and \"unwise\" chars.\n    unsafeProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that never have a hostname.\n    hostlessProtocol = {\n      'javascript': true,\n      'javascript:': true\n    },\n    // protocols that always contain a // bit.\n    slashedProtocol = {\n      'http': true,\n      'https': true,\n      'ftp': true,\n      'gopher': true,\n      'file': true,\n      'http:': true,\n      'https:': true,\n      'ftp:': true,\n      'gopher:': true,\n      'file:': true\n    },\n    querystring = require('querystring');\n\nfunction urlParse(url, parseQueryString, slashesDenoteHost) {\n  if (url && util.isObject(url) && url instanceof Url) return url;\n\n  var u = new Url;\n  u.parse(url, parseQueryString, slashesDenoteHost);\n  return u;\n}\n\nUrl.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {\n  if (!util.isString(url)) {\n    throw new TypeError(\"Parameter 'url' must be a string, not \" + typeof url);\n  }\n\n  // Copy chrome, IE, opera backslash-handling behavior.\n  // Back slashes before the query string get converted to forward slashes\n  // See: https://code.google.com/p/chromium/issues/detail?id=25916\n  var queryIndex = url.indexOf('?'),\n      splitter =\n          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',\n      uSplit = url.split(splitter),\n      slashRegex = /\\\\/g;\n  uSplit[0] = uSplit[0].replace(slashRegex, '/');\n  url = uSplit.join(splitter);\n\n  var rest = url;\n\n  // trim before proceeding.\n  // This is to support parse stuff like \"  http://foo.com  \\n\"\n  rest = rest.trim();\n\n  if (!slashesDenoteHost && url.split('#').length === 1) {\n    // Try fast path regexp\n    var simplePath = simplePathPattern.exec(rest);\n    if (simplePath) {\n      this.path = rest;\n      this.href = rest;\n      this.pathname = simplePath[1];\n      if (simplePath[2]) {\n        this.search = simplePath[2];\n        if (parseQueryString) {\n          this.query = querystring.parse(this.search.substr(1));\n        } else {\n          this.query = this.search.substr(1);\n        }\n      } else if (parseQueryString) {\n        this.search = '';\n        this.query = {};\n      }\n      return this;\n    }\n  }\n\n  var proto = protocolPattern.exec(rest);\n  if (proto) {\n    proto = proto[0];\n    var lowerProto = proto.toLowerCase();\n    this.protocol = lowerProto;\n    rest = rest.substr(proto.length);\n  }\n\n  // figure out if it's got a host\n  // user@server is *always* interpreted as a hostname, and url\n  // resolution will treat //foo/bar as host=foo,path=bar because that's\n  // how the browser resolves relative URLs.\n  if (slashesDenoteHost || proto || rest.match(/^\\/\\/[^@\\/]+@[^@\\/]+/)) {\n    var slashes = rest.substr(0, 2) === '//';\n    if (slashes && !(proto && hostlessProtocol[proto])) {\n      rest = rest.substr(2);\n      this.slashes = true;\n    }\n  }\n\n  if (!hostlessProtocol[proto] &&\n      (slashes || (proto && !slashedProtocol[proto]))) {\n\n    // there's a hostname.\n    // the first instance of /, ?, ;, or # ends the host.\n    //\n    // If there is an @ in the hostname, then non-host chars *are* allowed\n    // to the left of the last @ sign, unless some host-ending character\n    // comes *before* the @-sign.\n    // URLs are obnoxious.\n    //\n    // ex:\n    // http://a@b@c/ => user:a@b host:c\n    // http://a@b?@c => user:a host:c path:/?@c\n\n    // v0.12 TODO(isaacs): This is not quite how Chrome does things.\n    // Review our test case against browsers more comprehensively.\n\n    // find the first instance of any hostEndingChars\n    var hostEnd = -1;\n    for (var i = 0; i < hostEndingChars.length; i++) {\n      var hec = rest.indexOf(hostEndingChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n\n    // at this point, either we have an explicit point where the\n    // auth portion cannot go past, or the last @ char is the decider.\n    var auth, atSign;\n    if (hostEnd === -1) {\n      // atSign can be anywhere.\n      atSign = rest.lastIndexOf('@');\n    } else {\n      // atSign must be in auth portion.\n      // http://a@b/c@d => host:b auth:a path:/c@d\n      atSign = rest.lastIndexOf('@', hostEnd);\n    }\n\n    // Now we have a portion which is definitely the auth.\n    // Pull that off.\n    if (atSign !== -1) {\n      auth = rest.slice(0, atSign);\n      rest = rest.slice(atSign + 1);\n      this.auth = decodeURIComponent(auth);\n    }\n\n    // the host is the remaining to the left of the first non-host char\n    hostEnd = -1;\n    for (var i = 0; i < nonHostChars.length; i++) {\n      var hec = rest.indexOf(nonHostChars[i]);\n      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))\n        hostEnd = hec;\n    }\n    // if we still have not hit it, then the entire thing is a host.\n    if (hostEnd === -1)\n      hostEnd = rest.length;\n\n    this.host = rest.slice(0, hostEnd);\n    rest = rest.slice(hostEnd);\n\n    // pull out port.\n    this.parseHost();\n\n    // we've indicated that there is a hostname,\n    // so even if it's empty, it has to be present.\n    this.hostname = this.hostname || '';\n\n    // if hostname begins with [ and ends with ]\n    // assume that it's an IPv6 address.\n    var ipv6Hostname = this.hostname[0] === '[' &&\n        this.hostname[this.hostname.length - 1] === ']';\n\n    // validate a little.\n    if (!ipv6Hostname) {\n      var hostparts = this.hostname.split(/\\./);\n      for (var i = 0, l = hostparts.length; i < l; i++) {\n        var part = hostparts[i];\n        if (!part) continue;\n        if (!part.match(hostnamePartPattern)) {\n          var newpart = '';\n          for (var j = 0, k = part.length; j < k; j++) {\n            if (part.charCodeAt(j) > 127) {\n              // we replace non-ASCII char with a temporary placeholder\n              // we need this to make sure size of hostname is not\n              // broken by replacing non-ASCII by nothing\n              newpart += 'x';\n            } else {\n              newpart += part[j];\n            }\n          }\n          // we test again with ASCII char only\n          if (!newpart.match(hostnamePartPattern)) {\n            var validParts = hostparts.slice(0, i);\n            var notHost = hostparts.slice(i + 1);\n            var bit = part.match(hostnamePartStart);\n            if (bit) {\n              validParts.push(bit[1]);\n              notHost.unshift(bit[2]);\n            }\n            if (notHost.length) {\n              rest = '/' + notHost.join('.') + rest;\n            }\n            this.hostname = validParts.join('.');\n            break;\n          }\n        }\n      }\n    }\n\n    if (this.hostname.length > hostnameMaxLen) {\n      this.hostname = '';\n    } else {\n      // hostnames are always lower case.\n      this.hostname = this.hostname.toLowerCase();\n    }\n\n    if (!ipv6Hostname) {\n      // IDNA Support: Returns a punycoded representation of \"domain\".\n      // It only converts parts of the domain name that\n      // have non-ASCII characters, i.e. it doesn't matter if\n      // you call it with a domain that already is ASCII-only.\n      this.hostname = punycode.toASCII(this.hostname);\n    }\n\n    var p = this.port ? ':' + this.port : '';\n    var h = this.hostname || '';\n    this.host = h + p;\n    this.href += this.host;\n\n    // strip [ and ] from the hostname\n    // the host field still retains them, though\n    if (ipv6Hostname) {\n      this.hostname = this.hostname.substr(1, this.hostname.length - 2);\n      if (rest[0] !== '/') {\n        rest = '/' + rest;\n      }\n    }\n  }\n\n  // now rest is set to the post-host stuff.\n  // chop off any delim chars.\n  if (!unsafeProtocol[lowerProto]) {\n\n    // First, make 100% sure that any \"autoEscape\" chars get\n    // escaped, even if encodeURIComponent doesn't think they\n    // need to be.\n    for (var i = 0, l = autoEscape.length; i < l; i++) {\n      var ae = autoEscape[i];\n      if (rest.indexOf(ae) === -1)\n        continue;\n      var esc = encodeURIComponent(ae);\n      if (esc === ae) {\n        esc = escape(ae);\n      }\n      rest = rest.split(ae).join(esc);\n    }\n  }\n\n\n  // chop off from the tail first.\n  var hash = rest.indexOf('#');\n  if (hash !== -1) {\n    // got a fragment string.\n    this.hash = rest.substr(hash);\n    rest = rest.slice(0, hash);\n  }\n  var qm = rest.indexOf('?');\n  if (qm !== -1) {\n    this.search = rest.substr(qm);\n    this.query = rest.substr(qm + 1);\n    if (parseQueryString) {\n      this.query = querystring.parse(this.query);\n    }\n    rest = rest.slice(0, qm);\n  } else if (parseQueryString) {\n    // no query string, but parseQueryString still requested\n    this.search = '';\n    this.query = {};\n  }\n  if (rest) this.pathname = rest;\n  if (slashedProtocol[lowerProto] &&\n      this.hostname && !this.pathname) {\n    this.pathname = '/';\n  }\n\n  //to support http.request\n  if (this.pathname || this.search) {\n    var p = this.pathname || '';\n    var s = this.search || '';\n    this.path = p + s;\n  }\n\n  // finally, reconstruct the href based on what has been validated.\n  this.href = this.format();\n  return this;\n};\n\n// format a parsed object into a url string\nfunction urlFormat(obj) {\n  // ensure it's an object, and not a string url.\n  // If it's an obj, this is a no-op.\n  // this way, you can call url_format() on strings\n  // to clean up potentially wonky urls.\n  if (util.isString(obj)) obj = urlParse(obj);\n  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);\n  return obj.format();\n}\n\nUrl.prototype.format = function() {\n  var auth = this.auth || '';\n  if (auth) {\n    auth = encodeURIComponent(auth);\n    auth = auth.replace(/%3A/i, ':');\n    auth += '@';\n  }\n\n  var protocol = this.protocol || '',\n      pathname = this.pathname || '',\n      hash = this.hash || '',\n      host = false,\n      query = '';\n\n  if (this.host) {\n    host = auth + this.host;\n  } else if (this.hostname) {\n    host = auth + (this.hostname.indexOf(':') === -1 ?\n        this.hostname :\n        '[' + this.hostname + ']');\n    if (this.port) {\n      host += ':' + this.port;\n    }\n  }\n\n  if (this.query &&\n      util.isObject(this.query) &&\n      Object.keys(this.query).length) {\n    query = querystring.stringify(this.query);\n  }\n\n  var search = this.search || (query && ('?' + query)) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.\n  // unless they had them to begin with.\n  if (this.slashes ||\n      (!protocol || slashedProtocol[protocol]) && host !== false) {\n    host = '//' + (host || '');\n    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;\n  if (search && search.charAt(0) !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, function(match) {\n    return encodeURIComponent(match);\n  });\n  search = search.replace('#', '%23');\n\n  return protocol + host + pathname + search + hash;\n};\n\nfunction urlResolve(source, relative) {\n  return urlParse(source, false, true).resolve(relative);\n}\n\nUrl.prototype.resolve = function(relative) {\n  return this.resolveObject(urlParse(relative, false, true)).format();\n};\n\nfunction urlResolveObject(source, relative) {\n  if (!source) return relative;\n  return urlParse(source, false, true).resolveObject(relative);\n}\n\nUrl.prototype.resolveObject = function(relative) {\n  if (util.isString(relative)) {\n    var rel = new Url();\n    rel.parse(relative, false, true);\n    relative = rel;\n  }\n\n  var result = new Url();\n  var tkeys = Object.keys(this);\n  for (var tk = 0; tk < tkeys.length; tk++) {\n    var tkey = tkeys[tk];\n    result[tkey] = this[tkey];\n  }\n\n  // hash is always overridden, no matter what.\n  // even href=\"\" will remove it.\n  result.hash = relative.hash;\n\n  // if the relative url is empty, then there's nothing left to do here.\n  if (relative.href === '') {\n    result.href = result.format();\n    return result;\n  }\n\n  // hrefs like //foo/bar always cut to the protocol.\n  if (relative.slashes && !relative.protocol) {\n    // take everything except the protocol from relative\n    var rkeys = Object.keys(relative);\n    for (var rk = 0; rk < rkeys.length; rk++) {\n      var rkey = rkeys[rk];\n      if (rkey !== 'protocol')\n        result[rkey] = relative[rkey];\n    }\n\n    //urlParse appends trailing / to urls like http://www.example.com\n    if (slashedProtocol[result.protocol] &&\n        result.hostname && !result.pathname) {\n      result.path = result.pathname = '/';\n    }\n\n    result.href = result.format();\n    return result;\n  }\n\n  if (relative.protocol && relative.protocol !== result.protocol) {\n    // if it's a known url protocol, then changing\n    // the protocol does weird things\n    // first, if it's not file:, then we MUST have a host,\n    // and if there was a path\n    // to begin with, then we MUST have a path.\n    // if it is file:, then the host is dropped,\n    // because that's known to be hostless.\n    // anything else is assumed to be absolute.\n    if (!slashedProtocol[relative.protocol]) {\n      var keys = Object.keys(relative);\n      for (var v = 0; v < keys.length; v++) {\n        var k = keys[v];\n        result[k] = relative[k];\n      }\n      result.href = result.format();\n      return result;\n    }\n\n    result.protocol = relative.protocol;\n    if (!relative.host && !hostlessProtocol[relative.protocol]) {\n      var relPath = (relative.pathname || '').split('/');\n      while (relPath.length && !(relative.host = relPath.shift()));\n      if (!relative.host) relative.host = '';\n      if (!relative.hostname) relative.hostname = '';\n      if (relPath[0] !== '') relPath.unshift('');\n      if (relPath.length < 2) relPath.unshift('');\n      result.pathname = relPath.join('/');\n    } else {\n      result.pathname = relative.pathname;\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    result.host = relative.host || '';\n    result.auth = relative.auth;\n    result.hostname = relative.hostname || relative.host;\n    result.port = relative.port;\n    // to support http.request\n    if (result.pathname || result.search) {\n      var p = result.pathname || '';\n      var s = result.search || '';\n      result.path = p + s;\n    }\n    result.slashes = result.slashes || relative.slashes;\n    result.href = result.format();\n    return result;\n  }\n\n  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),\n      isRelAbs = (\n          relative.host ||\n          relative.pathname && relative.pathname.charAt(0) === '/'\n      ),\n      mustEndAbs = (isRelAbs || isSourceAbs ||\n                    (result.host && relative.pathname)),\n      removeAllDots = mustEndAbs,\n      srcPath = result.pathname && result.pathname.split('/') || [],\n      relPath = relative.pathname && relative.pathname.split('/') || [],\n      psychotic = result.protocol && !slashedProtocol[result.protocol];\n\n  // if the url is a non-slashed url, then relative\n  // links like ../.. should be able\n  // to crawl up to the hostname, as well.  This is strange.\n  // result.protocol has already been set by now.\n  // Later on, put the first path part into the host field.\n  if (psychotic) {\n    result.hostname = '';\n    result.port = null;\n    if (result.host) {\n      if (srcPath[0] === '') srcPath[0] = result.host;\n      else srcPath.unshift(result.host);\n    }\n    result.host = '';\n    if (relative.protocol) {\n      relative.hostname = null;\n      relative.port = null;\n      if (relative.host) {\n        if (relPath[0] === '') relPath[0] = relative.host;\n        else relPath.unshift(relative.host);\n      }\n      relative.host = null;\n    }\n    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');\n  }\n\n  if (isRelAbs) {\n    // it's absolute.\n    result.host = (relative.host || relative.host === '') ?\n                  relative.host : result.host;\n    result.hostname = (relative.hostname || relative.hostname === '') ?\n                      relative.hostname : result.hostname;\n    result.search = relative.search;\n    result.query = relative.query;\n    srcPath = relPath;\n    // fall through to the dot-handling below.\n  } else if (relPath.length) {\n    // it's relative\n    // throw away the existing file, and take the new path instead.\n    if (!srcPath) srcPath = [];\n    srcPath.pop();\n    srcPath = srcPath.concat(relPath);\n    result.search = relative.search;\n    result.query = relative.query;\n  } else if (!util.isNullOrUndefined(relative.search)) {\n    // just pull out the search.\n    // like href='?foo'.\n    // Put this after the other two cases because it simplifies the booleans\n    if (psychotic) {\n      result.hostname = result.host = srcPath.shift();\n      //occationaly the auth can get stuck only in host\n      //this especially happens in cases like\n      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n      var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                       result.host.split('@') : false;\n      if (authInHost) {\n        result.auth = authInHost.shift();\n        result.host = result.hostname = authInHost.shift();\n      }\n    }\n    result.search = relative.search;\n    result.query = relative.query;\n    //to support http.request\n    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n      result.path = (result.pathname ? result.pathname : '') +\n                    (result.search ? result.search : '');\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  if (!srcPath.length) {\n    // no path at all.  easy.\n    // we've already handled the other stuff above.\n    result.pathname = null;\n    //to support http.request\n    if (result.search) {\n      result.path = '/' + result.search;\n    } else {\n      result.path = null;\n    }\n    result.href = result.format();\n    return result;\n  }\n\n  // if a url ENDs in . or .., then it must get a trailing slash.\n  // however, if it ends in anything else non-slashy,\n  // then it must NOT get a trailing slash.\n  var last = srcPath.slice(-1)[0];\n  var hasTrailingSlash = (\n      (result.host || relative.host || srcPath.length > 1) &&\n      (last === '.' || last === '..') || last === '');\n\n  // strip single dots, resolve double dots to parent dir\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = srcPath.length; i >= 0; i--) {\n    last = srcPath[i];\n    if (last === '.') {\n      srcPath.splice(i, 1);\n    } else if (last === '..') {\n      srcPath.splice(i, 1);\n      up++;\n    } else if (up) {\n      srcPath.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (!mustEndAbs && !removeAllDots) {\n    for (; up--; up) {\n      srcPath.unshift('..');\n    }\n  }\n\n  if (mustEndAbs && srcPath[0] !== '' &&\n      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {\n    srcPath.unshift('');\n  }\n\n  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {\n    srcPath.push('');\n  }\n\n  var isAbsolute = srcPath[0] === '' ||\n      (srcPath[0] && srcPath[0].charAt(0) === '/');\n\n  // put the host back\n  if (psychotic) {\n    result.hostname = result.host = isAbsolute ? '' :\n                                    srcPath.length ? srcPath.shift() : '';\n    //occationaly the auth can get stuck only in host\n    //this especially happens in cases like\n    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')\n    var authInHost = result.host && result.host.indexOf('@') > 0 ?\n                     result.host.split('@') : false;\n    if (authInHost) {\n      result.auth = authInHost.shift();\n      result.host = result.hostname = authInHost.shift();\n    }\n  }\n\n  mustEndAbs = mustEndAbs || (result.host && srcPath.length);\n\n  if (mustEndAbs && !isAbsolute) {\n    srcPath.unshift('');\n  }\n\n  if (!srcPath.length) {\n    result.pathname = null;\n    result.path = null;\n  } else {\n    result.pathname = srcPath.join('/');\n  }\n\n  //to support request.http\n  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {\n    result.path = (result.pathname ? result.pathname : '') +\n                  (result.search ? result.search : '');\n  }\n  result.auth = relative.auth || result.auth;\n  result.slashes = result.slashes || relative.slashes;\n  result.href = result.format();\n  return result;\n};\n\nUrl.prototype.parseHost = function() {\n  var host = this.host;\n  var port = portPattern.exec(host);\n  if (port) {\n    port = port[0];\n    if (port !== ':') {\n      this.port = port.substr(1);\n    }\n    host = host.substr(0, host.length - port.length);\n  }\n  if (host) this.hostname = host;\n};\n","'use strict';\n\nmodule.exports = {\n  isString: function(arg) {\n    return typeof(arg) === 'string';\n  },\n  isObject: function(arg) {\n    return typeof(arg) === 'object' && arg !== null;\n  },\n  isNull: function(arg) {\n    return arg === null;\n  },\n  isNullOrUndefined: function(arg) {\n    return arg == null;\n  }\n};\n","\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","module.exports = function(module) {\n\tif (!module.webpackPolyfill) {\n\t\tmodule.deprecate = function() {};\n\t\tmodule.paths = [];\n\t\t// module.parent = undefined by default\n\t\tif (!module.children) module.children = [];\n\t\tObject.defineProperty(module, \"loaded\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.l;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(module, \"id\", {\n\t\t\tenumerable: true,\n\t\t\tget: function() {\n\t\t\t\treturn module.i;\n\t\t\t}\n\t\t});\n\t\tmodule.webpackPolyfill = 1;\n\t}\n\treturn module;\n};\n","function DOMParser(options){\r\n\tthis.options = options ||{locator:{}};\r\n\t\r\n}\r\nDOMParser.prototype.parseFromString = function(source,mimeType){\r\n\tvar options = this.options;\r\n\tvar sax =  new XMLReader();\r\n\tvar domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler\r\n\tvar errorHandler = options.errorHandler;\r\n\tvar locator = options.locator;\r\n\tvar defaultNSMap = options.xmlns||{};\r\n\tvar entityMap = {'lt':'<','gt':'>','amp':'&','quot':'\"','apos':\"'\"}\r\n\tif(locator){\r\n\t\tdomBuilder.setDocumentLocator(locator)\r\n\t}\r\n\t\r\n\tsax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);\r\n\tsax.domBuilder = options.domBuilder || domBuilder;\r\n\tif(/\\/x?html?$/.test(mimeType)){\r\n\t\tentityMap.nbsp = '\\xa0';\r\n\t\tentityMap.copy = '\\xa9';\r\n\t\tdefaultNSMap['']= 'http://www.w3.org/1999/xhtml';\r\n\t}\r\n\tdefaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';\r\n\tif(source){\r\n\t\tsax.parse(source,defaultNSMap,entityMap);\r\n\t}else{\r\n\t\tsax.errorHandler.error(\"invalid doc source\");\r\n\t}\r\n\treturn domBuilder.doc;\r\n}\r\nfunction buildErrorHandler(errorImpl,domBuilder,locator){\r\n\tif(!errorImpl){\r\n\t\tif(domBuilder instanceof DOMHandler){\r\n\t\t\treturn domBuilder;\r\n\t\t}\r\n\t\terrorImpl = domBuilder ;\r\n\t}\r\n\tvar errorHandler = {}\r\n\tvar isCallback = errorImpl instanceof Function;\r\n\tlocator = locator||{}\r\n\tfunction build(key){\r\n\t\tvar fn = errorImpl[key];\r\n\t\tif(!fn && isCallback){\r\n\t\t\tfn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;\r\n\t\t}\r\n\t\terrorHandler[key] = fn && function(msg){\r\n\t\t\tfn('[xmldom '+key+']\\t'+msg+_locator(locator));\r\n\t\t}||function(){};\r\n\t}\r\n\tbuild('warning');\r\n\tbuild('error');\r\n\tbuild('fatalError');\r\n\treturn errorHandler;\r\n}\r\n\r\n//console.log('#\\n\\n\\n\\n\\n\\n\\n####')\r\n/**\r\n * +ContentHandler+ErrorHandler\r\n * +LexicalHandler+EntityResolver2\r\n * -DeclHandler-DTDHandler \r\n * \r\n * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler\r\n * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html\r\n */\r\nfunction DOMHandler() {\r\n    this.cdata = false;\r\n}\r\nfunction position(locator,node){\r\n\tnode.lineNumber = locator.lineNumber;\r\n\tnode.columnNumber = locator.columnNumber;\r\n}\r\n/**\r\n * @see org.xml.sax.ContentHandler#startDocument\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html\r\n */ \r\nDOMHandler.prototype = {\r\n\tstartDocument : function() {\r\n    \tthis.doc = new DOMImplementation().createDocument(null, null, null);\r\n    \tif (this.locator) {\r\n        \tthis.doc.documentURI = this.locator.systemId;\r\n    \t}\r\n\t},\r\n\tstartElement:function(namespaceURI, localName, qName, attrs) {\r\n\t\tvar doc = this.doc;\r\n\t    var el = doc.createElementNS(namespaceURI, qName||localName);\r\n\t    var len = attrs.length;\r\n\t    appendElement(this, el);\r\n\t    this.currentElement = el;\r\n\t    \r\n\t\tthis.locator && position(this.locator,el)\r\n\t    for (var i = 0 ; i < len; i++) {\r\n\t        var namespaceURI = attrs.getURI(i);\r\n\t        var value = attrs.getValue(i);\r\n\t        var qName = attrs.getQName(i);\r\n\t\t\tvar attr = doc.createAttributeNS(namespaceURI, qName);\r\n\t\t\tthis.locator &&position(attrs.getLocator(i),attr);\r\n\t\t\tattr.value = attr.nodeValue = value;\r\n\t\t\tel.setAttributeNode(attr)\r\n\t    }\r\n\t},\r\n\tendElement:function(namespaceURI, localName, qName) {\r\n\t\tvar current = this.currentElement\r\n\t\tvar tagName = current.tagName;\r\n\t\tthis.currentElement = current.parentNode;\r\n\t},\r\n\tstartPrefixMapping:function(prefix, uri) {\r\n\t},\r\n\tendPrefixMapping:function(prefix) {\r\n\t},\r\n\tprocessingInstruction:function(target, data) {\r\n\t    var ins = this.doc.createProcessingInstruction(target, data);\r\n\t    this.locator && position(this.locator,ins)\r\n\t    appendElement(this, ins);\r\n\t},\r\n\tignorableWhitespace:function(ch, start, length) {\r\n\t},\r\n\tcharacters:function(chars, start, length) {\r\n\t\tchars = _toString.apply(this,arguments)\r\n\t\t//console.log(chars)\r\n\t\tif(chars){\r\n\t\t\tif (this.cdata) {\r\n\t\t\t\tvar charNode = this.doc.createCDATASection(chars);\r\n\t\t\t} else {\r\n\t\t\t\tvar charNode = this.doc.createTextNode(chars);\r\n\t\t\t}\r\n\t\t\tif(this.currentElement){\r\n\t\t\t\tthis.currentElement.appendChild(charNode);\r\n\t\t\t}else if(/^\\s*$/.test(chars)){\r\n\t\t\t\tthis.doc.appendChild(charNode);\r\n\t\t\t\t//process xml\r\n\t\t\t}\r\n\t\t\tthis.locator && position(this.locator,charNode)\r\n\t\t}\r\n\t},\r\n\tskippedEntity:function(name) {\r\n\t},\r\n\tendDocument:function() {\r\n\t\tthis.doc.normalize();\r\n\t},\r\n\tsetDocumentLocator:function (locator) {\r\n\t    if(this.locator = locator){// && !('lineNumber' in locator)){\r\n\t    \tlocator.lineNumber = 0;\r\n\t    }\r\n\t},\r\n\t//LexicalHandler\r\n\tcomment:function(chars, start, length) {\r\n\t\tchars = _toString.apply(this,arguments)\r\n\t    var comm = this.doc.createComment(chars);\r\n\t    this.locator && position(this.locator,comm)\r\n\t    appendElement(this, comm);\r\n\t},\r\n\t\r\n\tstartCDATA:function() {\r\n\t    //used in characters() methods\r\n\t    this.cdata = true;\r\n\t},\r\n\tendCDATA:function() {\r\n\t    this.cdata = false;\r\n\t},\r\n\t\r\n\tstartDTD:function(name, publicId, systemId) {\r\n\t\tvar impl = this.doc.implementation;\r\n\t    if (impl && impl.createDocumentType) {\r\n\t        var dt = impl.createDocumentType(name, publicId, systemId);\r\n\t        this.locator && position(this.locator,dt)\r\n\t        appendElement(this, dt);\r\n\t    }\r\n\t},\r\n\t/**\r\n\t * @see org.xml.sax.ErrorHandler\r\n\t * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html\r\n\t */\r\n\twarning:function(error) {\r\n\t\tconsole.warn('[xmldom warning]\\t'+error,_locator(this.locator));\r\n\t},\r\n\terror:function(error) {\r\n\t\tconsole.error('[xmldom error]\\t'+error,_locator(this.locator));\r\n\t},\r\n\tfatalError:function(error) {\r\n\t\tconsole.error('[xmldom fatalError]\\t'+error,_locator(this.locator));\r\n\t    throw error;\r\n\t}\r\n}\r\nfunction _locator(l){\r\n\tif(l){\r\n\t\treturn '\\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'\r\n\t}\r\n}\r\nfunction _toString(chars,start,length){\r\n\tif(typeof chars == 'string'){\r\n\t\treturn chars.substr(start,length)\r\n\t}else{//java sax connect width xmldom on rhino(what about: \"? && !(chars instanceof String)\")\r\n\t\tif(chars.length >= start+length || start){\r\n\t\t\treturn new java.lang.String(chars,start,length)+'';\r\n\t\t}\r\n\t\treturn chars;\r\n\t}\r\n}\r\n\r\n/*\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html\r\n * used method of org.xml.sax.ext.LexicalHandler:\r\n *  #comment(chars, start, length)\r\n *  #startCDATA()\r\n *  #endCDATA()\r\n *  #startDTD(name, publicId, systemId)\r\n *\r\n *\r\n * IGNORED method of org.xml.sax.ext.LexicalHandler:\r\n *  #endDTD()\r\n *  #startEntity(name)\r\n *  #endEntity(name)\r\n *\r\n *\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html\r\n * IGNORED method of org.xml.sax.ext.DeclHandler\r\n * \t#attributeDecl(eName, aName, type, mode, value)\r\n *  #elementDecl(name, model)\r\n *  #externalEntityDecl(name, publicId, systemId)\r\n *  #internalEntityDecl(name, value)\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html\r\n * IGNORED method of org.xml.sax.EntityResolver2\r\n *  #resolveEntity(String name,String publicId,String baseURI,String systemId)\r\n *  #resolveEntity(publicId, systemId)\r\n *  #getExternalSubset(name, baseURI)\r\n * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html\r\n * IGNORED method of org.xml.sax.DTDHandler\r\n *  #notationDecl(name, publicId, systemId) {};\r\n *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};\r\n */\r\n\"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl\".replace(/\\w+/g,function(key){\r\n\tDOMHandler.prototype[key] = function(){return null}\r\n})\r\n\r\n/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */\r\nfunction appendElement (hander,node) {\r\n    if (!hander.currentElement) {\r\n        hander.doc.appendChild(node);\r\n    } else {\r\n        hander.currentElement.appendChild(node);\r\n    }\r\n}//appendChild and setAttributeNS are preformance key\r\n\r\n//if(typeof require == 'function'){\r\n\tvar XMLReader = require('./sax').XMLReader;\r\n\tvar DOMImplementation = exports.DOMImplementation = require('./dom').DOMImplementation;\r\n\texports.XMLSerializer = require('./dom').XMLSerializer ;\r\n\texports.DOMParser = DOMParser;\r\n//}\r\n","/*\n * DOM Level 2\n * Object DOMException\n * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html\n */\n\nfunction copy(src,dest){\n\tfor(var p in src){\n\t\tdest[p] = src[p];\n\t}\n}\n/**\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*((?:.*\\{\\s*?[\\r\\n][\\s\\S]*?^})|\\S.*?(?=[;\\r\\n]));?\n^\\w+\\.prototype\\.([_\\w]+)\\s*=\\s*(\\S.*?(?=[;\\r\\n]));?\n */\nfunction _extends(Class,Super){\n\tvar pt = Class.prototype;\n\tif(Object.create){\n\t\tvar ppt = Object.create(Super.prototype)\n\t\tpt.__proto__ = ppt;\n\t}\n\tif(!(pt instanceof Super)){\n\t\tfunction t(){};\n\t\tt.prototype = Super.prototype;\n\t\tt = new t();\n\t\tcopy(pt,t);\n\t\tClass.prototype = pt = t;\n\t}\n\tif(pt.constructor != Class){\n\t\tif(typeof Class != 'function'){\n\t\t\tconsole.error(\"unknow Class:\"+Class)\n\t\t}\n\t\tpt.constructor = Class\n\t}\n}\nvar htmlns = 'http://www.w3.org/1999/xhtml' ;\n// Node Types\nvar NodeType = {}\nvar ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;\nvar ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;\nvar TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;\nvar CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;\nvar ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;\nvar ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;\nvar PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;\nvar COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;\nvar DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;\nvar DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;\nvar DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;\nvar NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;\n\n// ExceptionCode\nvar ExceptionCode = {}\nvar ExceptionMessage = {};\nvar INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]=\"Index size error\"),1);\nvar DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]=\"DOMString size error\"),2);\nvar HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]=\"Hierarchy request error\"),3);\nvar WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]=\"Wrong document\"),4);\nvar INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]=\"Invalid character\"),5);\nvar NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]=\"No data allowed\"),6);\nvar NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]=\"No modification allowed\"),7);\nvar NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]=\"Not found\"),8);\nvar NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]=\"Not supported\"),9);\nvar INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]=\"Attribute in use\"),10);\n//level2\nvar INVALID_STATE_ERR        \t= ExceptionCode.INVALID_STATE_ERR        \t= ((ExceptionMessage[11]=\"Invalid state\"),11);\nvar SYNTAX_ERR               \t= ExceptionCode.SYNTAX_ERR               \t= ((ExceptionMessage[12]=\"Syntax error\"),12);\nvar INVALID_MODIFICATION_ERR \t= ExceptionCode.INVALID_MODIFICATION_ERR \t= ((ExceptionMessage[13]=\"Invalid modification\"),13);\nvar NAMESPACE_ERR            \t= ExceptionCode.NAMESPACE_ERR           \t= ((ExceptionMessage[14]=\"Invalid namespace\"),14);\nvar INVALID_ACCESS_ERR       \t= ExceptionCode.INVALID_ACCESS_ERR      \t= ((ExceptionMessage[15]=\"Invalid access\"),15);\n\n\nfunction DOMException(code, message) {\n\tif(message instanceof Error){\n\t\tvar error = message;\n\t}else{\n\t\terror = this;\n\t\tError.call(this, ExceptionMessage[code]);\n\t\tthis.message = ExceptionMessage[code];\n\t\tif(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);\n\t}\n\terror.code = code;\n\tif(message) this.message = this.message + \": \" + message;\n\treturn error;\n};\nDOMException.prototype = Error.prototype;\ncopy(ExceptionCode,DOMException)\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177\n * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.\n * The items in the NodeList are accessible via an integral index, starting from 0.\n */\nfunction NodeList() {\n};\nNodeList.prototype = {\n\t/**\n\t * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.\n\t * @standard level1\n\t */\n\tlength:0, \n\t/**\n\t * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.\n\t * @standard level1\n\t * @param index  unsigned long \n\t *   Index into the collection.\n\t * @return Node\n\t * \tThe node at the indexth position in the NodeList, or null if that is not a valid index. \n\t */\n\titem: function(index) {\n\t\treturn this[index] || null;\n\t},\n\ttoString:function(isHTML,nodeFilter){\n\t\tfor(var buf = [], i = 0;i<this.length;i++){\n\t\t\tserializeToString(this[i],buf,isHTML,nodeFilter);\n\t\t}\n\t\treturn buf.join('');\n\t}\n};\nfunction LiveNodeList(node,refresh){\n\tthis._node = node;\n\tthis._refresh = refresh\n\t_updateLiveList(this);\n}\nfunction _updateLiveList(list){\n\tvar inc = list._node._inc || list._node.ownerDocument._inc;\n\tif(list._inc != inc){\n\t\tvar ls = list._refresh(list._node);\n\t\t//console.log(ls.length)\n\t\t__set__(list,'length',ls.length);\n\t\tcopy(ls,list);\n\t\tlist._inc = inc;\n\t}\n}\nLiveNodeList.prototype.item = function(i){\n\t_updateLiveList(this);\n\treturn this[i];\n}\n\n_extends(LiveNodeList,NodeList);\n/**\n * \n * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.\n * NamedNodeMap objects in the DOM are live.\n * used for attributes or DocumentType entities \n */\nfunction NamedNodeMap() {\n};\n\nfunction _findNodeIndex(list,node){\n\tvar i = list.length;\n\twhile(i--){\n\t\tif(list[i] === node){return i}\n\t}\n}\n\nfunction _addNamedNode(el,list,newAttr,oldAttr){\n\tif(oldAttr){\n\t\tlist[_findNodeIndex(list,oldAttr)] = newAttr;\n\t}else{\n\t\tlist[list.length++] = newAttr;\n\t}\n\tif(el){\n\t\tnewAttr.ownerElement = el;\n\t\tvar doc = el.ownerDocument;\n\t\tif(doc){\n\t\t\toldAttr && _onRemoveAttribute(doc,el,oldAttr);\n\t\t\t_onAddAttribute(doc,el,newAttr);\n\t\t}\n\t}\n}\nfunction _removeNamedNode(el,list,attr){\n\t//console.log('remove attr:'+attr)\n\tvar i = _findNodeIndex(list,attr);\n\tif(i>=0){\n\t\tvar lastIndex = list.length-1\n\t\twhile(i<lastIndex){\n\t\t\tlist[i] = list[++i]\n\t\t}\n\t\tlist.length = lastIndex;\n\t\tif(el){\n\t\t\tvar doc = el.ownerDocument;\n\t\t\tif(doc){\n\t\t\t\t_onRemoveAttribute(doc,el,attr);\n\t\t\t\tattr.ownerElement = null;\n\t\t\t}\n\t\t}\n\t}else{\n\t\tthrow DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))\n\t}\n}\nNamedNodeMap.prototype = {\n\tlength:0,\n\titem:NodeList.prototype.item,\n\tgetNamedItem: function(key) {\n//\t\tif(key.indexOf(':')>0 || key == 'xmlns'){\n//\t\t\treturn null;\n//\t\t}\n\t\t//console.log()\n\t\tvar i = this.length;\n\t\twhile(i--){\n\t\t\tvar attr = this[i];\n\t\t\t//console.log(attr.nodeName,key)\n\t\t\tif(attr.nodeName == key){\n\t\t\t\treturn attr;\n\t\t\t}\n\t\t}\n\t},\n\tsetNamedItem: function(attr) {\n\t\tvar el = attr.ownerElement;\n\t\tif(el && el!=this._ownerElement){\n\t\t\tthrow new DOMException(INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\tvar oldAttr = this.getNamedItem(attr.nodeName);\n\t\t_addNamedNode(this._ownerElement,this,attr,oldAttr);\n\t\treturn oldAttr;\n\t},\n\t/* returns Node */\n\tsetNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR\n\t\tvar el = attr.ownerElement, oldAttr;\n\t\tif(el && el!=this._ownerElement){\n\t\t\tthrow new DOMException(INUSE_ATTRIBUTE_ERR);\n\t\t}\n\t\toldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);\n\t\t_addNamedNode(this._ownerElement,this,attr,oldAttr);\n\t\treturn oldAttr;\n\t},\n\n\t/* returns Node */\n\tremoveNamedItem: function(key) {\n\t\tvar attr = this.getNamedItem(key);\n\t\t_removeNamedNode(this._ownerElement,this,attr);\n\t\treturn attr;\n\t\t\n\t\t\n\t},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR\n\t\n\t//for level2\n\tremoveNamedItemNS:function(namespaceURI,localName){\n\t\tvar attr = this.getNamedItemNS(namespaceURI,localName);\n\t\t_removeNamedNode(this._ownerElement,this,attr);\n\t\treturn attr;\n\t},\n\tgetNamedItemNS: function(namespaceURI, localName) {\n\t\tvar i = this.length;\n\t\twhile(i--){\n\t\t\tvar node = this[i];\n\t\t\tif(node.localName == localName && node.namespaceURI == namespaceURI){\n\t\t\t\treturn node;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n};\n/**\n * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490\n */\nfunction DOMImplementation(/* Object */ features) {\n\tthis._features = {};\n\tif (features) {\n\t\tfor (var feature in features) {\n\t\t\t this._features = features[feature];\n\t\t}\n\t}\n};\n\nDOMImplementation.prototype = {\n\thasFeature: function(/* string */ feature, /* string */ version) {\n\t\tvar versions = this._features[feature.toLowerCase()];\n\t\tif (versions && (!version || version in versions)) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR\n\t\tvar doc = new Document();\n\t\tdoc.implementation = this;\n\t\tdoc.childNodes = new NodeList();\n\t\tdoc.doctype = doctype;\n\t\tif(doctype){\n\t\t\tdoc.appendChild(doctype);\n\t\t}\n\t\tif(qualifiedName){\n\t\t\tvar root = doc.createElementNS(namespaceURI,qualifiedName);\n\t\t\tdoc.appendChild(root);\n\t\t}\n\t\treturn doc;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR\n\t\tvar node = new DocumentType();\n\t\tnode.name = qualifiedName;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.publicId = publicId;\n\t\tnode.systemId = systemId;\n\t\t// Introduced in DOM Level 2:\n\t\t//readonly attribute DOMString        internalSubset;\n\t\t\n\t\t//TODO:..\n\t\t//  readonly attribute NamedNodeMap     entities;\n\t\t//  readonly attribute NamedNodeMap     notations;\n\t\treturn node;\n\t}\n};\n\n\n/**\n * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247\n */\n\nfunction Node() {\n};\n\nNode.prototype = {\n\tfirstChild : null,\n\tlastChild : null,\n\tpreviousSibling : null,\n\tnextSibling : null,\n\tattributes : null,\n\tparentNode : null,\n\tchildNodes : null,\n\townerDocument : null,\n\tnodeValue : null,\n\tnamespaceURI : null,\n\tprefix : null,\n\tlocalName : null,\n\t// Modified in DOM Level 2:\n\tinsertBefore:function(newChild, refChild){//raises \n\t\treturn _insertBefore(this,newChild,refChild);\n\t},\n\treplaceChild:function(newChild, oldChild){//raises \n\t\tthis.insertBefore(newChild,oldChild);\n\t\tif(oldChild){\n\t\t\tthis.removeChild(oldChild);\n\t\t}\n\t},\n\tremoveChild:function(oldChild){\n\t\treturn _removeChild(this,oldChild);\n\t},\n\tappendChild:function(newChild){\n\t\treturn this.insertBefore(newChild,null);\n\t},\n\thasChildNodes:function(){\n\t\treturn this.firstChild != null;\n\t},\n\tcloneNode:function(deep){\n\t\treturn cloneNode(this.ownerDocument||this,this,deep);\n\t},\n\t// Modified in DOM Level 2:\n\tnormalize:function(){\n\t\tvar child = this.firstChild;\n\t\twhile(child){\n\t\t\tvar next = child.nextSibling;\n\t\t\tif(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){\n\t\t\t\tthis.removeChild(next);\n\t\t\t\tchild.appendData(next.data);\n\t\t\t}else{\n\t\t\t\tchild.normalize();\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t}\n\t},\n  \t// Introduced in DOM Level 2:\n\tisSupported:function(feature, version){\n\t\treturn this.ownerDocument.implementation.hasFeature(feature,version);\n\t},\n    // Introduced in DOM Level 2:\n    hasAttributes:function(){\n    \treturn this.attributes.length>0;\n    },\n    lookupPrefix:function(namespaceURI){\n    \tvar el = this;\n    \twhile(el){\n    \t\tvar map = el._nsMap;\n    \t\t//console.dir(map)\n    \t\tif(map){\n    \t\t\tfor(var n in map){\n    \t\t\t\tif(map[n] == namespaceURI){\n    \t\t\t\t\treturn n;\n    \t\t\t\t}\n    \t\t\t}\n    \t\t}\n    \t\tel = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;\n    \t}\n    \treturn null;\n    },\n    // Introduced in DOM Level 3:\n    lookupNamespaceURI:function(prefix){\n    \tvar el = this;\n    \twhile(el){\n    \t\tvar map = el._nsMap;\n    \t\t//console.dir(map)\n    \t\tif(map){\n    \t\t\tif(prefix in map){\n    \t\t\t\treturn map[prefix] ;\n    \t\t\t}\n    \t\t}\n    \t\tel = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;\n    \t}\n    \treturn null;\n    },\n    // Introduced in DOM Level 3:\n    isDefaultNamespace:function(namespaceURI){\n    \tvar prefix = this.lookupPrefix(namespaceURI);\n    \treturn prefix == null;\n    }\n};\n\n\nfunction _xmlEncoder(c){\n\treturn c == '<' && '&lt;' ||\n         c == '>' && '&gt;' ||\n         c == '&' && '&amp;' ||\n         c == '\"' && '&quot;' ||\n         '&#'+c.charCodeAt()+';'\n}\n\n\ncopy(NodeType,Node);\ncopy(NodeType,Node.prototype);\n\n/**\n * @param callback return true for continue,false for break\n * @return boolean true: break visit;\n */\nfunction _visitNode(node,callback){\n\tif(callback(node)){\n\t\treturn true;\n\t}\n\tif(node = node.firstChild){\n\t\tdo{\n\t\t\tif(_visitNode(node,callback)){return true}\n        }while(node=node.nextSibling)\n    }\n}\n\n\n\nfunction Document(){\n}\nfunction _onAddAttribute(doc,el,newAttr){\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI ;\n\tif(ns == 'http://www.w3.org/2000/xmlns/'){\n\t\t//update namespace\n\t\tel._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value\n\t}\n}\nfunction _onRemoveAttribute(doc,el,newAttr,remove){\n\tdoc && doc._inc++;\n\tvar ns = newAttr.namespaceURI ;\n\tif(ns == 'http://www.w3.org/2000/xmlns/'){\n\t\t//update namespace\n\t\tdelete el._nsMap[newAttr.prefix?newAttr.localName:'']\n\t}\n}\nfunction _onUpdateChild(doc,el,newChild){\n\tif(doc && doc._inc){\n\t\tdoc._inc++;\n\t\t//update childNodes\n\t\tvar cs = el.childNodes;\n\t\tif(newChild){\n\t\t\tcs[cs.length++] = newChild;\n\t\t}else{\n\t\t\t//console.log(1)\n\t\t\tvar child = el.firstChild;\n\t\t\tvar i = 0;\n\t\t\twhile(child){\n\t\t\t\tcs[i++] = child;\n\t\t\t\tchild =child.nextSibling;\n\t\t\t}\n\t\t\tcs.length = i;\n\t\t}\n\t}\n}\n\n/**\n * attributes;\n * children;\n * \n * writeable properties:\n * nodeValue,Attr:value,CharacterData:data\n * prefix\n */\nfunction _removeChild(parentNode,child){\n\tvar previous = child.previousSibling;\n\tvar next = child.nextSibling;\n\tif(previous){\n\t\tprevious.nextSibling = next;\n\t}else{\n\t\tparentNode.firstChild = next\n\t}\n\tif(next){\n\t\tnext.previousSibling = previous;\n\t}else{\n\t\tparentNode.lastChild = previous;\n\t}\n\t_onUpdateChild(parentNode.ownerDocument,parentNode);\n\treturn child;\n}\n/**\n * preformance key(refChild == null)\n */\nfunction _insertBefore(parentNode,newChild,nextChild){\n\tvar cp = newChild.parentNode;\n\tif(cp){\n\t\tcp.removeChild(newChild);//remove and update\n\t}\n\tif(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){\n\t\tvar newFirst = newChild.firstChild;\n\t\tif (newFirst == null) {\n\t\t\treturn newChild;\n\t\t}\n\t\tvar newLast = newChild.lastChild;\n\t}else{\n\t\tnewFirst = newLast = newChild;\n\t}\n\tvar pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;\n\n\tnewFirst.previousSibling = pre;\n\tnewLast.nextSibling = nextChild;\n\t\n\t\n\tif(pre){\n\t\tpre.nextSibling = newFirst;\n\t}else{\n\t\tparentNode.firstChild = newFirst;\n\t}\n\tif(nextChild == null){\n\t\tparentNode.lastChild = newLast;\n\t}else{\n\t\tnextChild.previousSibling = newLast;\n\t}\n\tdo{\n\t\tnewFirst.parentNode = parentNode;\n\t}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))\n\t_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);\n\t//console.log(parentNode.lastChild.nextSibling == null)\n\tif (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {\n\t\tnewChild.firstChild = newChild.lastChild = null;\n\t}\n\treturn newChild;\n}\nfunction _appendSingleChild(parentNode,newChild){\n\tvar cp = newChild.parentNode;\n\tif(cp){\n\t\tvar pre = parentNode.lastChild;\n\t\tcp.removeChild(newChild);//remove and update\n\t\tvar pre = parentNode.lastChild;\n\t}\n\tvar pre = parentNode.lastChild;\n\tnewChild.parentNode = parentNode;\n\tnewChild.previousSibling = pre;\n\tnewChild.nextSibling = null;\n\tif(pre){\n\t\tpre.nextSibling = newChild;\n\t}else{\n\t\tparentNode.firstChild = newChild;\n\t}\n\tparentNode.lastChild = newChild;\n\t_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);\n\treturn newChild;\n\t//console.log(\"__aa\",parentNode.lastChild.nextSibling == null)\n}\nDocument.prototype = {\n\t//implementation : null,\n\tnodeName :  '#document',\n\tnodeType :  DOCUMENT_NODE,\n\tdoctype :  null,\n\tdocumentElement :  null,\n\t_inc : 1,\n\t\n\tinsertBefore :  function(newChild, refChild){//raises \n\t\tif(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){\n\t\t\tvar child = newChild.firstChild;\n\t\t\twhile(child){\n\t\t\t\tvar next = child.nextSibling;\n\t\t\t\tthis.insertBefore(child,refChild);\n\t\t\t\tchild = next;\n\t\t\t}\n\t\t\treturn newChild;\n\t\t}\n\t\tif(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){\n\t\t\tthis.documentElement = newChild;\n\t\t}\n\t\t\n\t\treturn _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;\n\t},\n\tremoveChild :  function(oldChild){\n\t\tif(this.documentElement == oldChild){\n\t\t\tthis.documentElement = null;\n\t\t}\n\t\treturn _removeChild(this,oldChild);\n\t},\n\t// Introduced in DOM Level 2:\n\timportNode : function(importedNode,deep){\n\t\treturn importNode(this,importedNode,deep);\n\t},\n\t// Introduced in DOM Level 2:\n\tgetElementById :\tfunction(id){\n\t\tvar rtv = null;\n\t\t_visitNode(this.documentElement,function(node){\n\t\t\tif(node.nodeType == ELEMENT_NODE){\n\t\t\t\tif(node.getAttribute('id') == id){\n\t\t\t\t\trtv = node;\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\treturn rtv;\n\t},\n\t\n\t//document factory method:\n\tcreateElement :\tfunction(tagName){\n\t\tvar node = new Element();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = tagName;\n\t\tnode.tagName = tagName;\n\t\tnode.childNodes = new NodeList();\n\t\tvar attrs\t= node.attributes = new NamedNodeMap();\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\tcreateDocumentFragment :\tfunction(){\n\t\tvar node = new DocumentFragment();\n\t\tnode.ownerDocument = this;\n\t\tnode.childNodes = new NodeList();\n\t\treturn node;\n\t},\n\tcreateTextNode :\tfunction(data){\n\t\tvar node = new Text();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateComment :\tfunction(data){\n\t\tvar node = new Comment();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateCDATASection :\tfunction(data){\n\t\tvar node = new CDATASection();\n\t\tnode.ownerDocument = this;\n\t\tnode.appendData(data)\n\t\treturn node;\n\t},\n\tcreateProcessingInstruction :\tfunction(target,data){\n\t\tvar node = new ProcessingInstruction();\n\t\tnode.ownerDocument = this;\n\t\tnode.tagName = node.target = target;\n\t\tnode.nodeValue= node.data = data;\n\t\treturn node;\n\t},\n\tcreateAttribute :\tfunction(name){\n\t\tvar node = new Attr();\n\t\tnode.ownerDocument\t= this;\n\t\tnode.name = name;\n\t\tnode.nodeName\t= name;\n\t\tnode.localName = name;\n\t\tnode.specified = true;\n\t\treturn node;\n\t},\n\tcreateEntityReference :\tfunction(name){\n\t\tvar node = new EntityReference();\n\t\tnode.ownerDocument\t= this;\n\t\tnode.nodeName\t= name;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateElementNS :\tfunction(namespaceURI,qualifiedName){\n\t\tvar node = new Element();\n\t\tvar pl = qualifiedName.split(':');\n\t\tvar attrs\t= node.attributes = new NamedNodeMap();\n\t\tnode.childNodes = new NodeList();\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.tagName = qualifiedName;\n\t\tnode.namespaceURI = namespaceURI;\n\t\tif(pl.length == 2){\n\t\t\tnode.prefix = pl[0];\n\t\t\tnode.localName = pl[1];\n\t\t}else{\n\t\t\t//el.prefix = null;\n\t\t\tnode.localName = qualifiedName;\n\t\t}\n\t\tattrs._ownerElement = node;\n\t\treturn node;\n\t},\n\t// Introduced in DOM Level 2:\n\tcreateAttributeNS :\tfunction(namespaceURI,qualifiedName){\n\t\tvar node = new Attr();\n\t\tvar pl = qualifiedName.split(':');\n\t\tnode.ownerDocument = this;\n\t\tnode.nodeName = qualifiedName;\n\t\tnode.name = qualifiedName;\n\t\tnode.namespaceURI = namespaceURI;\n\t\tnode.specified = true;\n\t\tif(pl.length == 2){\n\t\t\tnode.prefix = pl[0];\n\t\t\tnode.localName = pl[1];\n\t\t}else{\n\t\t\t//el.prefix = null;\n\t\t\tnode.localName = qualifiedName;\n\t\t}\n\t\treturn node;\n\t}\n};\n_extends(Document,Node);\n\n\nfunction Element() {\n\tthis._nsMap = {};\n};\nElement.prototype = {\n\tnodeType : ELEMENT_NODE,\n\thasAttribute : function(name){\n\t\treturn this.getAttributeNode(name)!=null;\n\t},\n\tgetAttribute : function(name){\n\t\tvar attr = this.getAttributeNode(name);\n\t\treturn attr && attr.value || '';\n\t},\n\tgetAttributeNode : function(name){\n\t\treturn this.attributes.getNamedItem(name);\n\t},\n\tsetAttribute : function(name, value){\n\t\tvar attr = this.ownerDocument.createAttribute(name);\n\t\tattr.value = attr.nodeValue = \"\" + value;\n\t\tthis.setAttributeNode(attr)\n\t},\n\tremoveAttribute : function(name){\n\t\tvar attr = this.getAttributeNode(name)\n\t\tattr && this.removeAttributeNode(attr);\n\t},\n\t\n\t//four real opeartion method\n\tappendChild:function(newChild){\n\t\tif(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){\n\t\t\treturn this.insertBefore(newChild,null);\n\t\t}else{\n\t\t\treturn _appendSingleChild(this,newChild);\n\t\t}\n\t},\n\tsetAttributeNode : function(newAttr){\n\t\treturn this.attributes.setNamedItem(newAttr);\n\t},\n\tsetAttributeNodeNS : function(newAttr){\n\t\treturn this.attributes.setNamedItemNS(newAttr);\n\t},\n\tremoveAttributeNode : function(oldAttr){\n\t\t//console.log(this == oldAttr.ownerElement)\n\t\treturn this.attributes.removeNamedItem(oldAttr.nodeName);\n\t},\n\t//get real attribute name,and remove it by removeAttributeNode\n\tremoveAttributeNS : function(namespaceURI, localName){\n\t\tvar old = this.getAttributeNodeNS(namespaceURI, localName);\n\t\told && this.removeAttributeNode(old);\n\t},\n\t\n\thasAttributeNS : function(namespaceURI, localName){\n\t\treturn this.getAttributeNodeNS(namespaceURI, localName)!=null;\n\t},\n\tgetAttributeNS : function(namespaceURI, localName){\n\t\tvar attr = this.getAttributeNodeNS(namespaceURI, localName);\n\t\treturn attr && attr.value || '';\n\t},\n\tsetAttributeNS : function(namespaceURI, qualifiedName, value){\n\t\tvar attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);\n\t\tattr.value = attr.nodeValue = \"\" + value;\n\t\tthis.setAttributeNode(attr)\n\t},\n\tgetAttributeNodeNS : function(namespaceURI, localName){\n\t\treturn this.attributes.getNamedItemNS(namespaceURI, localName);\n\t},\n\t\n\tgetElementsByTagName : function(tagName){\n\t\treturn new LiveNodeList(this,function(base){\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base,function(node){\n\t\t\t\tif(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t});\n\t},\n\tgetElementsByTagNameNS : function(namespaceURI, localName){\n\t\treturn new LiveNodeList(this,function(base){\n\t\t\tvar ls = [];\n\t\t\t_visitNode(base,function(node){\n\t\t\t\tif(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){\n\t\t\t\t\tls.push(node);\n\t\t\t\t}\n\t\t\t});\n\t\t\treturn ls;\n\t\t\t\n\t\t});\n\t}\n};\nDocument.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;\nDocument.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;\n\n\n_extends(Element,Node);\nfunction Attr() {\n};\nAttr.prototype.nodeType = ATTRIBUTE_NODE;\n_extends(Attr,Node);\n\n\nfunction CharacterData() {\n};\nCharacterData.prototype = {\n\tdata : '',\n\tsubstringData : function(offset, count) {\n\t\treturn this.data.substring(offset, offset+count);\n\t},\n\tappendData: function(text) {\n\t\ttext = this.data+text;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t},\n\tinsertData: function(offset,text) {\n\t\tthis.replaceData(offset,0,text);\n\t\n\t},\n\tappendChild:function(newChild){\n\t\tthrow new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])\n\t},\n\tdeleteData: function(offset, count) {\n\t\tthis.replaceData(offset,count,\"\");\n\t},\n\treplaceData: function(offset, count, text) {\n\t\tvar start = this.data.substring(0,offset);\n\t\tvar end = this.data.substring(offset+count);\n\t\ttext = start + text + end;\n\t\tthis.nodeValue = this.data = text;\n\t\tthis.length = text.length;\n\t}\n}\n_extends(CharacterData,Node);\nfunction Text() {\n};\nText.prototype = {\n\tnodeName : \"#text\",\n\tnodeType : TEXT_NODE,\n\tsplitText : function(offset) {\n\t\tvar text = this.data;\n\t\tvar newText = text.substring(offset);\n\t\ttext = text.substring(0, offset);\n\t\tthis.data = this.nodeValue = text;\n\t\tthis.length = text.length;\n\t\tvar newNode = this.ownerDocument.createTextNode(newText);\n\t\tif(this.parentNode){\n\t\t\tthis.parentNode.insertBefore(newNode, this.nextSibling);\n\t\t}\n\t\treturn newNode;\n\t}\n}\n_extends(Text,CharacterData);\nfunction Comment() {\n};\nComment.prototype = {\n\tnodeName : \"#comment\",\n\tnodeType : COMMENT_NODE\n}\n_extends(Comment,CharacterData);\n\nfunction CDATASection() {\n};\nCDATASection.prototype = {\n\tnodeName : \"#cdata-section\",\n\tnodeType : CDATA_SECTION_NODE\n}\n_extends(CDATASection,CharacterData);\n\n\nfunction DocumentType() {\n};\nDocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;\n_extends(DocumentType,Node);\n\nfunction Notation() {\n};\nNotation.prototype.nodeType = NOTATION_NODE;\n_extends(Notation,Node);\n\nfunction Entity() {\n};\nEntity.prototype.nodeType = ENTITY_NODE;\n_extends(Entity,Node);\n\nfunction EntityReference() {\n};\nEntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;\n_extends(EntityReference,Node);\n\nfunction DocumentFragment() {\n};\nDocumentFragment.prototype.nodeName =\t\"#document-fragment\";\nDocumentFragment.prototype.nodeType =\tDOCUMENT_FRAGMENT_NODE;\n_extends(DocumentFragment,Node);\n\n\nfunction ProcessingInstruction() {\n}\nProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;\n_extends(ProcessingInstruction,Node);\nfunction XMLSerializer(){}\nXMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){\n\treturn nodeSerializeToString.call(node,isHtml,nodeFilter);\n}\nNode.prototype.toString = nodeSerializeToString;\nfunction nodeSerializeToString(isHtml,nodeFilter){\n\tvar buf = [];\n\tvar refNode = this.nodeType == 9?this.documentElement:this;\n\tvar prefix = refNode.prefix;\n\tvar uri = refNode.namespaceURI;\n\t\n\tif(uri && prefix == null){\n\t\t//console.log(prefix)\n\t\tvar prefix = refNode.lookupPrefix(uri);\n\t\tif(prefix == null){\n\t\t\t//isHTML = true;\n\t\t\tvar visibleNamespaces=[\n\t\t\t{namespace:uri,prefix:null}\n\t\t\t//{namespace:uri,prefix:''}\n\t\t\t]\n\t\t}\n\t}\n\tserializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);\n\t//console.log('###',this.nodeType,uri,prefix,buf.join(''))\n\treturn buf.join('');\n}\nfunction needNamespaceDefine(node,isHTML, visibleNamespaces) {\n\tvar prefix = node.prefix||'';\n\tvar uri = node.namespaceURI;\n\tif (!prefix && !uri){\n\t\treturn false;\n\t}\n\tif (prefix === \"xml\" && uri === \"http://www.w3.org/XML/1998/namespace\" \n\t\t|| uri == 'http://www.w3.org/2000/xmlns/'){\n\t\treturn false;\n\t}\n\t\n\tvar i = visibleNamespaces.length \n\t//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)\n\twhile (i--) {\n\t\tvar ns = visibleNamespaces[i];\n\t\t// get namespace prefix\n\t\t//console.log(node.nodeType,node.tagName,ns.prefix,prefix)\n\t\tif (ns.prefix == prefix){\n\t\t\treturn ns.namespace != uri;\n\t\t}\n\t}\n\t//console.log(isHTML,uri,prefix=='')\n\t//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){\n\t//\treturn false;\n\t//}\n\t//node.flag = '11111'\n\t//console.error(3,true,node.flag,node.prefix,node.namespaceURI)\n\treturn true;\n}\nfunction serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){\n\tif(nodeFilter){\n\t\tnode = nodeFilter(node);\n\t\tif(node){\n\t\t\tif(typeof node == 'string'){\n\t\t\t\tbuf.push(node);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}else{\n\t\t\treturn;\n\t\t}\n\t\t//buf.sort.apply(attrs, attributeSorter);\n\t}\n\tswitch(node.nodeType){\n\tcase ELEMENT_NODE:\n\t\tif (!visibleNamespaces) visibleNamespaces = [];\n\t\tvar startVisibleNamespaces = visibleNamespaces.length;\n\t\tvar attrs = node.attributes;\n\t\tvar len = attrs.length;\n\t\tvar child = node.firstChild;\n\t\tvar nodeName = node.tagName;\n\t\t\n\t\tisHTML =  (htmlns === node.namespaceURI) ||isHTML \n\t\tbuf.push('<',nodeName);\n\t\t\n\t\t\n\t\t\n\t\tfor(var i=0;i<len;i++){\n\t\t\t// add namespaces for attributes\n\t\t\tvar attr = attrs.item(i);\n\t\t\tif (attr.prefix == 'xmlns') {\n\t\t\t\tvisibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });\n\t\t\t}else if(attr.nodeName == 'xmlns'){\n\t\t\t\tvisibleNamespaces.push({ prefix: '', namespace: attr.value });\n\t\t\t}\n\t\t}\n\t\tfor(var i=0;i<len;i++){\n\t\t\tvar attr = attrs.item(i);\n\t\t\tif (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {\n\t\t\t\tvar prefix = attr.prefix||'';\n\t\t\t\tvar uri = attr.namespaceURI;\n\t\t\t\tvar ns = prefix ? ' xmlns:' + prefix : \" xmlns\";\n\t\t\t\tbuf.push(ns, '=\"' , uri , '\"');\n\t\t\t\tvisibleNamespaces.push({ prefix: prefix, namespace:uri });\n\t\t\t}\n\t\t\tserializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);\n\t\t}\n\t\t// add namespace for current node\t\t\n\t\tif (needNamespaceDefine(node,isHTML, visibleNamespaces)) {\n\t\t\tvar prefix = node.prefix||'';\n\t\t\tvar uri = node.namespaceURI;\n\t\t\tvar ns = prefix ? ' xmlns:' + prefix : \" xmlns\";\n\t\t\tbuf.push(ns, '=\"' , uri , '\"');\n\t\t\tvisibleNamespaces.push({ prefix: prefix, namespace:uri });\n\t\t}\n\t\t\n\t\tif(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){\n\t\t\tbuf.push('>');\n\t\t\t//if is cdata child node\n\t\t\tif(isHTML && /^script$/i.test(nodeName)){\n\t\t\t\twhile(child){\n\t\t\t\t\tif(child.data){\n\t\t\t\t\t\tbuf.push(child.data);\n\t\t\t\t\t}else{\n\t\t\t\t\t\tserializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);\n\t\t\t\t\t}\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}else\n\t\t\t{\n\t\t\t\twhile(child){\n\t\t\t\t\tserializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);\n\t\t\t\t\tchild = child.nextSibling;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbuf.push('</',nodeName,'>');\n\t\t}else{\n\t\t\tbuf.push('/>');\n\t\t}\n\t\t// remove added visible namespaces\n\t\t//visibleNamespaces.length = startVisibleNamespaces;\n\t\treturn;\n\tcase DOCUMENT_NODE:\n\tcase DOCUMENT_FRAGMENT_NODE:\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tserializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t\treturn;\n\tcase ATTRIBUTE_NODE:\n\t\treturn buf.push(' ',node.name,'=\"',node.value.replace(/[<&\"]/g,_xmlEncoder),'\"');\n\tcase TEXT_NODE:\n\t\treturn buf.push(node.data.replace(/[<&]/g,_xmlEncoder));\n\tcase CDATA_SECTION_NODE:\n\t\treturn buf.push( '<![CDATA[',node.data,']]>');\n\tcase COMMENT_NODE:\n\t\treturn buf.push( \"<!--\",node.data,\"-->\");\n\tcase DOCUMENT_TYPE_NODE:\n\t\tvar pubid = node.publicId;\n\t\tvar sysid = node.systemId;\n\t\tbuf.push('<!DOCTYPE ',node.name);\n\t\tif(pubid){\n\t\t\tbuf.push(' PUBLIC \"',pubid);\n\t\t\tif (sysid && sysid!='.') {\n\t\t\t\tbuf.push( '\" \"',sysid);\n\t\t\t}\n\t\t\tbuf.push('\">');\n\t\t}else if(sysid && sysid!='.'){\n\t\t\tbuf.push(' SYSTEM \"',sysid,'\">');\n\t\t}else{\n\t\t\tvar sub = node.internalSubset;\n\t\t\tif(sub){\n\t\t\t\tbuf.push(\" [\",sub,\"]\");\n\t\t\t}\n\t\t\tbuf.push(\">\");\n\t\t}\n\t\treturn;\n\tcase PROCESSING_INSTRUCTION_NODE:\n\t\treturn buf.push( \"<?\",node.target,\" \",node.data,\"?>\");\n\tcase ENTITY_REFERENCE_NODE:\n\t\treturn buf.push( '&',node.nodeName,';');\n\t//case ENTITY_NODE:\n\t//case NOTATION_NODE:\n\tdefault:\n\t\tbuf.push('??',node.nodeName);\n\t}\n}\nfunction importNode(doc,node,deep){\n\tvar node2;\n\tswitch (node.nodeType) {\n\tcase ELEMENT_NODE:\n\t\tnode2 = node.cloneNode(false);\n\t\tnode2.ownerDocument = doc;\n\t\t//var attrs = node2.attributes;\n\t\t//var len = attrs.length;\n\t\t//for(var i=0;i<len;i++){\n\t\t\t//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));\n\t\t//}\n\tcase DOCUMENT_FRAGMENT_NODE:\n\t\tbreak;\n\tcase ATTRIBUTE_NODE:\n\t\tdeep = true;\n\t\tbreak;\n\t//case ENTITY_REFERENCE_NODE:\n\t//case PROCESSING_INSTRUCTION_NODE:\n\t////case TEXT_NODE:\n\t//case CDATA_SECTION_NODE:\n\t//case COMMENT_NODE:\n\t//\tdeep = false;\n\t//\tbreak;\n\t//case DOCUMENT_NODE:\n\t//case DOCUMENT_TYPE_NODE:\n\t//cannot be imported.\n\t//case ENTITY_NODE:\n\t//case NOTATION_NODE：\n\t//can not hit in level3\n\t//default:throw e;\n\t}\n\tif(!node2){\n\t\tnode2 = node.cloneNode(false);//false\n\t}\n\tnode2.ownerDocument = doc;\n\tnode2.parentNode = null;\n\tif(deep){\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tnode2.appendChild(importNode(doc,child,deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n//\n//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,\n//\t\t\t\t\tattributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};\nfunction cloneNode(doc,node,deep){\n\tvar node2 = new node.constructor();\n\tfor(var n in node){\n\t\tvar v = node[n];\n\t\tif(typeof v != 'object' ){\n\t\t\tif(v != node2[n]){\n\t\t\t\tnode2[n] = v;\n\t\t\t}\n\t\t}\n\t}\n\tif(node.childNodes){\n\t\tnode2.childNodes = new NodeList();\n\t}\n\tnode2.ownerDocument = doc;\n\tswitch (node2.nodeType) {\n\tcase ELEMENT_NODE:\n\t\tvar attrs\t= node.attributes;\n\t\tvar attrs2\t= node2.attributes = new NamedNodeMap();\n\t\tvar len = attrs.length\n\t\tattrs2._ownerElement = node2;\n\t\tfor(var i=0;i<len;i++){\n\t\t\tnode2.setAttributeNode(cloneNode(doc,attrs.item(i),true));\n\t\t}\n\t\tbreak;;\n\tcase ATTRIBUTE_NODE:\n\t\tdeep = true;\n\t}\n\tif(deep){\n\t\tvar child = node.firstChild;\n\t\twhile(child){\n\t\t\tnode2.appendChild(cloneNode(doc,child,deep));\n\t\t\tchild = child.nextSibling;\n\t\t}\n\t}\n\treturn node2;\n}\n\nfunction __set__(object,key,value){\n\tobject[key] = value\n}\n//do dynamic\ntry{\n\tif(Object.defineProperty){\n\t\tObject.defineProperty(LiveNodeList.prototype,'length',{\n\t\t\tget:function(){\n\t\t\t\t_updateLiveList(this);\n\t\t\t\treturn this.$$length;\n\t\t\t}\n\t\t});\n\t\tObject.defineProperty(Node.prototype,'textContent',{\n\t\t\tget:function(){\n\t\t\t\treturn getTextContent(this);\n\t\t\t},\n\t\t\tset:function(data){\n\t\t\t\tswitch(this.nodeType){\n\t\t\t\tcase ELEMENT_NODE:\n\t\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\t\t\twhile(this.firstChild){\n\t\t\t\t\t\tthis.removeChild(this.firstChild);\n\t\t\t\t\t}\n\t\t\t\t\tif(data || String(data)){\n\t\t\t\t\t\tthis.appendChild(this.ownerDocument.createTextNode(data));\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\t//TODO:\n\t\t\t\t\tthis.data = data;\n\t\t\t\t\tthis.value = data;\n\t\t\t\t\tthis.nodeValue = data;\n\t\t\t\t}\n\t\t\t}\n\t\t})\n\t\t\n\t\tfunction getTextContent(node){\n\t\t\tswitch(node.nodeType){\n\t\t\tcase ELEMENT_NODE:\n\t\t\tcase DOCUMENT_FRAGMENT_NODE:\n\t\t\t\tvar buf = [];\n\t\t\t\tnode = node.firstChild;\n\t\t\t\twhile(node){\n\t\t\t\t\tif(node.nodeType!==7 && node.nodeType !==8){\n\t\t\t\t\t\tbuf.push(getTextContent(node));\n\t\t\t\t\t}\n\t\t\t\t\tnode = node.nextSibling;\n\t\t\t\t}\n\t\t\t\treturn buf.join('');\n\t\t\tdefault:\n\t\t\t\treturn node.nodeValue;\n\t\t\t}\n\t\t}\n\t\t__set__ = function(object,key,value){\n\t\t\t//console.log(value)\n\t\t\tobject['$$'+key] = value\n\t\t}\n\t}\n}catch(e){//ie8\n}\n\n//if(typeof require == 'function'){\n\texports.DOMImplementation = DOMImplementation;\n\texports.XMLSerializer = XMLSerializer;\n//}\n","//[4]   \tNameStartChar\t   ::=   \t\":\" | [A-Z] | \"_\" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]\r\n//[4a]   \tNameChar\t   ::=   \tNameStartChar | \"-\" | \".\" | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]\r\n//[5]   \tName\t   ::=   \tNameStartChar (NameChar)*\r\nvar nameStartChar = /[A-Z_a-z\\xC0-\\xD6\\xD8-\\xF6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD]///\\u10000-\\uEFFFF\r\nvar nameChar = new RegExp(\"[\\\\-\\\\.0-9\"+nameStartChar.source.slice(1,-1)+\"\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040]\");\r\nvar tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\\:'+nameStartChar.source+nameChar.source+'*)?$');\r\n//var tagNamePattern = /^[a-zA-Z_][\\w\\-\\.]*(?:\\:[a-zA-Z_][\\w\\-\\.]*)?$/\r\n//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')\r\n\r\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\r\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\r\nvar S_TAG = 0;//tag name offerring\r\nvar S_ATTR = 1;//attr name offerring \r\nvar S_ATTR_SPACE=2;//attr name end and space offer\r\nvar S_EQ = 3;//=space?\r\nvar S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)\r\nvar S_ATTR_END = 5;//attr value end and no space(quot end)\r\nvar S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)\r\nvar S_TAG_CLOSE = 7;//closed el<el />\r\n\r\nfunction XMLReader(){\r\n\t\r\n}\r\n\r\nXMLReader.prototype = {\r\n\tparse:function(source,defaultNSMap,entityMap){\r\n\t\tvar domBuilder = this.domBuilder;\r\n\t\tdomBuilder.startDocument();\r\n\t\t_copy(defaultNSMap ,defaultNSMap = {})\r\n\t\tparse(source,defaultNSMap,entityMap,\r\n\t\t\t\tdomBuilder,this.errorHandler);\r\n\t\tdomBuilder.endDocument();\r\n\t}\r\n}\r\nfunction parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){\r\n\tfunction fixedFromCharCode(code) {\r\n\t\t// String.prototype.fromCharCode does not supports\r\n\t\t// > 2 bytes unicode chars directly\r\n\t\tif (code > 0xffff) {\r\n\t\t\tcode -= 0x10000;\r\n\t\t\tvar surrogate1 = 0xd800 + (code >> 10)\r\n\t\t\t\t, surrogate2 = 0xdc00 + (code & 0x3ff);\r\n\r\n\t\t\treturn String.fromCharCode(surrogate1, surrogate2);\r\n\t\t} else {\r\n\t\t\treturn String.fromCharCode(code);\r\n\t\t}\r\n\t}\r\n\tfunction entityReplacer(a){\r\n\t\tvar k = a.slice(1,-1);\r\n\t\tif(k in entityMap){\r\n\t\t\treturn entityMap[k]; \r\n\t\t}else if(k.charAt(0) === '#'){\r\n\t\t\treturn fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))\r\n\t\t}else{\r\n\t\t\terrorHandler.error('entity not found:'+a);\r\n\t\t\treturn a;\r\n\t\t}\r\n\t}\r\n\tfunction appendText(end){//has some bugs\r\n\t\tif(end>start){\r\n\t\t\tvar xt = source.substring(start,end).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\tlocator&&position(start);\r\n\t\t\tdomBuilder.characters(xt,0,end-start);\r\n\t\t\tstart = end\r\n\t\t}\r\n\t}\r\n\tfunction position(p,m){\r\n\t\twhile(p>=lineEnd && (m = linePattern.exec(source))){\r\n\t\t\tlineStart = m.index;\r\n\t\t\tlineEnd = lineStart + m[0].length;\r\n\t\t\tlocator.lineNumber++;\r\n\t\t\t//console.log('line++:',locator,startPos,endPos)\r\n\t\t}\r\n\t\tlocator.columnNumber = p-lineStart+1;\r\n\t}\r\n\tvar lineStart = 0;\r\n\tvar lineEnd = 0;\r\n\tvar linePattern = /.*(?:\\r\\n?|\\n)|.*$/g\r\n\tvar locator = domBuilder.locator;\r\n\t\r\n\tvar parseStack = [{currentNSMap:defaultNSMapCopy}]\r\n\tvar closeMap = {};\r\n\tvar start = 0;\r\n\twhile(true){\r\n\t\ttry{\r\n\t\t\tvar tagStart = source.indexOf('<',start);\r\n\t\t\tif(tagStart<0){\r\n\t\t\t\tif(!source.substr(start).match(/^\\s*$/)){\r\n\t\t\t\t\tvar doc = domBuilder.doc;\r\n\t    \t\t\tvar text = doc.createTextNode(source.substr(start));\r\n\t    \t\t\tdoc.appendChild(text);\r\n\t    \t\t\tdomBuilder.currentElement = text;\r\n\t\t\t\t}\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif(tagStart>start){\r\n\t\t\t\tappendText(tagStart);\r\n\t\t\t}\r\n\t\t\tswitch(source.charAt(tagStart+1)){\r\n\t\t\tcase '/':\r\n\t\t\t\tvar end = source.indexOf('>',tagStart+3);\r\n\t\t\t\tvar tagName = source.substring(tagStart+2,end);\r\n\t\t\t\tvar config = parseStack.pop();\r\n\t\t\t\tif(end<0){\r\n\t\t\t\t\t\r\n\t        \t\ttagName = source.substring(tagStart+2).replace(/[\\s<].*/,'');\r\n\t        \t\t//console.error('#@@@@@@'+tagName)\r\n\t        \t\terrorHandler.error(\"end tag name: \"+tagName+' is not complete:'+config.tagName);\r\n\t        \t\tend = tagStart+1+tagName.length;\r\n\t        \t}else if(tagName.match(/\\s</)){\r\n\t        \t\ttagName = tagName.replace(/[\\s<].*/,'');\r\n\t        \t\terrorHandler.error(\"end tag name: \"+tagName+' maybe not complete');\r\n\t        \t\tend = tagStart+1+tagName.length;\r\n\t\t\t\t}\r\n\t\t\t\t//console.error(parseStack.length,parseStack)\r\n\t\t\t\t//console.error(config);\r\n\t\t\t\tvar localNSMap = config.localNSMap;\r\n\t\t\t\tvar endMatch = config.tagName == tagName;\r\n\t\t\t\tvar endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()\r\n\t\t        if(endIgnoreCaseMach){\r\n\t\t        \tdomBuilder.endElement(config.uri,config.localName,tagName);\r\n\t\t\t\t\tif(localNSMap){\r\n\t\t\t\t\t\tfor(var prefix in localNSMap){\r\n\t\t\t\t\t\t\tdomBuilder.endPrefixMapping(prefix) ;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif(!endMatch){\r\n\t\t            \terrorHandler.fatalError(\"end tag name: \"+tagName+' is not match the current start tagName:'+config.tagName );\r\n\t\t\t\t\t}\r\n\t\t        }else{\r\n\t\t        \tparseStack.push(config)\r\n\t\t        }\r\n\t\t\t\t\r\n\t\t\t\tend++;\r\n\t\t\t\tbreak;\r\n\t\t\t\t// end elment\r\n\t\t\tcase '?':// <?...?>\r\n\t\t\t\tlocator&&position(tagStart);\r\n\t\t\t\tend = parseInstruction(source,tagStart,domBuilder);\r\n\t\t\t\tbreak;\r\n\t\t\tcase '!':// <!doctype,<![CDATA,<!--\r\n\t\t\t\tlocator&&position(tagStart);\r\n\t\t\t\tend = parseDCC(source,tagStart,domBuilder,errorHandler);\r\n\t\t\t\tbreak;\r\n\t\t\tdefault:\r\n\t\t\t\tlocator&&position(tagStart);\r\n\t\t\t\tvar el = new ElementAttributes();\r\n\t\t\t\tvar currentNSMap = parseStack[parseStack.length-1].currentNSMap;\r\n\t\t\t\t//elStartEnd\r\n\t\t\t\tvar end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);\r\n\t\t\t\tvar len = el.length;\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){\r\n\t\t\t\t\tel.closed = true;\r\n\t\t\t\t\tif(!entityMap.nbsp){\r\n\t\t\t\t\t\terrorHandler.warning('unclosed xml attribute');\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif(locator && len){\r\n\t\t\t\t\tvar locator2 = copyLocator(locator,{});\r\n\t\t\t\t\t//try{//attribute position fixed\r\n\t\t\t\t\tfor(var i = 0;i<len;i++){\r\n\t\t\t\t\t\tvar a = el[i];\r\n\t\t\t\t\t\tposition(a.offset);\r\n\t\t\t\t\t\ta.locator = copyLocator(locator,{});\r\n\t\t\t\t\t}\r\n\t\t\t\t\t//}catch(e){console.error('@@@@@'+e)}\r\n\t\t\t\t\tdomBuilder.locator = locator2\r\n\t\t\t\t\tif(appendElement(el,domBuilder,currentNSMap)){\r\n\t\t\t\t\t\tparseStack.push(el)\r\n\t\t\t\t\t}\r\n\t\t\t\t\tdomBuilder.locator = locator;\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(appendElement(el,domBuilder,currentNSMap)){\r\n\t\t\t\t\t\tparseStack.push(el)\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\t\r\n\t\t\t\tif(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){\r\n\t\t\t\t\tend = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tend++;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}catch(e){\r\n\t\t\terrorHandler.error('element parse error: '+e)\r\n\t\t\t//errorHandler.error('element parse error: '+e);\r\n\t\t\tend = -1;\r\n\t\t\t//throw e;\r\n\t\t}\r\n\t\tif(end>start){\r\n\t\t\tstart = end;\r\n\t\t}else{\r\n\t\t\t//TODO: 这里有可能sax回退，有位置错误风险\r\n\t\t\tappendText(Math.max(tagStart,start)+1);\r\n\t\t}\r\n\t}\r\n}\r\nfunction copyLocator(f,t){\r\n\tt.lineNumber = f.lineNumber;\r\n\tt.columnNumber = f.columnNumber;\r\n\treturn t;\r\n}\r\n\r\n/**\r\n * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);\r\n * @return end of the elementStartPart(end of elementEndPart for selfClosed el)\r\n */\r\nfunction parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){\r\n\tvar attrName;\r\n\tvar value;\r\n\tvar p = ++start;\r\n\tvar s = S_TAG;//status\r\n\twhile(true){\r\n\t\tvar c = source.charAt(p);\r\n\t\tswitch(c){\r\n\t\tcase '=':\r\n\t\t\tif(s === S_ATTR){//attrName\r\n\t\t\t\tattrName = source.slice(start,p);\r\n\t\t\t\ts = S_EQ;\r\n\t\t\t}else if(s === S_ATTR_SPACE){\r\n\t\t\t\ts = S_EQ;\r\n\t\t\t}else{\r\n\t\t\t\t//fatalError: equal must after attrName or space after attrName\r\n\t\t\t\tthrow new Error('attribute equal must after attrName');\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase '\\'':\r\n\t\tcase '\"':\r\n\t\t\tif(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE\r\n\t\t\t\t){//equal\r\n\t\t\t\tif(s === S_ATTR){\r\n\t\t\t\t\terrorHandler.warning('attribute value must after \"=\"')\r\n\t\t\t\t\tattrName = source.slice(start,p)\r\n\t\t\t\t}\r\n\t\t\t\tstart = p+1;\r\n\t\t\t\tp = source.indexOf(c,start)\r\n\t\t\t\tif(p>0){\r\n\t\t\t\t\tvalue = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\t\tel.add(attrName,value,start-1);\r\n\t\t\t\t\ts = S_ATTR_END;\r\n\t\t\t\t}else{\r\n\t\t\t\t\t//fatalError: no end quot match\r\n\t\t\t\t\tthrow new Error('attribute value no end \\''+c+'\\' match');\r\n\t\t\t\t}\r\n\t\t\t}else if(s == S_ATTR_NOQUOT_VALUE){\r\n\t\t\t\tvalue = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\t//console.log(attrName,value,start,p)\r\n\t\t\t\tel.add(attrName,value,start);\r\n\t\t\t\t//console.dir(el)\r\n\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed start quot('+c+')!!');\r\n\t\t\t\tstart = p+1;\r\n\t\t\t\ts = S_ATTR_END\r\n\t\t\t}else{\r\n\t\t\t\t//fatalError: no equal before\r\n\t\t\t\tthrow new Error('attribute value must after \"=\"');\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase '/':\r\n\t\t\tswitch(s){\r\n\t\t\tcase S_TAG:\r\n\t\t\t\tel.setTagName(source.slice(start,p));\r\n\t\t\tcase S_ATTR_END:\r\n\t\t\tcase S_TAG_SPACE:\r\n\t\t\tcase S_TAG_CLOSE:\r\n\t\t\t\ts =S_TAG_CLOSE;\r\n\t\t\t\tel.closed = true;\r\n\t\t\tcase S_ATTR_NOQUOT_VALUE:\r\n\t\t\tcase S_ATTR:\r\n\t\t\tcase S_ATTR_SPACE:\r\n\t\t\t\tbreak;\r\n\t\t\t//case S_EQ:\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(\"attribute invalid close char('/')\")\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase ''://end document\r\n\t\t\t//throw new Error('unexpected end of input')\r\n\t\t\terrorHandler.error('unexpected end of input');\r\n\t\t\tif(s == S_TAG){\r\n\t\t\t\tel.setTagName(source.slice(start,p));\r\n\t\t\t}\r\n\t\t\treturn p;\r\n\t\tcase '>':\r\n\t\t\tswitch(s){\r\n\t\t\tcase S_TAG:\r\n\t\t\t\tel.setTagName(source.slice(start,p));\r\n\t\t\tcase S_ATTR_END:\r\n\t\t\tcase S_TAG_SPACE:\r\n\t\t\tcase S_TAG_CLOSE:\r\n\t\t\t\tbreak;//normal\r\n\t\t\tcase S_ATTR_NOQUOT_VALUE://Compatible state\r\n\t\t\tcase S_ATTR:\r\n\t\t\t\tvalue = source.slice(start,p);\r\n\t\t\t\tif(value.slice(-1) === '/'){\r\n\t\t\t\t\tel.closed  = true;\r\n\t\t\t\t\tvalue = value.slice(0,-1)\r\n\t\t\t\t}\r\n\t\t\tcase S_ATTR_SPACE:\r\n\t\t\t\tif(s === S_ATTR_SPACE){\r\n\t\t\t\t\tvalue = attrName;\r\n\t\t\t\t}\r\n\t\t\t\tif(s == S_ATTR_NOQUOT_VALUE){\r\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!!');\r\n\t\t\t\t\tel.add(attrName,value.replace(/&#?\\w+;/g,entityReplacer),start)\r\n\t\t\t\t}else{\r\n\t\t\t\t\tif(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){\r\n\t\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed value!! \"'+value+'\" instead!!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tel.add(value,value,start)\r\n\t\t\t\t}\r\n\t\t\t\tbreak;\r\n\t\t\tcase S_EQ:\r\n\t\t\t\tthrow new Error('attribute value missed!!');\r\n\t\t\t}\r\n//\t\t\tconsole.log(tagName,tagNamePattern,tagNamePattern.test(tagName))\r\n\t\t\treturn p;\r\n\t\t/*xml space '\\x20' | #x9 | #xD | #xA; */\r\n\t\tcase '\\u0080':\r\n\t\t\tc = ' ';\r\n\t\tdefault:\r\n\t\t\tif(c<= ' '){//space\r\n\t\t\t\tswitch(s){\r\n\t\t\t\tcase S_TAG:\r\n\t\t\t\t\tel.setTagName(source.slice(start,p));//tagName\r\n\t\t\t\t\ts = S_TAG_SPACE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_ATTR:\r\n\t\t\t\t\tattrName = source.slice(start,p)\r\n\t\t\t\t\ts = S_ATTR_SPACE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_ATTR_NOQUOT_VALUE:\r\n\t\t\t\t\tvar value = source.slice(start,p).replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\t\terrorHandler.warning('attribute \"'+value+'\" missed quot(\")!!');\r\n\t\t\t\t\tel.add(attrName,value,start)\r\n\t\t\t\tcase S_ATTR_END:\r\n\t\t\t\t\ts = S_TAG_SPACE;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\t//case S_TAG_SPACE:\r\n\t\t\t\t//case S_EQ:\r\n\t\t\t\t//case S_ATTR_SPACE:\r\n\t\t\t\t//\tvoid();break;\r\n\t\t\t\t//case S_TAG_CLOSE:\r\n\t\t\t\t\t//ignore warning\r\n\t\t\t\t}\r\n\t\t\t}else{//not space\r\n//S_TAG,\tS_ATTR,\tS_EQ,\tS_ATTR_NOQUOT_VALUE\r\n//S_ATTR_SPACE,\tS_ATTR_END,\tS_TAG_SPACE, S_TAG_CLOSE\r\n\t\t\t\tswitch(s){\r\n\t\t\t\t//case S_TAG:void();break;\r\n\t\t\t\t//case S_ATTR:void();break;\r\n\t\t\t\t//case S_ATTR_NOQUOT_VALUE:void();break;\r\n\t\t\t\tcase S_ATTR_SPACE:\r\n\t\t\t\t\tvar tagName =  el.tagName;\r\n\t\t\t\t\tif(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){\r\n\t\t\t\t\t\terrorHandler.warning('attribute \"'+attrName+'\" missed value!! \"'+attrName+'\" instead2!!')\r\n\t\t\t\t\t}\r\n\t\t\t\t\tel.add(attrName,attrName,start);\r\n\t\t\t\t\tstart = p;\r\n\t\t\t\t\ts = S_ATTR;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_ATTR_END:\r\n\t\t\t\t\terrorHandler.warning('attribute space is required\"'+attrName+'\"!!')\r\n\t\t\t\tcase S_TAG_SPACE:\r\n\t\t\t\t\ts = S_ATTR;\r\n\t\t\t\t\tstart = p;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_EQ:\r\n\t\t\t\t\ts = S_ATTR_NOQUOT_VALUE;\r\n\t\t\t\t\tstart = p;\r\n\t\t\t\t\tbreak;\r\n\t\t\t\tcase S_TAG_CLOSE:\r\n\t\t\t\t\tthrow new Error(\"elements closed character '/' and '>' must be connected to\");\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}//end outer switch\r\n\t\t//console.log('p++',p)\r\n\t\tp++;\r\n\t}\r\n}\r\n/**\r\n * @return true if has new namespace define\r\n */\r\nfunction appendElement(el,domBuilder,currentNSMap){\r\n\tvar tagName = el.tagName;\r\n\tvar localNSMap = null;\r\n\t//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;\r\n\tvar i = el.length;\r\n\twhile(i--){\r\n\t\tvar a = el[i];\r\n\t\tvar qName = a.qName;\r\n\t\tvar value = a.value;\r\n\t\tvar nsp = qName.indexOf(':');\r\n\t\tif(nsp>0){\r\n\t\t\tvar prefix = a.prefix = qName.slice(0,nsp);\r\n\t\t\tvar localName = qName.slice(nsp+1);\r\n\t\t\tvar nsPrefix = prefix === 'xmlns' && localName\r\n\t\t}else{\r\n\t\t\tlocalName = qName;\r\n\t\t\tprefix = null\r\n\t\t\tnsPrefix = qName === 'xmlns' && ''\r\n\t\t}\r\n\t\t//can not set prefix,because prefix !== ''\r\n\t\ta.localName = localName ;\r\n\t\t//prefix == null for no ns prefix attribute \r\n\t\tif(nsPrefix !== false){//hack!!\r\n\t\t\tif(localNSMap == null){\r\n\t\t\t\tlocalNSMap = {}\r\n\t\t\t\t//console.log(currentNSMap,0)\r\n\t\t\t\t_copy(currentNSMap,currentNSMap={})\r\n\t\t\t\t//console.log(currentNSMap,1)\r\n\t\t\t}\r\n\t\t\tcurrentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;\r\n\t\t\ta.uri = 'http://www.w3.org/2000/xmlns/'\r\n\t\t\tdomBuilder.startPrefixMapping(nsPrefix, value) \r\n\t\t}\r\n\t}\r\n\tvar i = el.length;\r\n\twhile(i--){\r\n\t\ta = el[i];\r\n\t\tvar prefix = a.prefix;\r\n\t\tif(prefix){//no prefix attribute has no namespace\r\n\t\t\tif(prefix === 'xml'){\r\n\t\t\t\ta.uri = 'http://www.w3.org/XML/1998/namespace';\r\n\t\t\t}if(prefix !== 'xmlns'){\r\n\t\t\t\ta.uri = currentNSMap[prefix || '']\r\n\t\t\t\t\r\n\t\t\t\t//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tvar nsp = tagName.indexOf(':');\r\n\tif(nsp>0){\r\n\t\tprefix = el.prefix = tagName.slice(0,nsp);\r\n\t\tlocalName = el.localName = tagName.slice(nsp+1);\r\n\t}else{\r\n\t\tprefix = null;//important!!\r\n\t\tlocalName = el.localName = tagName;\r\n\t}\r\n\t//no prefix element has default namespace\r\n\tvar ns = el.uri = currentNSMap[prefix || ''];\r\n\tdomBuilder.startElement(ns,localName,tagName,el);\r\n\t//endPrefixMapping and startPrefixMapping have not any help for dom builder\r\n\t//localNSMap = null\r\n\tif(el.closed){\r\n\t\tdomBuilder.endElement(ns,localName,tagName);\r\n\t\tif(localNSMap){\r\n\t\t\tfor(prefix in localNSMap){\r\n\t\t\t\tdomBuilder.endPrefixMapping(prefix) \r\n\t\t\t}\r\n\t\t}\r\n\t}else{\r\n\t\tel.currentNSMap = currentNSMap;\r\n\t\tel.localNSMap = localNSMap;\r\n\t\t//parseStack.push(el);\r\n\t\treturn true;\r\n\t}\r\n}\r\nfunction parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){\r\n\tif(/^(?:script|textarea)$/i.test(tagName)){\r\n\t\tvar elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);\r\n\t\tvar text = source.substring(elStartEnd+1,elEndStart);\r\n\t\tif(/[&<]/.test(text)){\r\n\t\t\tif(/^script$/i.test(tagName)){\r\n\t\t\t\t//if(!/\\]\\]>/.test(text)){\r\n\t\t\t\t\t//lexHandler.startCDATA();\r\n\t\t\t\t\tdomBuilder.characters(text,0,text.length);\r\n\t\t\t\t\t//lexHandler.endCDATA();\r\n\t\t\t\t\treturn elEndStart;\r\n\t\t\t\t//}\r\n\t\t\t}//}else{//text area\r\n\t\t\t\ttext = text.replace(/&#?\\w+;/g,entityReplacer);\r\n\t\t\t\tdomBuilder.characters(text,0,text.length);\r\n\t\t\t\treturn elEndStart;\r\n\t\t\t//}\r\n\t\t\t\r\n\t\t}\r\n\t}\r\n\treturn elStartEnd+1;\r\n}\r\nfunction fixSelfClosed(source,elStartEnd,tagName,closeMap){\r\n\t//if(tagName in closeMap){\r\n\tvar pos = closeMap[tagName];\r\n\tif(pos == null){\r\n\t\t//console.log(tagName)\r\n\t\tpos =  source.lastIndexOf('</'+tagName+'>')\r\n\t\tif(pos<elStartEnd){//忘记闭合\r\n\t\t\tpos = source.lastIndexOf('</'+tagName)\r\n\t\t}\r\n\t\tcloseMap[tagName] =pos\r\n\t}\r\n\treturn pos<elStartEnd;\r\n\t//} \r\n}\r\nfunction _copy(source,target){\r\n\tfor(var n in source){target[n] = source[n]}\r\n}\r\nfunction parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'\r\n\tvar next= source.charAt(start+2)\r\n\tswitch(next){\r\n\tcase '-':\r\n\t\tif(source.charAt(start + 3) === '-'){\r\n\t\t\tvar end = source.indexOf('-->',start+4);\r\n\t\t\t//append comment source.substring(4,end)//<!--\r\n\t\t\tif(end>start){\r\n\t\t\t\tdomBuilder.comment(source,start+4,end-start-4);\r\n\t\t\t\treturn end+3;\r\n\t\t\t}else{\r\n\t\t\t\terrorHandler.error(\"Unclosed comment\");\r\n\t\t\t\treturn -1;\r\n\t\t\t}\r\n\t\t}else{\r\n\t\t\t//error\r\n\t\t\treturn -1;\r\n\t\t}\r\n\tdefault:\r\n\t\tif(source.substr(start+3,6) == 'CDATA['){\r\n\t\t\tvar end = source.indexOf(']]>',start+9);\r\n\t\t\tdomBuilder.startCDATA();\r\n\t\t\tdomBuilder.characters(source,start+9,end-start-9);\r\n\t\t\tdomBuilder.endCDATA() \r\n\t\t\treturn end+3;\r\n\t\t}\r\n\t\t//<!DOCTYPE\r\n\t\t//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) \r\n\t\tvar matchs = split(source,start);\r\n\t\tvar len = matchs.length;\r\n\t\tif(len>1 && /!doctype/i.test(matchs[0][0])){\r\n\t\t\tvar name = matchs[1][0];\r\n\t\t\tvar pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]\r\n\t\t\tvar sysid = len>4 && matchs[4][0];\r\n\t\t\tvar lastMatch = matchs[len-1]\r\n\t\t\tdomBuilder.startDTD(name,pubid && pubid.replace(/^(['\"])(.*?)\\1$/,'$2'),\r\n\t\t\t\t\tsysid && sysid.replace(/^(['\"])(.*?)\\1$/,'$2'));\r\n\t\t\tdomBuilder.endDTD();\r\n\t\t\t\r\n\t\t\treturn lastMatch.index+lastMatch[0].length\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n\r\n\r\nfunction parseInstruction(source,start,domBuilder){\r\n\tvar end = source.indexOf('?>',start);\r\n\tif(end){\r\n\t\tvar match = source.substring(start,end).match(/^<\\?(\\S*)\\s*([\\s\\S]*?)\\s*$/);\r\n\t\tif(match){\r\n\t\t\tvar len = match[0].length;\r\n\t\t\tdomBuilder.processingInstruction(match[1], match[2]) ;\r\n\t\t\treturn end+2;\r\n\t\t}else{//error\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\treturn -1;\r\n}\r\n\r\n/**\r\n * @param source\r\n */\r\nfunction ElementAttributes(source){\r\n\t\r\n}\r\nElementAttributes.prototype = {\r\n\tsetTagName:function(tagName){\r\n\t\tif(!tagNamePattern.test(tagName)){\r\n\t\t\tthrow new Error('invalid tagName:'+tagName)\r\n\t\t}\r\n\t\tthis.tagName = tagName\r\n\t},\r\n\tadd:function(qName,value,offset){\r\n\t\tif(!tagNamePattern.test(qName)){\r\n\t\t\tthrow new Error('invalid attribute:'+qName)\r\n\t\t}\r\n\t\tthis[this.length++] = {qName:qName,value:value,offset:offset}\r\n\t},\r\n\tlength:0,\r\n\tgetLocalName:function(i){return this[i].localName},\r\n\tgetLocator:function(i){return this[i].locator},\r\n\tgetQName:function(i){return this[i].qName},\r\n\tgetURI:function(i){return this[i].uri},\r\n\tgetValue:function(i){return this[i].value}\r\n//\t,getIndex:function(uri, localName)){\r\n//\t\tif(localName){\r\n//\t\t\t\r\n//\t\t}else{\r\n//\t\t\tvar qName = uri\r\n//\t\t}\r\n//\t},\r\n//\tgetValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},\r\n//\tgetType:function(uri,localName){}\r\n//\tgetType:function(i){},\r\n}\r\n\r\n\r\n\r\n\r\nfunction _set_proto_(thiz,parent){\r\n\tthiz.__proto__ = parent;\r\n\treturn thiz;\r\n}\r\nif(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){\r\n\t_set_proto_ = function(thiz,parent){\r\n\t\tfunction p(){};\r\n\t\tp.prototype = parent;\r\n\t\tp = new p();\r\n\t\tfor(parent in thiz){\r\n\t\t\tp[parent] = thiz[parent];\r\n\t\t}\r\n\t\treturn p;\r\n\t}\r\n}\r\n\r\nfunction split(source,start){\r\n\tvar match;\r\n\tvar buf = [];\r\n\tvar reg = /'[^']+'|\"[^\"]+\"|[^\\s<>\\/=]+=?|(\\/?\\s*>|<)/g;\r\n\treg.lastIndex = start;\r\n\treg.exec(source);//skip <\r\n\twhile(match = reg.exec(source)){\r\n\t\tbuf.push(match);\r\n\t\tif(match[1])return buf;\r\n\t}\r\n}\r\n\r\nexports.XMLReader = XMLReader;\r\n\r\n","/*\r\n * xpath.js\r\n *\r\n * An XPath 1.0 library for JavaScript.\r\n *\r\n * Cameron McCormack <cam (at) mcc.id.au>\r\n *\r\n * This work is licensed under the MIT License.\r\n *\r\n * Revision 20: April 26, 2011\r\n *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,\r\n *   thanks to <shi_a009 (at) hotmail.com>.\r\n *\r\n * Revision 19: November 29, 2005\r\n *   Nodesets now store their nodes in a height balanced tree, increasing\r\n *   performance for the common case of selecting nodes in document order,\r\n *   thanks to S閎astien Cramatte <contact (at) zeninteractif.com>.\r\n *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.\r\n *\r\n * Revision 18: October 27, 2005\r\n *   DOM 3 XPath support.  Caveats:\r\n *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,\r\n *       but in XPathExpression.evaluate.\r\n *     - XPathResult.invalidIteratorState is not implemented.\r\n *\r\n * Revision 17: October 25, 2005\r\n *   Some core XPath function fixes and a patch to avoid crashing certain\r\n *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to\r\n *   S閎astien Cramatte <contact (at) zeninteractif.com>.\r\n *\r\n * Revision 16: September 22, 2005\r\n *   Workarounds for some IE 5.5 deficiencies.\r\n *   Fixed problem with prefix node tests on attribute nodes.\r\n *\r\n * Revision 15: May 21, 2005\r\n *   Fixed problem with QName node tests on elements with an xmlns=\"...\".\r\n *\r\n * Revision 14: May 19, 2005\r\n *   Fixed QName node tests on attribute node regression.\r\n *\r\n * Revision 13: May 3, 2005\r\n *   Node tests are case insensitive now if working in an HTML DOM.\r\n *\r\n * Revision 12: April 26, 2005\r\n *   Updated licence.  Slight code changes to enable use of Dean\r\n *   Edwards' script compression, http://dean.edwards.name/packer/ .\r\n *\r\n * Revision 11: April 23, 2005\r\n *   Fixed bug with 'and' and 'or' operators, fix thanks to\r\n *   Sandy McArthur <sandy (at) mcarthur.org>.\r\n *\r\n * Revision 10: April 15, 2005\r\n *   Added support for a virtual root node, supposedly helpful for\r\n *   implementing XForms.  Fixed problem with QName node tests and\r\n *   the parent axis.\r\n *\r\n * Revision 9: March 17, 2005\r\n *   Namespace resolver tweaked so using the document node as the context\r\n *   for namespace lookups is equivalent to using the document element.\r\n *\r\n * Revision 8: February 13, 2005\r\n *   Handle implicit declaration of 'xmlns' namespace prefix.\r\n *   Fixed bug when comparing nodesets.\r\n *   Instance data can now be associated with a FunctionResolver, and\r\n *     workaround for MSXML not supporting 'localName' and 'getElementById',\r\n *     thanks to Grant Gongaware.\r\n *   Fix a few problems when the context node is the root node.\r\n *\r\n * Revision 7: February 11, 2005\r\n *   Default namespace resolver fix from Grant Gongaware\r\n *   <grant (at) gongaware.com>.\r\n *\r\n * Revision 6: February 10, 2005\r\n *   Fixed bug in 'number' function.\r\n *\r\n * Revision 5: February 9, 2005\r\n *   Fixed bug where text nodes not getting converted to string values.\r\n *\r\n * Revision 4: January 21, 2005\r\n *   Bug in 'name' function, fix thanks to Bill Edney.\r\n *   Fixed incorrect processing of namespace nodes.\r\n *   Fixed NamespaceResolver to resolve 'xml' namespace.\r\n *   Implemented union '|' operator.\r\n *\r\n * Revision 3: January 14, 2005\r\n *   Fixed bug with nodeset comparisons, bug lexing < and >.\r\n *\r\n * Revision 2: October 26, 2004\r\n *   QName node test namespace handling fixed.  Few other bug fixes.\r\n *\r\n * Revision 1: August 13, 2004\r\n *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.\r\n *   Added minimal licence.\r\n *\r\n * Initial version: June 14, 2004\r\n */\r\n\r\n// non-node wrapper\r\nvar xpath = (typeof exports === 'undefined') ? {} : exports;\r\n\r\n(function(exports) {\r\n\"use strict\";\r\n\r\n// functional helpers\r\nfunction curry( func ) {\r\n    var slice = Array.prototype.slice,\r\n        totalargs = func.length,\r\n        partial = function( args, fn ) {\r\n            return function( ) {\r\n                return fn.apply( this, args.concat( slice.call( arguments ) ) );\r\n            }\r\n        },\r\n        fn = function( ) {\r\n            var args = slice.call( arguments );\r\n            return ( args.length < totalargs ) ?\r\n                partial( args, fn ) :\r\n                func.apply( this, slice.apply( arguments, [ 0, totalargs ] ) );\r\n        };\r\n    return fn;\r\n}\r\n\r\nvar forEach = curry(function (f, xs) {\r\n\tfor (var i = 0; i < xs.length; i += 1) {\r\n\t\tf(xs[i], i, xs);\r\n\t}\r\n});\r\n\r\nvar reduce = curry(function (f, seed, xs) {\r\n\tvar acc = seed;\r\n\r\n\tforEach(function (x, i) { acc = f(acc, x, i); }, xs);\r\n\r\n\treturn acc;\r\n});\r\n\r\nvar map = curry(function (f, xs) { \r\n\tvar mapped = new Array(xs.length);\r\n\t\r\n\tforEach(function (x, i) { mapped[i] = f(x); }, xs);\r\n\r\n\treturn mapped;\r\n});\r\n\r\nvar filter = curry(function (f, xs) {\r\n\tvar filtered = [];\r\n\t\r\n\tforEach(function (x, i) { if(f(x, i)) { filtered.push(x); } }, xs);\r\n\t\r\n\treturn filtered;\r\n});\r\n\r\nfunction compose() {\r\n    if (arguments.length === 0) { throw new Error('compose requires at least one argument'); }\r\n\r\n    var funcs = Array.prototype.slice.call(arguments).reverse();\r\n\t\r\n    var f0 = funcs[0];\r\n    var fRem = funcs.slice(1);\r\n\r\n    return function () {\r\n        return reduce(function (acc, next) {\r\n            return next(acc);\r\n        }, f0.apply(null, arguments), fRem);\r\n    };\r\n}\r\n\r\nvar includes = curry(function (values, value) {\r\n\tfor (var i = 0; i < values.length; i += 1) {\r\n\t\tif (values[i] === value){\r\n\t\t\treturn true;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn false;\r\n});\r\n\r\nfunction always(value) { return function () { return value ;} }\r\n\r\nvar prop = curry(function (name, obj) { return obj[name]; });\r\n\r\nfunction toString (x) { return x.toString(); }\r\nvar join = curry(function (s, xs) { return xs.join(s); });\r\nvar wrap = curry(function (pref, suf, str) { return pref + str + suf; });\r\n\r\nfunction assign(target) { // .length of function is 2\r\n    var to = Object(target);\r\n\r\n    for (var index = 1; index < arguments.length; index++) {\r\n        var nextSource = arguments[index];\r\n\r\n        if (nextSource != null) { // Skip over if undefined or null\r\n            for (var nextKey in nextSource) {\r\n                // Avoid bugs when hasOwnProperty is shadowed\r\n                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {\r\n                    to[nextKey] = nextSource[nextKey];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return to;\r\n}\r\n\r\n// XPathParser ///////////////////////////////////////////////////////////////\r\n\r\nXPathParser.prototype = new Object();\r\nXPathParser.prototype.constructor = XPathParser;\r\nXPathParser.superclass = Object.prototype;\r\n\r\nfunction XPathParser() {\r\n\tthis.init();\r\n}\r\n\r\nXPathParser.prototype.init = function() {\r\n\tthis.reduceActions = [];\r\n\r\n\tthis.reduceActions[3] = function(rhs) {\r\n\t\treturn new OrOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[5] = function(rhs) {\r\n\t\treturn new AndOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[7] = function(rhs) {\r\n\t\treturn new EqualsOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[8] = function(rhs) {\r\n\t\treturn new NotEqualOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[10] = function(rhs) {\r\n\t\treturn new LessThanOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[11] = function(rhs) {\r\n\t\treturn new GreaterThanOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[12] = function(rhs) {\r\n\t\treturn new LessThanOrEqualOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[13] = function(rhs) {\r\n\t\treturn new GreaterThanOrEqualOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[15] = function(rhs) {\r\n\t\treturn new PlusOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[16] = function(rhs) {\r\n\t\treturn new MinusOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[18] = function(rhs) {\r\n\t\treturn new MultiplyOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[19] = function(rhs) {\r\n\t\treturn new DivOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[20] = function(rhs) {\r\n\t\treturn new ModOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[22] = function(rhs) {\r\n\t\treturn new UnaryMinusOperation(rhs[1]);\r\n\t};\r\n\tthis.reduceActions[24] = function(rhs) {\r\n\t\treturn new BarOperation(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[25] = function(rhs) {\r\n\t\treturn new PathExpr(undefined, undefined, rhs[0]);\r\n\t};\r\n\tthis.reduceActions[27] = function(rhs) {\r\n\t\trhs[0].locationPath = rhs[2];\r\n\t\treturn rhs[0];\r\n\t};\r\n\tthis.reduceActions[28] = function(rhs) {\r\n\t\trhs[0].locationPath = rhs[2];\r\n\t\trhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));\r\n\t\treturn rhs[0];\r\n\t};\r\n\tthis.reduceActions[29] = function(rhs) {\r\n\t\treturn new PathExpr(rhs[0], [], undefined);\r\n\t};\r\n\tthis.reduceActions[30] = function(rhs) {\r\n\t\tif (Utilities.instance_of(rhs[0], PathExpr)) {\r\n\t\t\tif (rhs[0].filterPredicates == undefined) {\r\n\t\t\t\trhs[0].filterPredicates = [];\r\n\t\t\t}\r\n\t\t\trhs[0].filterPredicates.push(rhs[1]);\r\n\t\t\treturn rhs[0];\r\n\t\t} else {\r\n\t\t\treturn new PathExpr(rhs[0], [rhs[1]], undefined);\r\n\t\t}\r\n\t};\r\n\tthis.reduceActions[32] = function(rhs) {\r\n\t\treturn rhs[1];\r\n\t};\r\n\tthis.reduceActions[33] = function(rhs) {\r\n\t\treturn new XString(rhs[0]);\r\n\t};\r\n\tthis.reduceActions[34] = function(rhs) {\r\n\t\treturn new XNumber(rhs[0]);\r\n\t};\r\n\tthis.reduceActions[36] = function(rhs) {\r\n\t\treturn new FunctionCall(rhs[0], []);\r\n\t};\r\n\tthis.reduceActions[37] = function(rhs) {\r\n\t\treturn new FunctionCall(rhs[0], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[38] = function(rhs) {\r\n\t\treturn [ rhs[0] ];\r\n\t};\r\n\tthis.reduceActions[39] = function(rhs) {\r\n\t\trhs[2].unshift(rhs[0]);\r\n\t\treturn rhs[2];\r\n\t};\r\n\tthis.reduceActions[43] = function(rhs) {\r\n\t\treturn new LocationPath(true, []);\r\n\t};\r\n\tthis.reduceActions[44] = function(rhs) {\r\n\t\trhs[1].absolute = true;\r\n\t\treturn rhs[1];\r\n\t};\r\n\tthis.reduceActions[46] = function(rhs) {\r\n\t\treturn new LocationPath(false, [ rhs[0] ]);\r\n\t};\r\n\tthis.reduceActions[47] = function(rhs) {\r\n\t\trhs[0].steps.push(rhs[2]);\r\n\t\treturn rhs[0];\r\n\t};\r\n\tthis.reduceActions[49] = function(rhs) {\r\n\t\treturn new Step(rhs[0], rhs[1], []);\r\n\t};\r\n\tthis.reduceActions[50] = function(rhs) {\r\n\t\treturn new Step(Step.CHILD, rhs[0], []);\r\n\t};\r\n\tthis.reduceActions[51] = function(rhs) {\r\n\t\treturn new Step(rhs[0], rhs[1], rhs[2]);\r\n\t};\r\n\tthis.reduceActions[52] = function(rhs) {\r\n\t\treturn new Step(Step.CHILD, rhs[0], rhs[1]);\r\n\t};\r\n\tthis.reduceActions[54] = function(rhs) {\r\n\t\treturn [ rhs[0] ];\r\n\t};\r\n\tthis.reduceActions[55] = function(rhs) {\r\n\t\trhs[1].unshift(rhs[0]);\r\n\t\treturn rhs[1];\r\n\t};\r\n\tthis.reduceActions[56] = function(rhs) {\r\n\t\tif (rhs[0] == \"ancestor\") {\r\n\t\t\treturn Step.ANCESTOR;\r\n\t\t} else if (rhs[0] == \"ancestor-or-self\") {\r\n\t\t\treturn Step.ANCESTORORSELF;\r\n\t\t} else if (rhs[0] == \"attribute\") {\r\n\t\t\treturn Step.ATTRIBUTE;\r\n\t\t} else if (rhs[0] == \"child\") {\r\n\t\t\treturn Step.CHILD;\r\n\t\t} else if (rhs[0] == \"descendant\") {\r\n\t\t\treturn Step.DESCENDANT;\r\n\t\t} else if (rhs[0] == \"descendant-or-self\") {\r\n\t\t\treturn Step.DESCENDANTORSELF;\r\n\t\t} else if (rhs[0] == \"following\") {\r\n\t\t\treturn Step.FOLLOWING;\r\n\t\t} else if (rhs[0] == \"following-sibling\") {\r\n\t\t\treturn Step.FOLLOWINGSIBLING;\r\n\t\t} else if (rhs[0] == \"namespace\") {\r\n\t\t\treturn Step.NAMESPACE;\r\n\t\t} else if (rhs[0] == \"parent\") {\r\n\t\t\treturn Step.PARENT;\r\n\t\t} else if (rhs[0] == \"preceding\") {\r\n\t\t\treturn Step.PRECEDING;\r\n\t\t} else if (rhs[0] == \"preceding-sibling\") {\r\n\t\t\treturn Step.PRECEDINGSIBLING;\r\n\t\t} else if (rhs[0] == \"self\") {\r\n\t\t\treturn Step.SELF;\r\n\t\t}\r\n\t\treturn -1;\r\n\t};\r\n\tthis.reduceActions[57] = function(rhs) {\r\n\t\treturn Step.ATTRIBUTE;\r\n\t};\r\n\tthis.reduceActions[59] = function(rhs) {\r\n\t\tif (rhs[0] == \"comment\") {\r\n\t\t\treturn NodeTest.commentTest;\r\n\t\t} else if (rhs[0] == \"text\") {\r\n\t\t\treturn NodeTest.textTest;\r\n\t\t} else if (rhs[0] == \"processing-instruction\") {\r\n\t\t\treturn NodeTest.anyPiTest;\r\n\t\t} else if (rhs[0] == \"node\") {\r\n\t\t\treturn NodeTest.nodeTest;\r\n\t\t}\r\n\t\treturn new NodeTest(-1, undefined);\r\n\t};\r\n\tthis.reduceActions[60] = function(rhs) {\r\n\t\treturn new NodeTest.PITest(rhs[2]);\r\n\t};\r\n\tthis.reduceActions[61] = function(rhs) {\r\n\t\treturn rhs[1];\r\n\t};\r\n\tthis.reduceActions[63] = function(rhs) {\r\n\t\trhs[1].absolute = true;\r\n\t\trhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));\r\n\t\treturn rhs[1];\r\n\t};\r\n\tthis.reduceActions[64] = function(rhs) {\r\n\t\trhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));\r\n\t\trhs[0].steps.push(rhs[2]);\r\n\t\treturn rhs[0];\r\n\t};\r\n\tthis.reduceActions[65] = function(rhs) {\r\n\t\treturn new Step(Step.SELF, NodeTest.nodeTest, []);\r\n\t};\r\n\tthis.reduceActions[66] = function(rhs) {\r\n\t\treturn new Step(Step.PARENT, NodeTest.nodeTest, []);\r\n\t};\r\n\tthis.reduceActions[67] = function(rhs) {\r\n\t\treturn new VariableReference(rhs[1]);\r\n\t};\r\n\tthis.reduceActions[68] = function(rhs) {\r\n\t\treturn NodeTest.nameTestAny;\r\n\t};\r\n\tthis.reduceActions[69] = function(rhs) {\r\n\t\treturn new NodeTest.NameTestPrefixAny(rhs[0].split(':')[0]);\r\n\t};\r\n\tthis.reduceActions[70] = function(rhs) {\r\n\t\treturn new NodeTest.NameTestQName(rhs[0]);\r\n\t};\r\n};\r\n\r\nXPathParser.actionTable = [\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\"                 s                  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"                rrrrr               \",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\"rs  rrrrrrrr s  sssssrrrrrr  rrs rs \",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\"                            s       \",\r\n\t\"                            s       \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"  s                                 \",\r\n\t\"                            s       \",\r\n\t\" s           s  sssss          s  s \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"a                                   \",\r\n\t\"r       s                    rr  r  \",\r\n\t\"r      sr                    rr  r  \",\r\n\t\"r   s  rr            s       rr  r  \",\r\n\t\"r   rssrr            rss     rr  r  \",\r\n\t\"r   rrrrr            rrrss   rr  r  \",\r\n\t\"r   rrrrrsss         rrrrr   rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrr   rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrrs  rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrrr  rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrrr  rr  r  \",\r\n\t\"r  srrrrrrrr         rrrrrrs rr sr  \",\r\n\t\"r  srrrrrrrr         rrrrrrs rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r   rrrrrrrr         rrrrrr  rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrrr  rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"                sssss               \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr sr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"                             s      \",\r\n\t\"r  srrrrrrrr         rrrrrrs rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrr   rr  r  \",\r\n\t\"              s                     \",\r\n\t\"                             s      \",\r\n\t\"                rrrrr               \",\r\n\t\" s s        sssssssss    s sss s  ss\",\r\n\t\"r  srrrrrrrr         rrrrrrs rr  r  \",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s s        sssssssss      ss  s  ss\",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\" s           s  sssss          s  s \",\r\n\t\" s           s  sssss          s  s \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\" s           s  sssss          s  s \",\r\n\t\" s           s  sssss          s  s \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr sr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr sr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"                             s      \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"                             rr     \",\r\n\t\"                             s      \",\r\n\t\"                             rs     \",\r\n\t\"r      sr                    rr  r  \",\r\n\t\"r   s  rr            s       rr  r  \",\r\n\t\"r   rssrr            rss     rr  r  \",\r\n\t\"r   rssrr            rss     rr  r  \",\r\n\t\"r   rrrrr            rrrss   rr  r  \",\r\n\t\"r   rrrrr            rrrss   rr  r  \",\r\n\t\"r   rrrrr            rrrss   rr  r  \",\r\n\t\"r   rrrrr            rrrss   rr  r  \",\r\n\t\"r   rrrrrsss         rrrrr   rr  r  \",\r\n\t\"r   rrrrrsss         rrrrr   rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrr   rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrr   rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrr   rr  r  \",\r\n\t\"r   rrrrrrrr         rrrrrr  rr  r  \",\r\n\t\"                                 r  \",\r\n\t\"                                 s  \",\r\n\t\"r  srrrrrrrr         rrrrrrs rr  r  \",\r\n\t\"r  srrrrrrrr         rrrrrrs rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr  r  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\" s s        sssssssss    s ss  s  ss\",\r\n\t\"r  rrrrrrrrr         rrrrrrr rr rr  \",\r\n\t\"                             r      \"\r\n];\r\n\r\nXPathParser.actionTableNumber = [\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\"                 J                  \",\r\n\t\"a  aaaaaaaaa         aaaaaaa aa  a  \",\r\n\t\"                YYYYY               \",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\\\" \",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\"                            N       \",\r\n\t\"                            O       \",\r\n\t\"e  eeeeeeeee         eeeeeee ee ee  \",\r\n\t\"f  fffffffff         fffffff ff ff  \",\r\n\t\"d  ddddddddd         ddddddd dd dd  \",\r\n\t\"B  BBBBBBBBB         BBBBBBB BB BB  \",\r\n\t\"A  AAAAAAAAA         AAAAAAA AA AA  \",\r\n\t\"  P                                 \",\r\n\t\"                            Q       \",\r\n\t\" 1           .  +*)('          #  \\\" \",\r\n\t\"b  bbbbbbbbb         bbbbbbb bb  b  \",\r\n\t\"                                    \",\r\n\t\"!       S                    !!  !  \",\r\n\t\"\\\"      T\\\"                    \\\"\\\"  \\\"  \",\r\n\t\"$   V  $$            U       $$  $  \",\r\n\t\"&   &ZY&&            &XW     &&  &  \",\r\n\t\")   )))))            )))\\\\[   ))  )  \",\r\n\t\".   ....._^]         .....   ..  .  \",\r\n\t\"1   11111111         11111   11  1  \",\r\n\t\"5   55555555         55555`  55  5  \",\r\n\t\"7   77777777         777777  77  7  \",\r\n\t\"9   99999999         999999  99  9  \",\r\n\t\":  c::::::::         ::::::b :: a:  \",\r\n\t\"I  fIIIIIIII         IIIIIIe II  I  \",\r\n\t\"=  =========         ======= == ==  \",\r\n\t\"?  ?????????         ??????? ?? ??  \",\r\n\t\"C  CCCCCCCCC         CCCCCCC CC CC  \",\r\n\t\"J   JJJJJJJJ         JJJJJJ  JJ  J  \",\r\n\t\"M   MMMMMMMM         MMMMMM  MM  M  \",\r\n\t\"N  NNNNNNNNN         NNNNNNN NN  N  \",\r\n\t\"P  PPPPPPPPP         PPPPPPP PP  P  \",\r\n\t\"                +*)('               \",\r\n\t\"R  RRRRRRRRR         RRRRRRR RR aR  \",\r\n\t\"U  UUUUUUUUU         UUUUUUU UU  U  \",\r\n\t\"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  \",\r\n\t\"c  ccccccccc         ccccccc cc cc  \",\r\n\t\"                             j      \",\r\n\t\"L  fLLLLLLLL         LLLLLLe LL  L  \",\r\n\t\"6   66666666         66666   66  6  \",\r\n\t\"              k                     \",\r\n\t\"                             l      \",\r\n\t\"                XXXXX               \",\r\n\t\" 1 0        /.-,+*)('    & %$m #  \\\"!\",\r\n\t\"_  f________         ______e __  _  \",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('      %$  #  \\\"!\",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\" 1           .  +*)('          #  \\\" \",\r\n\t\" 1           .  +*)('          #  \\\" \",\r\n\t\">  >>>>>>>>>         >>>>>>> >> >>  \",\r\n\t\" 1           .  +*)('          #  \\\" \",\r\n\t\" 1           .  +*)('          #  \\\" \",\r\n\t\"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  \",\r\n\t\"V  VVVVVVVVV         VVVVVVV VV aV  \",\r\n\t\"T  TTTTTTTTT         TTTTTTT TT  T  \",\r\n\t\"@  @@@@@@@@@         @@@@@@@ @@ @@  \",\r\n\t\"                             \\x87      \",\r\n\t\"[  [[[[[[[[[         [[[[[[[ [[ [[  \",\r\n\t\"D  DDDDDDDDD         DDDDDDD DD DD  \",\r\n\t\"                             HH     \",\r\n\t\"                             \\x88      \",\r\n\t\"                             F\\x89     \",\r\n\t\"#      T#                    ##  #  \",\r\n\t\"%   V  %%            U       %%  %  \",\r\n\t\"'   'ZY''            'XW     ''  '  \",\r\n\t\"(   (ZY((            (XW     ((  (  \",\r\n\t\"+   +++++            +++\\\\[   ++  +  \",\r\n\t\"*   *****            ***\\\\[   **  *  \",\r\n\t\"-   -----            ---\\\\[   --  -  \",\r\n\t\",   ,,,,,            ,,,\\\\[   ,,  ,  \",\r\n\t\"0   00000_^]         00000   00  0  \",\r\n\t\"/   /////_^]         /////   //  /  \",\r\n\t\"2   22222222         22222   22  2  \",\r\n\t\"3   33333333         33333   33  3  \",\r\n\t\"4   44444444         44444   44  4  \",\r\n\t\"8   88888888         888888  88  8  \",\r\n\t\"                                 ^  \",\r\n\t\"                                 \\x8a  \",\r\n\t\";  f;;;;;;;;         ;;;;;;e ;;  ;  \",\r\n\t\"<  f<<<<<<<<         <<<<<<e <<  <  \",\r\n\t\"O  OOOOOOOOO         OOOOOOO OO  O  \",\r\n\t\"`  `````````         ``````` ``  `  \",\r\n\t\"S  SSSSSSSSS         SSSSSSS SS  S  \",\r\n\t\"W  WWWWWWWWW         WWWWWWW WW  W  \",\r\n\t\"\\\\  \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\\\\\\\\\\\\\\\ \\\\\\\\ \\\\\\\\  \",\r\n\t\"E  EEEEEEEEE         EEEEEEE EE EE  \",\r\n\t\" 1 0        /.-,+*)('    & %$  #  \\\"!\",\r\n\t\"]  ]]]]]]]]]         ]]]]]]] ]] ]]  \",\r\n\t\"                             G      \"\r\n];\r\n\r\nXPathParser.gotoTable = [\r\n\t\"3456789:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"L456789:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"            M        EFGH IJ \",\r\n\t\"       N;<=>?@ AB  CDEFGH IJ \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"            S        EFGH IJ \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"              e              \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                        h  J \",\r\n\t\"              i          j   \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"o456789:;<=>?@ ABpqCDEFGH IJ \",\r\n\t\"                             \",\r\n\t\"  r6789:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"   s789:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"    t89:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"    u89:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"     v9:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"     w9:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"     x9:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"     y9:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"      z:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"      {:;<=>?@ AB  CDEFGH IJ \",\r\n\t\"       |;<=>?@ AB  CDEFGH IJ \",\r\n\t\"       };<=>?@ AB  CDEFGH IJ \",\r\n\t\"       ~;<=>?@ AB  CDEFGH IJ \",\r\n\t\"         \\x7f=>?@ AB  CDEFGH IJ \",\r\n\t\"\\x80456789:;<=>?@ AB  CDEFGH IJ\\x81\",\r\n\t\"            \\x82        EFGH IJ \",\r\n\t\"            \\x83        EFGH IJ \",\r\n\t\"                             \",\r\n\t\"                     \\x84 GH IJ \",\r\n\t\"                     \\x85 GH IJ \",\r\n\t\"              i          \\x86   \",\r\n\t\"              i          \\x87   \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"                             \",\r\n\t\"o456789:;<=>?@ AB\\x8cqCDEFGH IJ \",\r\n\t\"                             \",\r\n\t\"                             \"\r\n];\r\n\r\nXPathParser.productions = [\r\n\t[1, 1, 2],\r\n\t[2, 1, 3],\r\n\t[3, 1, 4],\r\n\t[3, 3, 3, -9, 4],\r\n\t[4, 1, 5],\r\n\t[4, 3, 4, -8, 5],\r\n\t[5, 1, 6],\r\n\t[5, 3, 5, -22, 6],\r\n\t[5, 3, 5, -5, 6],\r\n\t[6, 1, 7],\r\n\t[6, 3, 6, -23, 7],\r\n\t[6, 3, 6, -24, 7],\r\n\t[6, 3, 6, -6, 7],\r\n\t[6, 3, 6, -7, 7],\r\n\t[7, 1, 8],\r\n\t[7, 3, 7, -25, 8],\r\n\t[7, 3, 7, -26, 8],\r\n\t[8, 1, 9],\r\n\t[8, 3, 8, -12, 9],\r\n\t[8, 3, 8, -11, 9],\r\n\t[8, 3, 8, -10, 9],\r\n\t[9, 1, 10],\r\n\t[9, 2, -26, 9],\r\n\t[10, 1, 11],\r\n\t[10, 3, 10, -27, 11],\r\n\t[11, 1, 12],\r\n\t[11, 1, 13],\r\n\t[11, 3, 13, -28, 14],\r\n\t[11, 3, 13, -4, 14],\r\n\t[13, 1, 15],\r\n\t[13, 2, 13, 16],\r\n\t[15, 1, 17],\r\n\t[15, 3, -29, 2, -30],\r\n\t[15, 1, -15],\r\n\t[15, 1, -16],\r\n\t[15, 1, 18],\r\n\t[18, 3, -13, -29, -30],\r\n\t[18, 4, -13, -29, 19, -30],\r\n\t[19, 1, 20],\r\n\t[19, 3, 20, -31, 19],\r\n\t[20, 1, 2],\r\n\t[12, 1, 14],\r\n\t[12, 1, 21],\r\n\t[21, 1, -28],\r\n\t[21, 2, -28, 14],\r\n\t[21, 1, 22],\r\n\t[14, 1, 23],\r\n\t[14, 3, 14, -28, 23],\r\n\t[14, 1, 24],\r\n\t[23, 2, 25, 26],\r\n\t[23, 1, 26],\r\n\t[23, 3, 25, 26, 27],\r\n\t[23, 2, 26, 27],\r\n\t[23, 1, 28],\r\n\t[27, 1, 16],\r\n\t[27, 2, 16, 27],\r\n\t[25, 2, -14, -3],\r\n\t[25, 1, -32],\r\n\t[26, 1, 29],\r\n\t[26, 3, -20, -29, -30],\r\n\t[26, 4, -21, -29, -15, -30],\r\n\t[16, 3, -33, 30, -34],\r\n\t[30, 1, 2],\r\n\t[22, 2, -4, 14],\r\n\t[24, 3, 14, -4, 23],\r\n\t[28, 1, -35],\r\n\t[28, 1, -2],\r\n\t[17, 2, -36, -18],\r\n\t[29, 1, -17],\r\n\t[29, 1, -19],\r\n\t[29, 1, -18]\r\n];\r\n\r\nXPathParser.DOUBLEDOT = 2;\r\nXPathParser.DOUBLECOLON = 3;\r\nXPathParser.DOUBLESLASH = 4;\r\nXPathParser.NOTEQUAL = 5;\r\nXPathParser.LESSTHANOREQUAL = 6;\r\nXPathParser.GREATERTHANOREQUAL = 7;\r\nXPathParser.AND = 8;\r\nXPathParser.OR = 9;\r\nXPathParser.MOD = 10;\r\nXPathParser.DIV = 11;\r\nXPathParser.MULTIPLYOPERATOR = 12;\r\nXPathParser.FUNCTIONNAME = 13;\r\nXPathParser.AXISNAME = 14;\r\nXPathParser.LITERAL = 15;\r\nXPathParser.NUMBER = 16;\r\nXPathParser.ASTERISKNAMETEST = 17;\r\nXPathParser.QNAME = 18;\r\nXPathParser.NCNAMECOLONASTERISK = 19;\r\nXPathParser.NODETYPE = 20;\r\nXPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;\r\nXPathParser.EQUALS = 22;\r\nXPathParser.LESSTHAN = 23;\r\nXPathParser.GREATERTHAN = 24;\r\nXPathParser.PLUS = 25;\r\nXPathParser.MINUS = 26;\r\nXPathParser.BAR = 27;\r\nXPathParser.SLASH = 28;\r\nXPathParser.LEFTPARENTHESIS = 29;\r\nXPathParser.RIGHTPARENTHESIS = 30;\r\nXPathParser.COMMA = 31;\r\nXPathParser.AT = 32;\r\nXPathParser.LEFTBRACKET = 33;\r\nXPathParser.RIGHTBRACKET = 34;\r\nXPathParser.DOT = 35;\r\nXPathParser.DOLLAR = 36;\r\n\r\nXPathParser.prototype.tokenize = function(s1) {\r\n\tvar types = [];\r\n\tvar values = [];\r\n\tvar s = s1 + '\\0';\r\n\r\n\tvar pos = 0;\r\n\tvar c = s.charAt(pos++);\r\n\twhile (1) {\r\n\t\twhile (c == ' ' || c == '\\t' || c == '\\r' || c == '\\n') {\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t}\r\n\t\tif (c == '\\0' || pos >= s.length) {\r\n\t\t\tbreak;\r\n\t\t}\r\n\r\n\t\tif (c == '(') {\r\n\t\t\ttypes.push(XPathParser.LEFTPARENTHESIS);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == ')') {\r\n\t\t\ttypes.push(XPathParser.RIGHTPARENTHESIS);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '[') {\r\n\t\t\ttypes.push(XPathParser.LEFTBRACKET);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == ']') {\r\n\t\t\ttypes.push(XPathParser.RIGHTBRACKET);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '@') {\r\n\t\t\ttypes.push(XPathParser.AT);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == ',') {\r\n\t\t\ttypes.push(XPathParser.COMMA);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '|') {\r\n\t\t\ttypes.push(XPathParser.BAR);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '+') {\r\n\t\t\ttypes.push(XPathParser.PLUS);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '-') {\r\n\t\t\ttypes.push(XPathParser.MINUS);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '=') {\r\n\t\t\ttypes.push(XPathParser.EQUALS);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tif (c == '$') {\r\n\t\t\ttypes.push(XPathParser.DOLLAR);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == '.') {\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tif (c == '.') {\r\n\t\t\t\ttypes.push(XPathParser.DOUBLEDOT);\r\n\t\t\t\tvalues.push(\"..\");\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tif (c >= '0' && c <= '9') {\r\n\t\t\t\tvar number = \".\" + c;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\twhile (c >= '0' && c <= '9') {\r\n\t\t\t\t\tnumber += c;\r\n\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t}\r\n\t\t\t\ttypes.push(XPathParser.NUMBER);\r\n\t\t\t\tvalues.push(number);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.DOT);\r\n\t\t\tvalues.push('.');\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == '\\'' || c == '\"') {\r\n\t\t\tvar delimiter = c;\r\n\t\t\tvar literal = \"\";\r\n\t\t\twhile (pos < s.length && (c = s.charAt(pos)) !== delimiter) {\r\n\t\t\t\tliteral += c;\r\n                pos += 1;\r\n\t\t\t}\r\n            if (c !== delimiter) {\r\n                throw XPathException.fromMessage(\"Unterminated string literal: \" + delimiter + literal);\r\n            }\r\n            pos += 1;\r\n\t\t\ttypes.push(XPathParser.LITERAL);\r\n\t\t\tvalues.push(literal);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c >= '0' && c <= '9') {\r\n\t\t\tvar number = c;\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\twhile (c >= '0' && c <= '9') {\r\n\t\t\t\tnumber += c;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t}\r\n\t\t\tif (c == '.') {\r\n\t\t\t\tif (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {\r\n\t\t\t\t\tnumber += c;\r\n\t\t\t\t\tnumber += s.charAt(pos++);\r\n\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t\twhile (c >= '0' && c <= '9') {\r\n\t\t\t\t\t\tnumber += c;\r\n\t\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.NUMBER);\r\n\t\t\tvalues.push(number);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == '*') {\r\n\t\t\tif (types.length > 0) {\r\n\t\t\t\tvar last = types[types.length - 1];\r\n\t\t\t\tif (last != XPathParser.AT\r\n\t\t\t\t\t\t&& last != XPathParser.DOUBLECOLON\r\n\t\t\t\t\t\t&& last != XPathParser.LEFTPARENTHESIS\r\n\t\t\t\t\t\t&& last != XPathParser.LEFTBRACKET\r\n\t\t\t\t\t\t&& last != XPathParser.AND\r\n\t\t\t\t\t\t&& last != XPathParser.OR\r\n\t\t\t\t\t\t&& last != XPathParser.MOD\r\n\t\t\t\t\t\t&& last != XPathParser.DIV\r\n\t\t\t\t\t\t&& last != XPathParser.MULTIPLYOPERATOR\r\n\t\t\t\t\t\t&& last != XPathParser.SLASH\r\n\t\t\t\t\t\t&& last != XPathParser.DOUBLESLASH\r\n\t\t\t\t\t\t&& last != XPathParser.BAR\r\n\t\t\t\t\t\t&& last != XPathParser.PLUS\r\n\t\t\t\t\t\t&& last != XPathParser.MINUS\r\n\t\t\t\t\t\t&& last != XPathParser.EQUALS\r\n\t\t\t\t\t\t&& last != XPathParser.NOTEQUAL\r\n\t\t\t\t\t\t&& last != XPathParser.LESSTHAN\r\n\t\t\t\t\t\t&& last != XPathParser.LESSTHANOREQUAL\r\n\t\t\t\t\t\t&& last != XPathParser.GREATERTHAN\r\n\t\t\t\t\t\t&& last != XPathParser.GREATERTHANOREQUAL) {\r\n\t\t\t\t\ttypes.push(XPathParser.MULTIPLYOPERATOR);\r\n\t\t\t\t\tvalues.push(c);\r\n\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.ASTERISKNAMETEST);\r\n\t\t\tvalues.push(c);\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == ':') {\r\n\t\t\tif (s.charAt(pos) == ':') {\r\n\t\t\t\ttypes.push(XPathParser.DOUBLECOLON);\r\n\t\t\t\tvalues.push(\"::\");\r\n\t\t\t\tpos++;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (c == '/') {\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tif (c == '/') {\r\n\t\t\t\ttypes.push(XPathParser.DOUBLESLASH);\r\n\t\t\t\tvalues.push(\"//\");\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.SLASH);\r\n\t\t\tvalues.push('/');\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == '!') {\r\n\t\t\tif (s.charAt(pos) == '=') {\r\n\t\t\t\ttypes.push(XPathParser.NOTEQUAL);\r\n\t\t\t\tvalues.push(\"!=\");\r\n\t\t\t\tpos++;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tif (c == '<') {\r\n\t\t\tif (s.charAt(pos) == '=') {\r\n\t\t\t\ttypes.push(XPathParser.LESSTHANOREQUAL);\r\n\t\t\t\tvalues.push(\"<=\");\r\n\t\t\t\tpos++;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.LESSTHAN);\r\n\t\t\tvalues.push('<');\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == '>') {\r\n\t\t\tif (s.charAt(pos) == '=') {\r\n\t\t\t\ttypes.push(XPathParser.GREATERTHANOREQUAL);\r\n\t\t\t\tvalues.push(\">=\");\r\n\t\t\t\tpos++;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.GREATERTHAN);\r\n\t\t\tvalues.push('>');\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tif (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {\r\n\t\t\tvar name = c;\r\n\t\t\tc = s.charAt(pos++);\r\n\t\t\twhile (Utilities.isNCNameChar(c.charCodeAt(0))) {\r\n\t\t\t\tname += c;\r\n\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t}\r\n\t\t\tif (types.length > 0) {\r\n\t\t\t\tvar last = types[types.length - 1];\r\n\t\t\t\tif (last != XPathParser.AT\r\n\t\t\t\t\t\t&& last != XPathParser.DOUBLECOLON\r\n\t\t\t\t\t\t&& last != XPathParser.LEFTPARENTHESIS\r\n\t\t\t\t\t\t&& last != XPathParser.LEFTBRACKET\r\n\t\t\t\t\t\t&& last != XPathParser.AND\r\n\t\t\t\t\t\t&& last != XPathParser.OR\r\n\t\t\t\t\t\t&& last != XPathParser.MOD\r\n\t\t\t\t\t\t&& last != XPathParser.DIV\r\n\t\t\t\t\t\t&& last != XPathParser.MULTIPLYOPERATOR\r\n\t\t\t\t\t\t&& last != XPathParser.SLASH\r\n\t\t\t\t\t\t&& last != XPathParser.DOUBLESLASH\r\n\t\t\t\t\t\t&& last != XPathParser.BAR\r\n\t\t\t\t\t\t&& last != XPathParser.PLUS\r\n\t\t\t\t\t\t&& last != XPathParser.MINUS\r\n\t\t\t\t\t\t&& last != XPathParser.EQUALS\r\n\t\t\t\t\t\t&& last != XPathParser.NOTEQUAL\r\n\t\t\t\t\t\t&& last != XPathParser.LESSTHAN\r\n\t\t\t\t\t\t&& last != XPathParser.LESSTHANOREQUAL\r\n\t\t\t\t\t\t&& last != XPathParser.GREATERTHAN\r\n\t\t\t\t\t\t&& last != XPathParser.GREATERTHANOREQUAL) {\r\n\t\t\t\t\tif (name == \"and\") {\r\n\t\t\t\t\t\ttypes.push(XPathParser.AND);\r\n\t\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (name == \"or\") {\r\n\t\t\t\t\t\ttypes.push(XPathParser.OR);\r\n\t\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (name == \"mod\") {\r\n\t\t\t\t\t\ttypes.push(XPathParser.MOD);\r\n\t\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (name == \"div\") {\r\n\t\t\t\t\t\ttypes.push(XPathParser.DIV);\r\n\t\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (c == ':') {\r\n\t\t\t\tif (s.charAt(pos) == '*') {\r\n\t\t\t\t\ttypes.push(XPathParser.NCNAMECOLONASTERISK);\r\n\t\t\t\t\tvalues.push(name + \":*\");\r\n\t\t\t\t\tpos++;\r\n\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {\r\n\t\t\t\t\tname += ':';\r\n\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t\twhile (Utilities.isNCNameChar(c.charCodeAt(0))) {\r\n\t\t\t\t\t\tname += c;\r\n\t\t\t\t\t\tc = s.charAt(pos++);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (c == '(') {\r\n\t\t\t\t\t\ttypes.push(XPathParser.FUNCTIONNAME);\r\n\t\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\t\t\t\t\ttypes.push(XPathParser.QNAME);\r\n\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (s.charAt(pos) == ':') {\r\n\t\t\t\t\ttypes.push(XPathParser.AXISNAME);\r\n\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (c == '(') {\r\n\t\t\t\tif (name == \"comment\" || name == \"text\" || name == \"node\") {\r\n\t\t\t\t\ttypes.push(XPathParser.NODETYPE);\r\n\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\tif (name == \"processing-instruction\") {\r\n\t\t\t\t\tif (s.charAt(pos) == ')') {\r\n\t\t\t\t\t\ttypes.push(XPathParser.NODETYPE);\r\n\t\t\t\t\t} else {\r\n\t\t\t\t\t\ttypes.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tvalues.push(name);\r\n\t\t\t\t\tcontinue;\r\n\t\t\t\t}\r\n\t\t\t\ttypes.push(XPathParser.FUNCTIONNAME);\r\n\t\t\t\tvalues.push(name);\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\ttypes.push(XPathParser.QNAME);\r\n\t\t\tvalues.push(name);\r\n\t\t\tcontinue;\r\n\t\t}\r\n\r\n\t\tthrow new Error(\"Unexpected character \" + c);\r\n\t}\r\n\ttypes.push(1);\r\n\tvalues.push(\"[EOF]\");\r\n\treturn [types, values];\r\n};\r\n\r\nXPathParser.SHIFT = 's';\r\nXPathParser.REDUCE = 'r';\r\nXPathParser.ACCEPT = 'a';\r\n\r\nXPathParser.prototype.parse = function(s) {\r\n\tvar types;\r\n\tvar values;\r\n\tvar res = this.tokenize(s);\r\n\tif (res == undefined) {\r\n\t\treturn undefined;\r\n\t}\r\n\ttypes = res[0];\r\n\tvalues = res[1];\r\n\tvar tokenPos = 0;\r\n\tvar state = [];\r\n\tvar tokenType = [];\r\n\tvar tokenValue = [];\r\n\tvar s;\r\n\tvar a;\r\n\tvar t;\r\n\r\n\tstate.push(0);\r\n\ttokenType.push(1);\r\n\ttokenValue.push(\"_S\");\r\n\r\n\ta = types[tokenPos];\r\n\tt = values[tokenPos++];\r\n\twhile (1) {\r\n\t\ts = state[state.length - 1];\r\n\t\tswitch (XPathParser.actionTable[s].charAt(a - 1)) {\r\n\t\t\tcase XPathParser.SHIFT:\r\n\t\t\t\ttokenType.push(-a);\r\n\t\t\t\ttokenValue.push(t);\r\n\t\t\t\tstate.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);\r\n\t\t\t\ta = types[tokenPos];\r\n\t\t\t\tt = values[tokenPos++];\r\n\t\t\t\tbreak;\r\n\t\t\tcase XPathParser.REDUCE:\r\n\t\t\t\tvar num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];\r\n\t\t\t\tvar rhs = [];\r\n\t\t\t\tfor (var i = 0; i < num; i++) {\r\n\t\t\t\t\ttokenType.pop();\r\n\t\t\t\t\trhs.unshift(tokenValue.pop());\r\n\t\t\t\t\tstate.pop();\r\n\t\t\t\t}\r\n\t\t\t\tvar s_ = state[state.length - 1];\r\n\t\t\t\ttokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);\r\n\t\t\t\tif (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {\r\n\t\t\t\t\ttokenValue.push(rhs[0]);\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));\r\n\t\t\t\t}\r\n\t\t\t\tstate.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);\r\n\t\t\t\tbreak;\r\n\t\t\tcase XPathParser.ACCEPT:\r\n\t\t\t\treturn new XPath(tokenValue.pop());\r\n\t\t\tdefault:\r\n\t\t\t\tthrow new Error(\"XPath parse error\");\r\n\t\t}\r\n\t}\r\n};\r\n\r\n// XPath /////////////////////////////////////////////////////////////////////\r\n\r\nXPath.prototype = new Object();\r\nXPath.prototype.constructor = XPath;\r\nXPath.superclass = Object.prototype;\r\n\r\nfunction XPath(e) {\r\n\tthis.expression = e;\r\n}\r\n\r\nXPath.prototype.toString = function() {\r\n\treturn this.expression.toString();\r\n};\r\n\r\nfunction setIfUnset(obj, prop, value) {\r\n\tif (!(prop in obj)) {\r\n\t\tobj[prop] = value;\r\n\t}\r\n}\r\n\r\nXPath.prototype.evaluate = function(c) {\r\n\tc.contextNode = c.expressionContextNode;\r\n\tc.contextSize = 1;\r\n\tc.contextPosition = 1;\r\n\r\n\t// [2017-11-25] Removed usage of .implementation.hasFeature() since it does\r\n\t//              not reliably detect HTML DOMs (always returns false in xmldom and true in browsers)\r\n\tif (c.isHtml) {\r\n\t\tsetIfUnset(c, 'caseInsensitive', true);\r\n\t\tsetIfUnset(c, 'allowAnyNamespaceForNoPrefix', true);\r\n\t}\r\n\t\r\n    setIfUnset(c, 'caseInsensitive', false);\r\n\r\n\treturn this.expression.evaluate(c);\r\n};\r\n\r\nXPath.XML_NAMESPACE_URI = \"http://www.w3.org/XML/1998/namespace\";\r\nXPath.XMLNS_NAMESPACE_URI = \"http://www.w3.org/2000/xmlns/\";\r\n\r\n// Expression ////////////////////////////////////////////////////////////////\r\n\r\nExpression.prototype = new Object();\r\nExpression.prototype.constructor = Expression;\r\nExpression.superclass = Object.prototype;\r\n\r\nfunction Expression() {\r\n}\r\n\r\nExpression.prototype.init = function() {\r\n};\r\n\r\nExpression.prototype.toString = function() {\r\n\treturn \"<Expression>\";\r\n};\r\n\r\nExpression.prototype.evaluate = function(c) {\r\n\tthrow new Error(\"Could not evaluate expression.\");\r\n};\r\n\r\n// UnaryOperation ////////////////////////////////////////////////////////////\r\n\r\nUnaryOperation.prototype = new Expression();\r\nUnaryOperation.prototype.constructor = UnaryOperation;\r\nUnaryOperation.superclass = Expression.prototype;\r\n\r\nfunction UnaryOperation(rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(rhs);\r\n\t}\r\n}\r\n\r\nUnaryOperation.prototype.init = function(rhs) {\r\n\tthis.rhs = rhs;\r\n};\r\n\r\n// UnaryMinusOperation ///////////////////////////////////////////////////////\r\n\r\nUnaryMinusOperation.prototype = new UnaryOperation();\r\nUnaryMinusOperation.prototype.constructor = UnaryMinusOperation;\r\nUnaryMinusOperation.superclass = UnaryOperation.prototype;\r\n\r\nfunction UnaryMinusOperation(rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(rhs);\r\n\t}\r\n}\r\n\r\nUnaryMinusOperation.prototype.init = function(rhs) {\r\n\tUnaryMinusOperation.superclass.init.call(this, rhs);\r\n};\r\n\r\nUnaryMinusOperation.prototype.evaluate = function(c) {\r\n\treturn this.rhs.evaluate(c).number().negate();\r\n};\r\n\r\nUnaryMinusOperation.prototype.toString = function() {\r\n\treturn \"-\" + this.rhs.toString();\r\n};\r\n\r\n// BinaryOperation ///////////////////////////////////////////////////////////\r\n\r\nBinaryOperation.prototype = new Expression();\r\nBinaryOperation.prototype.constructor = BinaryOperation;\r\nBinaryOperation.superclass = Expression.prototype;\r\n\r\nfunction BinaryOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nBinaryOperation.prototype.init = function(lhs, rhs) {\r\n\tthis.lhs = lhs;\r\n\tthis.rhs = rhs;\r\n};\r\n\r\n// OrOperation ///////////////////////////////////////////////////////////////\r\n\r\nOrOperation.prototype = new BinaryOperation();\r\nOrOperation.prototype.constructor = OrOperation;\r\nOrOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction OrOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nOrOperation.prototype.init = function(lhs, rhs) {\r\n\tOrOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nOrOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" or \" + this.rhs.toString() + \")\";\r\n};\r\n\r\nOrOperation.prototype.evaluate = function(c) {\r\n\tvar b = this.lhs.evaluate(c).bool();\r\n\tif (b.booleanValue()) {\r\n\t\treturn b;\r\n\t}\r\n\treturn this.rhs.evaluate(c).bool();\r\n};\r\n\r\n// AndOperation //////////////////////////////////////////////////////////////\r\n\r\nAndOperation.prototype = new BinaryOperation();\r\nAndOperation.prototype.constructor = AndOperation;\r\nAndOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction AndOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nAndOperation.prototype.init = function(lhs, rhs) {\r\n\tAndOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nAndOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" and \" + this.rhs.toString() + \")\";\r\n};\r\n\r\nAndOperation.prototype.evaluate = function(c) {\r\n\tvar b = this.lhs.evaluate(c).bool();\r\n\tif (!b.booleanValue()) {\r\n\t\treturn b;\r\n\t}\r\n\treturn this.rhs.evaluate(c).bool();\r\n};\r\n\r\n// EqualsOperation ///////////////////////////////////////////////////////////\r\n\r\nEqualsOperation.prototype = new BinaryOperation();\r\nEqualsOperation.prototype.constructor = EqualsOperation;\r\nEqualsOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction EqualsOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nEqualsOperation.prototype.init = function(lhs, rhs) {\r\n\tEqualsOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nEqualsOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" = \" + this.rhs.toString() + \")\";\r\n};\r\n\r\nEqualsOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).equals(this.rhs.evaluate(c));\r\n};\r\n\r\n// NotEqualOperation /////////////////////////////////////////////////////////\r\n\r\nNotEqualOperation.prototype = new BinaryOperation();\r\nNotEqualOperation.prototype.constructor = NotEqualOperation;\r\nNotEqualOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction NotEqualOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nNotEqualOperation.prototype.init = function(lhs, rhs) {\r\n\tNotEqualOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nNotEqualOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" != \" + this.rhs.toString() + \")\";\r\n};\r\n\r\nNotEqualOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));\r\n};\r\n\r\n// LessThanOperation /////////////////////////////////////////////////////////\r\n\r\nLessThanOperation.prototype = new BinaryOperation();\r\nLessThanOperation.prototype.constructor = LessThanOperation;\r\nLessThanOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction LessThanOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nLessThanOperation.prototype.init = function(lhs, rhs) {\r\n\tLessThanOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nLessThanOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));\r\n};\r\n\r\nLessThanOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" < \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// GreaterThanOperation //////////////////////////////////////////////////////\r\n\r\nGreaterThanOperation.prototype = new BinaryOperation();\r\nGreaterThanOperation.prototype.constructor = GreaterThanOperation;\r\nGreaterThanOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction GreaterThanOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nGreaterThanOperation.prototype.init = function(lhs, rhs) {\r\n\tGreaterThanOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nGreaterThanOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));\r\n};\r\n\r\nGreaterThanOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" > \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// LessThanOrEqualOperation //////////////////////////////////////////////////\r\n\r\nLessThanOrEqualOperation.prototype = new BinaryOperation();\r\nLessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;\r\nLessThanOrEqualOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction LessThanOrEqualOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nLessThanOrEqualOperation.prototype.init = function(lhs, rhs) {\r\n\tLessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nLessThanOrEqualOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));\r\n};\r\n\r\nLessThanOrEqualOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" <= \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// GreaterThanOrEqualOperation ///////////////////////////////////////////////\r\n\r\nGreaterThanOrEqualOperation.prototype = new BinaryOperation();\r\nGreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;\r\nGreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction GreaterThanOrEqualOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nGreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {\r\n\tGreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nGreaterThanOrEqualOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));\r\n};\r\n\r\nGreaterThanOrEqualOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" >= \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// PlusOperation /////////////////////////////////////////////////////////////\r\n\r\nPlusOperation.prototype = new BinaryOperation();\r\nPlusOperation.prototype.constructor = PlusOperation;\r\nPlusOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction PlusOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nPlusOperation.prototype.init = function(lhs, rhs) {\r\n\tPlusOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nPlusOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());\r\n};\r\n\r\nPlusOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" + \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// MinusOperation ////////////////////////////////////////////////////////////\r\n\r\nMinusOperation.prototype = new BinaryOperation();\r\nMinusOperation.prototype.constructor = MinusOperation;\r\nMinusOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction MinusOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nMinusOperation.prototype.init = function(lhs, rhs) {\r\n\tMinusOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nMinusOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());\r\n};\r\n\r\nMinusOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" - \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// MultiplyOperation /////////////////////////////////////////////////////////\r\n\r\nMultiplyOperation.prototype = new BinaryOperation();\r\nMultiplyOperation.prototype.constructor = MultiplyOperation;\r\nMultiplyOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction MultiplyOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nMultiplyOperation.prototype.init = function(lhs, rhs) {\r\n\tMultiplyOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nMultiplyOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());\r\n};\r\n\r\nMultiplyOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" * \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// DivOperation //////////////////////////////////////////////////////////////\r\n\r\nDivOperation.prototype = new BinaryOperation();\r\nDivOperation.prototype.constructor = DivOperation;\r\nDivOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction DivOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nDivOperation.prototype.init = function(lhs, rhs) {\r\n\tDivOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nDivOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());\r\n};\r\n\r\nDivOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" div \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// ModOperation //////////////////////////////////////////////////////////////\r\n\r\nModOperation.prototype = new BinaryOperation();\r\nModOperation.prototype.constructor = ModOperation;\r\nModOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction ModOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nModOperation.prototype.init = function(lhs, rhs) {\r\n\tModOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nModOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());\r\n};\r\n\r\nModOperation.prototype.toString = function() {\r\n\treturn \"(\" + this.lhs.toString() + \" mod \" + this.rhs.toString() + \")\";\r\n};\r\n\r\n// BarOperation //////////////////////////////////////////////////////////////\r\n\r\nBarOperation.prototype = new BinaryOperation();\r\nBarOperation.prototype.constructor = BarOperation;\r\nBarOperation.superclass = BinaryOperation.prototype;\r\n\r\nfunction BarOperation(lhs, rhs) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(lhs, rhs);\r\n\t}\r\n}\r\n\r\nBarOperation.prototype.init = function(lhs, rhs) {\r\n\tBarOperation.superclass.init.call(this, lhs, rhs);\r\n};\r\n\r\nBarOperation.prototype.evaluate = function(c) {\r\n\treturn this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());\r\n};\r\n\r\nBarOperation.prototype.toString = function() {\r\n\treturn map(toString, [this.lhs, this.rhs]).join(' | ');\r\n};\r\n\r\n// PathExpr //////////////////////////////////////////////////////////////////\r\n\r\nPathExpr.prototype = new Expression();\r\nPathExpr.prototype.constructor = PathExpr;\r\nPathExpr.superclass = Expression.prototype;\r\n\r\nfunction PathExpr(filter, filterPreds, locpath) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(filter, filterPreds, locpath);\r\n\t}\r\n}\r\n\r\nPathExpr.prototype.init = function(filter, filterPreds, locpath) {\r\n\tPathExpr.superclass.init.call(this);\r\n\tthis.filter = filter;\r\n\tthis.filterPredicates = filterPreds;\r\n\tthis.locationPath = locpath;\r\n};\r\n\r\n/**\r\n * Returns the topmost node of the tree containing node\r\n */\r\nfunction findRoot(node) {\r\n    while (node && node.parentNode) {\r\n        node = node.parentNode;\r\n    }\r\n\r\n    return node;\r\n}\r\n\r\nPathExpr.applyPredicates = function (predicates, c, nodes) {\r\n\treturn reduce(function (inNodes, pred) {\r\n\t\tvar ctx = c.extend({ contextSize: inNodes.length });\r\n\t\t\r\n\t\treturn filter(function (node, i) {\r\n\t\t\treturn PathExpr.predicateMatches(pred, ctx.extend({ contextNode: node, contextPosition: i + 1 }));\r\n\t\t}, inNodes);\r\n\t}, nodes, predicates);\r\n};\r\n\r\nPathExpr.getRoot = function (xpc, nodes) {\r\n\tvar firstNode = nodes[0];\r\n\t\r\n    if (firstNode.nodeType === 9 /*Node.DOCUMENT_NODE*/) {\r\n\t\treturn firstNode;\r\n\t}\r\n\t\r\n    if (xpc.virtualRoot) {\r\n    \treturn xpc.virtualRoot;\r\n    }\r\n\t\t\r\n\tvar ownerDoc = firstNode.ownerDocument;\r\n\t\r\n\tif (ownerDoc) {\r\n\t\treturn ownerDoc;\r\n\t}\r\n\t\t\t\r\n    // IE 5.5 doesn't have ownerDocument?\r\n    var n = firstNode;\r\n    while (n.parentNode != null) {\r\n    \tn = n.parentNode;\r\n    }\r\n    return n;\r\n}\r\n\r\nPathExpr.applyStep = function (step, xpc, node) {\r\n\tvar self = this;\r\n\tvar newNodes = [];\r\n    xpc.contextNode = node;\r\n    \r\n    switch (step.axis) {\r\n    \tcase Step.ANCESTOR:\r\n    \t\t// look at all the ancestor nodes\r\n    \t\tif (xpc.contextNode === xpc.virtualRoot) {\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t\tvar m;\r\n    \t\tif (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\r\n    \t\t\tm = PathExpr.getOwnerElement(xpc.contextNode);\r\n    \t\t} else {\r\n    \t\t\tm = xpc.contextNode.parentNode;\r\n    \t\t}\r\n    \t\twhile (m != null) {\r\n    \t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\tnewNodes.push(m);\r\n    \t\t\t}\r\n    \t\t\tif (m === xpc.virtualRoot) {\r\n    \t\t\t\tbreak;\r\n    \t\t\t}\r\n    \t\t\tm = m.parentNode;\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.ANCESTORORSELF:\r\n    \t\t// look at all the ancestor nodes and the current node\r\n    \t\tfor (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? PathExpr.getOwnerElement(m) : m.parentNode) {\r\n    \t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\tnewNodes.push(m);\r\n    \t\t\t}\r\n    \t\t\tif (m === xpc.virtualRoot) {\r\n    \t\t\t\tbreak;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.ATTRIBUTE:\r\n    \t\t// look at the attributes\r\n    \t\tvar nnm = xpc.contextNode.attributes;\r\n    \t\tif (nnm != null) {\r\n    \t\t\tfor (var k = 0; k < nnm.length; k++) {\r\n    \t\t\t\tvar m = nnm.item(k);\r\n    \t\t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\t\tnewNodes.push(m);\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.CHILD:\r\n    \t\t// look at all child elements\r\n    \t\tfor (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {\r\n    \t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\tnewNodes.push(m);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.DESCENDANT:\r\n    \t\t// look at all descendant nodes\r\n    \t\tvar st = [ xpc.contextNode.firstChild ];\r\n    \t\twhile (st.length > 0) {\r\n    \t\t\tfor (var m = st.pop(); m != null; ) {\r\n    \t\t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\t\tnewNodes.push(m);\r\n    \t\t\t\t}\r\n    \t\t\t\tif (m.firstChild != null) {\r\n    \t\t\t\t\tst.push(m.nextSibling);\r\n    \t\t\t\t\tm = m.firstChild;\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tm = m.nextSibling;\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.DESCENDANTORSELF:\r\n    \t\t// look at self\r\n    \t\tif (step.nodeTest.matches(xpc.contextNode, xpc)) {\r\n    \t\t\tnewNodes.push(xpc.contextNode);\r\n    \t\t}\r\n    \t\t// look at all descendant nodes\r\n    \t\tvar st = [ xpc.contextNode.firstChild ];\r\n    \t\twhile (st.length > 0) {\r\n    \t\t\tfor (var m = st.pop(); m != null; ) {\r\n    \t\t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\t\tnewNodes.push(m);\r\n    \t\t\t\t}\r\n    \t\t\t\tif (m.firstChild != null) {\r\n    \t\t\t\t\tst.push(m.nextSibling);\r\n    \t\t\t\t\tm = m.firstChild;\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tm = m.nextSibling;\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.FOLLOWING:\r\n    \t\tif (xpc.contextNode === xpc.virtualRoot) {\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t\tvar st = [];\r\n    \t\tif (xpc.contextNode.firstChild != null) {\r\n    \t\t\tst.unshift(xpc.contextNode.firstChild);\r\n    \t\t} else {\r\n    \t\t\tst.unshift(xpc.contextNode.nextSibling);\r\n    \t\t}\r\n    \t\tfor (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {\r\n    \t\t\tst.unshift(m.nextSibling);\r\n    \t\t}\r\n    \t\tdo {\r\n    \t\t\tfor (var m = st.pop(); m != null; ) {\r\n    \t\t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\t\tnewNodes.push(m);\r\n    \t\t\t\t}\r\n    \t\t\t\tif (m.firstChild != null) {\r\n    \t\t\t\t\tst.push(m.nextSibling);\r\n    \t\t\t\t\tm = m.firstChild;\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tm = m.nextSibling;\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t} while (st.length > 0);\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.FOLLOWINGSIBLING:\r\n    \t\tif (xpc.contextNode === xpc.virtualRoot) {\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t\tfor (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {\r\n    \t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\tnewNodes.push(m);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.NAMESPACE:\r\n    \t\tvar n = {};\r\n    \t\tif (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {\r\n    \t\t\tn[\"xml\"] = XPath.XML_NAMESPACE_URI;\r\n    \t\t\tn[\"xmlns\"] = XPath.XMLNS_NAMESPACE_URI;\r\n    \t\t\tfor (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {\r\n    \t\t\t\tfor (var k = 0; k < m.attributes.length; k++) {\r\n    \t\t\t\t\tvar attr = m.attributes.item(k);\r\n    \t\t\t\t\tvar nm = String(attr.name);\r\n    \t\t\t\t\tif (nm == \"xmlns\") {\r\n    \t\t\t\t\t\tif (n[\"\"] == undefined) {\r\n    \t\t\t\t\t\t\tn[\"\"] = attr.value;\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t\t} else if (nm.length > 6 && nm.substring(0, 6) == \"xmlns:\") {\r\n    \t\t\t\t\t\tvar pre = nm.substring(6, nm.length);\r\n    \t\t\t\t\t\tif (n[pre] == undefined) {\r\n    \t\t\t\t\t\t\tn[pre] = attr.value;\r\n    \t\t\t\t\t\t}\r\n    \t\t\t\t\t}\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t\tfor (var pre in n) {\r\n    \t\t\t\tvar nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);\r\n    \t\t\t\tif (step.nodeTest.matches(nsn, xpc)) {\r\n    \t\t\t\t\tnewNodes.push(nsn);\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.PARENT:\r\n    \t\tm = null;\r\n    \t\tif (xpc.contextNode !== xpc.virtualRoot) {\r\n    \t\t\tif (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\r\n    \t\t\t\tm = PathExpr.getOwnerElement(xpc.contextNode);\r\n    \t\t\t} else {\r\n    \t\t\t\tm = xpc.contextNode.parentNode;\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tif (m != null && step.nodeTest.matches(m, xpc)) {\r\n    \t\t\tnewNodes.push(m);\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.PRECEDING:\r\n    \t\tvar st;\r\n    \t\tif (xpc.virtualRoot != null) {\r\n    \t\t\tst = [ xpc.virtualRoot ];\r\n    \t\t} else {\r\n                // cannot rely on .ownerDocument because the node may be in a document fragment\r\n                st = [findRoot(xpc.contextNode)];\r\n    \t\t}\r\n    \t\touter: while (st.length > 0) {\r\n    \t\t\tfor (var m = st.pop(); m != null; ) {\r\n    \t\t\t\tif (m == xpc.contextNode) {\r\n    \t\t\t\t\tbreak outer;\r\n    \t\t\t\t}\r\n    \t\t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\t\tnewNodes.unshift(m);\r\n    \t\t\t\t}\r\n    \t\t\t\tif (m.firstChild != null) {\r\n    \t\t\t\t\tst.push(m.nextSibling);\r\n    \t\t\t\t\tm = m.firstChild;\r\n    \t\t\t\t} else {\r\n    \t\t\t\t\tm = m.nextSibling;\r\n    \t\t\t\t}\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.PRECEDINGSIBLING:\r\n    \t\tif (xpc.contextNode === xpc.virtualRoot) {\r\n    \t\t\tbreak;\r\n    \t\t}\r\n    \t\tfor (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {\r\n    \t\t\tif (step.nodeTest.matches(m, xpc)) {\r\n    \t\t\t\tnewNodes.push(m);\r\n    \t\t\t}\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tcase Step.SELF:\r\n    \t\tif (step.nodeTest.matches(xpc.contextNode, xpc)) {\r\n    \t\t\tnewNodes.push(xpc.contextNode);\r\n    \t\t}\r\n    \t\tbreak;\r\n    \r\n    \tdefault:\r\n    }\r\n\t\r\n\treturn newNodes;\r\n};\r\n\r\nPathExpr.applySteps = function (steps, xpc, nodes) {\r\n\treturn reduce(function (inNodes, step) {\r\n\t\treturn [].concat.apply([], map(function (node) {\r\n\t\t\treturn PathExpr.applyPredicates(step.predicates, xpc, PathExpr.applyStep(step, xpc, node));\r\n\t\t}, inNodes));\r\n\t}, nodes, steps);\r\n}\r\n\r\nPathExpr.prototype.applyFilter = function(c, xpc) {\r\n\tif (!this.filter) {\r\n\t\treturn { nodes: [ c.contextNode ] };\r\n\t}\r\n\t\r\n\tvar ns = this.filter.evaluate(c);\r\n\r\n\tif (!Utilities.instance_of(ns, XNodeSet)) {\r\n        if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {\r\n\t\t    throw new Error(\"Path expression filter must evaluate to a nodeset if predicates or location path are used\");\r\n\t\t}\r\n\r\n\t\treturn { nonNodes: ns };\r\n\t}\r\n\t\r\n\treturn { \r\n\t    nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray())\r\n\t};\r\n};\r\n\r\nPathExpr.applyLocationPath = function (locationPath, xpc, nodes) {\r\n\tif (!locationPath) {\r\n\t\treturn nodes;\r\n\t}\r\n\t\r\n\tvar startNodes = locationPath.absolute ? [ PathExpr.getRoot(xpc, nodes) ] : nodes;\r\n\t\t\r\n    return PathExpr.applySteps(locationPath.steps, xpc, startNodes);\r\n};\r\n\r\nPathExpr.prototype.evaluate = function(c) {\r\n\tvar xpc = assign(new XPathContext(), c);\r\n\t\r\n    var filterResult = this.applyFilter(c, xpc);\r\n\t\r\n\tif ('nonNodes' in filterResult) {\r\n\t\treturn filterResult.nonNodes;\r\n\t}\t\r\n\t\r\n\tvar ns = new XNodeSet();\r\n\tns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));\r\n\treturn ns;\r\n};\r\n\r\nPathExpr.predicateMatches = function(pred, c) {\r\n\tvar res = pred.evaluate(c);\r\n\t\r\n\treturn Utilities.instance_of(res, XNumber)\r\n\t\t? c.contextPosition == res.numberValue()\r\n\t\t: res.booleanValue();\r\n};\r\n\r\nPathExpr.predicateString = compose(wrap('[', ']'), toString);\r\nPathExpr.predicatesString = compose(join(''), map(PathExpr.predicateString));\r\n\r\nPathExpr.prototype.toString = function() {\r\n\tif (this.filter != undefined) {\r\n\t\tvar filterStr = toString(this.filter);\r\n\r\n\t\tif (Utilities.instance_of(this.filter, XString)) {\r\n\t\t\treturn wrap(\"'\", \"'\", filterStr);\r\n\t\t}\r\n\t\tif (this.filterPredicates != undefined && this.filterPredicates.length) {\r\n\t\t\treturn wrap('(', ')', filterStr) + \r\n\t\t\t    PathExpr.predicatesString(this.filterPredicates);\r\n\t\t}\r\n\t\tif (this.locationPath != undefined) {\r\n\t\t\treturn filterStr + \r\n\t\t\t    (this.locationPath.absolute ? '' : '/') +\r\n\t\t\t\ttoString(this.locationPath);\r\n\t\t}\r\n\r\n\t\treturn filterStr;\r\n\t}\r\n\r\n\treturn toString(this.locationPath);\r\n};\r\n\r\nPathExpr.getOwnerElement = function(n) {\r\n\t// DOM 2 has ownerElement\r\n\tif (n.ownerElement) {\r\n\t\treturn n.ownerElement;\r\n\t}\r\n\t// DOM 1 Internet Explorer can use selectSingleNode (ironically)\r\n\ttry {\r\n\t\tif (n.selectSingleNode) {\r\n\t\t\treturn n.selectSingleNode(\"..\");\r\n\t\t}\r\n\t} catch (e) {\r\n\t}\r\n\t// Other DOM 1 implementations must use this egregious search\r\n\tvar doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/\r\n\t\t\t? n\r\n\t\t\t: n.ownerDocument;\r\n\tvar elts = doc.getElementsByTagName(\"*\");\r\n\tfor (var i = 0; i < elts.length; i++) {\r\n\t\tvar elt = elts.item(i);\r\n\t\tvar nnm = elt.attributes;\r\n\t\tfor (var j = 0; j < nnm.length; j++) {\r\n\t\t\tvar an = nnm.item(j);\r\n\t\t\tif (an === n) {\r\n\t\t\t\treturn elt;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\n// LocationPath //////////////////////////////////////////////////////////////\r\n\r\nLocationPath.prototype = new Object();\r\nLocationPath.prototype.constructor = LocationPath;\r\nLocationPath.superclass = Object.prototype;\r\n\r\nfunction LocationPath(abs, steps) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(abs, steps);\r\n\t}\r\n}\r\n\r\nLocationPath.prototype.init = function(abs, steps) {\r\n\tthis.absolute = abs;\r\n\tthis.steps = steps;\r\n};\r\n\r\nLocationPath.prototype.toString = function() {\r\n\treturn (\r\n\t    (this.absolute ? '/' : '') +\r\n\t\tmap(toString, this.steps).join('/')\r\n    );\r\n};\r\n\r\n// Step //////////////////////////////////////////////////////////////////////\r\n\r\nStep.prototype = new Object();\r\nStep.prototype.constructor = Step;\r\nStep.superclass = Object.prototype;\r\n\r\nfunction Step(axis, nodetest, preds) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(axis, nodetest, preds);\r\n\t}\r\n}\r\n\r\nStep.prototype.init = function(axis, nodetest, preds) {\r\n\tthis.axis = axis;\r\n\tthis.nodeTest = nodetest;\r\n\tthis.predicates = preds;\r\n};\r\n\r\nStep.prototype.toString = function() {\r\n\treturn Step.STEPNAMES[this.axis] +\r\n        \"::\" +\r\n        this.nodeTest.toString() +\r\n\t    PathExpr.predicatesString(this.predicates);\r\n};\r\n\r\n\r\nStep.ANCESTOR = 0;\r\nStep.ANCESTORORSELF = 1;\r\nStep.ATTRIBUTE = 2;\r\nStep.CHILD = 3;\r\nStep.DESCENDANT = 4;\r\nStep.DESCENDANTORSELF = 5;\r\nStep.FOLLOWING = 6;\r\nStep.FOLLOWINGSIBLING = 7;\r\nStep.NAMESPACE = 8;\r\nStep.PARENT = 9;\r\nStep.PRECEDING = 10;\r\nStep.PRECEDINGSIBLING = 11;\r\nStep.SELF = 12;\r\n\r\nStep.STEPNAMES = reduce(function (acc, x) { return acc[x[0]] = x[1], acc; }, {}, [\r\n\t[Step.ANCESTOR, 'ancestor'],\r\n\t[Step.ANCESTORORSELF, 'ancestor-or-self'],\r\n\t[Step.ATTRIBUTE, 'attribute'],\r\n\t[Step.CHILD, 'child'],\r\n\t[Step.DESCENDANT, 'descendant'],\r\n\t[Step.DESCENDANTORSELF, 'descendant-or-self'],\r\n\t[Step.FOLLOWING, 'following'],\r\n\t[Step.FOLLOWINGSIBLING, 'following-sibling'],\r\n\t[Step.NAMESPACE, 'namespace'],\r\n\t[Step.PARENT, 'parent'],\r\n\t[Step.PRECEDING, 'preceding'],\r\n\t[Step.PRECEDINGSIBLING, 'preceding-sibling'],\r\n\t[Step.SELF, 'self']\r\n  ]);\r\n  \r\n// NodeTest //////////////////////////////////////////////////////////////////\r\n\r\nNodeTest.prototype = new Object();\r\nNodeTest.prototype.constructor = NodeTest;\r\nNodeTest.superclass = Object.prototype;\r\n\r\nfunction NodeTest(type, value) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(type, value);\r\n\t}\r\n}\r\n\r\nNodeTest.prototype.init = function(type, value) {\r\n\tthis.type = type;\r\n\tthis.value = value;\r\n};\r\n\r\nNodeTest.prototype.toString = function() {\r\n\treturn \"<unknown nodetest type>\";\r\n};\r\n\r\nNodeTest.prototype.matches = function (n, xpc) {\r\n    console.warn('unknown node test type');\r\n};\r\n\r\nNodeTest.NAMETESTANY = 0;\r\nNodeTest.NAMETESTPREFIXANY = 1;\r\nNodeTest.NAMETESTQNAME = 2;\r\nNodeTest.COMMENT = 3;\r\nNodeTest.TEXT = 4;\r\nNodeTest.PI = 5;\r\nNodeTest.NODE = 6;\r\n\r\nNodeTest.isNodeType = function (types){\r\n\treturn compose(includes(types), prop('nodeType'));\r\n};\r\n\r\nNodeTest.makeNodeTestType = function (type, members, ctor) {\r\n\tvar newType = ctor || function () {};\r\n\t\r\n\tnewType.prototype = new NodeTest(members.type);\r\n\tnewType.prototype.constructor = type;\r\n\t\r\n\tfor (var key in members) {\r\n\t\tnewType.prototype[key] = members[key];\r\n\t}\r\n\t\r\n\treturn newType;\r\n};\r\n// create invariant node test for certain node types\r\nNodeTest.makeNodeTypeTest = function (type, nodeTypes, stringVal) {\r\n\treturn new (NodeTest.makeNodeTestType(type, {\r\n\t\tmatches: NodeTest.isNodeType(nodeTypes),\r\n\t\ttoString: always(stringVal)\r\n\t}))();\r\n};\r\n\r\nNodeTest.hasPrefix = function (node) {\r\n\treturn node.prefix || (node.nodeName || node.tagName).indexOf(':') !== -1;\r\n};\r\n\r\nNodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);\r\nNodeTest.nameSpaceMatches = function (prefix, xpc, n) {\r\n\tvar nNamespace = (n.namespaceURI || '');\r\n\t\r\n\tif (!prefix) { \r\n\t    return !nNamespace || (xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n)); \r\n\t}\r\n\t\r\n    var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);\r\n\r\n\tif (ns == null) {\r\n        throw new Error(\"Cannot resolve QName \" + prefix);\r\n    }\r\n\r\n    return ns === nNamespace;\r\n};\r\nNodeTest.localNameMatches = function (localName, xpc, n) {\r\n\tvar nLocalName = (n.localName || n.nodeName);\r\n\t\r\n\treturn xpc.caseInsensitive\r\n\t    ? localName.toLowerCase() === nLocalName.toLowerCase()\r\n\t\t: localName === nLocalName;\r\n};\r\n\r\nNodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(NodeTest.NAMETESTPREFIXANY, {\r\n\tmatches: function (n, xpc){\r\n        return NodeTest.isElementOrAttribute(n) && \r\n\t\t    NodeTest.nameSpaceMatches(this.prefix, xpc, n);\r\n\t},\r\n\ttoString: function () {\r\n\t\treturn this.prefix + \":*\";\r\n\t}\r\n}, function (prefix) { this.prefix = prefix; });\r\n\r\nNodeTest.NameTestQName = NodeTest.makeNodeTestType(NodeTest.NAMETESTQNAME, {\r\n\tmatches: function (n, xpc) {\r\n\t\treturn NodeTest.isNodeType([1, 2, XPathNamespace.XPATH_NAMESPACE_NODE])(n) &&\r\n\t\t    NodeTest.nameSpaceMatches(this.prefix, xpc, n) &&\r\n            NodeTest.localNameMatches(this.localName, xpc, n);\r\n\t},\r\n\ttoString: function () {\r\n        return this.name;\r\n\t}\r\n}, function (name) { \r\n    var nameParts = name.split(':');\r\n\t\r\n\tthis.name = name;\r\n\tthis.prefix = nameParts.length > 1 ? nameParts[0] : null;\r\n\tthis.localName = nameParts[nameParts.length > 1 ? 1 : 0];\r\n});\r\n\r\nNodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {\r\n\tmatches: function (n, xpc) {\r\n\t\treturn NodeTest.isNodeType([7])(n) && (n.target || n.nodeName) === this.name;\r\n\t},\r\n\ttoString: function () {\r\n        return wrap('processing-instruction(\"', '\")', this.name);\r\n\t}\r\n}, function (name) { this.name = name; })\r\n\r\n// singletons\r\n\r\n// elements, attributes, namespaces\r\nNodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [1, 2, XPathNamespace.XPATH_NAMESPACE_NODE], '*');\r\n// text, cdata\r\nNodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], 'text()');\r\nNodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], 'comment()');\r\n// elements, attributes, text, cdata, PIs, comments, document nodes\r\nNodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [1, 2, 3, 4, 7, 8, 9], 'node()');\r\nNodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], 'processing-instruction()');\r\n\r\n// VariableReference /////////////////////////////////////////////////////////\r\n\r\nVariableReference.prototype = new Expression();\r\nVariableReference.prototype.constructor = VariableReference;\r\nVariableReference.superclass = Expression.prototype;\r\n\r\nfunction VariableReference(v) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(v);\r\n\t}\r\n}\r\n\r\nVariableReference.prototype.init = function(v) {\r\n\tthis.variable = v;\r\n};\r\n\r\nVariableReference.prototype.toString = function() {\r\n\treturn \"$\" + this.variable;\r\n};\r\n\r\nVariableReference.prototype.evaluate = function(c) {\r\n    var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);\r\n\r\n    if (parts[0] == null) {\r\n        throw new Error(\"Cannot resolve QName \" + fn);\r\n    }\r\n\tvar result = c.variableResolver.getVariable(parts[1], parts[0]);\r\n    if (!result) {\r\n        throw XPathException.fromMessage(\"Undeclared variable: \" + this.toString());\r\n    }\r\n    return result;\r\n};\r\n\r\n// FunctionCall //////////////////////////////////////////////////////////////\r\n\r\nFunctionCall.prototype = new Expression();\r\nFunctionCall.prototype.constructor = FunctionCall;\r\nFunctionCall.superclass = Expression.prototype;\r\n\r\nfunction FunctionCall(fn, args) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(fn, args);\r\n\t}\r\n}\r\n\r\nFunctionCall.prototype.init = function(fn, args) {\r\n\tthis.functionName = fn;\r\n\tthis.arguments = args;\r\n};\r\n\r\nFunctionCall.prototype.toString = function() {\r\n\tvar s = this.functionName + \"(\";\r\n\tfor (var i = 0; i < this.arguments.length; i++) {\r\n\t\tif (i > 0) {\r\n\t\t\ts += \", \";\r\n\t\t}\r\n\t\ts += this.arguments[i].toString();\r\n\t}\r\n\treturn s + \")\";\r\n};\r\n\r\nFunctionCall.prototype.evaluate = function(c) {\r\n    var f = FunctionResolver.getFunctionFromContext(this.functionName, c);\r\n\r\n    if (!f) {\r\n\t\tthrow new Error(\"Unknown function \" + this.functionName);\r\n\t}\r\n\r\n    var a = [c].concat(this.arguments);\r\n\treturn f.apply(c.functionResolver.thisArg, a);\r\n};\r\n\r\n// Operators /////////////////////////////////////////////////////////////////\r\n\r\nvar Operators = new Object();\r\n\r\nOperators.equals = function(l, r) {\r\n\treturn l.equals(r);\r\n};\r\n\r\nOperators.notequal = function(l, r) {\r\n\treturn l.notequal(r);\r\n};\r\n\r\nOperators.lessthan = function(l, r) {\r\n\treturn l.lessthan(r);\r\n};\r\n\r\nOperators.greaterthan = function(l, r) {\r\n\treturn l.greaterthan(r);\r\n};\r\n\r\nOperators.lessthanorequal = function(l, r) {\r\n\treturn l.lessthanorequal(r);\r\n};\r\n\r\nOperators.greaterthanorequal = function(l, r) {\r\n\treturn l.greaterthanorequal(r);\r\n};\r\n\r\n// XString ///////////////////////////////////////////////////////////////////\r\n\r\nXString.prototype = new Expression();\r\nXString.prototype.constructor = XString;\r\nXString.superclass = Expression.prototype;\r\n\r\nfunction XString(s) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(s);\r\n\t}\r\n}\r\n\r\nXString.prototype.init = function(s) {\r\n\tthis.str = String(s);\r\n};\r\n\r\nXString.prototype.toString = function() {\r\n\treturn this.str;\r\n};\r\n\r\nXString.prototype.evaluate = function(c) {\r\n\treturn this;\r\n};\r\n\r\nXString.prototype.string = function() {\r\n\treturn this;\r\n};\r\n\r\nXString.prototype.number = function() {\r\n\treturn new XNumber(this.str);\r\n};\r\n\r\nXString.prototype.bool = function() {\r\n\treturn new XBoolean(this.str);\r\n};\r\n\r\nXString.prototype.nodeset = function() {\r\n\tthrow new Error(\"Cannot convert string to nodeset\");\r\n};\r\n\r\nXString.prototype.stringValue = function() {\r\n\treturn this.str;\r\n};\r\n\r\nXString.prototype.numberValue = function() {\r\n\treturn this.number().numberValue();\r\n};\r\n\r\nXString.prototype.booleanValue = function() {\r\n\treturn this.bool().booleanValue();\r\n};\r\n\r\nXString.prototype.equals = function(r) {\r\n\tif (Utilities.instance_of(r, XBoolean)) {\r\n\t\treturn this.bool().equals(r);\r\n\t}\r\n\tif (Utilities.instance_of(r, XNumber)) {\r\n\t\treturn this.number().equals(r);\r\n\t}\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithString(this, Operators.equals);\r\n\t}\r\n\treturn new XBoolean(this.str == r.str);\r\n};\r\n\r\nXString.prototype.notequal = function(r) {\r\n\tif (Utilities.instance_of(r, XBoolean)) {\r\n\t\treturn this.bool().notequal(r);\r\n\t}\r\n\tif (Utilities.instance_of(r, XNumber)) {\r\n\t\treturn this.number().notequal(r);\r\n\t}\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithString(this, Operators.notequal);\r\n\t}\r\n\treturn new XBoolean(this.str != r.str);\r\n};\r\n\r\nXString.prototype.lessthan = function(r) {\r\n\treturn this.number().lessthan(r);\r\n};\r\n\r\nXString.prototype.greaterthan = function(r) {\r\n\treturn this.number().greaterthan(r);\r\n};\r\n\r\nXString.prototype.lessthanorequal = function(r) {\r\n\treturn this.number().lessthanorequal(r);\r\n};\r\n\r\nXString.prototype.greaterthanorequal = function(r) {\r\n\treturn this.number().greaterthanorequal(r);\r\n};\r\n\r\n// XNumber ///////////////////////////////////////////////////////////////////\r\n\r\nXNumber.prototype = new Expression();\r\nXNumber.prototype.constructor = XNumber;\r\nXNumber.superclass = Expression.prototype;\r\n\r\nfunction XNumber(n) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(n);\r\n\t}\r\n}\r\n\r\nXNumber.prototype.init = function(n) {\r\n\tthis.num = typeof n === \"string\" ? this.parse(n) : Number(n);\r\n};\r\n\r\nXNumber.prototype.numberFormat = /^\\s*-?[0-9]*\\.?[0-9]+\\s*$/;\r\n\r\nXNumber.prototype.parse = function(s) {\r\n    // XPath representation of numbers is more restrictive than what Number() or parseFloat() allow\r\n    return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;\r\n};\r\n\r\nfunction padSmallNumber(numberStr) {\r\n\tvar parts = numberStr.split('e-');\r\n\tvar base = parts[0].replace('.', '');\r\n\tvar exponent = Number(parts[1]);\r\n\t\r\n\tfor (var i = 0; i < exponent - 1; i += 1) {\r\n\t\tbase = '0' + base;\r\n\t}\r\n\t\r\n\treturn '0.' + base;\r\n}\r\n\r\nfunction padLargeNumber(numberStr) {\r\n\tvar parts = numberStr.split('e');\r\n\tvar base = parts[0].replace('.', '');\r\n\tvar exponent = Number(parts[1]);\r\n\tvar zerosToAppend = exponent + 1 - base.length;\r\n\t\r\n\tfor (var i = 0; i < zerosToAppend; i += 1){\r\n\t\tbase += '0';\r\n\t}\r\n\t\r\n\treturn base;\r\n}\r\n\r\nXNumber.prototype.toString = function() {\r\n\tvar strValue = this.num.toString();\r\n\r\n\tif (strValue.indexOf('e-') !== -1) {\r\n\t\treturn padSmallNumber(strValue);\r\n\t}\r\n    \r\n\tif (strValue.indexOf('e') !== -1) {\r\n\t\treturn padLargeNumber(strValue);\r\n\t}\r\n\t\r\n\treturn strValue;\r\n};\r\n\r\nXNumber.prototype.evaluate = function(c) {\r\n\treturn this;\r\n};\r\n\r\nXNumber.prototype.string = function() {\r\n\t\r\n\t\r\n\treturn new XString(this.toString());\r\n};\r\n\r\nXNumber.prototype.number = function() {\r\n\treturn this;\r\n};\r\n\r\nXNumber.prototype.bool = function() {\r\n\treturn new XBoolean(this.num);\r\n};\r\n\r\nXNumber.prototype.nodeset = function() {\r\n\tthrow new Error(\"Cannot convert number to nodeset\");\r\n};\r\n\r\nXNumber.prototype.stringValue = function() {\r\n\treturn this.string().stringValue();\r\n};\r\n\r\nXNumber.prototype.numberValue = function() {\r\n\treturn this.num;\r\n};\r\n\r\nXNumber.prototype.booleanValue = function() {\r\n\treturn this.bool().booleanValue();\r\n};\r\n\r\nXNumber.prototype.negate = function() {\r\n\treturn new XNumber(-this.num);\r\n};\r\n\r\nXNumber.prototype.equals = function(r) {\r\n\tif (Utilities.instance_of(r, XBoolean)) {\r\n\t\treturn this.bool().equals(r);\r\n\t}\r\n\tif (Utilities.instance_of(r, XString)) {\r\n\t\treturn this.equals(r.number());\r\n\t}\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithNumber(this, Operators.equals);\r\n\t}\r\n\treturn new XBoolean(this.num == r.num);\r\n};\r\n\r\nXNumber.prototype.notequal = function(r) {\r\n\tif (Utilities.instance_of(r, XBoolean)) {\r\n\t\treturn this.bool().notequal(r);\r\n\t}\r\n\tif (Utilities.instance_of(r, XString)) {\r\n\t\treturn this.notequal(r.number());\r\n\t}\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithNumber(this, Operators.notequal);\r\n\t}\r\n\treturn new XBoolean(this.num != r.num);\r\n};\r\n\r\nXNumber.prototype.lessthan = function(r) {\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithNumber(this, Operators.greaterthan);\r\n\t}\r\n\tif (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\r\n\t\treturn this.lessthan(r.number());\r\n\t}\r\n\treturn new XBoolean(this.num < r.num);\r\n};\r\n\r\nXNumber.prototype.greaterthan = function(r) {\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithNumber(this, Operators.lessthan);\r\n\t}\r\n\tif (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\r\n\t\treturn this.greaterthan(r.number());\r\n\t}\r\n\treturn new XBoolean(this.num > r.num);\r\n};\r\n\r\nXNumber.prototype.lessthanorequal = function(r) {\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithNumber(this, Operators.greaterthanorequal);\r\n\t}\r\n\tif (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\r\n\t\treturn this.lessthanorequal(r.number());\r\n\t}\r\n\treturn new XBoolean(this.num <= r.num);\r\n};\r\n\r\nXNumber.prototype.greaterthanorequal = function(r) {\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithNumber(this, Operators.lessthanorequal);\r\n\t}\r\n\tif (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {\r\n\t\treturn this.greaterthanorequal(r.number());\r\n\t}\r\n\treturn new XBoolean(this.num >= r.num);\r\n};\r\n\r\nXNumber.prototype.plus = function(r) {\r\n\treturn new XNumber(this.num + r.num);\r\n};\r\n\r\nXNumber.prototype.minus = function(r) {\r\n\treturn new XNumber(this.num - r.num);\r\n};\r\n\r\nXNumber.prototype.multiply = function(r) {\r\n\treturn new XNumber(this.num * r.num);\r\n};\r\n\r\nXNumber.prototype.div = function(r) {\r\n\treturn new XNumber(this.num / r.num);\r\n};\r\n\r\nXNumber.prototype.mod = function(r) {\r\n\treturn new XNumber(this.num % r.num);\r\n};\r\n\r\n// XBoolean //////////////////////////////////////////////////////////////////\r\n\r\nXBoolean.prototype = new Expression();\r\nXBoolean.prototype.constructor = XBoolean;\r\nXBoolean.superclass = Expression.prototype;\r\n\r\nfunction XBoolean(b) {\r\n\tif (arguments.length > 0) {\r\n\t\tthis.init(b);\r\n\t}\r\n}\r\n\r\nXBoolean.prototype.init = function(b) {\r\n\tthis.b = Boolean(b);\r\n};\r\n\r\nXBoolean.prototype.toString = function() {\r\n\treturn this.b.toString();\r\n};\r\n\r\nXBoolean.prototype.evaluate = function(c) {\r\n\treturn this;\r\n};\r\n\r\nXBoolean.prototype.string = function() {\r\n\treturn new XString(this.b);\r\n};\r\n\r\nXBoolean.prototype.number = function() {\r\n\treturn new XNumber(this.b);\r\n};\r\n\r\nXBoolean.prototype.bool = function() {\r\n\treturn this;\r\n};\r\n\r\nXBoolean.prototype.nodeset = function() {\r\n\tthrow new Error(\"Cannot convert boolean to nodeset\");\r\n};\r\n\r\nXBoolean.prototype.stringValue = function() {\r\n\treturn this.string().stringValue();\r\n};\r\n\r\nXBoolean.prototype.numberValue = function() {\r\n\treturn this.number().numberValue();\r\n};\r\n\r\nXBoolean.prototype.booleanValue = function() {\r\n\treturn this.b;\r\n};\r\n\r\nXBoolean.prototype.not = function() {\r\n\treturn new XBoolean(!this.b);\r\n};\r\n\r\nXBoolean.prototype.equals = function(r) {\r\n\tif (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {\r\n\t\treturn this.equals(r.bool());\r\n\t}\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithBoolean(this, Operators.equals);\r\n\t}\r\n\treturn new XBoolean(this.b == r.b);\r\n};\r\n\r\nXBoolean.prototype.notequal = function(r) {\r\n\tif (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {\r\n\t\treturn this.notequal(r.bool());\r\n\t}\r\n\tif (Utilities.instance_of(r, XNodeSet)) {\r\n\t\treturn r.compareWithBoolean(this, Operators.notequal);\r\n\t}\r\n\treturn new XBoolean(this.b != r.b);\r\n};\r\n\r\nXBoolean.prototype.lessthan = function(r) {\r\n\treturn this.number().lessthan(r);\r\n};\r\n\r\nXBoolean.prototype.greaterthan = function(r) {\r\n\treturn this.number().greaterthan(r);\r\n};\r\n\r\nXBoolean.prototype.lessthanorequal = function(r) {\r\n\treturn this.number().lessthanorequal(r);\r\n};\r\n\r\nXBoolean.prototype.greaterthanorequal = function(r) {\r\n\treturn this.number().greaterthanorequal(r);\r\n};\r\n\r\nXBoolean.true_ = new XBoolean(true);\r\nXBoolean.false_ = new XBoolean(false);\r\n\r\n// AVLTree ///////////////////////////////////////////////////////////////////\r\n\r\nAVLTree.prototype = new Object();\r\nAVLTree.prototype.constructor = AVLTree;\r\nAVLTree.superclass = Object.prototype;\r\n\r\nfunction AVLTree(n) {\r\n\tthis.init(n);\r\n}\r\n\r\nAVLTree.prototype.init = function(n) {\r\n\tthis.left = null;\r\n    this.right = null;\r\n\tthis.node = n;\r\n\tthis.depth = 1;\r\n};\r\n\r\nAVLTree.prototype.balance = function() {\r\n    var ldepth = this.left  == null ? 0 : this.left.depth;\r\n    var rdepth = this.right == null ? 0 : this.right.depth;\r\n\r\n\tif (ldepth > rdepth + 1) {\r\n        // LR or LL rotation\r\n        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;\r\n        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;\r\n\r\n        if (lldepth < lrdepth) {\r\n            // LR rotation consists of a RR rotation of the left child\r\n            this.left.rotateRR();\r\n            // plus a LL rotation of this node, which happens anyway\r\n        }\r\n        this.rotateLL();\r\n    } else if (ldepth + 1 < rdepth) {\r\n        // RR or RL rorarion\r\n\t\tvar rrdepth = this.right.right == null ? 0 : this.right.right.depth;\r\n\t\tvar rldepth = this.right.left  == null ? 0 : this.right.left.depth;\r\n\r\n        if (rldepth > rrdepth) {\r\n            // RR rotation consists of a LL rotation of the right child\r\n            this.right.rotateLL();\r\n            // plus a RR rotation of this node, which happens anyway\r\n        }\r\n        this.rotateRR();\r\n    }\r\n};\r\n\r\nAVLTree.prototype.rotateLL = function() {\r\n    // the left side is too long => rotate from the left (_not_ leftwards)\r\n    var nodeBefore = this.node;\r\n    var rightBefore = this.right;\r\n    this.node = this.left.node;\r\n    this.right = this.left;\r\n    this.left = this.left.left;\r\n    this.right.left = this.right.right;\r\n    this.right.right = rightBefore;\r\n    this.right.node = nodeBefore;\r\n    this.right.updateInNewLocation();\r\n    this.updateInNewLocation();\r\n};\r\n\r\nAVLTree.prototype.rotateRR = function() {\r\n    // the right side is too long => rotate from the right (_not_ rightwards)\r\n    var nodeBefore = this.node;\r\n    var leftBefore = this.left;\r\n    this.node = this.right.node;\r\n    this.left = this.right;\r\n    this.right = this.right.right;\r\n    this.left.right = this.left.left;\r\n    this.left.left = leftBefore;\r\n    this.left.node = nodeBefore;\r\n    this.left.updateInNewLocation();\r\n    this.updateInNewLocation();\r\n};\r\n\r\nAVLTree.prototype.updateInNewLocation = function() {\r\n    this.getDepthFromChildren();\r\n};\r\n\r\nAVLTree.prototype.getDepthFromChildren = function() {\r\n    this.depth = this.node == null ? 0 : 1;\r\n    if (this.left != null) {\r\n        this.depth = this.left.depth + 1;\r\n    }\r\n    if (this.right != null && this.depth <= this.right.depth) {\r\n        this.depth = this.right.depth + 1;\r\n    }\r\n};\r\n\r\nfunction nodeOrder(n1, n2) {\r\n\tif (n1 === n2) {\r\n\t\treturn 0;\r\n\t}\r\n\r\n\tif (n1.compareDocumentPosition) {\r\n\t    var cpos = n1.compareDocumentPosition(n2);\r\n\r\n        if (cpos & 0x01) {\r\n            // not in the same document; return an arbitrary result (is there a better way to do this)\r\n            return 1;\r\n        }\r\n        if (cpos & 0x0A) {\r\n            // n2 precedes or contains n1\r\n            return 1;\r\n        }\r\n        if (cpos & 0x14) {\r\n            // n2 follows or is contained by n1\r\n            return -1;\r\n        }\r\n\r\n\t    return 0;\r\n\t}\r\n\r\n\tvar d1 = 0,\r\n\t    d2 = 0;\r\n\tfor (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {\r\n\t\td1++;\r\n\t}\r\n\tfor (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {\r\n\t\td2++;\r\n\t}\r\n\r\n    // step up to same depth\r\n\tif (d1 > d2) {\r\n\t\twhile (d1 > d2) {\r\n\t\t\tn1 = n1.parentNode || n1.ownerElement;\r\n\t\t\td1--;\r\n\t\t}\r\n\t\tif (n1 === n2) {\r\n\t\t\treturn 1;\r\n\t\t}\r\n\t} else if (d2 > d1) {\r\n\t\twhile (d2 > d1) {\r\n\t\t\tn2 = n2.parentNode || n2.ownerElement;\r\n\t\t\td2--;\r\n\t\t}\r\n\t\tif (n1 === n2) {\r\n\t\t\treturn -1;\r\n\t\t}\r\n\t}\r\n\r\n    var n1Par = n1.parentNode || n1.ownerElement,\r\n        n2Par = n2.parentNode || n2.ownerElement;\r\n\r\n    // find common parent\r\n\twhile (n1Par !== n2Par) {\r\n\t\tn1 = n1Par;\r\n\t\tn2 = n2Par;\r\n\t\tn1Par = n1.parentNode || n1.ownerElement;\r\n\t    n2Par = n2.parentNode || n2.ownerElement;\r\n\t}\r\n    \r\n    var n1isAttr = Utilities.isAttribute(n1);\r\n    var n2isAttr = Utilities.isAttribute(n2);\r\n    \r\n    if (n1isAttr && !n2isAttr) {\r\n        return -1;\r\n    }\r\n    if (!n1isAttr && n2isAttr) {\r\n        return 1;\r\n    }\r\n    \r\n    if(n1Par) {\r\n\t    var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes,\r\n\t        len = cn.length;\r\n        for (var i = 0; i < len; i += 1) {\r\n            var n = cn[i];\r\n            if (n === n1) {\r\n                return -1;\r\n            }\r\n            if (n === n2) {\r\n                return 1;\r\n            }\r\n        }\r\n    }        \r\n    \r\n    throw new Error('Unexpected: could not determine node order');\r\n}\r\n\r\nAVLTree.prototype.add = function(n)  {\r\n\tif (n === this.node) {\r\n        return false;\r\n    }\r\n\r\n\tvar o = nodeOrder(n, this.node);\r\n\r\n    var ret = false;\r\n    if (o == -1) {\r\n        if (this.left == null) {\r\n            this.left = new AVLTree(n);\r\n            ret = true;\r\n        } else {\r\n            ret = this.left.add(n);\r\n            if (ret) {\r\n                this.balance();\r\n            }\r\n        }\r\n    } else if (o == 1) {\r\n        if (this.right == null) {\r\n            this.right = new AVLTree(n);\r\n            ret = true;\r\n        } else {\r\n            ret = this.right.add(n);\r\n            if (ret) {\r\n                this.balance();\r\n            }\r\n        }\r\n    }\r\n\r\n    if (ret) {\r\n        this.getDepthFromChildren();\r\n    }\r\n    return ret;\r\n};\r\n\r\n// XNodeSet //////////////////////////////////////////////////////////////////\r\n\r\nXNodeSet.prototype = new Expression();\r\nXNodeSet.prototype.constructor = XNodeSet;\r\nXNodeSet.superclass = Expression.prototype;\r\n\r\nfunction XNodeSet() {\r\n\tthis.init();\r\n}\r\n\r\nXNodeSet.prototype.init = function() {\r\n    this.tree = null;\r\n\tthis.nodes = [];\r\n\tthis.size = 0;\r\n};\r\n\r\nXNodeSet.prototype.toString = function() {\r\n\tvar p = this.first();\r\n\tif (p == null) {\r\n\t\treturn \"\";\r\n\t}\r\n\treturn this.stringForNode(p);\r\n};\r\n\r\nXNodeSet.prototype.evaluate = function(c) {\r\n\treturn this;\r\n};\r\n\r\nXNodeSet.prototype.string = function() {\r\n\treturn new XString(this.toString());\r\n};\r\n\r\nXNodeSet.prototype.stringValue = function() {\r\n\treturn this.toString();\r\n};\r\n\r\nXNodeSet.prototype.number = function() {\r\n\treturn new XNumber(this.string());\r\n};\r\n\r\nXNodeSet.prototype.numberValue = function() {\r\n\treturn Number(this.string());\r\n};\r\n\r\nXNodeSet.prototype.bool = function() {\r\n\treturn new XBoolean(this.booleanValue());\r\n};\r\n\r\nXNodeSet.prototype.booleanValue = function() {\r\n\treturn !!this.size;\r\n};\r\n\r\nXNodeSet.prototype.nodeset = function() {\r\n\treturn this;\r\n};\r\n\r\nXNodeSet.prototype.stringForNode = function(n) {\r\n\tif (n.nodeType == 9   /*Node.DOCUMENT_NODE*/ || \r\n        n.nodeType == 1   /*Node.ELEMENT_NODE */ || \r\n        n.nodeType === 11 /*Node.DOCUMENT_FRAGMENT*/) {\r\n\t\treturn this.stringForContainerNode(n);\r\n\t}\r\n    if (n.nodeType === 2 /* Node.ATTRIBUTE_NODE */) {\r\n        return n.value || n.nodeValue;\r\n    }\r\n\tif (n.isNamespaceNode) {\r\n\t\treturn n.namespace;\r\n\t}\r\n\treturn n.nodeValue;\r\n};\r\n\r\nXNodeSet.prototype.stringForContainerNode = function(n) {\r\n\tvar s = \"\";\r\n\tfor (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {\r\n        var nt = n2.nodeType;\r\n        //  Element,    Text,       CDATA,      Document,   Document Fragment\r\n        if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {\r\n            s += this.stringForNode(n2);\r\n        }\r\n\t}\r\n\treturn s;\r\n};\r\n\r\nXNodeSet.prototype.buildTree = function () {\r\n    if (!this.tree && this.nodes.length) {\r\n        this.tree = new AVLTree(this.nodes[0]);\r\n        for (var i = 1; i < this.nodes.length; i += 1) {\r\n            this.tree.add(this.nodes[i]);\r\n        }\r\n    }\r\n\r\n    return this.tree;\r\n};\r\n\r\nXNodeSet.prototype.first = function() {\r\n\tvar p = this.buildTree();\r\n\tif (p == null) {\r\n\t\treturn null;\r\n\t}\r\n\twhile (p.left != null) {\r\n\t\tp = p.left;\r\n\t}\r\n\treturn p.node;\r\n};\r\n\r\nXNodeSet.prototype.add = function(n) {\r\n    for (var i = 0; i < this.nodes.length; i += 1) {\r\n        if (n === this.nodes[i]) {\r\n            return;\r\n        }\r\n    }\r\n\r\n    this.tree = null;\r\n    this.nodes.push(n);\r\n    this.size += 1;\r\n};\r\n\r\nXNodeSet.prototype.addArray = function(ns) {\r\n\tvar self = this;\r\n\t\r\n\tforEach(function (x) { self.add(x); }, ns);\r\n};\r\n\r\n/**\r\n * Returns an array of the node set's contents in document order\r\n */\r\nXNodeSet.prototype.toArray = function() {\r\n\tvar a = [];\r\n\tthis.toArrayRec(this.buildTree(), a);\r\n\treturn a;\r\n};\r\n\r\nXNodeSet.prototype.toArrayRec = function(t, a) {\r\n\tif (t != null) {\r\n\t\tthis.toArrayRec(t.left, a);\r\n\t\ta.push(t.node);\r\n\t\tthis.toArrayRec(t.right, a);\r\n\t}\r\n};\r\n\r\n/**\r\n * Returns an array of the node set's contents in arbitrary order\r\n */\r\nXNodeSet.prototype.toUnsortedArray = function () {\r\n    return this.nodes.slice();\r\n};\r\n\r\nXNodeSet.prototype.compareWithString = function(r, o) {\r\n\tvar a = this.toUnsortedArray();\r\n\tfor (var i = 0; i < a.length; i++) {\r\n\t\tvar n = a[i];\r\n\t\tvar l = new XString(this.stringForNode(n));\r\n\t\tvar res = o(l, r);\r\n\t\tif (res.booleanValue()) {\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n\treturn new XBoolean(false);\r\n};\r\n\r\nXNodeSet.prototype.compareWithNumber = function(r, o) {\r\n\tvar a = this.toUnsortedArray();\r\n\tfor (var i = 0; i < a.length; i++) {\r\n\t\tvar n = a[i];\r\n\t\tvar l = new XNumber(this.stringForNode(n));\r\n\t\tvar res = o(l, r);\r\n\t\tif (res.booleanValue()) {\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n\treturn new XBoolean(false);\r\n};\r\n\r\nXNodeSet.prototype.compareWithBoolean = function(r, o) {\r\n\treturn o(this.bool(), r);\r\n};\r\n\r\nXNodeSet.prototype.compareWithNodeSet = function(r, o) {\r\n\tvar arr = this.toUnsortedArray();\r\n\tvar oInvert = function (lop, rop) { return o(rop, lop); };\r\n\t\r\n\tfor (var i = 0; i < arr.length; i++) {\r\n\t\tvar l = new XString(this.stringForNode(arr[i]));\r\n\r\n\t\tvar res = r.compareWithString(l, oInvert);\r\n\t\tif (res.booleanValue()) {\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n\t\r\n\treturn new XBoolean(false);\r\n};\r\n\r\nXNodeSet.compareWith = curry(function (o, r) {\r\n\tif (Utilities.instance_of(r, XString)) {\r\n\t\treturn this.compareWithString(r, o);\r\n\t}\r\n\tif (Utilities.instance_of(r, XNumber)) {\r\n\t\treturn this.compareWithNumber(r, o);\r\n\t}\r\n\tif (Utilities.instance_of(r, XBoolean)) {\r\n\t\treturn this.compareWithBoolean(r, o);\r\n\t}\r\n\treturn this.compareWithNodeSet(r, o);\r\n});\r\n\r\nXNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);\r\nXNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);\r\nXNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);\r\nXNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);\r\nXNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);\r\nXNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);\r\n\r\nXNodeSet.prototype.union = function(r) {\r\n\tvar ns = new XNodeSet();\r\n    ns.addArray(this.toUnsortedArray());\r\n\tns.addArray(r.toUnsortedArray());\r\n\treturn ns;\r\n};\r\n\r\n// XPathNamespace ////////////////////////////////////////////////////////////\r\n\r\nXPathNamespace.prototype = new Object();\r\nXPathNamespace.prototype.constructor = XPathNamespace;\r\nXPathNamespace.superclass = Object.prototype;\r\n\r\nfunction XPathNamespace(pre, ns, p) {\r\n\tthis.isXPathNamespace = true;\r\n\tthis.ownerDocument = p.ownerDocument;\r\n\tthis.nodeName = \"#namespace\";\r\n\tthis.prefix = pre;\r\n\tthis.localName = pre;\r\n\tthis.namespaceURI = ns;\r\n\tthis.nodeValue = ns;\r\n\tthis.ownerElement = p;\r\n\tthis.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;\r\n}\r\n\r\nXPathNamespace.prototype.toString = function() {\r\n\treturn \"{ \\\"\" + this.prefix + \"\\\", \\\"\" + this.namespaceURI + \"\\\" }\";\r\n};\r\n\r\n// XPathContext //////////////////////////////////////////////////////////////\r\n\r\nXPathContext.prototype = new Object();\r\nXPathContext.prototype.constructor = XPathContext;\r\nXPathContext.superclass = Object.prototype;\r\n\r\nfunction XPathContext(vr, nr, fr) {\r\n\tthis.variableResolver = vr != null ? vr : new VariableResolver();\r\n\tthis.namespaceResolver = nr != null ? nr : new NamespaceResolver();\r\n\tthis.functionResolver = fr != null ? fr : new FunctionResolver();\r\n}\r\n\r\nXPathContext.prototype.extend = function (newProps) {\r\n\treturn assign(new XPathContext(), this, newProps);\r\n};\r\n\r\n// VariableResolver //////////////////////////////////////////////////////////\r\n\r\nVariableResolver.prototype = new Object();\r\nVariableResolver.prototype.constructor = VariableResolver;\r\nVariableResolver.superclass = Object.prototype;\r\n\r\nfunction VariableResolver() {\r\n}\r\n\r\nVariableResolver.prototype.getVariable = function(ln, ns) {\r\n\treturn null;\r\n};\r\n\r\n// FunctionResolver //////////////////////////////////////////////////////////\r\n\r\nFunctionResolver.prototype = new Object();\r\nFunctionResolver.prototype.constructor = FunctionResolver;\r\nFunctionResolver.superclass = Object.prototype;\r\n\r\nfunction FunctionResolver(thisArg) {\r\n\tthis.thisArg = thisArg != null ? thisArg : Functions;\r\n\tthis.functions = new Object();\r\n\tthis.addStandardFunctions();\r\n}\r\n\r\nFunctionResolver.prototype.addStandardFunctions = function() {\r\n\tthis.functions[\"{}last\"] = Functions.last;\r\n\tthis.functions[\"{}position\"] = Functions.position;\r\n\tthis.functions[\"{}count\"] = Functions.count;\r\n\tthis.functions[\"{}id\"] = Functions.id;\r\n\tthis.functions[\"{}local-name\"] = Functions.localName;\r\n\tthis.functions[\"{}namespace-uri\"] = Functions.namespaceURI;\r\n\tthis.functions[\"{}name\"] = Functions.name;\r\n\tthis.functions[\"{}string\"] = Functions.string;\r\n\tthis.functions[\"{}concat\"] = Functions.concat;\r\n\tthis.functions[\"{}starts-with\"] = Functions.startsWith;\r\n\tthis.functions[\"{}contains\"] = Functions.contains;\r\n\tthis.functions[\"{}substring-before\"] = Functions.substringBefore;\r\n\tthis.functions[\"{}substring-after\"] = Functions.substringAfter;\r\n\tthis.functions[\"{}substring\"] = Functions.substring;\r\n\tthis.functions[\"{}string-length\"] = Functions.stringLength;\r\n\tthis.functions[\"{}normalize-space\"] = Functions.normalizeSpace;\r\n\tthis.functions[\"{}translate\"] = Functions.translate;\r\n\tthis.functions[\"{}boolean\"] = Functions.boolean_;\r\n\tthis.functions[\"{}not\"] = Functions.not;\r\n\tthis.functions[\"{}true\"] = Functions.true_;\r\n\tthis.functions[\"{}false\"] = Functions.false_;\r\n\tthis.functions[\"{}lang\"] = Functions.lang;\r\n\tthis.functions[\"{}number\"] = Functions.number;\r\n\tthis.functions[\"{}sum\"] = Functions.sum;\r\n\tthis.functions[\"{}floor\"] = Functions.floor;\r\n\tthis.functions[\"{}ceiling\"] = Functions.ceiling;\r\n\tthis.functions[\"{}round\"] = Functions.round;\r\n};\r\n\r\nFunctionResolver.prototype.addFunction = function(ns, ln, f) {\r\n\tthis.functions[\"{\" + ns + \"}\" + ln] = f;\r\n};\r\n\r\nFunctionResolver.getFunctionFromContext = function(qName, context) {\r\n    var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);\r\n\r\n    if (parts[0] === null) {\r\n        throw new Error(\"Cannot resolve QName \" + name);\r\n    }\r\n\r\n    return context.functionResolver.getFunction(parts[1], parts[0]);\r\n};\r\n\r\nFunctionResolver.prototype.getFunction = function(localName, namespace) {\r\n\treturn this.functions[\"{\" + namespace + \"}\" + localName];\r\n};\r\n\r\n// NamespaceResolver /////////////////////////////////////////////////////////\r\n\r\nNamespaceResolver.prototype = new Object();\r\nNamespaceResolver.prototype.constructor = NamespaceResolver;\r\nNamespaceResolver.superclass = Object.prototype;\r\n\r\nfunction NamespaceResolver() {\r\n}\r\n\r\nNamespaceResolver.prototype.getNamespace = function(prefix, n) {\r\n\tif (prefix == \"xml\") {\r\n\t\treturn XPath.XML_NAMESPACE_URI;\r\n\t} else if (prefix == \"xmlns\") {\r\n\t\treturn XPath.XMLNS_NAMESPACE_URI;\r\n\t}\r\n\tif (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {\r\n\t\tn = n.documentElement;\r\n\t} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\r\n\t\tn = PathExpr.getOwnerElement(n);\r\n\t} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {\r\n\t\tn = n.parentNode;\r\n\t}\r\n\twhile (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {\r\n\t\tvar nnm = n.attributes;\r\n\t\tfor (var i = 0; i < nnm.length; i++) {\r\n\t\t\tvar a = nnm.item(i);\r\n\t\t\tvar aname = a.name || a.nodeName;\r\n\t\t\tif ((aname === \"xmlns\" && prefix === \"\")\r\n\t\t\t\t\t|| aname === \"xmlns:\" + prefix) {\r\n\t\t\t\treturn String(a.value || a.nodeValue);\r\n\t\t\t}\r\n\t\t}\r\n\t\tn = n.parentNode;\r\n\t}\r\n\treturn null;\r\n};\r\n\r\n// Functions /////////////////////////////////////////////////////////////////\r\n\r\nvar Functions = new Object();\r\n\r\nFunctions.last = function(c) {\r\n\tif (arguments.length != 1) {\r\n\t\tthrow new Error(\"Function last expects ()\");\r\n\t}\r\n\r\n\treturn new XNumber(c.contextSize);\r\n};\r\n\r\nFunctions.position = function(c) {\r\n\tif (arguments.length != 1) {\r\n\t\tthrow new Error(\"Function position expects ()\");\r\n\t}\r\n\r\n\treturn new XNumber(c.contextPosition);\r\n};\r\n\r\nFunctions.count = function() {\r\n\tvar c = arguments[0];\r\n\tvar ns;\r\n\tif (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {\r\n\t\tthrow new Error(\"Function count expects (node-set)\");\r\n\t}\r\n\treturn new XNumber(ns.size);\r\n};\r\n\r\nFunctions.id = function() {\r\n\tvar c = arguments[0];\r\n\tvar id;\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function id expects (object)\");\r\n\t}\r\n\tid = arguments[1].evaluate(c);\r\n\tif (Utilities.instance_of(id, XNodeSet)) {\r\n\t\tid = id.toArray().join(\" \");\r\n\t} else {\r\n\t\tid = id.stringValue();\r\n\t}\r\n\tvar ids = id.split(/[\\x0d\\x0a\\x09\\x20]+/);\r\n\tvar count = 0;\r\n\tvar ns = new XNodeSet();\r\n\tvar doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/\r\n\t\t\t? c.contextNode\r\n\t\t\t: c.contextNode.ownerDocument;\r\n\tfor (var i = 0; i < ids.length; i++) {\r\n\t\tvar n;\r\n\t\tif (doc.getElementById) {\r\n\t\t\tn = doc.getElementById(ids[i]);\r\n\t\t} else {\r\n\t\t\tn = Utilities.getElementById(doc, ids[i]);\r\n\t\t}\r\n\t\tif (n != null) {\r\n\t\t\tns.add(n);\r\n\t\t\tcount++;\r\n\t\t}\r\n\t}\r\n\treturn ns;\r\n};\r\n\r\nFunctions.localName = function(c, eNode) {\r\n\tvar n;\r\n\t\r\n\tif (arguments.length == 1) {\r\n\t\tn = c.contextNode;\r\n\t} else if (arguments.length == 2) {\r\n\t\tn = eNode.evaluate(c).first();\r\n\t} else {\r\n\t\tthrow new Error(\"Function local-name expects (node-set?)\");\r\n\t}\r\n\t\r\n\tif (n == null) {\r\n\t\treturn new XString(\"\");\r\n\t}\r\n\r\n\treturn new XString(n.localName ||     //  standard elements and attributes\r\n\t                   n.baseName  ||     //  IE\r\n\t\t\t\t\t   n.target    ||     //  processing instructions\r\n                       n.nodeName  ||     //  DOM1 elements\r\n\t\t\t\t\t   \"\");               //  fallback\r\n};\r\n\r\nFunctions.namespaceURI = function() {\r\n\tvar c = arguments[0];\r\n\tvar n;\r\n\tif (arguments.length == 1) {\r\n\t\tn = c.contextNode;\r\n\t} else if (arguments.length == 2) {\r\n\t\tn = arguments[1].evaluate(c).first();\r\n\t} else {\r\n\t\tthrow new Error(\"Function namespace-uri expects (node-set?)\");\r\n\t}\r\n\tif (n == null) {\r\n\t\treturn new XString(\"\");\r\n\t}\r\n\treturn new XString(n.namespaceURI);\r\n};\r\n\r\nFunctions.name = function() {\r\n\tvar c = arguments[0];\r\n\tvar n;\r\n\tif (arguments.length == 1) {\r\n\t\tn = c.contextNode;\r\n\t} else if (arguments.length == 2) {\r\n\t\tn = arguments[1].evaluate(c).first();\r\n\t} else {\r\n\t\tthrow new Error(\"Function name expects (node-set?)\");\r\n\t}\r\n\tif (n == null) {\r\n\t\treturn new XString(\"\");\r\n\t}\r\n\tif (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {\r\n\t\treturn new XString(n.nodeName);\r\n\t} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {\r\n\t\treturn new XString(n.name || n.nodeName);\r\n\t} else if (n.nodeType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/) {\r\n\t    return new XString(n.target || n.nodeName);\r\n\t} else if (n.localName == null) {\r\n\t\treturn new XString(\"\");\r\n\t} else {\r\n\t\treturn new XString(n.localName);\r\n\t}\r\n};\r\n\r\nFunctions.string = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length == 1) {\r\n\t\treturn new XString(XNodeSet.prototype.stringForNode(c.contextNode));\r\n\t} else if (arguments.length == 2) {\r\n\t\treturn arguments[1].evaluate(c).string();\r\n\t}\r\n\tthrow new Error(\"Function string expects (object?)\");\r\n};\r\n\r\nFunctions.concat = function(c) {\r\n\tif (arguments.length < 3) {\r\n\t\tthrow new Error(\"Function concat expects (string, string[, string]*)\");\r\n\t}\r\n\tvar s = \"\";\r\n\tfor (var i = 1; i < arguments.length; i++) {\r\n\t\ts += arguments[i].evaluate(c).stringValue();\r\n\t}\r\n\treturn new XString(s);\r\n};\r\n\r\nFunctions.startsWith = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 3) {\r\n\t\tthrow new Error(\"Function startsWith expects (string, string)\");\r\n\t}\r\n\tvar s1 = arguments[1].evaluate(c).stringValue();\r\n\tvar s2 = arguments[2].evaluate(c).stringValue();\r\n\treturn new XBoolean(s1.substring(0, s2.length) == s2);\r\n};\r\n\r\nFunctions.contains = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 3) {\r\n\t\tthrow new Error(\"Function contains expects (string, string)\");\r\n\t}\r\n\tvar s1 = arguments[1].evaluate(c).stringValue();\r\n\tvar s2 = arguments[2].evaluate(c).stringValue();\r\n\treturn new XBoolean(s1.indexOf(s2) !== -1);\r\n};\r\n\r\nFunctions.substringBefore = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 3) {\r\n\t\tthrow new Error(\"Function substring-before expects (string, string)\");\r\n\t}\r\n\tvar s1 = arguments[1].evaluate(c).stringValue();\r\n\tvar s2 = arguments[2].evaluate(c).stringValue();\r\n\treturn new XString(s1.substring(0, s1.indexOf(s2)));\r\n};\r\n\r\nFunctions.substringAfter = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 3) {\r\n\t\tthrow new Error(\"Function substring-after expects (string, string)\");\r\n\t}\r\n\tvar s1 = arguments[1].evaluate(c).stringValue();\r\n\tvar s2 = arguments[2].evaluate(c).stringValue();\r\n\tif (s2.length == 0) {\r\n\t\treturn new XString(s1);\r\n\t}\r\n\tvar i = s1.indexOf(s2);\r\n\tif (i == -1) {\r\n\t\treturn new XString(\"\");\r\n\t}\r\n\treturn new XString(s1.substring(i + s2.length));\r\n};\r\n\r\nFunctions.substring = function() {\r\n\tvar c = arguments[0];\r\n\tif (!(arguments.length == 3 || arguments.length == 4)) {\r\n\t\tthrow new Error(\"Function substring expects (string, number, number?)\");\r\n\t}\r\n\tvar s = arguments[1].evaluate(c).stringValue();\r\n\tvar n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;\r\n\tvar n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;\r\n\treturn new XString(s.substring(n1, n2));\r\n};\r\n\r\nFunctions.stringLength = function() {\r\n\tvar c = arguments[0];\r\n\tvar s;\r\n\tif (arguments.length == 1) {\r\n\t\ts = XNodeSet.prototype.stringForNode(c.contextNode);\r\n\t} else if (arguments.length == 2) {\r\n\t\ts = arguments[1].evaluate(c).stringValue();\r\n\t} else {\r\n\t\tthrow new Error(\"Function string-length expects (string?)\");\r\n\t}\r\n\treturn new XNumber(s.length);\r\n};\r\n\r\nFunctions.normalizeSpace = function() {\r\n\tvar c = arguments[0];\r\n\tvar s;\r\n\tif (arguments.length == 1) {\r\n\t\ts = XNodeSet.prototype.stringForNode(c.contextNode);\r\n\t} else if (arguments.length == 2) {\r\n\t\ts = arguments[1].evaluate(c).stringValue();\r\n\t} else {\r\n\t\tthrow new Error(\"Function normalize-space expects (string?)\");\r\n\t}\r\n\tvar i = 0;\r\n\tvar j = s.length - 1;\r\n\twhile (Utilities.isSpace(s.charCodeAt(j))) {\r\n\t\tj--;\r\n\t}\r\n\tvar t = \"\";\r\n\twhile (i <= j && Utilities.isSpace(s.charCodeAt(i))) {\r\n\t\ti++;\r\n\t}\r\n\twhile (i <= j) {\r\n\t\tif (Utilities.isSpace(s.charCodeAt(i))) {\r\n\t\t\tt += \" \";\r\n\t\t\twhile (i <= j && Utilities.isSpace(s.charCodeAt(i))) {\r\n\t\t\t\ti++;\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tt += s.charAt(i);\r\n\t\t\ti++;\r\n\t\t}\r\n\t}\r\n\treturn new XString(t);\r\n};\r\n\r\nFunctions.translate = function(c, eValue, eFrom, eTo) {\r\n\tif (arguments.length != 4) {\r\n\t\tthrow new Error(\"Function translate expects (string, string, string)\");\r\n\t}\r\n\r\n\tvar value = eValue.evaluate(c).stringValue();\r\n\tvar from = eFrom.evaluate(c).stringValue();\r\n\tvar to = eTo.evaluate(c).stringValue();\r\n\t\r\n\tvar cMap = reduce(function (acc, ch, i) {\r\n\t\tif (!(ch in acc)) {\r\n\t\t\tacc[ch] = i > to.length ? '' : to[i];\r\n\t\t}\r\n\t\treturn acc;\r\n\t}, {}, from);\r\n\r\n    var t = join('', map(function (ch) {\r\n        return ch in cMap ? cMap[ch] : ch;\r\n    }, value));\r\n\r\n\treturn new XString(t);\r\n};\r\n\r\nFunctions.boolean_ = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function boolean expects (object)\");\r\n\t}\r\n\treturn arguments[1].evaluate(c).bool();\r\n};\r\n\r\nFunctions.not = function(c, eValue) {\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function not expects (object)\");\r\n\t}\r\n\treturn eValue.evaluate(c).bool().not();\r\n};\r\n\r\nFunctions.true_ = function() {\r\n\tif (arguments.length != 1) {\r\n\t\tthrow new Error(\"Function true expects ()\");\r\n\t}\r\n\treturn XBoolean.true_;\r\n};\r\n\r\nFunctions.false_ = function() {\r\n\tif (arguments.length != 1) {\r\n\t\tthrow new Error(\"Function false expects ()\");\r\n\t}\r\n\treturn XBoolean.false_;\r\n};\r\n\r\nFunctions.lang = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function lang expects (string)\");\r\n\t}\r\n\tvar lang;\r\n\tfor (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {\r\n\t\tvar a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, \"lang\");\r\n\t\tif (a != null) {\r\n\t\t\tlang = String(a);\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n\tif (lang == null) {\r\n\t\treturn XBoolean.false_;\r\n\t}\r\n\tvar s = arguments[1].evaluate(c).stringValue();\r\n\treturn new XBoolean(lang.substring(0, s.length) == s\r\n\t\t\t\t&& (lang.length == s.length || lang.charAt(s.length) == '-'));\r\n};\r\n\r\nFunctions.number = function() {\r\n\tvar c = arguments[0];\r\n\tif (!(arguments.length == 1 || arguments.length == 2)) {\r\n\t\tthrow new Error(\"Function number expects (object?)\");\r\n\t}\r\n\tif (arguments.length == 1) {\r\n\t\treturn new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));\r\n\t}\r\n\treturn arguments[1].evaluate(c).number();\r\n};\r\n\r\nFunctions.sum = function() {\r\n\tvar c = arguments[0];\r\n\tvar ns;\r\n\tif (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {\r\n\t\tthrow new Error(\"Function sum expects (node-set)\");\r\n\t}\r\n\tns = ns.toUnsortedArray();\r\n\tvar n = 0;\r\n\tfor (var i = 0; i < ns.length; i++) {\r\n\t\tn += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();\r\n\t}\r\n\treturn new XNumber(n);\r\n};\r\n\r\nFunctions.floor = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function floor expects (number)\");\r\n\t}\r\n\treturn new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));\r\n};\r\n\r\nFunctions.ceiling = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function ceiling expects (number)\");\r\n\t}\r\n\treturn new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));\r\n};\r\n\r\nFunctions.round = function() {\r\n\tvar c = arguments[0];\r\n\tif (arguments.length != 2) {\r\n\t\tthrow new Error(\"Function round expects (number)\");\r\n\t}\r\n\treturn new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));\r\n};\r\n\r\n// Utilities /////////////////////////////////////////////////////////////////\r\n\r\nvar Utilities = new Object();\r\n\r\nUtilities.isAttribute = function (val) {\r\n    return val && (val.nodeType === 2 || val.ownerElement);\r\n}\r\n\r\nUtilities.splitQName = function(qn) {\r\n\tvar i = qn.indexOf(\":\");\r\n\tif (i == -1) {\r\n\t\treturn [ null, qn ];\r\n\t}\r\n\treturn [ qn.substring(0, i), qn.substring(i + 1) ];\r\n};\r\n\r\nUtilities.resolveQName = function(qn, nr, n, useDefault) {\r\n\tvar parts = Utilities.splitQName(qn);\r\n\tif (parts[0] != null) {\r\n\t\tparts[0] = nr.getNamespace(parts[0], n);\r\n\t} else {\r\n\t\tif (useDefault) {\r\n\t\t\tparts[0] = nr.getNamespace(\"\", n);\r\n\t\t\tif (parts[0] == null) {\r\n\t\t\t\tparts[0] = \"\";\r\n\t\t\t}\r\n\t\t} else {\r\n\t\t\tparts[0] = \"\";\r\n\t\t}\r\n\t}\r\n\treturn parts;\r\n};\r\n\r\nUtilities.isSpace = function(c) {\r\n\treturn c == 0x9 || c == 0xd || c == 0xa || c == 0x20;\r\n};\r\n\r\nUtilities.isLetter = function(c) {\r\n\treturn c >= 0x0041 && c <= 0x005A ||\r\n\t\tc >= 0x0061 && c <= 0x007A ||\r\n\t\tc >= 0x00C0 && c <= 0x00D6 ||\r\n\t\tc >= 0x00D8 && c <= 0x00F6 ||\r\n\t\tc >= 0x00F8 && c <= 0x00FF ||\r\n\t\tc >= 0x0100 && c <= 0x0131 ||\r\n\t\tc >= 0x0134 && c <= 0x013E ||\r\n\t\tc >= 0x0141 && c <= 0x0148 ||\r\n\t\tc >= 0x014A && c <= 0x017E ||\r\n\t\tc >= 0x0180 && c <= 0x01C3 ||\r\n\t\tc >= 0x01CD && c <= 0x01F0 ||\r\n\t\tc >= 0x01F4 && c <= 0x01F5 ||\r\n\t\tc >= 0x01FA && c <= 0x0217 ||\r\n\t\tc >= 0x0250 && c <= 0x02A8 ||\r\n\t\tc >= 0x02BB && c <= 0x02C1 ||\r\n\t\tc == 0x0386 ||\r\n\t\tc >= 0x0388 && c <= 0x038A ||\r\n\t\tc == 0x038C ||\r\n\t\tc >= 0x038E && c <= 0x03A1 ||\r\n\t\tc >= 0x03A3 && c <= 0x03CE ||\r\n\t\tc >= 0x03D0 && c <= 0x03D6 ||\r\n\t\tc == 0x03DA ||\r\n\t\tc == 0x03DC ||\r\n\t\tc == 0x03DE ||\r\n\t\tc == 0x03E0 ||\r\n\t\tc >= 0x03E2 && c <= 0x03F3 ||\r\n\t\tc >= 0x0401 && c <= 0x040C ||\r\n\t\tc >= 0x040E && c <= 0x044F ||\r\n\t\tc >= 0x0451 && c <= 0x045C ||\r\n\t\tc >= 0x045E && c <= 0x0481 ||\r\n\t\tc >= 0x0490 && c <= 0x04C4 ||\r\n\t\tc >= 0x04C7 && c <= 0x04C8 ||\r\n\t\tc >= 0x04CB && c <= 0x04CC ||\r\n\t\tc >= 0x04D0 && c <= 0x04EB ||\r\n\t\tc >= 0x04EE && c <= 0x04F5 ||\r\n\t\tc >= 0x04F8 && c <= 0x04F9 ||\r\n\t\tc >= 0x0531 && c <= 0x0556 ||\r\n\t\tc == 0x0559 ||\r\n\t\tc >= 0x0561 && c <= 0x0586 ||\r\n\t\tc >= 0x05D0 && c <= 0x05EA ||\r\n\t\tc >= 0x05F0 && c <= 0x05F2 ||\r\n\t\tc >= 0x0621 && c <= 0x063A ||\r\n\t\tc >= 0x0641 && c <= 0x064A ||\r\n\t\tc >= 0x0671 && c <= 0x06B7 ||\r\n\t\tc >= 0x06BA && c <= 0x06BE ||\r\n\t\tc >= 0x06C0 && c <= 0x06CE ||\r\n\t\tc >= 0x06D0 && c <= 0x06D3 ||\r\n\t\tc == 0x06D5 ||\r\n\t\tc >= 0x06E5 && c <= 0x06E6 ||\r\n\t\tc >= 0x0905 && c <= 0x0939 ||\r\n\t\tc == 0x093D ||\r\n\t\tc >= 0x0958 && c <= 0x0961 ||\r\n\t\tc >= 0x0985 && c <= 0x098C ||\r\n\t\tc >= 0x098F && c <= 0x0990 ||\r\n\t\tc >= 0x0993 && c <= 0x09A8 ||\r\n\t\tc >= 0x09AA && c <= 0x09B0 ||\r\n\t\tc == 0x09B2 ||\r\n\t\tc >= 0x09B6 && c <= 0x09B9 ||\r\n\t\tc >= 0x09DC && c <= 0x09DD ||\r\n\t\tc >= 0x09DF && c <= 0x09E1 ||\r\n\t\tc >= 0x09F0 && c <= 0x09F1 ||\r\n\t\tc >= 0x0A05 && c <= 0x0A0A ||\r\n\t\tc >= 0x0A0F && c <= 0x0A10 ||\r\n\t\tc >= 0x0A13 && c <= 0x0A28 ||\r\n\t\tc >= 0x0A2A && c <= 0x0A30 ||\r\n\t\tc >= 0x0A32 && c <= 0x0A33 ||\r\n\t\tc >= 0x0A35 && c <= 0x0A36 ||\r\n\t\tc >= 0x0A38 && c <= 0x0A39 ||\r\n\t\tc >= 0x0A59 && c <= 0x0A5C ||\r\n\t\tc == 0x0A5E ||\r\n\t\tc >= 0x0A72 && c <= 0x0A74 ||\r\n\t\tc >= 0x0A85 && c <= 0x0A8B ||\r\n\t\tc == 0x0A8D ||\r\n\t\tc >= 0x0A8F && c <= 0x0A91 ||\r\n\t\tc >= 0x0A93 && c <= 0x0AA8 ||\r\n\t\tc >= 0x0AAA && c <= 0x0AB0 ||\r\n\t\tc >= 0x0AB2 && c <= 0x0AB3 ||\r\n\t\tc >= 0x0AB5 && c <= 0x0AB9 ||\r\n\t\tc == 0x0ABD ||\r\n\t\tc == 0x0AE0 ||\r\n\t\tc >= 0x0B05 && c <= 0x0B0C ||\r\n\t\tc >= 0x0B0F && c <= 0x0B10 ||\r\n\t\tc >= 0x0B13 && c <= 0x0B28 ||\r\n\t\tc >= 0x0B2A && c <= 0x0B30 ||\r\n\t\tc >= 0x0B32 && c <= 0x0B33 ||\r\n\t\tc >= 0x0B36 && c <= 0x0B39 ||\r\n\t\tc == 0x0B3D ||\r\n\t\tc >= 0x0B5C && c <= 0x0B5D ||\r\n\t\tc >= 0x0B5F && c <= 0x0B61 ||\r\n\t\tc >= 0x0B85 && c <= 0x0B8A ||\r\n\t\tc >= 0x0B8E && c <= 0x0B90 ||\r\n\t\tc >= 0x0B92 && c <= 0x0B95 ||\r\n\t\tc >= 0x0B99 && c <= 0x0B9A ||\r\n\t\tc == 0x0B9C ||\r\n\t\tc >= 0x0B9E && c <= 0x0B9F ||\r\n\t\tc >= 0x0BA3 && c <= 0x0BA4 ||\r\n\t\tc >= 0x0BA8 && c <= 0x0BAA ||\r\n\t\tc >= 0x0BAE && c <= 0x0BB5 ||\r\n\t\tc >= 0x0BB7 && c <= 0x0BB9 ||\r\n\t\tc >= 0x0C05 && c <= 0x0C0C ||\r\n\t\tc >= 0x0C0E && c <= 0x0C10 ||\r\n\t\tc >= 0x0C12 && c <= 0x0C28 ||\r\n\t\tc >= 0x0C2A && c <= 0x0C33 ||\r\n\t\tc >= 0x0C35 && c <= 0x0C39 ||\r\n\t\tc >= 0x0C60 && c <= 0x0C61 ||\r\n\t\tc >= 0x0C85 && c <= 0x0C8C ||\r\n\t\tc >= 0x0C8E && c <= 0x0C90 ||\r\n\t\tc >= 0x0C92 && c <= 0x0CA8 ||\r\n\t\tc >= 0x0CAA && c <= 0x0CB3 ||\r\n\t\tc >= 0x0CB5 && c <= 0x0CB9 ||\r\n\t\tc == 0x0CDE ||\r\n\t\tc >= 0x0CE0 && c <= 0x0CE1 ||\r\n\t\tc >= 0x0D05 && c <= 0x0D0C ||\r\n\t\tc >= 0x0D0E && c <= 0x0D10 ||\r\n\t\tc >= 0x0D12 && c <= 0x0D28 ||\r\n\t\tc >= 0x0D2A && c <= 0x0D39 ||\r\n\t\tc >= 0x0D60 && c <= 0x0D61 ||\r\n\t\tc >= 0x0E01 && c <= 0x0E2E ||\r\n\t\tc == 0x0E30 ||\r\n\t\tc >= 0x0E32 && c <= 0x0E33 ||\r\n\t\tc >= 0x0E40 && c <= 0x0E45 ||\r\n\t\tc >= 0x0E81 && c <= 0x0E82 ||\r\n\t\tc == 0x0E84 ||\r\n\t\tc >= 0x0E87 && c <= 0x0E88 ||\r\n\t\tc == 0x0E8A ||\r\n\t\tc == 0x0E8D ||\r\n\t\tc >= 0x0E94 && c <= 0x0E97 ||\r\n\t\tc >= 0x0E99 && c <= 0x0E9F ||\r\n\t\tc >= 0x0EA1 && c <= 0x0EA3 ||\r\n\t\tc == 0x0EA5 ||\r\n\t\tc == 0x0EA7 ||\r\n\t\tc >= 0x0EAA && c <= 0x0EAB ||\r\n\t\tc >= 0x0EAD && c <= 0x0EAE ||\r\n\t\tc == 0x0EB0 ||\r\n\t\tc >= 0x0EB2 && c <= 0x0EB3 ||\r\n\t\tc == 0x0EBD ||\r\n\t\tc >= 0x0EC0 && c <= 0x0EC4 ||\r\n\t\tc >= 0x0F40 && c <= 0x0F47 ||\r\n\t\tc >= 0x0F49 && c <= 0x0F69 ||\r\n\t\tc >= 0x10A0 && c <= 0x10C5 ||\r\n\t\tc >= 0x10D0 && c <= 0x10F6 ||\r\n\t\tc == 0x1100 ||\r\n\t\tc >= 0x1102 && c <= 0x1103 ||\r\n\t\tc >= 0x1105 && c <= 0x1107 ||\r\n\t\tc == 0x1109 ||\r\n\t\tc >= 0x110B && c <= 0x110C ||\r\n\t\tc >= 0x110E && c <= 0x1112 ||\r\n\t\tc == 0x113C ||\r\n\t\tc == 0x113E ||\r\n\t\tc == 0x1140 ||\r\n\t\tc == 0x114C ||\r\n\t\tc == 0x114E ||\r\n\t\tc == 0x1150 ||\r\n\t\tc >= 0x1154 && c <= 0x1155 ||\r\n\t\tc == 0x1159 ||\r\n\t\tc >= 0x115F && c <= 0x1161 ||\r\n\t\tc == 0x1163 ||\r\n\t\tc == 0x1165 ||\r\n\t\tc == 0x1167 ||\r\n\t\tc == 0x1169 ||\r\n\t\tc >= 0x116D && c <= 0x116E ||\r\n\t\tc >= 0x1172 && c <= 0x1173 ||\r\n\t\tc == 0x1175 ||\r\n\t\tc == 0x119E ||\r\n\t\tc == 0x11A8 ||\r\n\t\tc == 0x11AB ||\r\n\t\tc >= 0x11AE && c <= 0x11AF ||\r\n\t\tc >= 0x11B7 && c <= 0x11B8 ||\r\n\t\tc == 0x11BA ||\r\n\t\tc >= 0x11BC && c <= 0x11C2 ||\r\n\t\tc == 0x11EB ||\r\n\t\tc == 0x11F0 ||\r\n\t\tc == 0x11F9 ||\r\n\t\tc >= 0x1E00 && c <= 0x1E9B ||\r\n\t\tc >= 0x1EA0 && c <= 0x1EF9 ||\r\n\t\tc >= 0x1F00 && c <= 0x1F15 ||\r\n\t\tc >= 0x1F18 && c <= 0x1F1D ||\r\n\t\tc >= 0x1F20 && c <= 0x1F45 ||\r\n\t\tc >= 0x1F48 && c <= 0x1F4D ||\r\n\t\tc >= 0x1F50 && c <= 0x1F57 ||\r\n\t\tc == 0x1F59 ||\r\n\t\tc == 0x1F5B ||\r\n\t\tc == 0x1F5D ||\r\n\t\tc >= 0x1F5F && c <= 0x1F7D ||\r\n\t\tc >= 0x1F80 && c <= 0x1FB4 ||\r\n\t\tc >= 0x1FB6 && c <= 0x1FBC ||\r\n\t\tc == 0x1FBE ||\r\n\t\tc >= 0x1FC2 && c <= 0x1FC4 ||\r\n\t\tc >= 0x1FC6 && c <= 0x1FCC ||\r\n\t\tc >= 0x1FD0 && c <= 0x1FD3 ||\r\n\t\tc >= 0x1FD6 && c <= 0x1FDB ||\r\n\t\tc >= 0x1FE0 && c <= 0x1FEC ||\r\n\t\tc >= 0x1FF2 && c <= 0x1FF4 ||\r\n\t\tc >= 0x1FF6 && c <= 0x1FFC ||\r\n\t\tc == 0x2126 ||\r\n\t\tc >= 0x212A && c <= 0x212B ||\r\n\t\tc == 0x212E ||\r\n\t\tc >= 0x2180 && c <= 0x2182 ||\r\n\t\tc >= 0x3041 && c <= 0x3094 ||\r\n\t\tc >= 0x30A1 && c <= 0x30FA ||\r\n\t\tc >= 0x3105 && c <= 0x312C ||\r\n\t\tc >= 0xAC00 && c <= 0xD7A3 ||\r\n\t\tc >= 0x4E00 && c <= 0x9FA5 ||\r\n\t\tc == 0x3007 ||\r\n\t\tc >= 0x3021 && c <= 0x3029;\r\n};\r\n\r\nUtilities.isNCNameChar = function(c) {\r\n\treturn c >= 0x0030 && c <= 0x0039\r\n\t\t|| c >= 0x0660 && c <= 0x0669\r\n\t\t|| c >= 0x06F0 && c <= 0x06F9\r\n\t\t|| c >= 0x0966 && c <= 0x096F\r\n\t\t|| c >= 0x09E6 && c <= 0x09EF\r\n\t\t|| c >= 0x0A66 && c <= 0x0A6F\r\n\t\t|| c >= 0x0AE6 && c <= 0x0AEF\r\n\t\t|| c >= 0x0B66 && c <= 0x0B6F\r\n\t\t|| c >= 0x0BE7 && c <= 0x0BEF\r\n\t\t|| c >= 0x0C66 && c <= 0x0C6F\r\n\t\t|| c >= 0x0CE6 && c <= 0x0CEF\r\n\t\t|| c >= 0x0D66 && c <= 0x0D6F\r\n\t\t|| c >= 0x0E50 && c <= 0x0E59\r\n\t\t|| c >= 0x0ED0 && c <= 0x0ED9\r\n\t\t|| c >= 0x0F20 && c <= 0x0F29\r\n\t\t|| c == 0x002E\r\n\t\t|| c == 0x002D\r\n\t\t|| c == 0x005F\r\n\t\t|| Utilities.isLetter(c)\r\n\t\t|| c >= 0x0300 && c <= 0x0345\r\n\t\t|| c >= 0x0360 && c <= 0x0361\r\n\t\t|| c >= 0x0483 && c <= 0x0486\r\n\t\t|| c >= 0x0591 && c <= 0x05A1\r\n\t\t|| c >= 0x05A3 && c <= 0x05B9\r\n\t\t|| c >= 0x05BB && c <= 0x05BD\r\n\t\t|| c == 0x05BF\r\n\t\t|| c >= 0x05C1 && c <= 0x05C2\r\n\t\t|| c == 0x05C4\r\n\t\t|| c >= 0x064B && c <= 0x0652\r\n\t\t|| c == 0x0670\r\n\t\t|| c >= 0x06D6 && c <= 0x06DC\r\n\t\t|| c >= 0x06DD && c <= 0x06DF\r\n\t\t|| c >= 0x06E0 && c <= 0x06E4\r\n\t\t|| c >= 0x06E7 && c <= 0x06E8\r\n\t\t|| c >= 0x06EA && c <= 0x06ED\r\n\t\t|| c >= 0x0901 && c <= 0x0903\r\n\t\t|| c == 0x093C\r\n\t\t|| c >= 0x093E && c <= 0x094C\r\n\t\t|| c == 0x094D\r\n\t\t|| c >= 0x0951 && c <= 0x0954\r\n\t\t|| c >= 0x0962 && c <= 0x0963\r\n\t\t|| c >= 0x0981 && c <= 0x0983\r\n\t\t|| c == 0x09BC\r\n\t\t|| c == 0x09BE\r\n\t\t|| c == 0x09BF\r\n\t\t|| c >= 0x09C0 && c <= 0x09C4\r\n\t\t|| c >= 0x09C7 && c <= 0x09C8\r\n\t\t|| c >= 0x09CB && c <= 0x09CD\r\n\t\t|| c == 0x09D7\r\n\t\t|| c >= 0x09E2 && c <= 0x09E3\r\n\t\t|| c == 0x0A02\r\n\t\t|| c == 0x0A3C\r\n\t\t|| c == 0x0A3E\r\n\t\t|| c == 0x0A3F\r\n\t\t|| c >= 0x0A40 && c <= 0x0A42\r\n\t\t|| c >= 0x0A47 && c <= 0x0A48\r\n\t\t|| c >= 0x0A4B && c <= 0x0A4D\r\n\t\t|| c >= 0x0A70 && c <= 0x0A71\r\n\t\t|| c >= 0x0A81 && c <= 0x0A83\r\n\t\t|| c == 0x0ABC\r\n\t\t|| c >= 0x0ABE && c <= 0x0AC5\r\n\t\t|| c >= 0x0AC7 && c <= 0x0AC9\r\n\t\t|| c >= 0x0ACB && c <= 0x0ACD\r\n\t\t|| c >= 0x0B01 && c <= 0x0B03\r\n\t\t|| c == 0x0B3C\r\n\t\t|| c >= 0x0B3E && c <= 0x0B43\r\n\t\t|| c >= 0x0B47 && c <= 0x0B48\r\n\t\t|| c >= 0x0B4B && c <= 0x0B4D\r\n\t\t|| c >= 0x0B56 && c <= 0x0B57\r\n\t\t|| c >= 0x0B82 && c <= 0x0B83\r\n\t\t|| c >= 0x0BBE && c <= 0x0BC2\r\n\t\t|| c >= 0x0BC6 && c <= 0x0BC8\r\n\t\t|| c >= 0x0BCA && c <= 0x0BCD\r\n\t\t|| c == 0x0BD7\r\n\t\t|| c >= 0x0C01 && c <= 0x0C03\r\n\t\t|| c >= 0x0C3E && c <= 0x0C44\r\n\t\t|| c >= 0x0C46 && c <= 0x0C48\r\n\t\t|| c >= 0x0C4A && c <= 0x0C4D\r\n\t\t|| c >= 0x0C55 && c <= 0x0C56\r\n\t\t|| c >= 0x0C82 && c <= 0x0C83\r\n\t\t|| c >= 0x0CBE && c <= 0x0CC4\r\n\t\t|| c >= 0x0CC6 && c <= 0x0CC8\r\n\t\t|| c >= 0x0CCA && c <= 0x0CCD\r\n\t\t|| c >= 0x0CD5 && c <= 0x0CD6\r\n\t\t|| c >= 0x0D02 && c <= 0x0D03\r\n\t\t|| c >= 0x0D3E && c <= 0x0D43\r\n\t\t|| c >= 0x0D46 && c <= 0x0D48\r\n\t\t|| c >= 0x0D4A && c <= 0x0D4D\r\n\t\t|| c == 0x0D57\r\n\t\t|| c == 0x0E31\r\n\t\t|| c >= 0x0E34 && c <= 0x0E3A\r\n\t\t|| c >= 0x0E47 && c <= 0x0E4E\r\n\t\t|| c == 0x0EB1\r\n\t\t|| c >= 0x0EB4 && c <= 0x0EB9\r\n\t\t|| c >= 0x0EBB && c <= 0x0EBC\r\n\t\t|| c >= 0x0EC8 && c <= 0x0ECD\r\n\t\t|| c >= 0x0F18 && c <= 0x0F19\r\n\t\t|| c == 0x0F35\r\n\t\t|| c == 0x0F37\r\n\t\t|| c == 0x0F39\r\n\t\t|| c == 0x0F3E\r\n\t\t|| c == 0x0F3F\r\n\t\t|| c >= 0x0F71 && c <= 0x0F84\r\n\t\t|| c >= 0x0F86 && c <= 0x0F8B\r\n\t\t|| c >= 0x0F90 && c <= 0x0F95\r\n\t\t|| c == 0x0F97\r\n\t\t|| c >= 0x0F99 && c <= 0x0FAD\r\n\t\t|| c >= 0x0FB1 && c <= 0x0FB7\r\n\t\t|| c == 0x0FB9\r\n\t\t|| c >= 0x20D0 && c <= 0x20DC\r\n\t\t|| c == 0x20E1\r\n\t\t|| c >= 0x302A && c <= 0x302F\r\n\t\t|| c == 0x3099\r\n\t\t|| c == 0x309A\r\n\t\t|| c == 0x00B7\r\n\t\t|| c == 0x02D0\r\n\t\t|| c == 0x02D1\r\n\t\t|| c == 0x0387\r\n\t\t|| c == 0x0640\r\n\t\t|| c == 0x0E46\r\n\t\t|| c == 0x0EC6\r\n\t\t|| c == 0x3005\r\n\t\t|| c >= 0x3031 && c <= 0x3035\r\n\t\t|| c >= 0x309D && c <= 0x309E\r\n\t\t|| c >= 0x30FC && c <= 0x30FE;\r\n};\r\n\r\nUtilities.coalesceText = function(n) {\r\n\tfor (var m = n.firstChild; m != null; m = m.nextSibling) {\r\n\t\tif (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {\r\n\t\t\tvar s = m.nodeValue;\r\n\t\t\tvar first = m;\r\n\t\t\tm = m.nextSibling;\r\n\t\t\twhile (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {\r\n\t\t\t\ts += m.nodeValue;\r\n\t\t\t\tvar del = m;\r\n\t\t\t\tm = m.nextSibling;\r\n\t\t\t\tdel.parentNode.removeChild(del);\r\n\t\t\t}\r\n\t\t\tif (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {\r\n\t\t\t\tvar p = first.parentNode;\r\n\t\t\t\tif (first.nextSibling == null) {\r\n\t\t\t\t\tp.removeChild(first);\r\n\t\t\t\t\tp.appendChild(p.ownerDocument.createTextNode(s));\r\n\t\t\t\t} else {\r\n\t\t\t\t\tvar next = first.nextSibling;\r\n\t\t\t\t\tp.removeChild(first);\r\n\t\t\t\t\tp.insertBefore(p.ownerDocument.createTextNode(s), next);\r\n\t\t\t\t}\r\n\t\t\t} else {\r\n\t\t\t\tfirst.nodeValue = s;\r\n\t\t\t}\r\n\t\t\tif (m == null) {\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {\r\n\t\t\tUtilities.coalesceText(m);\r\n\t\t}\r\n\t}\r\n};\r\n\r\nUtilities.instance_of = function(o, c) {\r\n\twhile (o != null) {\r\n\t\tif (o.constructor === c) {\r\n\t\t\treturn true;\r\n\t\t}\r\n\t\tif (o === Object) {\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\to = o.constructor.superclass;\r\n\t}\r\n\treturn false;\r\n};\r\n\r\nUtilities.getElementById = function(n, id) {\r\n\t// Note that this does not check the DTD to check for actual\r\n\t// attributes of type ID, so this may be a bit wrong.\r\n\tif (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {\r\n\t\tif (n.getAttribute(\"id\") == id\r\n\t\t\t\t|| n.getAttributeNS(null, \"id\") == id) {\r\n\t\t\treturn n;\r\n\t\t}\r\n\t}\r\n\tfor (var m = n.firstChild; m != null; m = m.nextSibling) {\r\n\t\tvar res = Utilities.getElementById(m, id);\r\n\t\tif (res != null) {\r\n\t\t\treturn res;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n};\r\n\r\n// XPathException ////////////////////////////////////////////////////////////\r\n\r\nvar XPathException = (function () {\r\n    function getMessage(code, exception) {\r\n        var msg = exception ? \": \" + exception.toString() : \"\";\r\n        switch (code) {\r\n            case XPathException.INVALID_EXPRESSION_ERR:\r\n                return \"Invalid expression\" + msg;\r\n            case XPathException.TYPE_ERR:\r\n                return \"Type error\" + msg;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    function XPathException(code, error, message) {\r\n        var err = Error.call(this, getMessage(code, error) || message);\r\n\r\n        err.code = code;\r\n        err.exception = error;\r\n\r\n        return err;\r\n    }\r\n\r\n    XPathException.prototype = Object.create(Error.prototype);\r\n    XPathException.prototype.constructor = XPathException;\r\n    XPathException.superclass = Error;\r\n\r\n    XPathException.prototype.toString = function() {\r\n        return this.message;\r\n    };\r\n\r\n    XPathException.fromMessage = function(message, error) {\r\n        return new XPathException(null, error, message);\r\n    };\r\n\r\n    XPathException.INVALID_EXPRESSION_ERR = 51;\r\n    XPathException.TYPE_ERR = 52;\r\n\r\n    return XPathException;\r\n})();\r\n\r\n// XPathExpression ///////////////////////////////////////////////////////////\r\n\r\nXPathExpression.prototype = {};\r\nXPathExpression.prototype.constructor = XPathExpression;\r\nXPathExpression.superclass = Object.prototype;\r\n\r\nfunction XPathExpression(e, r, p) {\r\n\tthis.xpath = p.parse(e);\r\n\tthis.context = new XPathContext();\r\n\tthis.context.namespaceResolver = new XPathNSResolverWrapper(r);\r\n}\r\n\r\nXPathExpression.getOwnerDocument = function (n) {\r\n\treturn n.nodeType === 9 /*Node.DOCUMENT_NODE*/ ? n : n.ownerDocument;\r\n}\r\n\r\nXPathExpression.detectHtmlDom = function (n) {\r\n\tif (!n) { return false; }\r\n\t\r\n\tvar doc = XPathExpression.getOwnerDocument(n);\r\n\t\r\n\ttry {\r\n\t\treturn doc.implementation.hasFeature(\"HTML\", \"2.0\");\r\n\t} catch (e) {\r\n\t\treturn true;\r\n\t}\r\n}\r\n\r\nXPathExpression.prototype.evaluate = function(n, t, res) {\r\n\tthis.context.expressionContextNode = n;\r\n\t// backward compatibility - no reliable way to detect whether the DOM is HTML, but\r\n\t// this library has been using this method up until now, so we will continue to use it\r\n\t// ONLY when using an XPathExpression\r\n\tthis.context.caseInsensitive = XPathExpression.detectHtmlDom(n);\r\n\t\r\n\tvar result = this.xpath.evaluate(this.context);\r\n\treturn new XPathResult(result, t);\r\n}\r\n\r\n// XPathNSResolverWrapper ////////////////////////////////////////////////////\r\n\r\nXPathNSResolverWrapper.prototype = {};\r\nXPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;\r\nXPathNSResolverWrapper.superclass = Object.prototype;\r\n\r\nfunction XPathNSResolverWrapper(r) {\r\n\tthis.xpathNSResolver = r;\r\n}\r\n\r\nXPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {\r\n    if (this.xpathNSResolver == null) {\r\n        return null;\r\n    }\r\n\treturn this.xpathNSResolver.lookupNamespaceURI(prefix);\r\n};\r\n\r\n// NodeXPathNSResolver ///////////////////////////////////////////////////////\r\n\r\nNodeXPathNSResolver.prototype = {};\r\nNodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;\r\nNodeXPathNSResolver.superclass = Object.prototype;\r\n\r\nfunction NodeXPathNSResolver(n) {\r\n\tthis.node = n;\r\n\tthis.namespaceResolver = new NamespaceResolver();\r\n}\r\n\r\nNodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {\r\n\treturn this.namespaceResolver.getNamespace(prefix, this.node);\r\n};\r\n\r\n// XPathResult ///////////////////////////////////////////////////////////////\r\n\r\nXPathResult.prototype = {};\r\nXPathResult.prototype.constructor = XPathResult;\r\nXPathResult.superclass = Object.prototype;\r\n\r\nfunction XPathResult(v, t) {\r\n\tif (t == XPathResult.ANY_TYPE) {\r\n\t\tif (v.constructor === XString) {\r\n\t\t\tt = XPathResult.STRING_TYPE;\r\n\t\t} else if (v.constructor === XNumber) {\r\n\t\t\tt = XPathResult.NUMBER_TYPE;\r\n\t\t} else if (v.constructor === XBoolean) {\r\n\t\t\tt = XPathResult.BOOLEAN_TYPE;\r\n\t\t} else if (v.constructor === XNodeSet) {\r\n\t\t\tt = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;\r\n\t\t}\r\n\t}\r\n\tthis.resultType = t;\r\n\tswitch (t) {\r\n\t\tcase XPathResult.NUMBER_TYPE:\r\n\t\t\tthis.numberValue = v.numberValue();\r\n\t\t\treturn;\r\n\t\tcase XPathResult.STRING_TYPE:\r\n\t\t\tthis.stringValue = v.stringValue();\r\n\t\t\treturn;\r\n\t\tcase XPathResult.BOOLEAN_TYPE:\r\n\t\t\tthis.booleanValue = v.booleanValue();\r\n\t\t\treturn;\r\n\t\tcase XPathResult.ANY_UNORDERED_NODE_TYPE:\r\n\t\tcase XPathResult.FIRST_ORDERED_NODE_TYPE:\r\n\t\t\tif (v.constructor === XNodeSet) {\r\n\t\t\t\tthis.singleNodeValue = v.first();\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase XPathResult.UNORDERED_NODE_ITERATOR_TYPE:\r\n\t\tcase XPathResult.ORDERED_NODE_ITERATOR_TYPE:\r\n\t\t\tif (v.constructor === XNodeSet) {\r\n\t\t\t\tthis.invalidIteratorState = false;\r\n\t\t\t\tthis.nodes = v.toArray();\r\n\t\t\t\tthis.iteratorIndex = 0;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t\tcase XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:\r\n\t\tcase XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:\r\n\t\t\tif (v.constructor === XNodeSet) {\r\n\t\t\t\tthis.nodes = v.toArray();\r\n\t\t\t\tthis.snapshotLength = this.nodes.length;\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbreak;\r\n\t}\r\n\tthrow new XPathException(XPathException.TYPE_ERR);\r\n};\r\n\r\nXPathResult.prototype.iterateNext = function() {\r\n\tif (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE\r\n\t\t\t&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {\r\n\t\tthrow new XPathException(XPathException.TYPE_ERR);\r\n\t}\r\n\treturn this.nodes[this.iteratorIndex++];\r\n};\r\n\r\nXPathResult.prototype.snapshotItem = function(i) {\r\n\tif (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE\r\n\t\t\t&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {\r\n\t\tthrow new XPathException(XPathException.TYPE_ERR);\r\n\t}\r\n\treturn this.nodes[i];\r\n};\r\n\r\nXPathResult.ANY_TYPE = 0;\r\nXPathResult.NUMBER_TYPE = 1;\r\nXPathResult.STRING_TYPE = 2;\r\nXPathResult.BOOLEAN_TYPE = 3;\r\nXPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;\r\nXPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;\r\nXPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;\r\nXPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;\r\nXPathResult.ANY_UNORDERED_NODE_TYPE = 8;\r\nXPathResult.FIRST_ORDERED_NODE_TYPE = 9;\r\n\r\n// DOM 3 XPath support ///////////////////////////////////////////////////////\r\n\r\nfunction installDOM3XPathSupport(doc, p) {\r\n\tdoc.createExpression = function(e, r) {\r\n\t\ttry {\r\n\t\t\treturn new XPathExpression(e, r, p);\r\n\t\t} catch (e) {\r\n\t\t\tthrow new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);\r\n\t\t}\r\n\t};\r\n\tdoc.createNSResolver = function(n) {\r\n\t\treturn new NodeXPathNSResolver(n);\r\n\t};\r\n\tdoc.evaluate = function(e, cn, r, t, res) {\r\n\t\tif (t < 0 || t > 9) {\r\n\t\t\tthrow { code: 0, toString: function() { return \"Request type not supported\"; } };\r\n\t\t}\r\n        return doc.createExpression(e, r, p).evaluate(cn, t, res);\r\n\t};\r\n};\r\n\r\n// ---------------------------------------------------------------------------\r\n\r\n// Install DOM 3 XPath support for the current document.\r\ntry {\r\n\tvar shouldInstall = true;\r\n\ttry {\r\n\t\tif (document.implementation\r\n\t\t\t\t&& document.implementation.hasFeature\r\n\t\t\t\t&& document.implementation.hasFeature(\"XPath\", null)) {\r\n\t\t\tshouldInstall = false;\r\n\t\t}\r\n\t} catch (e) {\r\n\t}\r\n\tif (shouldInstall) {\r\n\t\tinstallDOM3XPathSupport(document, new XPathParser());\r\n\t}\r\n} catch (e) {\r\n}\r\n\r\n// ---------------------------------------------------------------------------\r\n// exports for node.js\r\n\r\ninstallDOM3XPathSupport(exports, new XPathParser());\r\n\r\n(function() {\r\n    var parser = new XPathParser();\r\n\r\n    var defaultNSResolver = new NamespaceResolver();\r\n    var defaultFunctionResolver = new FunctionResolver();\r\n    var defaultVariableResolver = new VariableResolver();\r\n\r\n    function makeNSResolverFromFunction(func) {\r\n        return {\r\n            getNamespace: function (prefix, node) {\r\n                var ns = func(prefix, node);\r\n\r\n                return ns || defaultNSResolver.getNamespace(prefix, node);\r\n            }\r\n        };\r\n    }\r\n\r\n    function makeNSResolverFromObject(obj) {\r\n        return makeNSResolverFromFunction(obj.getNamespace.bind(obj));\r\n    }\r\n\r\n    function makeNSResolverFromMap(map) {\r\n        return makeNSResolverFromFunction(function (prefix) {\r\n            return map[prefix];\r\n        });\r\n    }\r\n\r\n    function makeNSResolver(resolver) {\r\n        if (resolver && typeof resolver.getNamespace === \"function\") {\r\n            return makeNSResolverFromObject(resolver);\r\n        }\r\n\r\n        if (typeof resolver === \"function\") {\r\n            return makeNSResolverFromFunction(resolver);\r\n        }\r\n\r\n        // assume prefix -> uri mapping\r\n        if (typeof resolver === \"object\") {\r\n            return makeNSResolverFromMap(resolver);\r\n        }\r\n\r\n        return defaultNSResolver;\r\n    }\r\n\r\n    /** Converts native JavaScript types to their XPath library equivalent */\r\n    function convertValue(value) {\r\n        if (value === null ||\r\n            typeof value === \"undefined\" ||\r\n            value instanceof XString ||\r\n            value instanceof XBoolean ||\r\n            value instanceof XNumber ||\r\n            value instanceof XNodeSet) {\r\n            return value;\r\n        }\r\n\r\n        switch (typeof value) {\r\n            case \"string\": return new XString(value);\r\n            case \"boolean\": return new XBoolean(value);\r\n            case \"number\": return new XNumber(value);\r\n        }\r\n\r\n        // assume node(s)\r\n        var ns = new XNodeSet();\r\n        ns.addArray([].concat(value));\r\n        return ns;\r\n    }\r\n\r\n    function makeEvaluator(func) {\r\n        return function (context) {\r\n            var args = Array.prototype.slice.call(arguments, 1).map(function (arg) {\r\n                return arg.evaluate(context);\r\n            });\r\n            var result = func.apply(this, [].concat(context, args));\r\n            return convertValue(result);\r\n        };\r\n    }\r\n\r\n    function makeFunctionResolverFromFunction(func) {\r\n        return {\r\n            getFunction: function (name, namespace) {\r\n                var found = func(name, namespace);\r\n                if (found) {\r\n                    return makeEvaluator(found);\r\n                }\r\n                return defaultFunctionResolver.getFunction(name, namespace);\r\n            }\r\n        };\r\n    }\r\n\r\n    function makeFunctionResolverFromObject(obj) {\r\n        return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));\r\n    }\r\n\r\n    function makeFunctionResolverFromMap(map) {\r\n        return makeFunctionResolverFromFunction(function (name) {\r\n            return map[name];\r\n        });\r\n    }\r\n\r\n    function makeFunctionResolver(resolver) {\r\n        if (resolver && typeof resolver.getFunction === \"function\") {\r\n            return makeFunctionResolverFromObject(resolver);\r\n        }\r\n\r\n        if (typeof resolver === \"function\") {\r\n            return makeFunctionResolverFromFunction(resolver);\r\n        }\r\n\r\n        // assume map\r\n        if (typeof resolver === \"object\") {\r\n            return makeFunctionResolverFromMap(resolver);\r\n        }\r\n\r\n        return defaultFunctionResolver;\r\n    }\r\n\r\n    function makeVariableResolverFromFunction(func) {\r\n        return {\r\n            getVariable: function (name, namespace) {\r\n                var value = func(name, namespace);\r\n                return convertValue(value);\r\n            }\r\n        };\r\n    }\r\n\r\n    function makeVariableResolver(resolver) {\r\n        if (resolver) {\r\n            if (typeof resolver.getVariable === \"function\") {\r\n                return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));\r\n            }\r\n\r\n            if (typeof resolver === \"function\") {\r\n                return makeVariableResolverFromFunction(resolver);\r\n            }\r\n\r\n            // assume map\r\n            if (typeof resolver === \"object\") {\r\n                return makeVariableResolverFromFunction(function (name) {\r\n                    return resolver[name];\r\n                });\r\n            }\r\n        }\r\n\r\n        return defaultVariableResolver;\r\n    }\r\n\t\r\n\tfunction copyIfPresent(prop, dest, source) {\r\n\t\tif (prop in source) { dest[prop] = source[prop]; }\r\n\t}\r\n\r\n    function makeContext(options) {\r\n        var context = new XPathContext();\r\n\r\n        if (options) {\r\n            context.namespaceResolver = makeNSResolver(options.namespaces);\r\n            context.functionResolver = makeFunctionResolver(options.functions);\r\n            context.variableResolver = makeVariableResolver(options.variables);\r\n\t\t\tcontext.expressionContextNode = options.node;\r\n\t\t\tcopyIfPresent('allowAnyNamespaceForNoPrefix', context, options);\r\n\t\t\tcopyIfPresent('isHtml', context, options);\r\n        } else {\r\n            context.namespaceResolver = defaultNSResolver;\r\n        }\r\n\r\n        return context;\r\n    }\r\n\r\n    function evaluate(parsedExpression, options) {\r\n        var context = makeContext(options);\r\n\r\n        return parsedExpression.evaluate(context);\r\n    }\r\n\r\n    var evaluatorPrototype = {\r\n        evaluate: function (options) {\r\n            return evaluate(this.expression, options);\r\n        }\r\n\r\n        ,evaluateNumber: function (options) {\r\n            return this.evaluate(options).numberValue();\r\n        }\r\n\r\n        ,evaluateString: function (options) {\r\n            return this.evaluate(options).stringValue();\r\n        }\r\n\r\n        ,evaluateBoolean: function (options) {\r\n            return this.evaluate(options).booleanValue();\r\n        }\r\n\r\n        ,evaluateNodeSet: function (options) {\r\n            return this.evaluate(options).nodeset();\r\n        }\r\n\r\n        ,select: function (options) {\r\n            return this.evaluateNodeSet(options).toArray()\r\n        }\r\n\r\n        ,select1: function (options) {\r\n            return this.select(options)[0];\r\n        }\r\n    };\r\n\r\n    function parse(xpath) {\r\n        var parsed = parser.parse(xpath);\r\n\r\n        return Object.create(evaluatorPrototype, {\r\n            expression: {\r\n                value: parsed\r\n            }\r\n        });\r\n    }\r\n\r\n    exports.parse = parse;\r\n})();\r\n\r\nexports.XPath = XPath;\r\nexports.XPathParser = XPathParser;\r\nexports.XPathResult = XPathResult;\r\n\r\nexports.Step = Step;\r\nexports.NodeTest = NodeTest;\r\nexports.BarOperation = BarOperation;\r\n\r\nexports.NamespaceResolver = NamespaceResolver;\r\nexports.FunctionResolver = FunctionResolver;\r\nexports.VariableResolver = VariableResolver;\r\n\r\nexports.Utilities = Utilities;\r\n\r\nexports.XPathContext = XPathContext;\r\nexports.XNodeSet = XNodeSet;\r\nexports.XBoolean = XBoolean;\r\nexports.XString = XString;\r\nexports.XNumber = XNumber;\r\n\r\n// helper\r\nexports.select = function(e, doc, single) {\r\n\treturn exports.selectWithResolver(e, doc, null, single);\r\n};\r\n\r\nexports.useNamespaces = function(mappings) {\r\n\tvar resolver = {\r\n\t\tmappings: mappings || {},\r\n\t\tlookupNamespaceURI: function(prefix) {\r\n\t\t\treturn this.mappings[prefix];\r\n\t\t}\r\n\t};\r\n\r\n\treturn function(e, doc, single) {\r\n\t\treturn exports.selectWithResolver(e, doc, resolver, single);\r\n\t};\r\n};\r\n\r\nexports.selectWithResolver = function(e, doc, resolver, single) {\r\n\tvar expression = new XPathExpression(e, resolver, new XPathParser());\r\n\tvar type = XPathResult.ANY_TYPE;\r\n\r\n\tvar result = expression.evaluate(doc, type, null);\r\n\r\n\tif (result.resultType == XPathResult.STRING_TYPE) {\r\n\t\tresult = result.stringValue;\r\n\t}\r\n\telse if (result.resultType == XPathResult.NUMBER_TYPE) {\r\n\t\tresult = result.numberValue;\r\n\t}\r\n\telse if (result.resultType == XPathResult.BOOLEAN_TYPE) {\r\n\t\tresult = result.booleanValue;\r\n\t}\r\n\telse {\r\n\t\tresult = result.nodes;\r\n\t\tif (single) {\r\n\t\t\tresult = result[0];\r\n\t\t}\r\n\t}\r\n\r\n\treturn result;\r\n};\r\n\r\nexports.select1 = function(e, doc) {\r\n\treturn exports.select(e, doc, true);\r\n};\r\n\r\n// end non-node wrapper\r\n})(xpath);\r\n","module.exports = extend\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nfunction extend() {\n    var target = {}\n\n    for (var i = 0; i < arguments.length; i++) {\n        var source = arguments[i]\n\n        for (var key in source) {\n            if (hasOwnProperty.call(source, key)) {\n                target[key] = source[key]\n            }\n        }\n    }\n\n    return target\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Utils */\r\n\r\nimport { AccessToken } from \"./Token\";\r\nimport { Guid, ClientRequestContext, ClientRequestContextProps, GuidString } from \"@bentley/bentleyjs-core\";\r\n\r\n/** The properties of AuthorizedClientRequestContext.\r\n * @public\r\n */\r\nexport interface AuthorizedClientRequestContextProps extends ClientRequestContextProps {\r\n  accessToken: any;\r\n}\r\n\r\n/** Provides generic context for a server application to get details of a particular request that originated at the client.\r\n * This context includes an [[AccessToken]] that carries authorization information. For services that do not require authorization\r\n * it's sufficient to pass an instance of the base class [[ClientRequestContext]].\r\n * @see [ClientRequestContext rules]($docs/learning/backend/managingclientrequestcontext.md).\r\n * @see [[ClientRequestContext]]\r\n * @public\r\n */\r\nexport class AuthorizedClientRequestContext extends ClientRequestContext implements AuthorizedClientRequestContextProps {\r\n  /** The access token value of the client application.\r\n   * @beta\r\n   */\r\n  public accessToken: AccessToken;\r\n\r\n  /** Constructor\r\n   * @beta\r\n   */\r\n  public constructor(accessToken: AccessToken, activityId: GuidString = Guid.createValue(), applicationId: string = \"\", applicationVersion: string = \"\", sessionId: GuidString = Guid.empty) {\r\n    super(activityId, applicationId, applicationVersion, sessionId);\r\n    this.accessToken = accessToken;\r\n  }\r\n\r\n  /**\r\n   * @internal\r\n   */\r\n  public toJSON(): AuthorizedClientRequestContextProps {\r\n    const obj = super.toJSON() as AuthorizedClientRequestContextProps;\r\n    obj.accessToken = this.accessToken;\r\n    return obj;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module BaseClients */\r\nimport { ClientRequestContext, Logger } from \"@bentley/bentleyjs-core\";\r\nimport * as deepAssign from \"deep-assign\";\r\nimport { AuthorizedClientRequestContext } from \"./AuthorizedClientRequestContext\";\r\nimport { Config } from \"./Config\";\r\nimport { ClientsLoggerCategory } from \"./ClientsLoggerCategory\";\r\nimport { request, RequestOptions, Response, ResponseError } from \"./Request\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.Clients;\r\n\r\n/**\r\n * Provider for default RequestOptions, used by Client to set defaults.\r\n * @internal\r\n */\r\nexport class DefaultRequestOptionsProvider {\r\n  protected _defaultOptions: RequestOptions;\r\n  /** Creates an instance of DefaultRequestOptionsProvider and sets up the default options. */\r\n  constructor() {\r\n    this._defaultOptions = {\r\n      method: \"GET\",\r\n      useCorsProxy: false,\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Augments options with the provider's default values.\r\n   * @note The options passed in override any defaults where necessary.\r\n   * @param options Options that should be augmented.\r\n   */\r\n  public async assignOptions(options: RequestOptions): Promise<void> {\r\n    const clonedOptions: RequestOptions = Object.assign({}, options);\r\n    deepAssign(options, this._defaultOptions);\r\n    deepAssign(options, clonedOptions); // ensure the supplied options override the defaults\r\n    return Promise.resolve();\r\n  }\r\n}\r\n\r\n// @todo Setup a logging framework.\r\n/**\r\n * Base class for all Client implementations\r\n * @beta\r\n */\r\nexport abstract class Client {\r\n  private static _defaultRequestOptionsProvider: DefaultRequestOptionsProvider;\r\n  protected _url?: string;\r\n\r\n  /**  Creates an instance of Client. */\r\n  protected constructor() {\r\n  }\r\n\r\n  /**\r\n   * Augments request options with defaults returned by the DefaultRequestOptionsProvider.\r\n   * @note The options passed in by clients override any defaults where necessary.\r\n   * @param options Options the caller wants to eaugment with the defaults.\r\n   * @returns Promise resolves after the defaults are setup.\r\n   */\r\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\r\n    if (!Client._defaultRequestOptionsProvider)\r\n      Client._defaultRequestOptionsProvider = new DefaultRequestOptionsProvider();\r\n    return Client._defaultRequestOptionsProvider.assignOptions(options);\r\n  }\r\n\r\n  /**\r\n   * Implemented by clients to specify the name/key to query the service URLs from\r\n   * the URL Discovery Service (\"Buddi\")\r\n   * @returns Search key for the URL.\r\n   */\r\n  protected abstract getUrlSearchKey(): string; // same as the URL Discovery Service (\"Buddi\") name\r\n\r\n  /**\r\n   * Gets the URL of the service. Attempts to discover and cache the URL from the URL Discovery Service. If not\r\n   * found uses the default URL provided by client implementations. Note that for consistency\r\n   * sake, the URL is stripped of any trailing \"/\"\r\n   * @returns URL for the service\r\n   */\r\n  public async getUrl(requestContext: ClientRequestContext): Promise<string> {\r\n    if (this._url) {\r\n      return Promise.resolve(this._url);\r\n    }\r\n\r\n    const urlDiscoveryClient: UrlDiscoveryClient = new UrlDiscoveryClient();\r\n    const searchKey: string = this.getUrlSearchKey();\r\n    return urlDiscoveryClient.discoverUrl(requestContext, searchKey, undefined)\r\n      .then(async (url: string): Promise<string> => {\r\n        this._url = url;\r\n        return Promise.resolve(this._url); // TODO: On the server this really needs a lifetime!!\r\n      })\r\n      .catch(async (): Promise<string> => {\r\n        return Promise.reject(`Failed to discover URL for service identified by \"${searchKey}\"`);\r\n      });\r\n  }\r\n\r\n  /** used by clients to send delete requests */\r\n  protected async delete(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string): Promise<void> {\r\n    requestContext.enter();\r\n    const url: string = await this.getUrl(requestContext) + relativeUrlPath;\r\n    Logger.logInfo(loggerCategory, \"Sending DELETE request\", () => ({ url }));\r\n    const options: RequestOptions = {\r\n      method: \"DELETE\",\r\n      headers: { authorization: requestContext.accessToken.toTokenString() },\r\n    };\r\n    await this.setupOptionDefaults(options);\r\n    await request(requestContext, url, options);\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Successful DELETE request\", () => ({ url }));\r\n  }\r\n}\r\n\r\n/**\r\n * Error for issues with authentication.\r\n * @beta\r\n */\r\nexport class AuthenticationError extends ResponseError {\r\n}\r\n\r\n/**\r\n * Client API to discover URLs from the URL Discovery service (a.k.a. Buddi service)\r\n * @internal\r\n */\r\nexport class UrlDiscoveryClient extends Client {\r\n  public static readonly configURL = \"imjs_buddi_url\";\r\n  public static readonly configResolveUrlUsingRegion = \"imjs_buddi_resolve_url_using_region\";\r\n  /**\r\n   * Creates an instance of UrlDiscoveryClient.\r\n   */\r\n  public constructor() {\r\n    super();\r\n  }\r\n\r\n  /**\r\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\r\n   * @returns Search key for the URL.\r\n   */\r\n  protected getUrlSearchKey(): string {\r\n    return \"\";\r\n  }\r\n\r\n  /**\r\n   * Gets the URL for the discovery service\r\n   * @returns URL of the discovery service.\r\n   */\r\n  public async getUrl(): Promise<string> {\r\n    return Promise.resolve(Config.App.getString(UrlDiscoveryClient.configURL, \"https://buddi.bentley.com/WebService\"));\r\n  }\r\n\r\n  /**\r\n   * Discovers a URL given the search key.\r\n   * @param searchKey Search key registered for the service.\r\n   * @param regionId Override region to use for URL discovery.\r\n   * @returns Registered URL for the service.\r\n   */\r\n  public async discoverUrl(requestContext: ClientRequestContext, searchKey: string, regionId: number | undefined): Promise<string> {\r\n    requestContext.enter();\r\n\r\n    const url: string = await this.getUrl() + \"/GetUrl/\";\r\n    const resolvedRegion = typeof regionId !== \"undefined\" ? regionId : Config.App.getNumber(UrlDiscoveryClient.configResolveUrlUsingRegion, 0);\r\n    const options: RequestOptions = {\r\n      method: \"GET\",\r\n      qs: {\r\n        url: searchKey,\r\n        region: resolvedRegion,\r\n      },\r\n    };\r\n\r\n    await this.setupOptionDefaults(options);\r\n    requestContext.enter();\r\n\r\n    const response: Response = await request(requestContext, url, options);\r\n    requestContext.enter();\r\n\r\n    const discoveredUrl: string = response.body.result.url.replace(/\\/$/, \"\"); // strip trailing \"/\" for consistency\r\n    return Promise.resolve(discoveredUrl);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Logging */\r\n\r\n/** Logger categories used by this package\r\n * @note All logger categories in this package start with the `imodeljs-clients` prefix.\r\n * @see [Logger]($bentley)\r\n * @beta\r\n */\r\nexport enum ClientsLoggerCategory {\r\n  /** The logger category used by base clients */\r\n  Clients = \"imodeljs-clients.Clients\",\r\n\r\n  /** The logger category used when converting to/from ECJson. */\r\n  ECJson = \"ECJson\",\r\n\r\n  /** @internal */\r\n  IModelBank = \"imodeljs-clients.iModelBank\",\r\n\r\n  /** The logger category used for interactions with iModelHub. */\r\n  IModelHub = \"imodeljs-clients.imodelhub\",\r\n\r\n  /** @internal */\r\n  ImsClients = \"imodeljs-clients.ImsClients\",\r\n\r\n  Request = \"imodeljs-clients.Request\",\r\n\r\n  /** @internal */\r\n  UlasClient = \"ulasclient\",\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Config */\r\n\r\ntype ValueType = string | boolean | number;\r\n\r\n/** Option to specify the version of the iModel to be acquired and used\r\n * @public\r\n */\r\nexport class Config {\r\n  private static _appConfig: Config;\r\n  private _container: any = {};\r\n  private _expanded: any = {};\r\n  private constructor() { }\r\n\r\n  /** append system vars */\r\n  private appendSystemVars() {\r\n    this.set(\"imjs_env_is_browser\", Boolean(typeof window !== undefined));\r\n    try {\r\n      const configRequest: XMLHttpRequest = new XMLHttpRequest();\r\n      configRequest.open(\"GET\", \"config.json\", false);\r\n      configRequest.send();\r\n      const configResponse: any = JSON.parse(configRequest.responseText);\r\n      if (typeof configResponse !== \"undefined\") {\r\n        this.merge(configResponse);\r\n      }\r\n    } catch (error) {\r\n      // couldn't get config.\r\n    }\r\n\r\n    // Merge system environment variables that start with \"imjs\"\r\n    const imjsPrefix = /^imjs/i;\r\n    const systemEnv = Object.keys(process.env)\r\n      .filter((key) => imjsPrefix.test(key))\r\n      .reduce<any>((env: any, key: string) => {\r\n        env[key] = process.env[key];\r\n        return env;\r\n      }, {});\r\n    this.merge(systemEnv);\r\n  }\r\n\r\n  /** Translate a external var name to a local one if it already exist */\r\n  private translateVar(name: string): string {\r\n    const foundVar = Object.keys(this._container).find((key) => {\r\n      if (key.toLowerCase() === name.toLowerCase()) {\r\n        return true;\r\n      } else {\r\n        return false;\r\n      }\r\n    });\r\n    return foundVar ? foundVar : name;\r\n  }\r\n  /**\r\n   * Expand var containing other vars as values.\r\n   * This is strict function that will fail if recursion is detected or var name is not found.\r\n   */\r\n  private expand(name: string, value: any): any {\r\n    if (typeof value !== \"string\")\r\n      return value;\r\n\r\n    const descriptor = Object.getOwnPropertyDescriptor(this._expanded, name);\r\n    if (descriptor !== undefined) {\r\n      return descriptor.value;\r\n    }\r\n\r\n    const vars: any = {};\r\n    const matches = value.match(/\\${[\\w]+}/gi);\r\n    if (matches === null)\r\n      return value;\r\n\r\n    matches.forEach((element: string) => {\r\n      const varName: string = element.match(/\\${([\\w]+)}/i)![1];\r\n      if (!vars.hasOwnProperty(varName))\r\n        vars[varName] = element;\r\n    });\r\n\r\n    this._expanded[name] = null; // avoid recursive resolution by setting current entry to empty\r\n    Object.getOwnPropertyNames(vars).forEach((element: string) => {\r\n      const toReplace = vars[element];\r\n      const subDescriptor = Object.getOwnPropertyDescriptor(this._expanded, element);\r\n      if (subDescriptor !== undefined) {\r\n        if (subDescriptor.value === null) {\r\n          throw new Error(`Found recursive definition of var ${element}`);\r\n        }\r\n        value = value.replace(toReplace, subDescriptor.value);\r\n      } else if (this.has(element)) {\r\n        value = value.replace(toReplace, this.get(element));\r\n      } else {\r\n        throw new Error(`Failed to expand var ${element}`);\r\n      }\r\n    });\r\n\r\n    this._expanded[name] = value;\r\n    return value;\r\n  }\r\n  /** Get a property value. Throws exception if property name is not found */\r\n  public get(varName: string, defaultVal?: ValueType): any {\r\n    const name = this.translateVar(varName);\r\n    const descriptor = Object.getOwnPropertyDescriptor(this._container, name);\r\n    if (descriptor === undefined) {\r\n      if (defaultVal !== undefined)\r\n        return defaultVal;\r\n      throw new Error(`Property ${name} does not exists.`);\r\n    }\r\n    if (typeof descriptor.value === \"string\") {\r\n      const strVal = descriptor.value as string;\r\n      if (strVal.match(/\\${\\w+}/) !== null)\r\n        return this.expand(name, strVal);\r\n    }\r\n    return descriptor.value;\r\n  }\r\n  /** Checks if a property exists or not */\r\n  public has(varName: string): boolean {\r\n    const name = this.translateVar(varName);\r\n    return this._container.hasOwnProperty(name);\r\n  }\r\n  /** retrieves a property if it exists, otherwise returns undefined */\r\n  public query(varName: string): any {\r\n    return this.has(varName) ? this.get(varName) : undefined;\r\n  }\r\n  /** Get number type property */\r\n  public getNumber(name: string, defaultVal?: number): number {\r\n    return Number(this.get(name, defaultVal));\r\n  }\r\n  /** Get boolean type property */\r\n  public getBoolean(name: string, defaultVal?: boolean): boolean {\r\n    return Boolean(this.get(name, defaultVal));\r\n  }\r\n  /** Get string type property */\r\n  public getString(name: string, defaultVal?: string): string {\r\n    return String(this.get(name, defaultVal));\r\n  }\r\n  /** Remove a property from config */\r\n  public remove(varName: string) {\r\n    const name = this.translateVar(varName);\r\n    if (!this.has(name)) {\r\n      throw new Error(`Property ${name} does not exists.`);\r\n    }\r\n    this._expanded = {};\r\n    delete this._container[name];\r\n  }\r\n  /** Set define a new property if it does not exist or update a writable property to new value */\r\n  public set(varName: string, value: ValueType) {\r\n    const name = this.translateVar(varName);\r\n    this._container[name] = value;\r\n    this._expanded = {};\r\n  }\r\n  /**\r\n   *  Return list of property names present in config\r\n   */\r\n  public getVars(): string[] {\r\n    return Object.getOwnPropertyNames(this._container);\r\n  }\r\n  /**\r\n   * Override or add new values from a given object into config. Immutable properties are skipped.\r\n   */\r\n  public merge(source: any) {\r\n    if (source === undefined || source === null || source !== Object(source)) {\r\n      throw new Error(\"source should be an object\");\r\n    }\r\n    this._copyProperties(this._container, source, true);\r\n  }\r\n\r\n  // copies the properties, recursing into object properties. Only do the translateVar at the top level.\r\n  private _copyProperties(destination: any, source: any, doTranslate: boolean) {\r\n    Object.keys(source).forEach((varName) => {\r\n      // if subkey is an object, recurse.\r\n      if (typeof (source[varName]) === \"object\") {\r\n        destination[varName] = {};\r\n        this._copyProperties(destination[varName], source[varName], false);\r\n\r\n      } else {\r\n        const name = doTranslate ? this.translateVar(varName) : varName;\r\n        const val = source[name];\r\n        if (typeof val === \"object\" || typeof val === \"undefined\" || val === null)\r\n          return;\r\n\r\n        const descriptor = Object.getOwnPropertyDescriptor(source, name);\r\n        if (descriptor !== undefined) {\r\n          if (!descriptor.writable)\r\n            return;\r\n        }\r\n        destination[name] = val;\r\n      }\r\n    });\r\n  }\r\n  /**\r\n   * Return clone of the internal property container object.\r\n   */\r\n  public getContainer(): any {\r\n    return JSON.parse(JSON.stringify(this._container));\r\n  }\r\n  /**\r\n   * Provide singleton object for application\r\n   */\r\n  public static get App(): Config {\r\n    if (!Config._appConfig) {\r\n      Config._appConfig = new Config();\r\n      Config._appConfig.appendSystemVars();\r\n    }\r\n    return Config._appConfig;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module ConnectServices */\nimport { WsgClient } from \"./WsgClient\";\nimport { RequestQueryOptions, RequestOptions } from \"./Request\";\nimport { ECJsonTypeMap, WsgInstance } from \"./ECJsonTypeMap\";\nimport { AuthorizedClientRequestContext } from \"./AuthorizedClientRequestContext\";\nimport { Config } from \"./Config\";\nimport * as deepAssign from \"deep-assign\";\n\n/** Connect context type\n * @beta\n */\nexport enum ContextType {\n  Unknown,\n  Asset = 2,\n  Project = 3,\n}\n\n/** Connect context. Currently supported contexts are [[Project]] and [[Asset]].\n * @beta\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"CONNECTEDContext.Context\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class Context extends WsgInstance {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ContextTypeId\")\n  public contextTypeId?: ContextType;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Name\")\n  public name?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Number\")\n  public number?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UltimateRefId\")\n  public ultimateRefId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.DataLocationId\")\n  public dataLocationId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Status\")\n  public status?: number;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.AllowExternalTeamMembers\")\n  public allowExternalTeamMembers?: boolean;\n}\n\n/**\n * @beta\n */\nabstract class CommonContext extends Context {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Industry\")\n  public industry?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Location\")\n  public location?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Latitude\")\n  public latitude?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Longitude\")\n  public longitude?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CountryCode\")\n  public countryCode?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.TimeZoneLocation\")\n  public timeZoneLocation?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.RegisteredDate\")\n  public registeredDate?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.LastModifiedDate\")\n  public lastModifiedDate?: string;\n}\n\n/** Connect project. Represents time-constrained work done on an [[Asset]].\n * @beta\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"CONNECTEDContext.Project\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class Project extends CommonContext {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.AssetId\")\n  public assetId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Type\")\n  public type?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IsRbacEnabled\")\n  public isRbacEnabled?: boolean;\n}\n\n/** Connect asset. Assets represent a large scale item that is owned and/or operated by organization, such as buildings, highways and so on.\n * @beta\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"CONNECTEDContext.Asset\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class Asset extends CommonContext {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.AssetType\")\n  public assetType?: string;\n}\n\n/** RBAC project\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"RBAC.Project\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class RbacProject extends WsgInstance {\n  // Empty!\n}\n\n/** RBAC user\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"RBAC.User\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class RbacUser extends WsgInstance {\n  // Empty!\n}\n\n/** RBAC permission\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"RBAC.Permission\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class Permission extends WsgInstance {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Name\")\n  public name?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Description\")\n  public description?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ServiceGPRId\")\n  public serviceGprId?: number;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CategoryId\")\n  public categoryId?: number;\n}\n\n/** Options to request connect projects\n * @beta\n */\nexport interface ConnectRequestQueryOptions extends RequestQueryOptions {\n  /** Set to true to request the most recently used projects */\n  isMRU?: boolean;\n\n  /** Set to true to request the favorite projects */\n  isFavorite?: boolean;\n}\n\n/** @internal */\nexport interface RbacRequestQueryOptions extends RequestQueryOptions {\n  rbacOnly?: boolean;\n}\n\n/** Client API to access the connect services.\n * @beta\n */\nexport class ConnectClient extends WsgClient {\n  public static readonly searchKey: string = \"CONNECTEDContextService.URL\";\n  public static readonly configRelyingPartyUri = \"imjs_connected_context_service_relying_party_uri\";\n\n  public constructor() {\n    super(\"sv1.0\");\n  }\n\n  /**\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return ConnectClient.searchKey;\n  }\n\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\n    await super.setupOptionDefaults(options);\n    deepAssign(options, { headers: { \"content-type\": \"application/json\" } });\n  }\n\n  /**\n   * Gets theRelyingPartyUrl for the service.\n   * @returns RelyingPartyUrl for the service.\n   */\n  protected getRelyingPartyUrl(): string {\n    if (Config.App.has(ConnectClient.configRelyingPartyUri))\n      return Config.App.get(ConnectClient.configRelyingPartyUri) + \"/\";\n\n    if (Config.App.getBoolean(WsgClient.configUseHostRelyingPartyUriAsFallback, true)) {\n      if (Config.App.has(WsgClient.configHostRelyingPartyUri))\n        return Config.App.get(WsgClient.configHostRelyingPartyUri) + \"/\";\n    }\n\n    throw new Error(`RelyingPartyUrl not set. Set it in Config.App using key ${ConnectClient.configRelyingPartyUri}`);\n  }\n\n  /**\n   * Gets connect projects accessible to the authorized user.\n   * @param requestContext The client request context\n   * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.\n   * @returns Resolves to an array of projects.\n   */\n  public async getProjects(requestContext: AuthorizedClientRequestContext, queryOptions?: ConnectRequestQueryOptions): Promise<Project[]> {\n    return this.getInstances<Project>(requestContext, Project, \"/Repositories/BentleyCONNECT--Main/ConnectedContext/Project\", queryOptions);\n  }\n\n  /**\n   * Gets a connect project.\n   * @param requestContext The client request context\n   * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.\n   * @returns Resolves to the found project. Rejects if no projects, or more than one project is found.\n   */\n  public async getProject(requestContext: AuthorizedClientRequestContext, queryOptions?: ConnectRequestQueryOptions): Promise<Project> {\n    const projects: Project[] = await this.getProjects(requestContext, queryOptions);\n    if (projects.length === 0)\n      throw new Error(\"Could not find a project with the specified criteria that the user has access to\");\n    else if (projects.length > 1)\n      throw new Error(\"More than one project found with the specified criteria\");\n\n    return projects[0];\n  }\n\n  /** Get the projects the user has been \"invited\" to.\n   * @param token Delegation token of the authorized user.\n   * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.\n   * @returns Resolves to an array of invited projects.\n   */\n  public async getInvitedProjects(requestContext: AuthorizedClientRequestContext, queryOptions?: ConnectRequestQueryOptions): Promise<Project[]> {\n    return this.getInstances<Project>(requestContext, Project, \"/Repositories/BentleyCONNECT--Main/ConnectedContext/Project?rbaconly=true\", queryOptions);\n  }\n\n  /**\n   * Gets a connect asset.\n   * @param requestContext The client request context\n   * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.\n   * @returns Resolves to the found asset. Rejects if no assets, or more than one asset is found.\n   */\n  public async getAsset(requestContext: AuthorizedClientRequestContext, queryOptions?: RequestQueryOptions): Promise<Asset> {\n    const assets: Asset[] = await this.getAssets(requestContext, queryOptions);\n    if (assets.length === 0)\n      throw new Error(\"Could not find an asset with the specified criteria that the user has access to\");\n    else if (assets.length > 1)\n      throw new Error(\"More than one asset found with the specified criteria\");\n\n    return assets[0];\n  }\n\n  /**\n   * Gets connect assets accessible to the authorized user.\n   * @param requestContext The client request context\n   * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.\n   * @returns Resolves to an array of assets.\n   */\n  public async getAssets(requestContext: AuthorizedClientRequestContext, queryOptions?: RequestQueryOptions): Promise<Asset[]> {\n    return this.getInstances<Asset>(requestContext, Asset, \"/Repositories/BentleyCONNECT--Main/ConnectedContext/Asset\", queryOptions);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Utils */\r\n\r\n/**\r\n * Manages the mapping between TypeScript and EC Classes/Properties to transform back and forth\r\n * between TypeScript objects (strongly typed) and raw JSON instances. The raw JSON instances can\r\n * conform to one or more \"application\" ECSchemas.\r\n *\r\n * The mappings are setup on the TypeScript classes using class decorators: {@link ECJsonTypeMap.classToJson}\r\n * and TypeScript properties using property decorators: {@link ECJsonTypeMap.propertyToJson}.\r\n *\r\n * The following utility methods can then be used to convert between TypeScript and JSON:\r\n * {@link ECJsonTypeMap.fromJson<T>} is used to convert a JSON instance into an instance of type T.\r\n * {@link ECJsonTypeMap.toJson<T>} is used to convert an instance of some type T to JSON.\r\n * The caller passes the application as an argument to these methods to identify the schema of the\r\n * raw JSON that's being generated or consumed.\r\n *\r\n * #### example\r\n * The BriefcaseManager API requires that a briefcase be fetched from the server (based on the \"wsg\" ECSchema-s),\r\n * kept in memory as a strongly typed TypeScript object, and then saved locally in a ECDb cache (based on\r\n * the ECSchema in the ECDb). The JSON would need to be transformed between WSG, ECDb and in-memory TypeScript\r\n * objects. Listed below are:\r\n * 1. the EC-JSON required/sent by WSG\r\n * 2. the EC-JSON required/sent by ECDb\r\n * 3. the TypeScript instance\r\n * 4. the corresponding TypeScript class definition with the class and property decorators to make the required transformations.\r\n *\r\n * 1. the EC-JSON required/sent by WSG\r\n *     const wsgJsonForBriefcase: any = {\r\n *       instanceId: \"5\",\r\n *       schemaName: \"iModelScope\",\r\n *       className: \"Briefcase\",\r\n *       eTag: \"87fgQrN6y3mHD6ciCsPxhCdxCxU=\",\r\n *       properties: {\r\n *         FileName: \"MyTestModel.bim\",\r\n *         FileDescription: null,\r\n *         FileSize: \"1232896\",\r\n *         FileId: \"0056da15-2009-4862-b82a-c031cb3902d8\",\r\n *         BriefcaseId: 5,\r\n *         UserOwned: \"efefac5b-9a57-488b-aed2-df27bffe6d78\",\r\n *         AcquiredDate: \"2017-07-04T18:08:15.77\",\r\n *         IsReadOnly: false,\r\n *         },\r\n *       relationshipInstances: [{\r\n *         className: \"FileAccessKey\",\r\n *         relatedInstance: {\r\n *           className: \"AccessKey\",\r\n *           properties: {\r\n *           DownloadUrl: \"https://imodelhubqasa01.blob.core.windows.net/imodelhub-5018f11f-...\",\r\n *           },\r\n *         },\r\n *       },\r\n *       ],\r\n *     };\r\n *\r\n * 2. the EC-JSON required/sent by ECDb\r\n *     const ecdbJsonForBriefcase: any = {\r\n *       id: \"1\",\r\n *       className: \"ServiceStore.LocalBriefcase\",\r\n *       briefcaseId: 5,\r\n *       userId: \"efefac5b-9a57-488b-aed2-df27bffe6d78\",\r\n *       isReadOnly: false,\r\n *       accessMode: 0,\r\n *       localPathname: \"d:/SomePathHere/MyTestModel.bim\",\r\n *       lastAccessedAt: \"2017-07-04T18:08:15.77\",\r\n *     };\r\n *\r\n * 3. the TypeScript instance\r\n *     const briefcase: Briefcase = {\r\n *       id: \"5\",\r\n *       federationGuid: \"5\",\r\n *       eTag: \"87fgQrN6y3mHD6ciCsPxhCdxCxU=\",\r\n *       fileName: \"MyTestModel.bim\",\r\n *       fileDescription: null,\r\n *       fileSize: \"1232896\",\r\n *       fileId: \"0056da15-2009-4862-b82a-c031cb3902d8\",\r\n *       briefcaseId: 5,\r\n *       userId: \"efefac5b-9a57-488b-aed2-df27bffe6d78\",\r\n *       acquiredDate: \"2017-07-04T18:08:15.77\",\r\n *       isReadOnly: false,\r\n *       downloadUrl: \"https://imodelhubqasa01.blob.core.windows.net/i...\",\r\n *       accessMode: 0,\r\n *       localPathname: \"%TEMP%iModeljs/imodelName/\",\r\n *       lastAccessedAt: \"2017-07-04T18:08:15.77\",\r\n *     };\r\n *\r\n * 4. the corresponding TypeScript class definition with the class and property decorators\r\n *\r\n *     // Base class for all typed instances mapped to ECInstance-s in an ECDb\r\n *     export abstract class ECInstance\r\n *     {\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"id\")\r\n *       public id: string;\r\n *\r\n *       [index: string]: any;\r\n *     }\r\n *\r\n *     // Base class for all typed instances mapped to ECInstance-s in both an ECDb, and the WSG repository\r\n *     export abstract class WsgInstance extends ECInstance\r\n *     {\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"instanceId\")\r\n *       public federationGuid: GuidString;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"eTag\")\r\n *       public eTag?: string;\r\n *     }\r\n *\r\n *     // Briefcase\r\n *     @ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.Briefcase\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\n *     @ECJsonTypeMap.classToJson(\"ecdb\", \"ServiceStore.LocalBriefcase\", {classKeyPropertyName: \"className\"})\r\n *     export class Briefcase extends WsgInstance\r\n *     {\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileName\")\r\n *       public fileName: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileDescription\")\r\n *       public fileDescription: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileSize\")\r\n *       public fileSize: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileId\")\r\n *       public fileId: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.BriefcaseId\")\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"briefcaseId\")\r\n *       public briefcaseId: number;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UserOwned\")\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"userId\")\r\n *       public userOwned: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.AcquiredDate\")\r\n *       public acquiredDate: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IsReadOnly\")\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"isReadOnly\")\r\n *       public isReadOnly: boolean;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl\")\r\n *       public downloadUrl?: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"accessMode\")\r\n *       public accessMode: BriefcaseAccessMode;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"localPathname\")\r\n *       public localPathname: string;\r\n *\r\n *       @ECJsonTypeMap.propertyToJson(\"ecdb\", \"lastAccessedAt\")\r\n *       public lastAccessedAt: Date;\r\n *     }\r\n */\r\n// @todo Update example with property type conversions once that's available.\r\n\r\nimport { assert, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { ClientsLoggerCategory } from \"./ClientsLoggerCategory\";\r\n\r\n/** @internal */\r\nexport type ConstructorType = new () => any;\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.ECJson;\r\nconst className = \"className\";\r\n\r\n/** @internal */\r\nexport interface ClassKeyMapInfo {\r\n  /** The key of the JSON property that stores the schema name - e.g., set to\"schemaName\" in the case of JSON consumed/supplied by WSG */\r\n  schemaPropertyName?: string;\r\n  /** The key of the JSON property that stores the class name - e.g., set to \"className\" in the case of JSON consumed/supplied by WSG. */\r\n  classPropertyName?: string;\r\n  /** The key of the JSON property that stores the \"ECClassKey\" - e.g., set to \"className\" in the case of JSON consumed/supplied by the ECDb API */\r\n  classKeyPropertyName?: string;\r\n}\r\n\r\nclass PropertyEntry {\r\n  constructor(public readonly typedPropertyName: string, public propertyAccessString: string) {\r\n  }\r\n}\r\n\r\ntype PropertiesByAccessString = Map<string, PropertyEntry>;\r\n\r\nclass ApplicationEntry {\r\n  public readonly propertiesByAccessString: PropertiesByAccessString = new Map<string, PropertyEntry>();\r\n  public classKey: string;\r\n  public classKeyMapInfo: ClassKeyMapInfo;\r\n\r\n  /** Constructor */\r\n  constructor(public applicationKey: string) {\r\n  }\r\n\r\n  private getPropertyByAccessString(propertyAccessString: string): PropertyEntry | undefined {\r\n    return this.propertiesByAccessString.get(propertyAccessString);\r\n  }\r\n\r\n  /** Adds a new entry for a mapped property */\r\n  public addProperty(typedPropertyName: string, propertyAccessString: string): void {\r\n    let propertyEntry = this.getPropertyByAccessString(propertyAccessString);\r\n    if (propertyEntry) {\r\n      const err = `The ECProperty ${propertyAccessString} has already been mapped to another TypeScript property ${propertyEntry.typedPropertyName}`;\r\n      throw new Error(err);\r\n    }\r\n\r\n    propertyEntry = new PropertyEntry(typedPropertyName, propertyAccessString);\r\n    this.propertiesByAccessString.set(propertyAccessString, propertyEntry);\r\n  }\r\n}\r\n\r\ntype ApplicationsByKey = Map<string, ApplicationEntry>;\r\n\r\n/** Entry in the registry to capture the mapping between a single EC and TypeScript class */\r\nclass ClassEntry {\r\n  public readonly typedConstructor: ConstructorType;\r\n  public readonly baseClassEntries: ClassEntry[] = new Array<ClassEntry>();\r\n  public readonly applicationsByKey: ApplicationsByKey = new Map<string, ApplicationEntry>();\r\n\r\n  /** Constructor */\r\n  constructor(typedConstructor: ConstructorType) {\r\n    this.typedConstructor = typedConstructor;\r\n  }\r\n\r\n  /** Gets the application entry by the key  */\r\n  public getApplicationByKey(applicationKey: string): ApplicationEntry | undefined {\r\n    return this.applicationsByKey.get(applicationKey);\r\n  }\r\n\r\n  /** Adds a new entry for a mapped application within a class  */\r\n  public addApplication(applicationKey: string): ApplicationEntry {\r\n    let applicationEntry = this.getApplicationByKey(applicationKey);\r\n    if (applicationEntry)\r\n      throw new Error(`Internal error: Cannot add the same application twice`);\r\n\r\n    applicationEntry = new ApplicationEntry(applicationKey);\r\n    this.applicationsByKey.set(applicationKey, applicationEntry);\r\n    return applicationEntry;\r\n  }\r\n}\r\n\r\ntype ClassesByTypedName = Map<ConstructorType, ClassEntry>;\r\n\r\n/** Manages the mapping between TypeScript and EC Classes/Properties\r\n * @internal\r\n */\r\nexport class ECJsonTypeMap {\r\n  private static _classesByTypedName: ClassesByTypedName = new Map<ConstructorType, ClassEntry>();\r\n\r\n  /** Gets an existing entry for a mapped class from the name of the TypeScript class */\r\n  private static getClassByType(typedConstructor: ConstructorType): ClassEntry | undefined {\r\n    return ECJsonTypeMap._classesByTypedName.get(typedConstructor);\r\n  }\r\n\r\n  /** Recursively gathers all class entries for base classes starting with the specified class */\r\n  private static gatherBaseClassEntries(baseClassEntries: ClassEntry[], classEntry: ClassEntry): void {\r\n    const baseTypedConstructor: ConstructorType = Object.getPrototypeOf(classEntry.typedConstructor.prototype).constructor;\r\n    const baseClassEntry: ClassEntry | undefined = ECJsonTypeMap.getClassByType(baseTypedConstructor);\r\n    if (baseClassEntry) {\r\n      baseClassEntries.push(baseClassEntry);\r\n      this.gatherBaseClassEntries(baseClassEntries, baseClassEntry);\r\n    }\r\n  }\r\n\r\n  private static addClassPlaceholder(typedConstructor: ConstructorType): ClassEntry {\r\n    const classEntry = new ClassEntry(typedConstructor);\r\n    ECJsonTypeMap._classesByTypedName.set(typedConstructor, classEntry);\r\n    ECJsonTypeMap.gatherBaseClassEntries(classEntry.baseClassEntries, classEntry);\r\n    return classEntry;\r\n  }\r\n\r\n  /** Adds a new entry for a mapped class */\r\n  private static addClass(typedConstructor: ConstructorType, applicationKey: string, classKey: string, classKeyMapInfo: ClassKeyMapInfo): ClassEntry {\r\n    if (!(classKeyMapInfo.classKeyPropertyName || (classKeyMapInfo.schemaPropertyName && classKeyMapInfo.classPropertyName)))\r\n      throw new Error(\"Either classKeyPropertyName or schemaPropertyName+classPropertyName have to be supplied to identify how the class information is persisted in JSON\");\r\n\r\n    let classEntry: ClassEntry | undefined = ECJsonTypeMap.getClassByType(typedConstructor);\r\n    if (!classEntry) {\r\n      classEntry = this.addClassPlaceholder(typedConstructor);\r\n    }\r\n\r\n    let applicationEntry = classEntry.getApplicationByKey(applicationKey);\r\n    if (!applicationEntry) {\r\n      applicationEntry = classEntry.addApplication(applicationKey);\r\n      // will only happen if there are no properties that are mapped to the application - otherwise the property maps will cause the application entry to be added before\r\n    } else if (applicationEntry.classKey === classKey) {\r\n      const err = `Duplicate classKeys ${classKey} found on TypeScript class ${typedConstructor.name} for application ${applicationKey}`;\r\n      throw new Error(err);\r\n    }\r\n    applicationEntry.classKey = classKey;\r\n    applicationEntry.classKeyMapInfo = classKeyMapInfo;\r\n\r\n    return classEntry;\r\n  }\r\n\r\n  /** Adds a new entry for a mapped property */\r\n  private static addProperty(typedPropertyName: string, typedConstructor: ConstructorType, applicationKey: string, propertyAccessString: string) {\r\n    let classEntry: ClassEntry | undefined = ECJsonTypeMap.getClassByType(typedConstructor);\r\n    if (!classEntry)\r\n      classEntry = ECJsonTypeMap.addClassPlaceholder(typedConstructor);\r\n\r\n    let applicationEntry = classEntry.getApplicationByKey(applicationKey);\r\n    if (!applicationEntry)\r\n      applicationEntry = classEntry.addApplication(applicationKey);\r\n\r\n    applicationEntry.addProperty(typedPropertyName, propertyAccessString);\r\n  }\r\n\r\n  /** Create a typed instance from an untyped JSON ECInstance  */\r\n  public static fromJson<T extends ECInstance>(typedConstructor: new () => T, applicationKey: string, ecJsonInstance: any): T | undefined {\r\n    const mappedClassEntry: ClassEntry | undefined = ECJsonTypeMap.getClassByType(typedConstructor);\r\n    if (!mappedClassEntry) {\r\n      Logger.logError(loggerCategory, `Type ${typedConstructor.name} is not mapped to an ECClass. Supply the appropriate class decorator`);\r\n      return undefined;\r\n    }\r\n\r\n    const lowCaseApplicationKey = applicationKey.toLowerCase();\r\n    const mappedApplicationEntry: ApplicationEntry | undefined = mappedClassEntry.getApplicationByKey(lowCaseApplicationKey);\r\n    if (!mappedApplicationEntry) {\r\n      Logger.logError(loggerCategory, `Type ${typedConstructor.name} is not mapped for the supplied application.`);\r\n      return undefined;\r\n    }\r\n\r\n    let ecJsonClassKey: string;\r\n    if (mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName)\r\n      ecJsonClassKey = ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName];\r\n    else if (mappedApplicationEntry.classKeyMapInfo.schemaPropertyName && mappedApplicationEntry.classKeyMapInfo.classPropertyName)\r\n      ecJsonClassKey = ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.schemaPropertyName] + \".\" + ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.classPropertyName];\r\n    else {\r\n      assert(false, \"Unexpected classKeyMapInfo\");\r\n      return undefined;\r\n    }\r\n\r\n    if (mappedApplicationEntry.classKey !== ecJsonClassKey) {\r\n      Logger.logError(loggerCategory, `The ClassKey ${mappedApplicationEntry.classKey} was specified to map with ${typedConstructor.name}, but does not match that specified in the JSON: ${ecJsonClassKey} `);\r\n      return undefined;\r\n    }\r\n\r\n    let classEntries = Array<ClassEntry>(mappedClassEntry);\r\n    classEntries = classEntries.concat(mappedClassEntry.baseClassEntries);\r\n\r\n    const typedInstance: T = new typedConstructor();\r\n\r\n    classEntries.forEach((classEntry: ClassEntry) => {\r\n      const applicationEntry = classEntry.getApplicationByKey(lowCaseApplicationKey);\r\n      if (!applicationEntry)\r\n        return;\r\n\r\n      applicationEntry.propertiesByAccessString.forEach((propertyEntry: PropertyEntry, propertyAccessString: string) => {\r\n        let ecValue: any = ecJsonInstance;\r\n\r\n        const ecNameParts: string[] = propertyAccessString.split(\".\"); // e.g., \"relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId\"\r\n        for (let i = 0; i < ecNameParts.length; i++) {\r\n          const ecNameSubParts: string[] | null = ecNameParts[i].match(/[^\\[\\]]+/g);\r\n          if (!ecNameSubParts || ecNameSubParts.length === 0 || ecNameSubParts.length > 2)\r\n            return;\r\n\r\n          const subAccessString: string = ecNameSubParts[0];\r\n          ecValue = ecValue[subAccessString];\r\n          if (typeof ecValue === \"undefined\")\r\n            return;\r\n\r\n          if (ecNameSubParts.length === 2 && subAccessString === \"relationshipInstances\" && i < ecNameParts.length - 1) {\r\n            const nextEcNameSubParts: string[] | null = ecNameParts[i + 1].match(/[^\\[\\]]+/g);\r\n            if (!nextEcNameSubParts || nextEcNameSubParts.length !== 2)\r\n              return;\r\n\r\n            const expectedRelationshipInstanceClass: any = ecNameSubParts[1];\r\n            const relatedInstanceAccessString: any = nextEcNameSubParts[0];\r\n            const expectedRelatedInstanceClass: any = nextEcNameSubParts[1];\r\n\r\n            let arrayIndex: number = 0;\r\n            let arrayValue: any;\r\n            let actualRelatedInstanceClass: any;\r\n            while (expectedRelatedInstanceClass !== actualRelatedInstanceClass) {\r\n              arrayValue = ecValue[arrayIndex++];\r\n              if (typeof arrayValue === \"undefined\")\r\n                return;\r\n\r\n              if (expectedRelationshipInstanceClass === arrayValue[className]) {\r\n                const relatedInstance: any = arrayValue[relatedInstanceAccessString];\r\n                if (relatedInstance !== \"undefined\")\r\n                  actualRelatedInstanceClass = relatedInstance[className];\r\n              }\r\n            }\r\n\r\n            ecValue = arrayValue[relatedInstanceAccessString];\r\n            i++;\r\n          }\r\n        }\r\n\r\n        typedInstance[propertyEntry.typedPropertyName] = ecValue;\r\n\r\n      });\r\n    });\r\n\r\n    return typedInstance;\r\n  }\r\n\r\n  /** Create an untyped instance from a typed instance */\r\n  public static toJson<T extends ECInstance>(applicationKey: string, typedInstance: T): any | undefined {\r\n    const lowCaseApplicationKey = applicationKey.toLowerCase(); // e.g., wsg\r\n    const typedConstructor = Object.getPrototypeOf(typedInstance).constructor;\r\n    const mappedClassEntry: ClassEntry | undefined = ECJsonTypeMap.getClassByType(typedConstructor);\r\n    if (!mappedClassEntry)\r\n      return undefined;\r\n\r\n    const mappedApplicationEntry: ApplicationEntry | undefined = mappedClassEntry.getApplicationByKey(lowCaseApplicationKey);\r\n    if (!mappedApplicationEntry)\r\n      return undefined;\r\n\r\n    const untypedInstance: any = {};\r\n\r\n    if (mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName) {\r\n      untypedInstance[mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName] = mappedApplicationEntry.classKey;\r\n    } else if (mappedApplicationEntry.classKeyMapInfo.schemaPropertyName && mappedApplicationEntry.classKeyMapInfo.classPropertyName) {\r\n      const classKeyParts = mappedApplicationEntry.classKey.split(\".\", 2);\r\n      untypedInstance[mappedApplicationEntry.classKeyMapInfo.schemaPropertyName] = classKeyParts[0];\r\n      untypedInstance[mappedApplicationEntry.classKeyMapInfo.classPropertyName] = classKeyParts[1];\r\n    } else {\r\n      assert(false, \"Unexpected classKeyMapInfo\");\r\n      return undefined;\r\n    }\r\n\r\n    let classEntries = Array<ClassEntry>(mappedClassEntry);\r\n    classEntries = classEntries.concat(mappedClassEntry.baseClassEntries);\r\n\r\n    classEntries.forEach((classEntry: ClassEntry) => {\r\n      const applicationEntry = classEntry.getApplicationByKey(lowCaseApplicationKey);\r\n      if (!applicationEntry)\r\n        return;\r\n\r\n      applicationEntry.propertiesByAccessString.forEach((propertyEntry: PropertyEntry, propertyAccessString: string) => {\r\n        const typedValue: any = typedInstance[propertyEntry.typedPropertyName];\r\n        if (typeof typedValue === \"undefined\")\r\n          return;\r\n\r\n        const ecNameParts: string[] = propertyAccessString.split(\".\"); // e.g., \"relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId\"\r\n        let untypedInstanceCursor: any = untypedInstance;\r\n\r\n        // iterate through each part of the propertyAccessString that was separated by dots\r\n        ecNameParts.forEach((ecNamePart, index) => {\r\n\r\n          // if the name part has brackets, we want to extract the value inside the brackets and outside into a single array\r\n          // e.g., relationshipInstances[HasThumbnail] --> [relationshipInstances, HasThumbnail]\r\n          // e.g., property --> [property]\r\n          const ecNameSubParts: string[] | null = ecNamePart.match(/[^\\[\\]]+/g);\r\n          // we only want to continue if the ecNameSubParts array has 1 or 2 values\r\n          if (!ecNameSubParts || ecNameSubParts.length === 0 || ecNameSubParts.length > 2)\r\n            return;\r\n\r\n          // the access string is the current property of the class\r\n          const accessString: string = ecNameSubParts[0];\r\n          // only the last part of the propertyAccessString will be bound to the typedValue\r\n          const isLastPart: boolean = index >= ecNameParts.length - 1;\r\n\r\n          // if we have just 1 value in the ecNameSubParts array...\r\n          if (ecNameSubParts.length !== 2) {\r\n            // if the current cursor of the ec class object has no value for the access string\r\n            if (undefined === untypedInstanceCursor[accessString]) {\r\n              // we need to bind it the typedValue or initialize an empty object\r\n              let value = {};\r\n              if (isLastPart) {\r\n                value = typedValue;\r\n              }\r\n              untypedInstanceCursor[accessString] = value;\r\n            }\r\n            // advance the cursor to the newly defined value set by the accessString\r\n            untypedInstanceCursor = untypedInstanceCursor[accessString];\r\n            return;\r\n          }\r\n\r\n          // if we have 2 values in the ecNameSubParts array...\r\n          // the second value we can assume to be the expected class name of the ec object corresponding to the current position of the cursor\r\n          const expectedclassName: string = ecNameSubParts[1];\r\n\r\n          // if the accessString is relationshipInstances we know we have some like: \"relationshipInstances[className]\"\r\n          if (accessString === \"relationshipInstances\") {\r\n            // initially relationshipInstances will be undefined, but it will always be an array, so we need to initialize it as one\r\n            if (!untypedInstanceCursor[accessString])\r\n              untypedInstanceCursor[accessString] = [];\r\n\r\n            // determine if the relationshipInstance has an associated relatedInstance\r\n            const hasNextEcPart = /\\[.*\\]/.test(ecNameParts[index + 1]);\r\n\r\n            // split the related instance into an array with its class name\r\n            // e.g., relatedInstance[className] --> [relatedInstance, className]\r\n            // e.g., property --> [property]\r\n            const nextEcNameSubParts: string[] | null = ecNameParts[index + 1].match(/[^\\[\\]]+/g);\r\n            // we only want to continue if the nextEcNameSubParts array has 1 or 2 values\r\n            if (!nextEcNameSubParts || nextEcNameSubParts.length === 0 || nextEcNameSubParts.length > 2)\r\n              return;\r\n\r\n            // if there is a next ec part, then grab the first value, which ostensibly would always be \"relatedInstance\"\r\n            const relatedInstanceAccessString: any = hasNextEcPart ? nextEcNameSubParts[0] : undefined;\r\n            // if there is a next ec part, then grab the second value, which corresponds to the relatedInstance's expected class name\r\n            const expectedRelatedInstanceClass: any = hasNextEcPart ? nextEcNameSubParts[1] : undefined;\r\n\r\n            // determine the current index of the relationshipInstance that matches the expected class name\r\n            // given there may be multiple relationship instances, but we assume there is a unique combination\r\n            // between the class of the relationship instance and its relatedInstance (if the related instance is provided)\r\n            // e.g., given: relationshipInstances[classA].relatedInstance[classB] , classA and classB together are unique among all relationship instances\r\n            let relationshipCount: number = 0;\r\n            // while the index points to a defined relationship instance, check if classA and classB (from above example) match the expected classes\r\n            // the exception is if the relationship instance doesn't have a relatedInstance (possibly because the typedValue is the entire instance)\r\n            // in that case we only care about the matching the relationship instance class name\r\n            while (untypedInstanceCursor[accessString][relationshipCount]\r\n              && (untypedInstanceCursor[accessString][relationshipCount][className] !== expectedclassName\r\n                || (hasNextEcPart && untypedInstanceCursor[accessString][relationshipCount][relatedInstanceAccessString] && untypedInstanceCursor[accessString][relationshipCount][relatedInstanceAccessString][className] !== expectedRelatedInstanceClass))) {\r\n              relationshipCount++;\r\n            }\r\n\r\n            // if this is the first round, no relationship instances will be defined yet, so we need to initialize it\r\n            if (!untypedInstanceCursor[accessString][relationshipCount]) {\r\n              // Note: the only way this would be the last part is if the entire relationship instance is the typed value\r\n              let value = {};\r\n              if (isLastPart) {\r\n                value = typedValue;\r\n              }\r\n              untypedInstanceCursor[accessString][relationshipCount] = value;\r\n            }\r\n\r\n            // advance the cursor to the newly defined value set by the accessString\r\n            untypedInstanceCursor = untypedInstanceCursor[accessString][relationshipCount];\r\n          } else {\r\n            if (accessString !== \"relatedInstance\" || !untypedInstanceCursor[accessString]\r\n              || (accessString === \"relatedInstance\" && untypedInstanceCursor[accessString][className] !== expectedclassName)) {\r\n              let value = {};\r\n              if (isLastPart) {\r\n                value = typedValue;\r\n              }\r\n              untypedInstanceCursor[accessString] = value;\r\n            }\r\n            untypedInstanceCursor = untypedInstanceCursor[accessString];\r\n          }\r\n\r\n          if (undefined === untypedInstanceCursor[className])\r\n            untypedInstanceCursor[className] = expectedclassName;\r\n        });\r\n      });\r\n    });\r\n\r\n    return untypedInstance;\r\n  }\r\n\r\n  /**\r\n   * Decorator function for mapping TypeScript classes to JSON\r\n   * @param applicationKey Identifies the application for which the mapping is specified. e.g., \"ecdb\", \"wsg\", etc.\r\n   * @param classKey Identifies the ec class backing the JSON instance. (e.g., \"ServiceStore.Briefcase\" (ecdb) or \"iModelScope.Briefcase\" (wsg))\r\n   * @param classKeyMapInfo Information on how the class key is persisted in the JSON instance (e.g., as two properties \"schemaName\" and \"className\")\r\n   */\r\n  public static classToJson(applicationKey: string, classKey: string, classKeyMapInfo: ClassKeyMapInfo) {\r\n    return (typedConstructor: ConstructorType): void => {\r\n      ECJsonTypeMap.addClass(typedConstructor, applicationKey.toLowerCase(), classKey, classKeyMapInfo);\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Decorator function for mapping typescript properties to JSON\r\n   * @param applicationKey Identifies the application for which the mapping is specified. e.g., \"ecdb\", \"wsg\", etc.\r\n   * @param propertyAccessString Access string for the ECProperty\r\n   */\r\n  public static propertyToJson(applicationKey: string, propertyAccessString: string) {\r\n    return (object: any, propertyKey: string): void => {\r\n      ECJsonTypeMap.addProperty(propertyKey, object.constructor as ConstructorType, applicationKey.toLowerCase(), propertyAccessString);\r\n    };\r\n  }\r\n}\r\n\r\n/** Base class for all typed instances mapped to ECInstance-s in an ECDb\r\n * @beta\r\n */\r\nexport abstract class ECInstance {\r\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"id\")\r\n  public ecId: string;\r\n\r\n  [index: string]: any;\r\n}\r\n\r\n/** @beta */\r\nexport type ChangeState = \"new\" | \"modified\" | \"deleted\";\r\n\r\n/** Base class for all typed instances mapped to ECInstance-s in both an ECDb, and the WSG repository\r\n * @beta\r\n */\r\nexport abstract class WsgInstance extends ECInstance {\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\r\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"wsgId\")\r\n  public wsgId: string;\r\n\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"eTag\")\r\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"eTag\")\r\n  public eTag?: string;\r\n\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"changeState\")\r\n  public changeState?: ChangeState;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModels */\r\nimport { FileHandler } from \"./FileHandler\";\r\nimport { BriefcaseHandler } from \"./imodelhub/Briefcases\";\r\nimport { IModelsHandler, IModelHandler } from \"./imodelhub/iModels\";\r\nimport { ChangeSetHandler } from \"./imodelhub/ChangeSets\";\r\nimport { CheckpointHandler } from \"./imodelhub/Checkpoints\";\r\nimport { LockHandler } from \"./imodelhub/Locks\";\r\nimport { CodeHandler } from \"./imodelhub/Codes\";\r\nimport { UserInfoHandler } from \"./imodelhub/Users\";\r\nimport { VersionHandler } from \"./imodelhub/Versions\";\r\nimport { EventHandler } from \"./imodelhub/Events\";\r\nimport { ThumbnailHandler } from \"./imodelhub/Thumbnails\";\r\nimport { GlobalEventHandler } from \"./imodelhub/GlobalEvents\";\r\nimport { IModelBaseHandler } from \"./imodelhub/BaseHandler\";\r\nimport { CustomRequestOptions } from \"./imodelhub/CustomRequestOptions\";\r\n\r\n/**\r\n * Base class that allows access to different iModel related Class handlers. Handlers should be accessed through an instance of this class, rather than constructed directly.\r\n * @beta\r\n */\r\nexport abstract class IModelClient {\r\n  protected _handler: IModelBaseHandler;\r\n  private _fileHandler?: FileHandler;\r\n  /**\r\n   * Creates an instance of [[IModelClient]].\r\n   * @param fileHandler File handler to handle file upload/download and file system operations.\r\n   */\r\n  public constructor(baseHandler: IModelBaseHandler, fileHandler?: FileHandler) {\r\n    this._handler = baseHandler;\r\n    this._fileHandler = fileHandler || this._handler.getFileHandler();\r\n    if (this._fileHandler)\r\n      this._fileHandler.agent = this._handler.getAgent();\r\n  }\r\n\r\n  /**\r\n   * Sets file handler for file upload/download.\r\n   * @param fileHandler File handler to handle file upload/download and file system operations.\r\n   */\r\n  public setFileHandler(fileHandler: FileHandler) {\r\n    this._fileHandler = fileHandler;\r\n    this._fileHandler.agent = this._handler.getAgent();\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[HubIModel]] instances.\r\n   * @note Use [[IModelHubClient.IModel]] for the preferred single iModel per [[Project]] workflow.\r\n   */\r\n  public get iModels(): IModelsHandler {\r\n    return new IModelsHandler(this._handler, this._fileHandler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[HubIModel]].\r\n   */\r\n  public get iModel(): IModelHandler {\r\n    return new IModelHandler(new IModelsHandler(this._handler, this._fileHandler));\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[Briefcase]]s.\r\n   * @internal\r\n   */\r\n  public get briefcases(): BriefcaseHandler {\r\n    return new BriefcaseHandler(this._handler, this._fileHandler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[ChangeSet]]s.\r\n   * @beta\r\n   */\r\n  public get changeSets(): ChangeSetHandler {\r\n    return new ChangeSetHandler(this._handler, this._fileHandler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[Checkpoint]]s.\r\n   * @alpha\r\n   */\r\n  public get checkpoints(): CheckpointHandler {\r\n    return new CheckpointHandler(this._handler, this._fileHandler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[Lock]]s.\r\n   * @alpha\r\n   */\r\n  public get locks(): LockHandler {\r\n    return new LockHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [Code]($common)s.\r\n   * @alpha\r\n   */\r\n  public get codes(): CodeHandler {\r\n    return new CodeHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[UserInfo]].\r\n   * @alpha\r\n   */\r\n  public get users(): UserInfoHandler {\r\n    return new UserInfoHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[Version]]s.\r\n   * @beta\r\n   */\r\n  public get versions(): VersionHandler {\r\n    return new VersionHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[Thumbnail]]s.\r\n   * @alpha\r\n   */\r\n  public get thumbnails(): ThumbnailHandler {\r\n    return new ThumbnailHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[IModelHubEvent]]s.\r\n   */\r\n  public get events(): EventHandler {\r\n    return new EventHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the handler for [[IModelHubGlobalEvent]]s.\r\n   */\r\n  public get globalEvents(): GlobalEventHandler {\r\n    return new GlobalEventHandler(this._handler);\r\n  }\r\n\r\n  /**\r\n   * Get the [CustomRequestOptions]($clients) object for controlling future request options.\r\n   * @internal\r\n   */\r\n  public get requestOptions(): CustomRequestOptions {\r\n    return this._handler.getCustomRequestOptions();\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Authentication */\n\nimport { assert, AuthStatus, BentleyError, ClientRequestContext, Logger } from \"@bentley/bentleyjs-core\";\nimport { DOMParser } from \"xmldom\";\nimport * as xpath from \"xpath\";\nimport { IAuthorizationClient } from \"./AuthorizationClient\";\nimport { Client } from \"./Client\";\nimport { Config } from \"./Config\";\nimport { ClientsLoggerCategory } from \"./ClientsLoggerCategory\";\nimport { request, RequestOptions, Response } from \"./Request\";\nimport { AccessToken, AuthorizationToken } from \"./Token\";\n\nconst loggerCategory: string = ClientsLoggerCategory.ImsClients;\n\n/** Interface for user credentials for programmatic login to IMS\n * Note: This can only be used in test environments. In a real application, the password cannot be explicitly used in any API.\n * @internal\n * @deprecated\n */\nexport interface ImsUserCredentials {\n  email: string;\n  password: string;\n}\n\n/** Client API for the IMS Federated Authentication Service.\n * @internal\n * @deprecated\n */\nexport class ImsFederatedAuthenticationClient extends Client {\n  public static readonly searchKey: string = \"IMS.FederatedAuth.Url\";\n  /** Creates an instance of ImsFederatedAuthenticationClient. */\n  public constructor() {\n    super();\n  }\n\n  /** Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return ImsFederatedAuthenticationClient.searchKey;\n  }\n\n  /** Parses the response from the token request to obtain the token and the user profile.\n   * @param authTokenResponse Response for the token request.\n   */\n  public static parseTokenResponse(authTokenResponse: string): AuthorizationToken | undefined {\n    const select: xpath.XPathSelect = xpath.useNamespaces({\n      trust: \"http://docs.oasis-open.org/ws-sx/ws-trust/200512\",\n    });\n    const dom: Document = (new DOMParser()).parseFromString(authTokenResponse);\n    const samlAssertion: string = select(\"//saml:Assertion\", dom).toString();\n    if (!samlAssertion)\n      return undefined;\n\n    return AuthorizationToken.fromSamlAssertion(samlAssertion);\n  }\n}\n\n/** Client API for the IMS Active Secure Token Service.\n * @internal\n * @deprecated\n */\nexport class ImsActiveSecureTokenClient extends Client {\n  public static readonly searchKey: string = \"Mobile.ImsStsAuth\";\n  /**\n   * Creates an instance of ImsActiveSecureTokenClient.\n   */\n  public constructor() {\n    super();\n  }\n\n  /**\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return ImsActiveSecureTokenClient.searchKey;\n  }\n\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\n    await super.setupOptionDefaults(options);\n    options.useCorsProxy = false;\n  }\n\n  /**\n   * Gets the authorization token given the credentials.\n   * Note that this can only be used in test environments - in an application passwords are never passed around, and the\n   * application would/should not be aware of it.\n   * @param userCredentials User credentials\n   * @returns Resolves to the token and user profile.\n   */\n  public async getToken(requestContext: ClientRequestContext, userCredentials: ImsUserCredentials, appId?: string): Promise<AuthorizationToken> {\n    const url: string = await this.getUrl(requestContext);\n    const imjsAppId = appId ? `imodeljs ${appId}` : \"imodeljs\";\n\n    const options: RequestOptions = {\n      method: \"POST\",\n      auth: {\n        user: userCredentials.email,\n        password: userCredentials.password,\n      },\n      body: {\n        AppliesTo: Config.App.get(\"imjs_default_relying_party_uri\"),\n        DeviceId: (typeof window === \"undefined\") ? \"backend\" : \"frontend\",\n        AppId: imjsAppId,\n        Lifetime: 7 * 24 * 60, // 7 days\n      },\n    };\n    await this.setupOptionDefaults(options);\n\n    return request(requestContext, url, options)\n      .then(async (res: Response): Promise<AuthorizationToken> => {\n        if (!res.body.RequestedSecurityToken)\n          return Promise.reject(new Error(\"Authorization token not in expected format \" + JSON.stringify(res)));\n\n        const token: AuthorizationToken = AuthorizationToken.fromSamlAssertion(res.body.RequestedSecurityToken);\n        return Promise.resolve(token);\n      });\n  }\n}\n\n/** Client API for the IMS Delegation Secure Token Service.\n * @internal\n * @deprecated\n */\nexport class ImsDelegationSecureTokenClient extends Client {\n  public static readonly searchKey: string = \"ActiveSTSDelegationServiceUrl\";\n  /**\n   * Creates an instance of ImsDelegationSecureTokenClient.\n   */\n  public constructor() {\n    super();\n  }\n\n  /**\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return ImsDelegationSecureTokenClient.searchKey;\n  }\n\n  /**\n   * Gets the default URL for the service.\n   * @returns Default URL for the service.\n   */\n\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\n    await super.setupOptionDefaults(options);\n    options.useCorsProxy = false;\n  }\n\n  /**\n   * Gets the (delegation) access token given the authorization token.\n   * @param requestContext The client request context\n   * @param authTokenInfo Access token.\n   * @param relyingPartyUri Relying party URI required by the service - defaults to a value defined by the configuration.\n   * @param appId Application id that's used for logging and tracing the authorization request\n   * @returns Resolves to the (delegation) access token.\n   */\n  public async getToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken, relyingPartyUri?: string, appId?: string): Promise<AccessToken> {\n    const url: string = await this.getUrl(requestContext) + \"/json/IssueEx\";\n    if (!relyingPartyUri) {\n      relyingPartyUri = Config.App.get(\"imjs_default_relying_party_uri\");\n    }\n\n    const imjsAppId = appId ? `imodeljs ${appId}` : \"imodeljs\";\n\n    const options: RequestOptions = {\n      method: \"POST\",\n      headers: {\n        \"authorization\": authorizationToken.toTokenString(),\n        \"User-Agent\": imjsAppId,\n      },\n      body: {\n        ActAs: authorizationToken.getSamlAssertion(),\n        AppliesTo: relyingPartyUri,\n        AppliesToBootstrapToken: relyingPartyUri,\n        DeviceId: (typeof window === \"undefined\") ? \"backend\" : \"frontend\",\n        AppId: imjsAppId,\n        Lifetime: 60, // 60 minutes\n      },\n    };\n    await this.setupOptionDefaults(options);\n\n    return request(requestContext, url, options)\n      .then(async (res: Response): Promise<AccessToken> => {\n        if (!res.body.RequestedSecurityToken)\n          return Promise.reject(new Error(\"Authorization token not in expected format \" + JSON.stringify(res)));\n\n        const accessToken: AccessToken = AccessToken.fromSamlAssertion(res.body.RequestedSecurityToken);\n        return Promise.resolve(accessToken);\n      });\n  }\n}\n\n/** Implementation of IAuthorizationClient using IMS - this is only used in test environments\n * @internal\n * @deprecated\n */\nexport class ImsTestAuthorizationClient implements IAuthorizationClient {\n  private _accessToken?: AccessToken;\n  private _userCredentials?: ImsUserCredentials;\n  private _relyingPartyUri?: string;\n\n  public async signIn(requestContext: ClientRequestContext, userCredentials: ImsUserCredentials, relyingPartyUri?: string): Promise<AccessToken> {\n    this._userCredentials = userCredentials;\n    this._relyingPartyUri = relyingPartyUri;\n    const authToken: AuthorizationToken = await (new ImsActiveSecureTokenClient()).getToken(requestContext, userCredentials);\n    this._accessToken = await (new ImsDelegationSecureTokenClient()).getToken(requestContext, authToken, relyingPartyUri);\n    return this._accessToken;\n  }\n\n  /** Returns true if there's a current authorized user or client (in the case of agent applications).\n   * Returns true if signed in and the access token has not expired, and false otherwise.\n   */\n  public get isAuthorized(): boolean {\n    return !!this._accessToken && !this.hasExpired;\n  }\n\n  /** Returns true if the user has signed in, but the token has expired and requires a refresh */\n  public get hasExpired(): boolean {\n    if (!this._accessToken)\n      return false;\n    const expiresAt = this._accessToken.getExpiresAt();\n    assert(!!expiresAt);\n    return ((expiresAt!.getTime() - Date.now()) <= 0);\n  }\n\n  /** Returns true if the user has signed in, but the token has expired and requires a refresh */\n  public get hasSignedIn(): boolean {\n    return !!this._accessToken;\n  }\n\n  /** Returns a promise that resolves to the AccessToken of the currently authorized user\n   * or authorized client (in the case of agent applications).\n   * The token is refreshed if necessary and possible.\n   * @throws [[BentleyError]] If the client was not used to authorize, or there was an authorization error.\n   */\n  public async getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken> {\n    if (this.isAuthorized)\n      return this._accessToken!;\n    if (!this._userCredentials)\n      throw new BentleyError(AuthStatus.Error, \"No use has signed in - call ImsTokenManager.signIn() before fetching access token\", Logger.logError, loggerCategory);\n    return this.signIn(requestContext || new ClientRequestContext(), this._userCredentials, this._relyingPartyUri);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module OtherServices */\nimport { ClientRequestContext, Guid } from \"@bentley/bentleyjs-core\";\nimport { ECJsonTypeMap, WsgInstance } from \"./ECJsonTypeMap\";\nimport { WsgClient } from \"./WsgClient\";\nimport { URL } from \"url\";\nimport { request, RequestOptions } from \"./Request\";\nimport { Config } from \"./Config\";\nimport { AuthorizedClientRequestContext } from \"./AuthorizedClientRequestContext\";\nimport { Angle, Range2d } from \"@bentley/geometry-core\";\n\n/** RealityData\n * This class implements a Reality Data stored in ProjectWise Context Share (Reality Data Service)\n * Data is accessed directly through methods of the reality data instance.\n * Access to the data required a properly entitled token though the access to the blob is controlled through\n * an Azure blob URL, the token may be required to obtain this Azure blob URL or refresh it.\n * The Azure blob URL is considered valid for an hour and is refreshed after 50 minutes.\n * In addition to the reality data properties, and Azure blob URL and internal states, a reality data also contains\n * the identification of the CONNECT project to identify the context(used for access permissions resolution) and\n * may contain a RealityDataClient to obtain the WSG client specialization to communicate with ProjectWise Context Share (to obtain the Azure blob URL).\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"S3MX.RealityData\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class RealityData extends WsgInstance {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Id\")\n  public id?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.OrganizationId\")\n  public organizationId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UltimateId\")\n  public ultimateId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UltimateSite\")\n  public ultimateSite?: string;\n\n  /** This is typically the iModelId */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ContainerName\")\n  public containerName?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.DataLocationGuid\")\n  public dataLocationGuid?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Name\")\n  public name?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Dataset\")\n  public dataSet?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Group\")\n  public group?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Description\")\n  public description?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.RootDocument\")\n  public rootDocument?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Size\")\n  public size?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.SizeUpToDate\")\n  public sizeUpToDate?: boolean;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Classification\")\n  public classification?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Streamed\")\n  public streamed?: boolean;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Type\")\n  public type?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Footprint\")\n  public footprint?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ApproximateFootprint\")\n  public approximateFootprint?: boolean;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ThumbnailDocument\")\n  public thumbnailDocument?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.MetadataUrl\")\n  public metadataUrl?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Copyright\")\n  public copyright?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.TermsOfUse\")\n  public termsOfUse?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.AccuracyInMeters\")\n  public accuracyInMeters?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ResolutionInMeters\")\n  public resolutionInMeters?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Visibility\")\n  public visibility?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Listable\")\n  public listable?: boolean;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ModifiedTimestamp\")\n  public modifiedTimestamp?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.LastAccessedTimeStamp\")\n  public lastAccessedTimestamp?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatedTimestamp\")\n  public createdTimestamp?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.OwnedBy\")\n  public ownedBy?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.OwnerId\")\n  public ownerId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatorId\")\n  public creatorId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Version\")\n  public version?: string;\n\n  // Delegate permission is read-only and irrelevant for use so it is omitted.\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Hidden\")\n  public hidden?: boolean;\n\n  // Cache parameters for reality data access. Contains the blob url, the timestamp to refresh (every 50 minutes) the url and the root document path.\n  private _blobUrl: any;\n  private _blobTimeStamp: Date;\n  private _blobRooDocumentPath: undefined | string; // Path relative to blob root of root document. It is slash terminated if not empty\n\n  // Link to client to fetch the blob url\n  public client: undefined | RealityDataServicesClient;\n\n  // project id used when using the client. If defined must contain the GUID of the CONNECT\n  // project or \"Server\" to indicate access is performed out of context (for accessing PUBLIC or ENTERPRISE data).\n  // If undefined when accessing reality data tiles then it will automatically be set to \"Server\"\n  public projectId: undefined | string;\n\n  /**\n   * Gets string url to fetch blob data from. Access is read-only.\n   * @param requestContext The client request context.\n   * @param name name or path of tile\n   * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.\n   * @returns string url for blob data\n   */\n  public async getBlobStringUrl(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath: boolean = false): Promise<string> {\n    const url = await this.getBlobUrl(requestContext);\n\n    let host: string = \"\";\n    if (nameRelativeToRootDocumentPath && this._blobRooDocumentPath && this._blobRooDocumentPath !== \"\")\n      host = url.origin + url.pathname + \"/\" + this._blobRooDocumentPath; // _blobRootDocumentPath is always '/' terminated if not empty\n    else\n      host = url.origin + url.pathname + \"/\";\n\n    const query = url.search;\n\n    return `${host}${name}${query}`;\n  }\n\n  /**\n   * Gets a tileset's tile data\n   * @param requestContext The client request context.\n   * @param name name or path of tile\n   * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.\n   * @returns tile data json\n   */\n  public async getModelData(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath: boolean = false): Promise<any> {\n    return this.getTileJson(requestContext, name, nameRelativeToRootDocumentPath);\n  }\n\n  /**\n   * Gets a tile access url URL object\n   * @param requestContext The client request context.\n   * @param writeAccess Optional boolean indicating if write access is requested. Default is false for read-only access.\n   * @returns app URL object for blob url\n   */\n  public async getBlobUrl(requestContext: AuthorizedClientRequestContext, writeAccess: boolean = false): Promise<URL> {\n    // Normally the client is set when the reality data is extracted for the client but it could be undefined\n    // if the reality data instance is created manually.\n    if (!this.client)\n      this.client = new RealityDataServicesClient();\n\n    if (!this.projectId)\n      this.projectId = \"Server\";\n\n    if (!this.id)\n      return Promise.reject(new Error(\"id not set\"));\n\n    if (undefined === this._blobUrl || this._blobTimeStamp.valueOf() - Date.now() > 3000000) { // 3 million milliseconds or 50 minutes\n      const fileAccess: FileAccessKey[] = await this.client.getFileAccessKey(requestContext, this.projectId as string, this.id, writeAccess);\n      if (fileAccess.length !== 1)\n        return Promise.reject(new Error(\"Could not obtain blob file access key for reality data: \" + this.id));\n      const urlString = fileAccess[0].url!;\n      this._blobUrl = (typeof window !== \"undefined\") ? new window.URL(urlString) : new URL(urlString);\n      this._blobTimeStamp = new Date(Date.now());\n      if (!this._blobRooDocumentPath && this.rootDocument) {\n        const urlParts = this.rootDocument.split(\"/\");\n        urlParts.pop();\n        if (urlParts.length === 0)\n          this._blobRooDocumentPath = \"\";\n        else\n          this._blobRooDocumentPath = urlParts.join(\"/\") + \"/\";\n      }\n    }\n\n    return Promise.resolve(this._blobUrl);\n  }\n\n  /**\n   * Gets a tileset's app data json\n   * @param requestContext The client request context.\n   * @param name name or path of tile\n   * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.\n   * @returns app data json object\n   */\n  public async getTileJson(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath: boolean = false): Promise<any> {\n    const stringUrl = await this.getBlobStringUrl(requestContext, name, nameRelativeToRootDocumentPath);\n    const options: RequestOptions = {\n      method: \"GET\",\n      responseType: \"json\",\n    };\n    const data = await request(requestContext, stringUrl, options);\n    return data.body;\n  }\n\n  /**\n   * Gets tile content\n   * @param requestContext The client request context.\n   * @param name name or path of tile\n   * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.\n   * @returns array buffer of tile content\n   */\n  public async getTileContent(requestContext: AuthorizedClientRequestContext, name: string, nameRelativeToRootDocumentPath: boolean = false): Promise<any> {\n    const stringUrl = await this.getBlobStringUrl(requestContext, name, nameRelativeToRootDocumentPath);\n    const options: RequestOptions = {\n      method: \"GET\",\n      responseType: \"arraybuffer\",\n    };\n    const data = await request(requestContext, stringUrl, options);\n    return data.body;\n  }\n\n  /**\n   * Gets a reality data root document json\n   * @param requestContext The client request context.\n   * @returns tile data json\n   */\n  public async getRootDocumentJson(requestContext: AuthorizedClientRequestContext): Promise<any> {\n    requestContext.enter();\n\n    if (!this.rootDocument)\n      return Promise.reject(new Error(\"Root document not defined for reality data: \" + this.id));\n\n    const root = this.rootDocument!;\n\n    return this.getModelData(requestContext, root, false);\n  }\n\n}\n\n/** File Access Key\n * This class is used by the RealityDataServicesClient to extract an Azure blob URL\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"FileAccess.FileAccessKey\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class FileAccessKey extends WsgInstance {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Url\")\n  public url?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Type\")\n  public type?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Permissions\")\n  public permissions?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.RequiresConfirmation\")\n  public requiresConfirmation?: string;\n}\n\n/** RealityDataRelationship\n * This class is used to represent relationships with a Reality Data and CONNECT Context (CONNECT Project or CONNECT Asset)\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"S3MX.RealityDataRelationship\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class RealityDataRelationship extends WsgInstance {\n  //  @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\n  //  public id?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.RealityDataId\")\n  public realityDataId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.RelationType\")\n  public relationType?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.RelatedId\")\n  public relatedId?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ModifiedTimestamp\")\n  public modifiedTimestamp?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatedTimestamp\")\n  public createdTimestamp?: string;\n}\n\n/**\n * Client wrapper to Reality Data Service.\n * An instance of this class is used to extract reality data from the ProjectWise Context Share (Reality Data Service)\n * Most important methods enable to obtain a specific reality data, fetch all reality data associated to a project and\n * all reality data of a project within a provided spatial extent.\n * This class also implements extraction of the Azure blob address.\n * @internal\n */\nexport class RealityDataServicesClient extends WsgClient {\n  public static readonly searchKey: string = \"RealityDataServices\";\n  public static readonly configRelyingPartyUri = \"imjs_reality_data_service_relying_party_uri\";\n\n  /**\n   * Creates an instance of RealityDataServicesClient.\n   */\n  public constructor() {\n    super(\"v2.5\");\n  }\n\n  /**\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return RealityDataServicesClient.searchKey;\n  }\n\n  /**\n   * Gets theRelyingPartyUrl for the service.\n   * @returns RelyingPartyUrl for the service.\n   */\n  protected getRelyingPartyUrl(): string {\n    if (Config.App.has(RealityDataServicesClient.configRelyingPartyUri))\n      return Config.App.get(RealityDataServicesClient.configRelyingPartyUri) + \"/\";\n\n    if (Config.App.getBoolean(WsgClient.configUseHostRelyingPartyUriAsFallback, true)) {\n      if (Config.App.has(WsgClient.configHostRelyingPartyUri))\n        return Config.App.get(WsgClient.configHostRelyingPartyUri) + \"/\";\n    }\n\n    throw new Error(`RelyingPartyUrl not set. Set it in Config.App using key ${RealityDataServicesClient.configRelyingPartyUri}`);\n  }\n\n  /**\n   * This method returns the URL to obtain the Reality Data details from PW Context Share.\n   * Technically it should never be required as the RealityData object returned should have all the information to obtain the\n   * data.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job\n   * @returns string containing the URL to reality data for indicated tile.\n   */\n  public async getRealityDataUrl(requestContext: ClientRequestContext, projectId: string, tilesId: string): Promise<string> {\n    const serverUrl: string = await this.getUrl(requestContext);\n\n    return serverUrl + `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${tilesId}`;\n  }\n\n  /**\n   * Gets reality data with all of its properties\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job\n   * @returns The requested reality data.\n   */\n  public async getRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, tilesId: string): Promise<RealityData> {\n    const realityDatas: RealityData[] = await this.getInstances<RealityData>(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${tilesId}`);\n    if (realityDatas.length !== 1)\n      return Promise.reject(new Error(\"Could not fetch reality data: \" + tilesId));\n\n    realityDatas[0].client = this;\n    realityDatas[0].projectId = projectId;\n    return realityDatas[0];\n  }\n\n  /**\n   * Gets all reality data associated to the project. Consider using getRealityDataInProjectOverlapping() if spatial extent is known.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @returns an array of RealityData that are associated to the project.\n   */\n  public async getRealityDataInProject(requestContext: AuthorizedClientRequestContext, projectId: string): Promise<RealityData[]> {\n    const realityDatas: RealityData[] = await this.getInstances<RealityData>(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData?project=${projectId}&$filter=Type+eq+'RealityMesh3DTiles'`);\n    realityDatas.forEach((realityData) => { realityData.client = this; realityData.projectId = projectId; });\n    return realityDatas;\n  }\n\n  /**\n   * Gets all reality data that has a footprint defined that overlaps the given area and that are associated with the project. Reality Data returned must be accessible by user\n   * as public, enterprise data, private or accessible through context RBAC rights attributed to user.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param range The range to search for given as a range 2d where X represents the longitude in radians and Y the latitude in radians\n   * longitude can be in the range -2P to 2PI but the minimum value must be smaller numerically to the maximum.\n   * Note that the longitudes are usually by convention in the range of -PI to PI except\n   * for ranges that overlap the -PI/+PI frontier in which case either representation is acceptable.\n   * @returns an array of RealityData\n   */\n  public async getRealityDataInProjectOverlapping(requestContext: AuthorizedClientRequestContext, projectId: string, range: Range2d): Promise<RealityData[]> {\n    const minLongDeg = Angle.radiansToDegrees(range.low.x);\n    const maxLongDeg = Angle.radiansToDegrees(range.high.x);\n    const minLatDeg = Angle.radiansToDegrees(range.low.y);\n    const maxLatDeg = Angle.radiansToDegrees(range.high.y);\n    const polygonString = `{\\\"points\\\":[[${minLongDeg},${minLatDeg}],[${maxLongDeg},${minLatDeg}],[${maxLongDeg},${maxLatDeg}],[${minLongDeg},${maxLatDeg}],[${minLongDeg},${minLatDeg}]], \\\"coordinate_system\\\":\\\"4326\\\"}`;\n\n    const realityDatas: RealityData[] = await this.getInstances<RealityData>(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData?project=${projectId}&polygon=${polygonString}&$filter=Type+eq+'RealityMesh3DTiles'`);\n    realityDatas.forEach((realityData) => { realityData.client = this; realityData.projectId = projectId; });\n    return realityDatas;\n  }\n\n  /**\n   * Creates a reality data with given properties\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param realityData The reality data to create. The Id of the reality data is usually left empty indicating for the service to assign\n   * one. If set then the reality id must not exist on the server.\n   * realityDataInstance id, called tilesId when returned from tile generator job\n   * @returns The new reality data with all read-only properties set.\n   */\n  public async createRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, realityData: RealityData): Promise<RealityData> {\n    const resultRealityData: RealityData = await this.postInstance<RealityData>(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData`, realityData);\n    if (!resultRealityData)\n      return Promise.reject(new Error(\"Could not create new reality data: \" + (realityData.id ? realityData.id : realityData.name)));\n\n    resultRealityData.client = this;\n    resultRealityData.projectId = projectId;\n    return resultRealityData;\n  }\n\n  /**\n   * Updates a reality data with given properties\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param realityData The reality data to update. The Id must contain the identifier of the reality data to update.\n   * NOTE: As a probable known defect some specific read-only attributes must be undefined prior to passing the reality data.\n   * These are: organizationId, sizeUpToDate, ownedBy, ownerId\n   * @returns The newly modified reality data.\n   */\n  public async updateRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, realityData: RealityData): Promise<RealityData> {\n    const resultRealityData: RealityData = await this.postInstance<RealityData>(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${realityData.id}`, realityData);\n    if (!resultRealityData)\n      return Promise.reject(new Error(\"Could not update reality data: \" + (realityData.id ? realityData.id : realityData.name)));\n\n    resultRealityData.client = this;\n    resultRealityData.projectId = projectId;\n    return resultRealityData;\n  }\n\n  /**\n   * Deletes a reality data.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param realityDataId The identifier of the reality data to delete.\n   * @returns a void Promise.\n   */\n  public async deleteRealityData(requestContext: AuthorizedClientRequestContext, projectId: string, realityDataId: string): Promise<void> {\n    return this.deleteInstance<RealityData>(requestContext, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${realityDataId}`);\n  }\n\n  /**\n   * Gets all reality data relationships associated to the given reality id, not only the relationship for given project.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project in which to make to call for permission reason\n   * @param realityDataId realityDataInstance id to obtain the relationships for.\n   * @returns All relationships associated to reality data. NThe requested reality data.\n   */\n  public async getRealityDataRelationships(requestContext: AuthorizedClientRequestContext, projectId: string, realityDataId: string): Promise<RealityDataRelationship[]> {\n    const relationships: RealityDataRelationship[] = await this.getInstances<RealityDataRelationship>(requestContext, RealityDataRelationship, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityDataRelationship?$filter=RealityDataId+eq+'${realityDataId}'`);\n    return relationships;\n  }\n\n  /**\n   * Gets all reality data relationships associated to the given reality id, not only the relationship for given project.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project in which to make to call for permission reason\n   * @param realityDataId realityDataInstance id to obtain the relationships for.\n   * @returns All relationships associated to reality data. NThe requested reality data.\n   */\n  public async createRealityDataRelationship(requestContext: AuthorizedClientRequestContext, projectId: string, relationship: RealityDataRelationship): Promise<RealityDataRelationship> {\n    const resultRealityDataRelationship: RealityDataRelationship = await this.postInstance<RealityDataRelationship>(requestContext, RealityDataRelationship, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityDataRelationship`, relationship);\n    if (!resultRealityDataRelationship)\n      return Promise.reject(new Error(\"Could not create new reality data relationship between reality data: \" + (relationship.realityDataId ? relationship.realityDataId : \"\") + \" and context: \" + (relationship.relatedId ? relationship.relatedId : \"\")));\n\n    return resultRealityDataRelationship;\n  }\n\n  /**\n   * Gets all reality data relationships associated to the given reality id, not only the relationship for given project.\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project in which to make to call for permission reason\n   * @param realityDataId realityDataInstance id to obtain the relationships for.\n   * @returns All relationships associated to reality data. NThe requested reality data.\n   */\n  public async deleteRealityDataRelationship(requestContext: AuthorizedClientRequestContext, projectId: string, relationshipId: string): Promise<void> {\n    return this.deleteInstance<RealityDataRelationship>(requestContext, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityDataRelationship/${relationshipId}`);\n  }\n\n  /**\n   * Gets a tile file access key\n   * @param requestContext The client request context.\n   * @param projectId id of associated connect project\n   * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job.\n   * @param writeAccess Optional boolean indicating if write access is requested. Default is false for read-only access.\n   * @returns a FileAccessKey object containing the Azure blob address.\n   */\n  public async getFileAccessKey(requestContext: AuthorizedClientRequestContext, projectId: string, tilesId: string, writeAccess: boolean = false): Promise<FileAccessKey[]> {\n    const path = encodeURIComponent(tilesId);\n    if (writeAccess)\n      return this.getInstances<FileAccessKey>(requestContext, FileAccessKey, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${path}/FileAccess.FileAccessKey?$filter=Permissions+eq+%27Write%27`);\n    else\n      return this.getInstances<FileAccessKey>(requestContext, FileAccessKey, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${path}/FileAccess.FileAccessKey?$filter=Permissions+eq+%27Read%27`);\n  }\n\n  // ###TODO temporary means of extracting the tileId and projectId from the given url\n  // This is the method that determines if the url refers to Reality Data stored on PW Context Share. If not then undefined is returned.\n  /**\n   * This is the method that determines if the url refers to Reality Data stored on PW Context Share. If not then undefined is returned.\n   * @param url A fully formed URL to a reality data or a reality data folder or document of the form:\n   *              https://{Host}/{version}/Repositories/S3MXECPlugin--{ProjectId}/S3MX/RealityData/{RealityDataId}\n   *              https://{Host}/{version}/Repositories/S3MXECPlugin--{ProjectId}/S3MX/Folder/{RealityDataId}~2F{Folder}\n   *              https://{Host}/{version}/Repositories/S3MXECPlugin--{ProjectId}/S3MX/Document/{RealityDataId}~2F{Full Document Path and name}'\n   *            Where {Host} represents the Reality Data Service server (ex: connect-realitydataservices.bentley.com). This value is ignored since the\n   *            actual host server name depends on the environment or can be changed in the future.\n   *            Where {version} is the Bentley Web Service Gateway protocol version. This value is ignored but the version must be supported by Reality Data Service.\n   *            Where {Folder} and {Document} are the full folder or document path relative to the Reality Data root.\n   *            {RealityDataId} is extracted after validation of the URL and returned.\n   *            {ProjectId} is ignored.\n   * @returns A string containing the Reality Data Identifier (otherwise named tile id). If the URL is not a reality data service URL then undefined is returned.\n   */\n  public getRealityDataIdFromUrl(url: string): string | undefined {\n    let realityDataId: string | undefined;\n\n    const formattedUrl = url.replace(/~2F/g, \"/\");\n    const urlParts = formattedUrl.split(\"/\").map((entry: string) => entry.replace(/%2D/g, \"-\"));\n\n    if ((urlParts[4] === \"Repositories\") && urlParts[5].match(\"S3MXECPlugin--*\") && (urlParts[6] === \"S3MX\")) {\n      // URL appears tpo be a correctly formed URL to Reality Data Service ... obtain the first GUID\n      realityDataId = urlParts.find(Guid.isGuid);\n    }\n    return realityDataId;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module BaseClients */\nimport { BentleyError, ClientRequestContext, GetMetaDataFunction, HttpStatus, Logger, LogLevel } from \"@bentley/bentleyjs-core\";\nimport * as deepAssign from \"deep-assign\";\nimport * as https from \"https\";\nimport { IStringifyOptions, stringify } from \"qs\";\nimport * as sarequest from \"superagent\";\nimport { Config } from \"./Config\";\nimport { ClientsLoggerCategory } from \"./ClientsLoggerCategory\";\n\nconst loggerCategory: string = ClientsLoggerCategory.Request;\n\n/** @beta */\nexport const requestIdHeaderName = \"X-Correlation-Id\";\n\n/** @beta */\nexport interface RequestBasicCredentials { // axios: AxiosBasicCredentials\n  user: string; // axios: username\n  password: string; // axios: password\n  // sendImmediately deprecated, user -> userName\n}\n\n/** Typical option to query REST API. Note that services may not quite support these fields,\n * and the interface is only provided as a hint.\n * @beta\n */\nexport interface RequestQueryOptions {\n  /**\n   * Select string used by the query (use the mapped EC property names, and not TypeScript property names)\n   * Example: \"Name,Size,Description\"\n   */\n  $select?: string;\n\n  /**\n   * Filter string used by the query (use the mapped EC property names, and not TypeScript property names)\n   *  Example: \"Name like '*.pdf' and Size lt 1000\"\n   */\n  $filter?: string;\n\n  /** Sets the limit on the number of entries to be returned by the query */\n  $top?: number;\n\n  /** Sets the number of entries to be skipped */\n  $skip?: number;\n\n  /**\n   * Orders the return values (use the mapped EC property names, and not TypeScript property names)\n   * Example: \"Size desc\"\n   */\n  $orderby?: string;\n\n  /**\n   *  Sets the limit on the number of entries to be returned by a single response.\n   *  Can be used with a Top option. For example if Top is set to 1000 and PageSize\n   *  is set to 100 then 10 requests will be performed to get result.\n   */\n  $pageSize?: number;\n}\n\n/** @beta */\nexport interface RequestQueryStringifyOptions {\n  delimiter?: string;\n  encode?: boolean;\n  // sep -> delimiter, eq deprecated, encode -> encode\n}\n\n/** Option to control the time outs\n * Use a short response timeout to detect unresponsive networks quickly, and a long deadline to give time for downloads on slow,\n * but reliable, networks. Note that both of these timers limit how long uploads of attached files are allowed to take. Use long\n * timeouts if you're uploading files.\n * @beta\n */\nexport interface RequestTimeoutOptions {\n  /** Sets a deadline (in milliseconds) for the entire request (including all uploads, redirects, server processing time) to complete.\n   * If the response isn't fully downloaded within that time, the request will be aborted\n   */\n  deadline?: number;\n\n  /** Sets maximum time (in milliseconds) to wait for the first byte to arrive from the server, but it does not limit how long the entire\n   * download can take. Response timeout should be at least few seconds longer than just the time it takes the server to respond, because\n   * it also includes time to make DNS lookup, TCP/IP and TLS connections, and time to upload request data.\n   */\n  response?: number;\n}\n\n/** @beta */\nexport interface RequestOptions {\n  method: string;\n  headers?: any; // {Mas-App-Guid, Mas-UUid, User-Agent}\n  auth?: RequestBasicCredentials;\n  body?: any;\n  qs?: any | RequestQueryOptions;\n  responseType?: string;\n  timeout?: RequestTimeoutOptions; // Optional timeouts. If unspecified, an arbitrary default is setup.\n  stream?: any; // Optional stream to read the response to/from (only for NodeJs applications)\n  readStream?: any; // Optional stream to read input from (only for NodeJs applications)\n  buffer?: any;\n  parser?: any;\n  accept?: string;\n  redirects?: number;\n  errorCallback?: (response: any) => ResponseError;\n  retryCallback?: (error: any, response: any) => boolean;\n  progressCallback?: (progress: ProgressInfo) => void;\n  agent?: https.Agent;\n  retries?: number;\n  useCorsProxy?: boolean;\n}\n\n/** Response object if the request was successful. Note that the status within the range of 200-299 are considered as a success.\n * @beta\n */\nexport interface Response {\n  body: any; // Parsed body of response\n  header: any; // Parsed headers of response\n  status: number; // Status code of response\n}\n\n/** @beta */\nexport interface ProgressInfo {\n  percent?: number;\n  total?: number;\n  loaded: number;\n}\n\n/** @beta */\nexport class RequestGlobalOptions {\n  public static httpsProxy?: https.Agent = undefined;\n  public static timeout: RequestTimeoutOptions = {\n    deadline: 25000,\n    response: 10000,\n  };\n}\n\n/** Error object that's thrown/rejected if the Request fails due to a network error, or if the status is *not* in the range of 200-299 (inclusive)\n * @beta\n */\nexport class ResponseError extends BentleyError {\n  protected _data?: any;\n  public status?: number;\n  public description?: string;\n  public constructor(errorNumber: number | HttpStatus, message?: string, getMetaData?: GetMetaDataFunction) {\n    super(errorNumber, message, undefined, undefined, getMetaData);\n  }\n\n  /**\n   * Parses error from server's response\n   * @param response Http response from the server.\n   * @returns Parsed error.\n   * @internal\n   */\n  public static parse(response: any, log = true): ResponseError {\n    const error = new ResponseError(ResponseError.parseHttpStatus(response.statusType));\n    if (!response) {\n      error.message = \"Couldn't get response object.\";\n      return error;\n    }\n\n    if (response.response) {\n      if (response.response.error) {\n        error.name = response.response.error.name || error.name;\n        error.description = response.response.error.message;\n      }\n      if (response.response.res) {\n        error.message = response.response.res.statusMessage;\n      }\n      if (response.response.body && Object.keys(response.response.body).length > 0) {\n        error._data = {};\n        deepAssign(error._data, response.response.body);\n      } else {\n        error._data = response.response.text;\n      }\n    }\n\n    error.status = response.status || response.statusCode;\n    error.name = response.code || response.name || error.name;\n    error.message = error.message || response.message || response.statusMessage;\n\n    if (log)\n      error.log();\n\n    return error;\n  }\n\n  /**\n   * Decides whether request should be retried or not\n   * @param error Error returned by request\n   * @param response Response returned by request\n   * @internal\n   */\n  public static shouldRetry(error: any, response: any): boolean {\n    if (error !== undefined && error !== null) {\n      if ((error.status === undefined || error.status === null) && (error.res === undefined || error.res === null)) {\n        return true;\n      }\n    }\n    return (response !== undefined && response.statusType === HttpStatus.ServerError);\n  }\n\n  /**\n   * @internal\n   */\n  public static parseHttpStatus(statusType: number): HttpStatus {\n    switch (statusType) {\n      case 1:\n        return HttpStatus.Info;\n      case 2:\n        return HttpStatus.Success;\n      case 3:\n        return HttpStatus.Redirection;\n      case 4:\n        return HttpStatus.ClientError;\n      case 5:\n        return HttpStatus.ServerError;\n      default:\n        return HttpStatus.Success;\n    }\n  }\n\n  /**\n   * @internal\n   */\n  public logMessage(): string {\n    return `${this.status} ${this.name}: ${this.message}`;\n  }\n\n  /**\n   * Logs this error\n   * @internal\n   */\n  public log(): void {\n    Logger.logError(loggerCategory, this.logMessage(), this.getMetaData());\n  }\n}\n\nconst logResponse = (req: sarequest.SuperAgentRequest, startTime: number) => (res: sarequest.Response) => {\n  const elapsed = new Date().getTime() - startTime;\n  const elapsedTime = elapsed + \"ms\";\n  Logger.logTrace(loggerCategory, `${req.method.toUpperCase()} ${res.status} ${req.url} (${elapsedTime})`);\n};\n\nconst logRequest = (req: sarequest.SuperAgentRequest) => {\n  const startTime = new Date().getTime();\n  req.on(\"response\", logResponse(req, startTime));\n  return req;\n};\n\n// @todo The purpose of this wrapper is to allow us to easily replace this with another\n// module that will rid us of NodeJs dependency.\n\n/** Wrapper around HTTP request utility\n * @param requestContext The client request context\n * @param url Server URL to address the request\n * @param options Options to pass to the request\n * @returns Resolves to the response from the server\n * @throws ResponseError if the request fails due to network issues, or if the returned status is *outside* the range of 200-299 (inclusive)\n * @internal\n */\nexport async function request(requestContext: ClientRequestContext, url: string, options: RequestOptions): Promise<Response> {\n  requestContext.enter();\n  let proxyUrl = \"\";\n  if (options.useCorsProxy === true) {\n    proxyUrl = Config.App.get(\"imjs_dev_cors_proxy_server\", \"\");\n    if (proxyUrl === \"\")\n      proxyUrl = url;\n    else\n      proxyUrl = proxyUrl.replace(/\\/$/, \"\") + \"/\" + url;\n  } else {\n    proxyUrl = url;\n  }\n  const retries = typeof options.retries === \"undefined\" ? 4 : options.retries;\n  let sareq: sarequest.SuperAgentRequest = sarequest(options.method, proxyUrl).retry(retries, options.retryCallback);\n\n  if (Logger.isEnabled(loggerCategory, LogLevel.Trace))\n    sareq = sareq.use(logRequest);\n\n  if (options.headers)\n    sareq = sareq.set(options.headers);\n\n  if (requestContext.activityId !== \"\")\n    sareq.set(requestIdHeaderName, requestContext.activityId);\n\n  let queryStr: string = \"\";\n  let fullUrl: string = \"\";\n  if (options.qs && Object.keys(options.qs).length > 0) {\n    const stringifyOptions: IStringifyOptions = { delimiter: \"&\", encode: false };\n    queryStr = stringify(options.qs, stringifyOptions);\n    sareq = sareq.query(queryStr);\n    fullUrl = url + \"?\" + queryStr;\n  } else {\n    fullUrl = url;\n  }\n\n  Logger.logInfo(loggerCategory, fullUrl);\n\n  if (options.auth)\n    sareq = sareq.auth(options.auth.user, options.auth.password);\n\n  if (options.accept)\n    sareq = sareq.accept(options.accept);\n\n  if (options.body)\n    sareq = sareq.send(options.body);\n\n  if (options.timeout)\n    sareq = sareq.timeout(options.timeout);\n  else\n    sareq = sareq.timeout(RequestGlobalOptions.timeout);\n\n  if (options.responseType)\n    sareq = sareq.responseType(options.responseType);\n\n  if (options.redirects)\n    sareq = sareq.redirects(options.redirects);\n  else\n    sareq = sareq.redirects(0);\n\n  if (options.buffer)\n    sareq.buffer(options.buffer);\n\n  if (options.parser)\n    sareq.parse(options.parser);\n\n  if (options.agent)\n    sareq.agent(options.agent);\n  else if (RequestGlobalOptions.httpsProxy)\n    sareq.agent(RequestGlobalOptions.httpsProxy);\n\n  if (options.progressCallback) {\n    sareq.on(\"progress\", (event: sarequest.ProgressEvent) => {\n      if (event) {\n        options.progressCallback!({\n          loaded: event.loaded,\n          total: event.total,\n          percent: event.percent,\n        });\n      }\n    });\n  }\n\n  const errorCallback = options.errorCallback ? options.errorCallback : ResponseError.parse;\n\n  if (options.readStream) {\n    if (typeof window !== \"undefined\")\n      throw new Error(\"This option is not supported on browsers\");\n\n    return new Promise<Response>((resolve, reject) => {\n      sareq = sareq.type(\"blob\");\n      options\n        .readStream\n        .pipe(sareq)\n        .on(\"error\", (error: any) => {\n          const parsedError = errorCallback(error);\n          reject(parsedError);\n        })\n        .on(\"end\", () => {\n          const retResponse: Response = {\n            status: 201,\n            header: undefined,\n            body: undefined,\n          };\n          resolve(retResponse);\n        });\n    });\n  }\n\n  if (options.stream) {\n    if (typeof window !== \"undefined\")\n      throw new Error(\"This option is not supported on browsers\");\n\n    return new Promise<Response>((resolve, reject) => {\n      sareq\n        .on(\"response\", (res: any) => {\n          if (res.statusCode !== 200) {\n            const parsedError = errorCallback(res);\n            reject(parsedError);\n            return;\n          }\n        })\n        .pipe(options.stream)\n        .on(\"error\", (error: any) => {\n          const parsedError = errorCallback(error);\n          reject(parsedError);\n        })\n        .on(\"finish\", () => {\n          const retResponse: Response = {\n            status: 200,\n            header: undefined,\n            body: undefined,\n          };\n          resolve(retResponse);\n        });\n    });\n  }\n\n  // console.log(\"%s %s %s\", url, options.method, queryStr);\n\n  /*\n  * Note:\n  * Javascript's fetch returns status.OK if error is between 200-299 inclusive, and doesn't reject in this case.\n  * Fetch only rejects if there's some network issue (permissions issue or similar)\n  * Superagent rejects network issues, and errors outside the range of 200-299. We are currently using\n  * superagent, but may eventually switch to JavaScript's fetch library.\n  */\n  return sareq\n    .then(async (response: sarequest.Response) => {\n      const retResponse: Response = {\n        body: response.body,\n        header: response.header,\n        status: response.status,\n      };\n      return Promise.resolve(retResponse);\n    })\n    .catch(async (error: any) => {\n      const parsedError = errorCallback(error);\n      return Promise.reject(parsedError);\n    });\n}\n\n/**\n * fetch array buffer from HTTP request\n * @param url server URL to address the request\n * @internal\n */\nexport async function getArrayBuffer(requestContext: ClientRequestContext, url: string): Promise<any> {\n  const options: RequestOptions = {\n    method: \"GET\",\n    responseType: \"arraybuffer\",\n  };\n  const data = await request(requestContext, url, options);\n  return data.body;\n}\n\n/**\n * fetch json from HTTP request\n * @param url server URL to address the request\n * @internal\n */\nexport async function getJson(requestContext: ClientRequestContext, url: string): Promise<any> {\n  const options: RequestOptions = {\n    method: \"GET\",\n    responseType: \"json\",\n  };\n  const data = await request(requestContext, url, options);\n  return data.body;\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Settings */\r\n\r\nimport { AuthorizedClientRequestContext } from \"./AuthorizedClientRequestContext\";\r\n\r\n/** Possible values for SettingsResults.status\r\n * @alpha\r\n */\r\nexport enum SettingsStatus {\r\n  SETTINGS_ERROR_BASE = 0x1b000,\r\n  /** The specified setting was successfully saved, deleted, or retrieved. */\r\n  Success = 0,\r\n  /** Access to the specified setting was blocked. */\r\n  AuthorizationError = SETTINGS_ERROR_BASE + 1,\r\n  /** The Url for the setting is not properly formed. Check the characters in the setting name. */\r\n  UrlError = SETTINGS_ERROR_BASE + 2,\r\n  /** An invalid projectId was specified. */\r\n  ProjectInvalid = SETTINGS_ERROR_BASE + 3,\r\n  /** An invalid iModelId was specified. */\r\n  IModelInvalid = SETTINGS_ERROR_BASE + 4,\r\n  /** The setting specified for deletion or retrieval does not exist. */\r\n  SettingNotFound = SETTINGS_ERROR_BASE + 5,\r\n  /** The settings server malfunctioned.  */\r\n  ServerError = SETTINGS_ERROR_BASE + 6,\r\n  /** An unexpected error occurred.  */\r\n  UnknownError = SETTINGS_ERROR_BASE + 8,\r\n}\r\n\r\n/** The result of the SettingsAdmin methods to save, retrieve, and delete settings.\r\n * These are constructed by the SettingsAdmin methods and examined by applications.\r\n * @alpha\r\n */\r\nexport class SettingsResult {\r\n  /** Construct a new SettingsResult. SettingsResult objects are created by the SettingsAdmin methods.\r\n   * @internal\r\n   * @param status The result of the settings method.\r\n   * @param errorMessage An error message that is sometimes returned by the server.\r\n   * @param setting The object returned by the \"get\" Settings methods.\r\n   */\r\n  constructor(public status: SettingsStatus, public errorMessage?: string, public setting?: any) {\r\n  }\r\n}\r\n\r\n/** The result of the SettingsAdmin methods to retrieve all settings by namespace.\r\n * These are constructed by the SettingsAdmin \"getxxxByNamespace\" methods and examined by applications.\r\n * @alpha\r\n */\r\nexport class SettingsMapResult {\r\n  /** Construct a new SettingsResult. SettingsResult objects are created by the SettingsAdmin methods.\r\n   * @internal\r\n   * @param status The result of the settings method.\r\n   * @param errorMessage An error message that is sometimes returned by the server.\r\n   * @param settingsMap A Map of name to property objects.\r\n   */\r\n  constructor(public status: SettingsStatus, public errorMessage?: string, public settingsMap?: Map<string, any>) {\r\n  }\r\n}\r\n/** Methods available to save and get Settings objects on behalf of combinations of the Application, Project, iModel, and User\r\n * @alpha\r\n */\r\nexport interface SettingsAdmin {\r\n\r\n  /** Saves a user-specific settings object to the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param settings The object to be saved. It is saved as a JSON string.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the save operation. The setting member is undefined for save operations.\r\n   */\r\n  saveUserSetting(requestContext: AuthorizedClientRequestContext, settings: any, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Retrieves a user-specific settings object from the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the retrieval operation. The setting member contains the setting if the operation succeeds.\r\n   */\r\n  getUserSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Deletes a user-specific settings object from the settings service.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the save operation. The setting member is undefined for delete operations. If the setting specified for deletion\r\n   * does not exists, the SettingsResult.status is SettingsStatus.SettingNotFound.\r\n   */\r\n  deleteUserSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Retrieves an array of user-specific settings objects that are stored with the specified namespace\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program - supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, to retrieve settings specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, to retrieve settings specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the retrieval operation. If successful, SettingsResult.settingsMap contains a map of string to settings values containing all of the settings stored with the specified namespace.\r\n   */\r\n  getUserSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult>;\r\n\r\n  /** Saves a shared settings object to the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param settings The object to be saved. It is saved as a JSON string.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the save operation. The setting member is undefined for save operations.\r\n   */\r\n  saveSharedSetting(requestContext: AuthorizedClientRequestContext, settings: any, namespace: string, name: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Retrieves a shared settings object from the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project (required for Shared Setting).\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined.\r\n   * @return The result of the retrieval operation. The setting member contains the setting if the operation succeeds.\r\n   */\r\n  getSharedSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Deletes a shared settings object from the settings service.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project (required for Shared Setting).\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined.\r\n   * @return The result of the save operation. The setting member is undefined for delete operations. If the setting specified for deletion\r\n   * does not exists, the SettingsResult.status is SettingsStatus.SettingNotFound.\r\n   */\r\n  deleteSharedSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Retrieves an array of shared settings objects that are stored with the specified namespace\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program - supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project (required for Shared Setting).\r\n   * @param iModelId The wsgId of the iModel, to retrieve settings specific to an iModel, otherwise undefined.\r\n   * @return The result of the retrieval operation. If successful, SettingsResult.settingsMap contains a map of string to settings values containing all of the settings stored with the specified namespace.\r\n   */\r\n  getSharedSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsMapResult>;\r\n\r\n  /** Saves a non-user-specific settings object to the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param settings The object to be saved. It is saved as a JSON string.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the save operation. The setting member is undefined for save operations.\r\n   * @note The logged in user must have the appropriate permissions to save a non-user-specific setting.\r\n   */\r\n  saveSetting(requestContext: AuthorizedClientRequestContext, settings: any, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Retrieves a non-user-specific settings object from the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the retrieval operation. The setting member contains the setting if the operation succeeds.\r\n   */\r\n  getSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Deletes a non-user-specific settings object from the settings service.\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program-supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param name The name of the setting. Acceptable characters are alphanumeric and the period character.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, if the settings is specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, if the setting is specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the save operation. The setting member is undefined for delete operations. If the setting specified for deletion\r\n   * does not exists, the SettingsResult.status is SettingsStatus.SettingNotFound.\r\n   * @note The logged in user must have the appropriate permissions to delete a non-user-specific setting.\r\n   */\r\n  deleteSetting(requestContext: AuthorizedClientRequestContext, namespace: string, name: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult>;\r\n\r\n  /** Retrieves an array of non-user-specific settings objects that are stored with the specified namespace\r\n   * @param requestContext The client request context.\r\n   * @param namespace A program - supplied namespace that is used to organize settings and prevent name collisions.\r\n   * @param applicationSpecific Specifies whether the setting is specific to the current application, or used by all applications.\r\n   * @param projectId The wsgId of the Project, to retrieve settings specific to a project, otherwise undefined.\r\n   * @param iModelId The wsgId of the iModel, to retrieve settings specific to an iModel, otherwise undefined. The projectId must be specified if iModelId is specified.\r\n   * @return The result of the retrieval operation. If successful, SettingsResult.settingsMap contains a map of string to settings values containing all of the settings stored with the specified namespace.\r\n   */\r\n  getSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult>;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Settings */\r\nimport { request, RequestOptions, Response } from \"./Request\";\r\nimport { Client } from \"./Client\";\r\nimport { AuthorizationToken, AccessToken } from \"./Token\";\r\nimport { SettingsAdmin, SettingsStatus, SettingsResult, SettingsMapResult } from \"./SettingsAdmin\";\r\nimport { BentleyError, BentleyStatus, ClientRequestContext } from \"@bentley/bentleyjs-core\";\r\nimport { ImsDelegationSecureTokenClient } from \"./ImsClients\";\r\nimport { AuthorizedClientRequestContext } from \"./AuthorizedClientRequestContext\";\r\n\r\n/**\r\n * Client API for the CONNECT ProductSettingsService - implements the SettingsAdmin interface when settings are stored by CONNECT.\r\n * This class is not accessed directly from applications, they should use IModelApp.SettingsAdmin.\r\n * @internal\r\n */\r\nexport class ConnectSettingsClient extends Client implements SettingsAdmin {\r\n  public static readonly searchKey: string = \"ProductSettingsService.RP\";\r\n  /**\r\n   * Creates an instance of ConnectSettingsClient.\r\n   * @param deploymentEnv Deployment environment.\r\n   */\r\n  public constructor(public applicationId: string) { super(); }\r\n\r\n  /** Convenience method to get access token from a SAML authorization token.\r\n   * @param requestContext The client request context.\r\n   * @param authSamlToken Authorization SAML token (e.g. as obtained from ImsFederatedAuthenticationClient)\r\n   * @returns SAML access token\r\n   * @internal\r\n   */\r\n  public async getAccessToken(requestContext: ClientRequestContext, authSamlToken: AuthorizationToken): Promise<AccessToken> {\r\n    const baseUrl: string = await this.getUrl(requestContext);\r\n\r\n    const imsClient = new ImsDelegationSecureTokenClient();\r\n    return imsClient.getToken(requestContext, authSamlToken, baseUrl);\r\n  }\r\n\r\n  protected getUrlSearchKey(): string { return ConnectSettingsClient.searchKey; }\r\n\r\n  // gets the portion of the Url that encapsulates the type of setting requested.\r\n  private getUrlOptions(settingNamespace: string | undefined, settingName: string | undefined, userSpecific: boolean, applicationSpecific: boolean, shared: boolean, projectId?: string, iModelId?: string) {\r\n    // The types of settings are:\r\n    // Application, Project, iModel, and User specific.\r\n    // Application, Project, and User Specific\r\n    // Application and User Specific\r\n    // Project, iModel, and User specific\r\n    // Project and User Specific\r\n    // Application Specific\r\n    let urlTerminator: string;\r\n    if (userSpecific) {\r\n      urlTerminator = \"/User/Setting\";\r\n    } else {\r\n      if (shared)\r\n        urlTerminator = \"/SharedSetting\";\r\n      else\r\n        urlTerminator = \"/Setting\";\r\n    }\r\n    // append the settingsNamespace and settingName if appropriate.\r\n    if (settingNamespace)\r\n      urlTerminator = urlTerminator.concat(`/${settingNamespace}`);\r\n    if (settingName)\r\n      urlTerminator = urlTerminator.concat(`/${settingName}`);\r\n\r\n    let urlOptions: string;\r\n    if (applicationSpecific) {\r\n      if (projectId) {\r\n        if (iModelId) {\r\n          urlOptions = `/v1.0/Application/${this.applicationId}/Context/${projectId}/iModel/${iModelId}${urlTerminator}`;\r\n        } else {\r\n          urlOptions = `/v1.0/Application/${this.applicationId}/Context/${projectId}${urlTerminator}`;\r\n        }\r\n      } else {\r\n        urlOptions = `/v1.0/Application/${this.applicationId}${urlTerminator}`;\r\n      }\r\n    } else {\r\n      if (projectId) {\r\n        if (iModelId) {\r\n          urlOptions = `/v1.0/Context/${projectId}/iModel/${iModelId}${urlTerminator}`;\r\n        } else {\r\n          urlOptions = `/v1.0/Context/${projectId}${urlTerminator}`;\r\n        }\r\n      } else {\r\n        // settings must depend on at least one of Application and Project\r\n        throw new BentleyError(BentleyStatus.ERROR, \"Improperly specified setting\");\r\n      }\r\n    }\r\n    return urlOptions;\r\n  }\r\n\r\n  // Forms the response when there is an error.\r\n  private formErrorResponse(response: Response): SettingsResult {\r\n    if (400 === response.status) {\r\n      return new SettingsResult(SettingsStatus.ProjectInvalid, \"Malformed URL or invalid Project \" + JSON.stringify(response));\r\n    } else if (401 === response.status) {\r\n      return new SettingsResult(SettingsStatus.AuthorizationError, \"Authorization failure \" + JSON.stringify(response));\r\n    } else if (404 === response.status) {\r\n      return new SettingsResult(SettingsStatus.SettingNotFound);\r\n    } else {\r\n      return new SettingsResult(SettingsStatus.ServerError, \"Status indicates server error \" + JSON.stringify(response));\r\n    }\r\n  }\r\n\r\n  // Private function that can retrieve either user specific settings or non-user-specific settings\r\n  private async saveAnySetting(requestContext: AuthorizedClientRequestContext, userSpecific: boolean, settings: any, settingNamespace: string, settingName: string, applicationSpecific: boolean, shared: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    const baseUrl: string = await this.getUrl(requestContext);\r\n    const accessTokenString: string | undefined = requestContext.accessToken.toTokenString();\r\n\r\n    const options: RequestOptions = {\r\n      method: \"PUT\",\r\n      headers: { authorization: accessTokenString },\r\n      body: {\r\n        properties: settings,\r\n      },\r\n    };\r\n    await this.setupOptionDefaults(options);\r\n\r\n    const urlOptions: string = this.getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId);\r\n    const url: string = baseUrl.concat(urlOptions);\r\n\r\n    return request(requestContext, url, options).then(async (_response: Response): Promise<SettingsResult> => {\r\n      return Promise.resolve(new SettingsResult(SettingsStatus.Success));\r\n    }, async (response: Response): Promise<SettingsResult> => {\r\n      if ((response.status < 200) || (response.status > 299))\r\n        return Promise.resolve(this.formErrorResponse(response));\r\n      return Promise.resolve(new SettingsResult(SettingsStatus.UnknownError, \"Unexpected Status \" + JSON.stringify(response)));\r\n    });\r\n  }\r\n\r\n  // Retrieves previously saved user settings\r\n  private async getAnySetting(requestContext: AuthorizedClientRequestContext, userSpecific: boolean, settingNamespace: string, settingName: string, applicationSpecific: boolean, shared: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    const baseUrl: string = await this.getUrl(requestContext);\r\n    const accessTokenString: string | undefined = requestContext.accessToken.toTokenString();\r\n\r\n    const options: RequestOptions = {\r\n      method: \"GET\",\r\n      headers: { authorization: accessTokenString },\r\n    };\r\n    await this.setupOptionDefaults(options);\r\n\r\n    const urlOptions: string = this.getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId);\r\n    const url: string = baseUrl.concat(urlOptions);\r\n\r\n    return request(requestContext, url, options).then(async (response: Response): Promise<SettingsResult> => {\r\n      return Promise.resolve(new SettingsResult(SettingsStatus.Success, undefined, response.body.properties));\r\n    }, async (response: Response): Promise<SettingsResult> => {\r\n      if ((response.status < 200) || (response.status > 299))\r\n        return Promise.resolve(this.formErrorResponse(response));\r\n      return Promise.resolve(new SettingsResult(SettingsStatus.UnknownError, \"Unexpected Status \" + JSON.stringify(response)));\r\n    });\r\n  }\r\n\r\n  // Retrieves all saved settings with the same namespace.\r\n  private async getAnySettingsByNamespace(requestContext: AuthorizedClientRequestContext, userSpecific: boolean, settingNamespace: string, applicationSpecific: boolean, shared: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult> {\r\n    const baseUrl: string = await this.getUrl(requestContext);\r\n    const accessTokenString: string | undefined = requestContext.accessToken.toTokenString();\r\n\r\n    const options: RequestOptions = {\r\n      method: \"GET\",\r\n      headers: { authorization: accessTokenString },\r\n    };\r\n    await this.setupOptionDefaults(options);\r\n\r\n    const urlOptions: string = this.getUrlOptions(undefined, undefined, userSpecific, applicationSpecific, shared, projectId, iModelId);\r\n    let url: string = baseUrl.concat(urlOptions);\r\n\r\n    // now we want to append the query for the namespace.\r\n    const queryString = `?$filter=namespace+eq+'${settingNamespace}'`;\r\n    url = url.concat(queryString);\r\n\r\n    return request(requestContext, url, options).then(async (response: Response): Promise<SettingsResult> => {\r\n      const settingsMap: Map<string, any> = new Map<string, any>();\r\n      for (const settingBody of response.body) {\r\n        settingsMap.set(settingBody.name, settingBody.properties);\r\n      }\r\n      return Promise.resolve(new SettingsMapResult(SettingsStatus.Success, undefined, settingsMap));\r\n    }, async (response: Response): Promise<SettingsMapResult> => {\r\n      if ((response.status < 200) || (response.status > 299))\r\n        return Promise.resolve(this.formErrorResponse(response));\r\n      return Promise.resolve(new SettingsResult(SettingsStatus.UnknownError, \"Unexpected Status \" + JSON.stringify(response)));\r\n    });\r\n  }\r\n\r\n  private async deleteAnySetting(requestContext: AuthorizedClientRequestContext, userSpecific: boolean, settingNamespace: string, settingName: string, applicationSpecific: boolean, shared: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    const baseUrl: string = await this.getUrl(requestContext);\r\n    const accessTokenString: string | undefined = requestContext.accessToken.toTokenString();\r\n\r\n    const options: RequestOptions = {\r\n      method: \"DELETE\",\r\n      headers: { authorization: accessTokenString },\r\n\r\n    };\r\n    await this.setupOptionDefaults(options);\r\n\r\n    const urlOptions: string = this.getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId);\r\n    const url: string = baseUrl.concat(urlOptions);\r\n\r\n    return request(requestContext, url, options).then(async (_response: Response): Promise<SettingsResult> => {\r\n      return Promise.resolve(new SettingsResult(SettingsStatus.Success));\r\n    }, async (response: Response): Promise<SettingsResult> => {\r\n      if ((response.status < 200) || (response.status > 299))\r\n        return Promise.resolve(this.formErrorResponse(response));\r\n      else\r\n        return Promise.resolve(new SettingsResult(SettingsStatus.UnknownError, \"Unexpected Status \" + JSON.stringify(response)));\r\n    });\r\n  }\r\n\r\n  public async saveUserSetting(requestContext: AuthorizedClientRequestContext, settings: any, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.saveAnySetting(requestContext, true, settings, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async getUserSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.getAnySetting(requestContext, true, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async deleteUserSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.deleteAnySetting(requestContext, true, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async getUserSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult> {\r\n    return this.getAnySettingsByNamespace(requestContext, true, namespace, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async saveSharedSetting(requestContext: AuthorizedClientRequestContext, settings: any, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.saveAnySetting(requestContext, false, settings, settingNamespace, settingName, applicationSpecific, true, projectId, iModelId);\r\n  }\r\n\r\n  public async getSharedSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.getAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, true, projectId, iModelId);\r\n  }\r\n\r\n  public async deleteSharedSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.deleteAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, true, projectId, iModelId);\r\n  }\r\n\r\n  public async getSharedSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId: string, iModelId?: string): Promise<SettingsMapResult> {\r\n    return this.getAnySettingsByNamespace(requestContext, false, namespace, applicationSpecific, true, projectId, iModelId);\r\n  }\r\n\r\n  public async saveSetting(requestContext: AuthorizedClientRequestContext, settings: any, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.saveAnySetting(requestContext, false, settings, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async getSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.getAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async deleteSetting(requestContext: AuthorizedClientRequestContext, settingNamespace: string, settingName: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsResult> {\r\n    return this.deleteAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n  public async getSettingsByNamespace(requestContext: AuthorizedClientRequestContext, namespace: string, applicationSpecific: boolean, projectId?: string, iModelId?: string): Promise<SettingsMapResult> {\r\n    return this.getAnySettingsByNamespace(requestContext, false, namespace, applicationSpecific, false, projectId, iModelId);\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Authentication */\r\n\r\nimport * as xpath from \"xpath\";\r\nimport { DOMParser } from \"xmldom\";\r\nimport { UserInfo } from \"./UserInfo\";\r\nimport { Base64 } from \"js-base64\";\r\nimport { BentleyError, BentleyStatus } from \"@bentley/bentleyjs-core\";\r\n\r\n/** @internal */\r\nexport enum IncludePrefix {\r\n  Yes = 0,\r\n  No = 1,\r\n}\r\n\r\n/** Base class for JWT and SAML tokens\r\n * @beta\r\n */\r\nexport abstract class Token {\r\n  protected _samlAssertion?: string;\r\n  protected _saml?: string;\r\n  protected _jwt?: string;\r\n\r\n  protected _userInfo?: UserInfo;\r\n  protected _startsAt?: Date;\r\n  protected _expiresAt?: Date;\r\n  protected _x509Certificate?: string;\r\n\r\n  protected constructor() {\r\n  }\r\n\r\n  /** @internal */\r\n  protected getSaml(): string | undefined {\r\n    if (this._saml)\r\n      return this._saml;\r\n    if (!this._samlAssertion)\r\n      return undefined;\r\n    this._saml = Base64.encode(this._samlAssertion);\r\n    return this._saml;\r\n  }\r\n\r\n  /** @internal */\r\n  public getSamlAssertion(): string | undefined {\r\n    if (this._samlAssertion)\r\n      return this._samlAssertion;\r\n    if (!this._saml)\r\n      return undefined;\r\n    this._samlAssertion = Base64.decode(this._saml);\r\n    return this._samlAssertion;\r\n  }\r\n\r\n  /** @internal */\r\n  public getUserInfo(): UserInfo | undefined {\r\n    if (this._userInfo || this._jwt)\r\n      return this._userInfo;\r\n    if (!this.parseSamlAssertion())\r\n      return undefined;\r\n    return this._userInfo;\r\n  }\r\n\r\n  /** @internal */\r\n  public setUserInfo(userInfo: UserInfo) {\r\n    this._userInfo = userInfo;\r\n  }\r\n\r\n  /** @internal */\r\n  public getExpiresAt(): Date | undefined {\r\n    if (this._expiresAt || this._jwt)\r\n      return this._expiresAt;\r\n    if (!this.parseSamlAssertion())\r\n      return undefined;\r\n    return this._expiresAt;\r\n  }\r\n\r\n  /** @internal */\r\n  public getStartsAt(): Date | undefined {\r\n    if (this._startsAt || this._jwt)\r\n      return this._startsAt;\r\n    if (!this.parseSamlAssertion())\r\n      return undefined;\r\n    return this._startsAt;\r\n  }\r\n\r\n  /** @internal */\r\n  protected parseSamlAssertion(): boolean {\r\n    this._samlAssertion = this.getSamlAssertion();\r\n    if (!this._samlAssertion)\r\n      return false;\r\n\r\n    const select: xpath.XPathSelect = xpath.useNamespaces({\r\n      ds: \"http://www.w3.org/2000/09/xmldsig#\",\r\n      saml: \"urn:oasis:names:tc:SAML:1.0:assertion\",\r\n    });\r\n    const dom: Document = (new DOMParser()).parseFromString(this._samlAssertion);\r\n\r\n    this._x509Certificate = select(\"/saml:Assertion/ds:Signature/ds:KeyInfo/ds:X509Data/ds:X509Certificate/text()\", dom).toString();\r\n\r\n    const startsAtStr: string = select(\"string(/saml:Assertion/saml:Conditions/@NotBefore)\", dom).toString();\r\n    this._startsAt = new Date(startsAtStr);\r\n\r\n    const expiresAtStr: string = select(\"string(/saml:Assertion/saml:Conditions/@NotOnOrAfter)\", dom).toString();\r\n\r\n    const extractAttribute: (attributeName: string) => string = (attributeName: string) =>\r\n      select(\"/saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='\" +\r\n        attributeName + \"']/saml:AttributeValue/text()\", dom).toString();\r\n\r\n    const id = extractAttribute(\"userid\");\r\n    const email = {\r\n      id: extractAttribute(\"emailaddress\"),\r\n    };\r\n    const profile = {\r\n      name: extractAttribute(\"name\"),\r\n      firstName: extractAttribute(\"givenname\"),\r\n      lastName: extractAttribute(\"surname\"),\r\n    };\r\n    const organization = {\r\n      id: extractAttribute(\"organizationid\"),\r\n      name: extractAttribute(\"organization\"),\r\n    };\r\n    const featureTracking = {\r\n      ultimateSite: extractAttribute(\"ultimatesite\"),\r\n      usageCountryIso: extractAttribute(\"usagecountryiso\"),\r\n    };\r\n\r\n    this._userInfo = new UserInfo(id, email, profile, organization, featureTracking);\r\n    this._startsAt = new Date(startsAtStr);\r\n    this._expiresAt = new Date(expiresAtStr);\r\n\r\n    return !!this._x509Certificate && !!this._startsAt && !!this._expiresAt;\r\n  }\r\n}\r\n\r\n/** Token issued by Active Secure Token Service or Federated Authentication Service for user authentication/authorization\r\n * @internal\r\n */\r\nexport class AuthorizationToken extends Token {\r\n\r\n  /** Sets up a new AuthorizationToken based on the SAML that was passed in.\r\n   * Does NOT validate the resulting token.\r\n   * @internal\r\n   */\r\n  public static fromSamlAssertion(samlAssertion: string): AuthorizationToken {\r\n    const token = new AuthorizationToken();\r\n    token._samlAssertion = samlAssertion;\r\n    return token;\r\n  }\r\n\r\n  /** Creates a string representation of the contained token\r\n   * @internal\r\n   */\r\n  public toTokenString(includePrefix: IncludePrefix = IncludePrefix.Yes): string {\r\n    if (!this.parseSamlAssertion() || !this._x509Certificate)\r\n      throw new BentleyError(BentleyStatus.ERROR, \"Invalid access token\");\r\n\r\n    const prefix = (includePrefix === IncludePrefix.Yes) ? \"X509 access_token=\" : \"\";\r\n    return prefix + Buffer.from(this._x509Certificate, \"utf8\").toString(\"base64\");\r\n  }\r\n}\r\n\r\n/** Token issued by DelegationSecureTokenService for API access\r\n * @beta\r\n */\r\nexport class AccessToken extends Token {\r\n  private static _samlTokenPrefix = \"Token\";\r\n  private static _jwtTokenPrefix = \"Bearer\";\r\n  public static foreignProjectAccessTokenJsonProperty = \"ForeignProjectAccessToken\";\r\n  private _foreignJwt?: string;\r\n\r\n  /** Returns true if it's a Jason Web Token, and false if it's a SAML token\r\n   * @internal\r\n   */\r\n  public get isJwt(): boolean {\r\n    return !!this._jwt;\r\n  }\r\n\r\n  /** Sets up a new AccessToken based on the SAML that was passed in.\r\n   * Does NOT validate the resulting token.\r\n   * @internal\r\n   */\r\n  public static fromSamlAssertion(samlAssertion: string): AccessToken {\r\n    const token = new AccessToken();\r\n    token._samlAssertion = samlAssertion;\r\n    return token;\r\n  }\r\n\r\n  /** Sets up a new AccessToken based on some generic token abstraction used for iModelBank use cases\r\n   * @internal\r\n   */\r\n  public static fromForeignProjectAccessTokenJson(foreignJsonStr: string): AccessToken | undefined {\r\n    if (!foreignJsonStr.startsWith(`{\\\"${this.foreignProjectAccessTokenJsonProperty}\\\":`))\r\n      return undefined;\r\n    const props: any = JSON.parse(foreignJsonStr);\r\n    if (props[this.foreignProjectAccessTokenJsonProperty] === undefined)\r\n      return undefined;\r\n    const tok = new AccessToken();\r\n    tok._foreignJwt = foreignJsonStr;\r\n    tok._userInfo = props[this.foreignProjectAccessTokenJsonProperty].userInfo;\r\n    return tok;\r\n  }\r\n\r\n  /** Create an AccessToken from a SAML string for Windows Federated Authentication workflows.\r\n   * Does NOT validate the token.\r\n   * @internal\r\n   */\r\n  public static fromSamlTokenString(accessTokenStr: string, includesPrefix: IncludePrefix = IncludePrefix.Yes): AccessToken {\r\n    let saml = accessTokenStr;\r\n    if (includesPrefix === IncludePrefix.Yes) {\r\n      const prefixLength = AccessToken._samlTokenPrefix.length;\r\n      if (accessTokenStr.substr(0, prefixLength).toLowerCase() !== AccessToken._samlTokenPrefix.toLowerCase())\r\n        throw new BentleyError(BentleyStatus.ERROR, \"Invalid saml token\");\r\n      saml = accessTokenStr.slice(6);\r\n      if (!saml)\r\n        throw new BentleyError(BentleyStatus.ERROR, \"Invalid saml token\");\r\n    }\r\n    const token = new AccessToken();\r\n    token._saml = saml;\r\n    return token;\r\n  }\r\n\r\n  /** Create an AccessToken from a JWT token for OIDC workflows\r\n   * Does NOT validate the token.\r\n   * @internal\r\n   */\r\n  public static fromJsonWebTokenString(jwt: string, startsAt?: Date, expiresAt?: Date, userInfo?: UserInfo): AccessToken {\r\n    const token = new AccessToken();\r\n    token._jwt = jwt;\r\n    token._startsAt = startsAt;\r\n    token._expiresAt = expiresAt;\r\n    token._userInfo = userInfo;\r\n    return token;\r\n  }\r\n\r\n  /**\r\n   * Convert this AccessToken to a string\r\n   * @param includePrefix Include the token prefix to identify JWT or SAML tokens\r\n   * @internal\r\n   */\r\n  public toTokenString(includePrefix: IncludePrefix = IncludePrefix.Yes): string {\r\n    if (this._jwt)\r\n      return (includePrefix === IncludePrefix.Yes) ? AccessToken._jwtTokenPrefix + \" \" + this._jwt : this._jwt;\r\n\r\n    const saml = this.getSaml();\r\n    if (saml)\r\n      return (includePrefix === IncludePrefix.Yes) ? AccessToken._samlTokenPrefix + \" \" + saml : saml;\r\n\r\n    if (this._foreignJwt) {\r\n      return Base64.encode(this._foreignJwt); // TODO: migrate iModelBank to support Oidc tokens (_jwt)\r\n    }\r\n\r\n    throw new BentleyError(BentleyStatus.ERROR, \"Cannot convert invalid access token to string\");\r\n  }\r\n\r\n  /**\r\n   * Create an AccessToken from a string. The token must include the prefix to differentiate between JWT and SAML.\r\n   * @param tokenStr String representation of the token\r\n   * @internal\r\n   */\r\n  public static fromTokenString(tokenStr: string): AccessToken {\r\n    if (tokenStr.startsWith(AccessToken._jwtTokenPrefix)) {\r\n      const jwtString = tokenStr.substr(AccessToken._jwtTokenPrefix.length + 1);\r\n      return AccessToken.fromJsonWebTokenString(jwtString);\r\n    }\r\n\r\n    if (tokenStr.startsWith(AccessToken._samlTokenPrefix)) {\r\n      tokenStr.substr(AccessToken._samlTokenPrefix.length + 1);\r\n      const samlString = tokenStr.substr(AccessToken._samlTokenPrefix.length + 1);\r\n      return AccessToken.fromSamlTokenString(samlString, IncludePrefix.No);\r\n    }\r\n\r\n    if (tokenStr.startsWith(`{\\\"${AccessToken.foreignProjectAccessTokenJsonProperty}\\\":`)) {\r\n      const accessToken = AccessToken.fromForeignProjectAccessTokenJson(tokenStr);\r\n      if (!accessToken)\r\n        throw new BentleyError(BentleyStatus.ERROR, \"Invalid access token\");\r\n    }\r\n\r\n    throw new BentleyError(BentleyStatus.ERROR, \"Invalid access token\");\r\n  }\r\n\r\n  /**\r\n   * Creates an AccessToken from an untyped JSON object\r\n   * @param jsonObj\r\n   * @internal\r\n   */\r\n  public static fromJson(jsonObj: any): AccessToken | undefined {\r\n    if (jsonObj._jwt)\r\n      return AccessToken.fromJsonWebTokenString(jsonObj._jwt, jsonObj._startsAt, jsonObj._expiresAt, jsonObj._userInfo);\r\n\r\n    if (jsonObj._foreignJwt) {\r\n      const foreignTok = AccessToken.fromForeignProjectAccessTokenJson(jsonObj._foreignJwt);\r\n      if (foreignTok !== undefined)\r\n        return foreignTok;\r\n    }\r\n\r\n    return AccessToken.fromSamlAssertion(jsonObj._samlAssertion) as AccessToken;\r\n  }\r\n}\r\n","\n/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Authentication */\n\n/** Information on the authenticated user.\n * @beta\n */\nexport class UserInfo {\n  constructor(\n    /** Id of the user */\n    public id: string,\n\n    /** Email details */\n    public email?: { id: string, isVerified?: boolean },\n\n    /** Profile of the user */\n    public profile?: { firstName: string, lastName: string, name?: string, preferredUserName?: string },\n\n    /** Organization the user belongs to */\n    public organization?: { id: string, name: string },\n\n    /** Feature tracking information associated with the user */\n    public featureTracking?: { ultimateSite: string, usageCountryIso: string },\n  ) { }\n\n  public static fromJson(jsonObj: any): UserInfo | undefined {\n    if (!jsonObj)\n      return undefined;\n    const id: string = jsonObj.sub;\n    const email: any = jsonObj.email ? { id: jsonObj.email, isVerified: jsonObj.email_verified } : undefined;\n    const profile: any = jsonObj.given_name ? { name: jsonObj.name, preferredUserName: jsonObj.preferred_username, firstName: jsonObj.given_name, lastName: jsonObj.family_name } : undefined;\n    const organization: any = jsonObj.org ? { id: jsonObj.org, name: jsonObj.org_name } : undefined;\n    const featureTracking: any = jsonObj.feature_tracking ? { ultimateSite: jsonObj.ultimate_site, usageCountryIso: jsonObj.usage_country_iso } : undefined;\n    return new UserInfo(id, email, profile, organization, featureTracking);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module BaseClients */\nimport { ClientRequestContext, GetMetaDataFunction, HttpStatus, Logger, WSStatus } from \"@bentley/bentleyjs-core\";\nimport * as deepAssign from \"deep-assign\";\nimport { AuthorizedClientRequestContext } from \"./AuthorizedClientRequestContext\";\nimport { AuthenticationError, Client, DefaultRequestOptionsProvider } from \"./Client\";\nimport { ECJsonTypeMap, WsgInstance } from \"./ECJsonTypeMap\";\nimport { ImsDelegationSecureTokenClient } from \"./ImsClients\";\nimport { ClientsLoggerCategory } from \"./ClientsLoggerCategory\";\nimport { request, RequestOptions, RequestQueryOptions, Response, ResponseError } from \"./Request\";\nimport { AccessToken, AuthorizationToken } from \"./Token\";\n\nconst loggerCategory: string = ClientsLoggerCategory.Clients;\n\n/** Error that was returned by a WSG based service.\n * @beta\n */\nexport class WsgError extends ResponseError {\n  public constructor(errorNumber: number | HttpStatus, message?: string, getMetaData?: GetMetaDataFunction) {\n    super(errorNumber, message, getMetaData);\n  }\n\n  /** Attempt to parse the error from the response.\n   * Attempts to parse error data in a format that is returned by WSG services.\n   * This method only accesses data that was parsed by parent class to avoid dependencies on http libraries.\n   * @param response Response from the server.\n   * @returns Parsed error.\n   */\n  public static parse(response: any, log = true): ResponseError {\n    const responseError = ResponseError.parse(response, false);\n    const wsgError = new WsgError(WSStatus.Unknown);\n    deepAssign(wsgError, responseError);\n\n    if (wsgError._data) {\n      if (typeof wsgError._data === \"object\") {\n        if (wsgError._data.errorMessage || wsgError._data.errorId) {\n          wsgError.message = wsgError._data.errorMessage || wsgError.message;\n          wsgError.name = wsgError._data.errorId || wsgError.name;\n          wsgError.description = wsgError._data.errorDescription || wsgError.description;\n          wsgError.errorNumber = WsgError.getWSStatusId(wsgError.name ? wsgError.name : \"\");\n          if (log)\n            wsgError.log();\n          return wsgError;\n        }\n      } else {\n        if (wsgError.status === 302 && wsgError._data.indexOf(\"ims.bentley.com\") >= 0) {\n          const authenticationError = new AuthenticationError(WSStatus.LoginRequired);\n          deepAssign(authenticationError, responseError);\n          authenticationError.name = \"Authentication Error\";\n          authenticationError.message = \"Authentication Error - Check if the accessToken is valid\";\n          return authenticationError;\n        }\n      }\n    }\n    if (log)\n      responseError.log();\n    return responseError;\n  }\n\n  /**\n   * Decides whether request should be retried or not\n   * @param error Error\n   * @param response Response\n   */\n  public static shouldRetry(error: any, response: any): boolean {\n    if (response === undefined || response === null) {\n      return super.shouldRetry(error, response);\n    }\n\n    if (super.parseHttpStatus(response.statusType) === HttpStatus.Success) {\n      return false;\n    }\n\n    const parsedError = WsgError.parse({ response }, false);\n    if (!(parsedError instanceof WsgError)) {\n      return super.shouldRetry(error, response);\n    }\n\n    const errorCodesToRetry: number[] = [WSStatus.LoginFailed,\n    WSStatus.SslRequired,\n    WSStatus.NotEnoughRights,\n    WSStatus.RepositoryNotFound,\n    WSStatus.SchemaNotFound,\n    WSStatus.ClassNotFound,\n    WSStatus.PropertyNotFound,\n    WSStatus.InstanceNotFound,\n    WSStatus.FileNotFound,\n    WSStatus.NotSupported,\n    WSStatus.NoServerLicense,\n    WSStatus.NoClientLicense,\n    WSStatus.TooManyBadLoginAttempts,\n    HttpStatus.ServerError,\n    HttpStatus.ClientError,\n    WSStatus.Unknown];\n    const errorStatus = WsgError.getErrorStatus(parsedError.name !== undefined ?\n      WsgError.getWSStatusId(parsedError.name) : WSStatus.Unknown, response.statusType);\n    return errorCodesToRetry.includes(errorStatus);\n  }\n\n  /**\n   * Gets error status from current WSError and HTTP Status type\n   * @param error Error returned by request\n   * @param response Response returned by request\n   */\n  public static getErrorStatus(errorId: number, httpStatusType: number): number {\n    if (WSStatus.Unknown !== errorId) {\n      return errorId;\n    }\n    if (super.parseHttpStatus(httpStatusType) === HttpStatus.ServerError) {\n      return HttpStatus.ServerError;\n    }\n    if (super.parseHttpStatus(httpStatusType) === HttpStatus.ClientError) {\n      return HttpStatus.ClientError;\n    }\n    return WSStatus.Unknown;\n  }\n\n  /**\n   * Get WSError from error string\n   * @param error error to be returned in WSError enum\n   */\n  public static getWSStatusId(error: string): number {\n    switch (error) {\n      case \"LoginFailed\":\n        return WSStatus.LoginFailed;\n      case \"SslRequired\":\n        return WSStatus.SslRequired;\n      case \"NotEnoughRights\":\n        return WSStatus.NotEnoughRights;\n      case \"DatasourceNotFound\":\n        return WSStatus.RepositoryNotFound;\n      case \"RepositoryNotFound\":\n        return WSStatus.RepositoryNotFound;\n      case \"SchemaNotFound\":\n        return WSStatus.SchemaNotFound;\n      case \"ClassNotFound\":\n        return WSStatus.ClassNotFound;\n      case \"PropertyNotFound\":\n        return WSStatus.PropertyNotFound;\n      case \"LinkTypeNotFound\":\n        return WSStatus.ClassNotFound;\n      case \"ObjectNotFound\":\n        return WSStatus.InstanceNotFound;\n      case \"InstanceNotFound\":\n        return WSStatus.InstanceNotFound;\n      case \"FileNotFound\":\n        return WSStatus.FileNotFound;\n      case \"NotSupported\":\n        return WSStatus.NotSupported;\n      case \"NoServerLicense\":\n        return WSStatus.NoServerLicense;\n      case \"NoClientLicense\":\n        return WSStatus.NoClientLicense;\n      case \"TooManyBadLoginAttempts\":\n        return WSStatus.TooManyBadLoginAttempts;\n      default:\n        return WSStatus.Unknown;\n    }\n  }\n\n  /**\n   * Logs this error\n   */\n  public log(): void {\n    Logger.logError(loggerCategory, this.logMessage(), this.getMetaData());\n  }\n}\n\n/**\n * Provider for wsg RequestOptions, used by WsgClient to set defaults.\n * @internal\n */\nexport class DefaultWsgRequestOptionsProvider extends DefaultRequestOptionsProvider {\n  /**\n   * Creates an instance of DefaultWsgRequestOptionsProvider and sets up the default options.\n   */\n  constructor() {\n    super();\n    this._defaultOptions.errorCallback = WsgError.parse;\n    this._defaultOptions.retryCallback = WsgError.shouldRetry;\n  }\n}\n\n/**\n * Options for WSG requests sent to the service\n * @beta\n */\nexport interface WsgRequestOptions {\n  ResponseContent?: \"FullInstance\" | \"Empty\" | \"InstanceId\";\n  RefreshInstances?: boolean;\n  CustomOptions?: any;\n}\n\n/**\n * Base class for Client implementations of services that are based on WSG\n * @beta\n */\nexport abstract class WsgClient extends Client {\n  public static readonly configHostRelyingPartyUri = \"imjs_default_relying_party_uri\";\n  public static readonly configUseHostRelyingPartyUriAsFallback = \"imjs_use_default_relying_party_uri_as_fallback\";\n  private static _defaultWsgRequestOptionsProvider: DefaultWsgRequestOptionsProvider;\n  protected _url?: string;\n\n  /**\n   * Creates an instance of Client.\n   * @param apiVersion ApiVersion if the service supports it\n   */\n  protected constructor(public apiVersion: string) {\n    super();\n    this.apiVersion = apiVersion;\n  }\n\n  /**\n   * Augments request options with defaults returned by the DefaultWsgRequestOptionsProvider.\n   * @note that the options passed in by clients override any defaults where necessary.\n   * @param options Options the caller wants to augment with the defaults.\n   * @returns Promise resolves after the defaults are setup.\n   */\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\n    if (!WsgClient._defaultWsgRequestOptionsProvider)\n      WsgClient._defaultWsgRequestOptionsProvider = new DefaultWsgRequestOptionsProvider();\n    return WsgClient._defaultWsgRequestOptionsProvider.assignOptions(options);\n  }\n\n  /**\n   * Implemented by clients to specify the relyingPartyUrl for the service.\n   * @protected\n   * @returns Default relyingPartyUrl for the service.\n   */\n  protected abstract getRelyingPartyUrl(): string;\n\n  /**\n   * Gets the URL of the service.\n   * Attempts to discover and cache the URL from the URL Discovery Service. If not\n   * found uses the default URL provided by client implementations. Note that for consistency\n   * sake, the URL is stripped of any trailing \"/\"\n   * @param excludeApiVersion Pass true to optionally exclude the API version from the URL.\n   * @returns URL for the service\n   */\n  public async getUrl(requestContext: ClientRequestContext, excludeApiVersion?: boolean): Promise<string> {\n    if (this._url) {\n      return Promise.resolve(this._url);\n    }\n\n    return super.getUrl(requestContext)\n      .then(async (url: string): Promise<string> => {\n        this._url = url;\n        if (!excludeApiVersion) {\n          this._url += \"/\" + this.apiVersion;\n        }\n        return Promise.resolve(this._url); // TODO: On the server this really needs a lifetime!!\n      });\n  }\n\n  /**\n   * Gets the (delegation) access token to access the service\n   * @param authTokenInfo Access token.\n   * @returns Resolves to the (delegation) access token.\n   * @internal\n   */\n  public async getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken> {\n    const imsClient = new ImsDelegationSecureTokenClient();\n    return imsClient.getToken(requestContext, authorizationToken, this.getRelyingPartyUrl());\n  }\n\n  /** used by clients to delete strongly typed instances through the standard WSG REST API */\n  protected async deleteInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string, instance?: T, requestOptions?: WsgRequestOptions): Promise<void> {\n    requestContext.enter();\n    const url: string = await this.getUrl(requestContext) + relativeUrlPath;\n    requestContext.enter();\n    const untypedInstance: any = instance ? ECJsonTypeMap.toJson<T>(\"wsg\", instance) : undefined;\n    const options: RequestOptions = {\n      method: \"DELETE\",\n      headers: { authorization: requestContext.accessToken.toTokenString() },\n      body: {\n        instance: untypedInstance,\n      },\n    };\n    if (requestOptions) {\n      options.body.requestOptions = requestOptions;\n    }\n    await this.setupOptionDefaults(options);\n    return request(requestContext, url, options).then(async () => Promise.resolve());\n  }\n\n  /**\n   * Used by clients to post strongly typed instances through standard WSG REST API\n   * @param requestContext The client request context\n   * @param typedConstructor Used by clients to post a strongly typed instance through the REST API that's expected to return a standard response.\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param instance Strongly typed instance to be posted.\n   * @param requestOptions WSG options for the request.\n   * @returns The posted instance that's returned back from the server.\n   */\n  protected async postInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instance: T, requestOptions?: WsgRequestOptions): Promise<T> {\n    const url: string = await this.getUrl(requestContext) + relativeUrlPath;\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Sending POST request\", () => ({ url }));\n    const untypedInstance: any = ECJsonTypeMap.toJson<T>(\"wsg\", instance);\n\n    const options: RequestOptions = {\n      method: \"POST\",\n      headers: { authorization: requestContext.accessToken.toTokenString() },\n      body: {\n        instance: untypedInstance,\n      },\n    };\n    if (requestOptions) {\n      options.body.requestOptions = requestOptions;\n    }\n    await this.setupOptionDefaults(options);\n    requestContext.enter();\n    const res: Response = await request(requestContext, url, options);\n    requestContext.enter();\n    if (!res.body || !res.body.changedInstance || !res.body.changedInstance.instanceAfterChange) {\n      return Promise.reject(new Error(`POST to URL ${url} executed successfully, but did not return the expected result.`));\n    }\n    const ecJsonInstance = res.body.changedInstance.instanceAfterChange;\n    const typedInstance: T | undefined = ECJsonTypeMap.fromJson<T>(typedConstructor, \"wsg\", ecJsonInstance);\n\n    // console.log(JSON.stringify(res.body.instances));\n    if (!typedInstance) {\n      return Promise.reject(new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`));\n    }\n\n    Logger.logTrace(loggerCategory, \"Successful POST request\", () => ({ url }));\n    return Promise.resolve(typedInstance);\n  }\n\n  /** Used by clients to post multiple strongly typed instances through standard WSG REST API\n   * @param requestContext Client request context\n   * @param typedConstructor Used by clients to post a strongly typed instances through the REST API that's expected to return a standard response.\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param instances Strongly typed instances to be posted.\n   * @param requestOptions WSG options for the request.\n   * @returns The posted instances that's returned back from the server.\n   */\n  protected async postInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instances: T[], requestOptions?: WsgRequestOptions): Promise<T[]> {\n    requestContext.enter();\n    const url: string = await this.getUrl(requestContext) + relativeUrlPath;\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Sending POST request\", () => ({ url }));\n    const untypedInstances: any[] = instances.map((value: T) => ECJsonTypeMap.toJson<T>(\"wsg\", value));\n\n    const options: RequestOptions = {\n      method: \"POST\",\n      headers: { authorization: requestContext.accessToken.toTokenString() },\n      body: {\n        instances: untypedInstances,\n      },\n    };\n    if (requestOptions) {\n      options.body.requestOptions = requestOptions;\n    }\n    await this.setupOptionDefaults(options);\n    requestContext.enter();\n\n    const res: Response = await request(requestContext, url, options);\n    requestContext.enter();\n    if (!res.body || !res.body.changedInstances) {\n      return Promise.reject(new Error(`POST to URL ${url} executed successfully, but did not return the expected result.`));\n    }\n    const changedInstances: T[] = (res.body.changedInstances as any[]).map<T>((value: any) => {\n      const untypedInstance = value.instanceAfterChange;\n      if (!untypedInstance) {\n        throw new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`);\n      }\n      const typedInstance = ECJsonTypeMap.fromJson<T>(typedConstructor, \"wsg\", untypedInstance);\n      if (!typedInstance) {\n        throw new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`);\n      }\n      return typedInstance;\n    });\n\n    Logger.logTrace(loggerCategory, \"Successful POST request\", () => ({ url }));\n    return Promise.resolve(changedInstances);\n  }\n\n  // @todo Use lower level utilities instead of the node based Request API.\n  // @todo Deserialize stream directly to the type, instead of creating an intermediate JSON object.\n  /**\n   * Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.\n   * @param requestContext Client request context\n   * @param typedConstructor Constructor function for the type\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param queryOptions Query options.\n   * @returns Array of strongly typed instances.\n   */\n  protected async getInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions?: RequestQueryOptions): Promise<T[]> {\n    requestContext.enter();\n    const url: string = await this.getUrl(requestContext) + relativeUrlPath;\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Sending GET request\", () => ({ url }));\n\n    let useSkipToken: boolean = false;\n    let instancesLeft: number = -1;\n    if (queryOptions) {\n      if (!queryOptions.$top) {\n        // Top was undefined. All instances must be returned by using SkipToken.\n        queryOptions.$top = queryOptions.$pageSize;\n        useSkipToken = true;\n      } else if (queryOptions.$pageSize) {\n        // Top and PageSize are defined. If Top is less or equal to PageSize then single request should be performed.\n        // Otherwise multiple request should be performed by using SkipToken.\n        if (queryOptions.$top > queryOptions.$pageSize) {\n          instancesLeft = queryOptions.$top;\n          queryOptions.$top = queryOptions.$pageSize;\n          useSkipToken = true;\n        }\n      }\n      // Clear PageSize so that it won't be included in url.\n      queryOptions.$pageSize = undefined;\n    }\n\n    let skipToken: string = \"\";\n    const typedInstances: T[] = new Array<T>();\n    do {\n      if (useSkipToken && instancesLeft > 0) {\n        // Top was greater than PageSize. Update Top if this is the last page.\n        if (instancesLeft > queryOptions!.$top!) {\n          instancesLeft -= queryOptions!.$top!;\n        } else {\n          queryOptions!.$top = instancesLeft;\n          useSkipToken = false;\n        }\n      }\n\n      const options: RequestOptions = {\n        method: \"GET\",\n        qs: queryOptions,\n        accept: \"application/json\",\n      };\n\n      if (skipToken.length === 0) {\n        options.headers = {\n          authorization: requestContext.accessToken.toTokenString(),\n        };\n      } else {\n        options.headers = {\n          authorization: requestContext.accessToken.toTokenString(),\n          skiptoken: skipToken,\n        };\n      }\n\n      await this.setupOptionDefaults(options);\n      requestContext.enter();\n\n      const res: Response = await request(requestContext, url, options);\n      requestContext.enter();\n      if (!res.body || !res.body.hasOwnProperty(\"instances\")) {\n        return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return any instances.`));\n      }\n      // console.log(JSON.stringify(res.body.instances));\n      for (const ecJsonInstance of res.body.instances) {\n        const typedInstance: T | undefined = ECJsonTypeMap.fromJson<T>(typedConstructor, \"wsg\", ecJsonInstance);\n        if (typedInstance) {\n          typedInstances.push(typedInstance);\n        }\n      }\n      skipToken = res.header.skiptoken;\n    } while (skipToken && useSkipToken);\n\n    Logger.logTrace(loggerCategory, \"Successful GET request\", () => ({ url }));\n    return Promise.resolve(typedInstances);\n  }\n\n  private getQueryRequestBody(queryOptions: RequestQueryOptions) {\n    const addPart = (query: string, key: string, value: string) => {\n      if (query !== \"\")\n        query += \"&\";\n      query += `${key}=${value}`;\n      return query;\n    };\n    let result = \"\";\n    if (queryOptions.$filter) {\n      result = addPart(result, \"$filter\", queryOptions.$filter);\n    }\n    if (queryOptions.$orderby) {\n      result = addPart(result, \"$orderby\", queryOptions.$orderby);\n    }\n    if (queryOptions.$select) {\n      result = addPart(result, \"$select\", queryOptions.$select);\n    }\n    if (queryOptions.$skip) {\n      result = addPart(result, \"$skip\", queryOptions.$skip.toString(10));\n    }\n    if (queryOptions.$top) {\n      result = addPart(result, \"$top\", queryOptions.$top.toString(10));\n    }\n    return result;\n  }\n\n  /** Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.\n   * @param typedConstructor Constructor function for the type\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param queryOptions Query options.\n   * @returns Array of strongly typed instances.\n   */\n  protected async postQuery<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions: RequestQueryOptions): Promise<T[]> {\n    requestContext.enter();\n    const url: string = `${await this.getUrl(requestContext)}${relativeUrlPath}$query`;\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Sending POST request\", () => ({ url }));\n\n    const options: RequestOptions = {\n      method: \"POST\",\n      headers: { authorization: requestContext.accessToken.toTokenString() },\n      body: this.getQueryRequestBody(queryOptions),\n    };\n\n    await this.setupOptionDefaults(options);\n    requestContext.enter();\n\n    const res: Response = await request(requestContext, url, options);\n    requestContext.enter();\n    if (!res.body || !res.body.hasOwnProperty(\"instances\")) {\n      return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return any instances.`));\n    }\n    // console.log(JSON.stringify(res.body.instances));\n    const typedInstances: T[] = new Array<T>();\n    for (const ecJsonInstance of res.body.instances) {\n      const typedInstance: T | undefined = ECJsonTypeMap.fromJson<T>(typedConstructor, \"wsg\", ecJsonInstance);\n      if (typedInstance) {\n        typedInstances.push(typedInstance);\n      }\n    }\n\n    Logger.logTrace(loggerCategory, \"Successful POST request\", () => ({ url }));\n    return Promise.resolve(typedInstances);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelBank */\r\nimport { FileHandler } from \"../FileHandler\";\r\nimport { IModelClient } from \"../IModelClient\";\r\nimport { IModelBankHandler } from \"./IModelBankHandler\";\r\n\r\n/** Class that allows access to different iModelHub class handlers.\r\n * Handlers should be accessed through an instance of this class, rather than constructed directly.\r\n * @internal\r\n */\r\nexport class IModelBankClient extends IModelClient {\r\n  /** Creates an instance of IModelBankClient.\r\n   * @param url Url to iModel Bank instance.\r\n   */\r\n  public constructor(url: string, handler: FileHandler | undefined) {\r\n    super(new IModelBankHandler(url, handler));\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { IModelHubStatus, Logger, WSStatus } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { Project, Asset } from \"../ConnectClients\";\r\nimport { ContextManagerClient } from \"../IModelCloudEnvironment\";\r\nimport { IModelHubClientError } from \"../imodelhub/Errors\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { request, RequestOptions, Response } from \"../Request\";\r\nimport { WsgError } from \"../WsgClient\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.IModelBank;\r\n\r\n// Format of the imodelContext.json file found in the root directory of an iModel file system context master directory.\r\n// TODO: Remove this when we\r\n/** @internal */\r\nexport interface IModelFileSystemContextProps {\r\n  name: string;\r\n  id: string;\r\n  description: string;\r\n}\r\n\r\n/** @internal */\r\nexport class IModelBankFileSystemContextClient implements ContextManagerClient {\r\n  constructor(public baseUri: string) {\r\n  }\r\n\r\n  private async queryContextProps(requestContext: AuthorizedClientRequestContext, projectName: string): Promise<IModelFileSystemContextProps[]> {\r\n    requestContext.enter();\r\n    const url: string = this.baseUri + \"/sv1.0/Repositories/IModelBankFileSystem--main/IModelBankFileSystem/Context\";\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, `Sending GET request to ${url}`);\r\n\r\n    const queryOptions = {      // use the same ODATA-style queries that Connect and iModelHub use\r\n      $select: \"*\",\r\n      $filter: `name+eq+'${projectName}'`,\r\n    };\r\n\r\n    const options: RequestOptions = {\r\n      method: \"GET\",\r\n      headers: { authorization: requestContext.accessToken.toTokenString() },\r\n      qs: queryOptions,\r\n      accept: \"application/json\",\r\n    };\r\n\r\n    const res: Response = await request(requestContext, url, options);\r\n    requestContext.enter();\r\n    if (!res.body) {\r\n      return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return anything.`));\r\n    }\r\n\r\n    const props = res.body as IModelFileSystemContextProps[];\r\n    if (props.length === 0)\r\n      return Promise.reject(new WsgError(WSStatus.InstanceNotFound));\r\n\r\n    if (props.length !== 1)\r\n      return Promise.reject(new IModelHubClientError(IModelHubStatus.InvalidArgumentError));\r\n\r\n    Logger.logTrace(loggerCategory, `Successful GET request to ${url}`);\r\n\r\n    return props;\r\n  }\r\n\r\n  public async queryAssetByName(requestContext: AuthorizedClientRequestContext, assetName: string): Promise<Asset> {\r\n    const props = await this.queryContextProps(requestContext, assetName);\r\n    requestContext.enter();\r\n\r\n    const asset = new Asset();\r\n    asset.wsgId = asset.ecId = props[0].id;\r\n    asset.name = props[0].name;\r\n    return Promise.resolve(asset);\r\n  }\r\n\r\n  public async queryProjectByName(requestContext: AuthorizedClientRequestContext, projectName: string): Promise<Project> {\r\n    const props = await this.queryContextProps(requestContext, projectName);\r\n    requestContext.enter();\r\n\r\n    const project = new Project();\r\n    project.wsgId = project.ecId = props[0].id;\r\n    project.name = props[0].name;\r\n    return Promise.resolve(project);\r\n  }\r\n\r\n  public async createContext(requestContext: AuthorizedClientRequestContext, name: string): Promise<void> {\r\n    requestContext.enter();\r\n    const url: string = this.baseUri + \"/sv1.0/Repositories/IModelBankFileSystem--main/IModelBankFileSystem/Context\";\r\n\r\n    Logger.logInfo(loggerCategory, `Sending POST request to ${url}`);\r\n\r\n    const body: IModelFileSystemContextProps = { name, id: \"\", description: \"\" };\r\n\r\n    const options: RequestOptions = {\r\n      method: \"POST\",\r\n      headers: { authorization: requestContext.accessToken.toTokenString() },\r\n      body,\r\n    };\r\n\r\n    return request(requestContext, url, options).then(async () => Promise.resolve());\r\n  }\r\n\r\n  public async deleteContext(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<void> {\r\n    requestContext.enter();\r\n    const url: string = this.baseUri + \"/sv1.0/Repositories/IModelBankFileSystem--main/IModelBankFileSystem/Context/\" + contextId;\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, `Sending DELETE request to ${url}`);\r\n\r\n    const options: RequestOptions = {\r\n      method: \"DELETE\",\r\n      headers: { authorization: requestContext.accessToken.toTokenString() },\r\n    };\r\n\r\n    return request(requestContext, url, options).then(async () => Promise.resolve());\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelBank */\r\nimport { assert, ClientRequestContext } from \"@bentley/bentleyjs-core\";\r\nimport { IModelBaseHandler } from \"../imodelhub/BaseHandler\";\r\nimport { FileHandler } from \"../imodeljs-clients\";\r\n\r\n/**\r\n * This class acts as the WsgClient for other iModelBank Handlers.\r\n * @beta\r\n */\r\nexport class IModelBankHandler extends IModelBaseHandler {\r\n  private _baseUrl: string;\r\n\r\n  /**\r\n   * Creates an instance of IModelBankWsgClient.\r\n   * @param handler The upload/download handler to use -- backends only.\r\n   * @param keepAliveDuration TBD\r\n   */\r\n  public constructor(url: string, handler: FileHandler | undefined, keepAliveDuration = 30000) {\r\n    super(keepAliveDuration, handler);\r\n    this._baseUrl = url;\r\n  }\r\n\r\n  protected getUrlSearchKey(): string { assert(false, \"Bentley cloud-specific method should be factored out of WsgClient base class\"); return \"\"; }\r\n\r\n  public async getUrl(_requestContext: ClientRequestContext, excludeApiVersion?: boolean): Promise<string> {\r\n    if (this._url)\r\n      return Promise.resolve(this._url!);\r\n\r\n    this._url = this._baseUrl;\r\n    if (!excludeApiVersion) {\r\n      this._url += \"/\" + this.apiVersion;\r\n    }\r\n    return Promise.resolve(this._url!);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\nimport { ClientRequestContext } from \"@bentley/bentleyjs-core\";\nimport { DefaultWsgRequestOptionsProvider, WsgClient, WsgRequestOptions } from \"../WsgClient\";\nimport { RequestOptions, RequestQueryOptions } from \"../Request\";\nimport { WsgInstance } from \"../ECJsonTypeMap\";\nimport { IModelHubError } from \"./Errors\";\nimport { AuthorizationToken, AccessToken } from \"../Token\";\nimport { ImsDelegationSecureTokenClient } from \"../ImsClients\";\nimport { FileHandler } from \"../imodeljs-clients\";\nimport { CustomRequestOptions } from \"./CustomRequestOptions\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { Config } from \"../Config\";\n/**\n * Provides default options for iModelHub requests.\n */\nclass DefaultIModelHubRequestOptionsProvider extends DefaultWsgRequestOptionsProvider {\n  public constructor(agent: any) {\n    super();\n    this._defaultOptions.errorCallback = IModelHubError.parse;\n    this._defaultOptions.retryCallback = IModelHubError.shouldRetry;\n    this._defaultOptions.agent = agent;\n  }\n}\n\n/**\n * This class acts as the WsgClient for other iModelHub Handlers.\n * @beta\n */\nexport class IModelBaseHandler extends WsgClient {\n  protected _url?: string;\n  private _defaultIModelHubOptionsProvider: DefaultIModelHubRequestOptionsProvider;\n  public static readonly searchKey: string = \"iModelHubApi\";\n  public static readonly configRelyingPartyUri = \"imjs_imodelhub_relying_party_uri\";\n  protected _agent: any;\n  protected _fileHandler: FileHandler | undefined;\n  private _customRequestOptions: CustomRequestOptions = new CustomRequestOptions();\n\n  /**\n   * Create an instance of IModelBaseHandler.\n   * @internal\n   */\n  public constructor(keepAliveDuration = 30000, fileHandler?: FileHandler) {\n    super(\"sv1.1\");\n    this._fileHandler = fileHandler;\n    const isMobile = typeof (self) !== \"undefined\" && (self as any).imodeljsMobile;\n    if (!(typeof window === \"undefined\") && !isMobile) {\n      // tslint:disable-next-line:no-var-requires\n      this._agent = require(\"https\").Agent({ keepAlive: keepAliveDuration > 0, keepAliveMsecs: keepAliveDuration, secureProtocol: \"TLSv1_2_method\" });\n    }\n  }\n\n  public formatContextIdForUrl(contextId: string) { return contextId; }\n\n  public getFileHandler(): FileHandler | undefined { return this._fileHandler; }\n\n  /**\n   * Augment request options with defaults returned by the DefaultIModelHubRequestOptionsProvider. Note that the options passed in by clients override any defaults where necessary.\n   * @param options Options the caller wants to augment with the defaults.\n   * @returns Promise resolves after the defaults are setup.\n   */\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\n    if (!this._defaultIModelHubOptionsProvider)\n      this._defaultIModelHubOptionsProvider = new DefaultIModelHubRequestOptionsProvider(this._agent);\n\n    return this._defaultIModelHubOptionsProvider.assignOptions(options);\n  }\n\n  /**\n   * Get name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return IModelBaseHandler.searchKey;\n  }\n\n  /**\n   * Gets theRelyingPartyUrl for the service.\n   * @returns RelyingPartyUrl for the service.\n   */\n  protected getRelyingPartyUrl(): string {\n    if (Config.App.has(IModelBaseHandler.configRelyingPartyUri))\n      return Config.App.get(IModelBaseHandler.configRelyingPartyUri) + \"/\";\n\n    if (Config.App.getBoolean(WsgClient.configUseHostRelyingPartyUriAsFallback, true)) {\n      if (Config.App.has(WsgClient.configHostRelyingPartyUri))\n        return Config.App.get(WsgClient.configHostRelyingPartyUri) + \"/\";\n    }\n\n    throw new Error(`RelyingPartyUrl not set. Set it in Config.App using key ${IModelBaseHandler.configRelyingPartyUri}`);\n  }\n\n  /**\n   * Get the agent used for imodelhub connection pooling.\n   * @returns The agent used for imodelhub connection pooling.\n   */\n  public getAgent(): any {\n    return this._agent;\n  }\n\n  /**\n   * Get the URL of the service. This method attempts to discover and cache the URL from the URL Discovery Service. If not found uses the default URL provided by client implementations. Note that for consistency sake, the URL is stripped of any trailing \"/\"\n   * @returns URL for the service\n   */\n  public async getUrl(requestContext: ClientRequestContext): Promise<string> {\n    return super.getUrl(requestContext);\n  }\n\n  /**\n   * Get the (delegation) access token to access the service\n   * @param requestContext The client request context\n   * @param authorizationToken Authorization token.\n   * @returns Resolves to the (delegation) access token.\n   * @internal\n   */\n  public async getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken> {\n    const imsClient = new ImsDelegationSecureTokenClient();\n    return imsClient.getToken(requestContext, authorizationToken, this.getRelyingPartyUrl());\n  }\n\n  /**\n   * Send a delete request. Sends a request without body.\n   * @param requestContext The client request context\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @returns Promise resolves after successfully deleting REST resource at the specified path.\n   */\n  public async delete(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string): Promise<void> {\n    return super.delete(requestContext, relativeUrlPath);\n  }\n\n  /**\n   * Delete a strongly typed instance. Sends a request body with a WSG instance.\n   * @param requestContext The client request context\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param instance Instance to be deleted.\n   * @param requestOptions WSG options for the request.\n   * @returns Promise resolves after successfully deleting instance.\n   */\n  public async deleteInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, relativeUrlPath: string, instance?: T, requestOptions?: WsgRequestOptions): Promise<void> {\n    if (this._customRequestOptions.isSet) {\n      if (!requestOptions) {\n        requestOptions = {};\n      }\n      requestOptions.CustomOptions = this._customRequestOptions.insertCustomOptions(requestOptions.CustomOptions);\n    }\n    return super.deleteInstance<T>(requestContext, relativeUrlPath, instance, requestOptions);\n  }\n\n  /**\n   * Post a strongly typed instance. Sends a request body with a WSG instance.\n   * @param requestContext The client request context\n   * @param typedConstructor Used to construct the resulting instances from the response.\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param instance Strongly typed instance to be posted.\n   * @param requestOptions WSG options for the request.\n   * @returns The posted instance that's returned back from the server.\n   */\n  public async postInstance<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instance: T, requestOptions?: WsgRequestOptions): Promise<T> {\n    if (this._customRequestOptions.isSet) {\n      if (!requestOptions) {\n        requestOptions = {};\n      }\n      requestOptions.CustomOptions = this._customRequestOptions.insertCustomOptions(requestOptions.CustomOptions);\n    }\n    return super.postInstance<T>(requestContext, typedConstructor, relativeUrlPath, instance, requestOptions);\n  }\n\n  /**\n   * Post multiple strongly typed instances. Sends a request body with WSG instances.\n   * @param requestContext The client request context\n   * @param typedConstructor Used to construct the resulting instances from the response.\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param instances Strongly typed instances to be posted.\n   * @param requestOptions WSG options for the request.\n   * @returns The posted instances that's returned back from the server.\n   */\n  public async postInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, instances: T[], requestOptions?: WsgRequestOptions): Promise<T[]> {\n    return super.postInstances(requestContext, typedConstructor, relativeUrlPath, instances, requestOptions);\n  }\n\n  /**\n   * Get multiple strongly typed instances.\n   * @param requestContext The client request context\n   * @param typedConstructor Used to construct the resulting instances from the response.\n   * @param token Delegation token of the authorized user.\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param queryOptions Query options.\n   * @returns Array of strongly typed instances.\n   */\n  public async getInstances<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions?: RequestQueryOptions): Promise<T[]> {\n    return super.getInstances(requestContext, typedConstructor, relativeUrlPath, queryOptions);\n  }\n\n  /**\n   * Get multiple strongly typed instances. Sends query in the request's body. This can be used for queries that are too long to fit in URL.\n   * @param requestContext The client request context\n   * @param typedConstructor Used to construct the resulting instances from the response.\n   * @param relativeUrlPath Relative path to the REST resource.\n   * @param queryOptions Query options.\n   * @returns Array of strongly typed instances.\n   */\n  public async postQuery<T extends WsgInstance>(requestContext: AuthorizedClientRequestContext, typedConstructor: new () => T, relativeUrlPath: string, queryOptions: RequestQueryOptions): Promise<T[]> {\n    return super.postQuery(requestContext, typedConstructor, relativeUrlPath, queryOptions);\n  }\n\n  /**\n   * Get an instance of CustomRequestOptions, which can be used to set custom request parameters for all future requests made by this handler.\n   */\n  public getCustomRequestOptions(): CustomRequestOptions {\n    return this._customRequestOptions;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { GuidString, Logger } from \"@bentley/bentleyjs-core\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { FileHandler } from \"../FileHandler\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { ProgressInfo } from \"../Request\";\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\nimport { IModelBaseHandler } from \"./BaseHandler\";\nimport { ArgumentCheck, IModelHubClientError } from \"./Errors\";\nimport { addSelectFileAccessKey, Query } from \"./Query\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\n\n/** Controls whether the user has exclusive or shared access to a local briefcase\n * @internal\n */\nexport enum BriefcaseAccessMode {\n  Shared = 0,\n  Exclusive = 1,\n}\n\n/**\n * Briefcase is a copy of the master file, that user acquires to work with the iModel. Briefcase instance represents metadata about a copy of iModel's master file.\n *\n * File properties describe the file that would be downloaded through downloadUrl. It is the most recently updated copy of master file that is stored on iModelHub. These copies do not necessarily have the latest [[ChangeSet]] applied to them.\n *\n * briefcaseId is the id that user needs to write into the local copy of master file and use for other iModelHub requests. briefcaseId ranges from 2 to 16777215, see [BriefcaseId]($backend).\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.Briefcase\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\n@ECJsonTypeMap.classToJson(\"ecdb\", \"ServiceStore.Briefcase\", { classKeyPropertyName: \"className\" })\nexport class Briefcase extends WsgInstance {\n  /** File name of the master file. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileName\")\n  public fileName?: string;\n\n  /** Description of the master file. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileDescription\")\n  public fileDescription?: string;\n\n  /** Size of the latest copy of the master file in iModelHub. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileSize\")\n  public fileSize?: string;\n\n  /** FileId of the master file. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileId\")\n  public fileId?: GuidString;\n\n  /** Id of the briefcase. See [BriefcaseId]($backend) */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.BriefcaseId\")\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"briefcaseId\")\n  public briefcaseId?: number;\n\n  /** Id of the user that acquired this briefcase. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UserOwned\")\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"userId\")\n  public userId?: string;\n\n  /** Id of the last [[ChangeSet]] that was merged into the latest copy of master file on iModelHub. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.MergedChangeSetId\")\n  public mergedChangeSetId?: string;\n\n  /** Date when this briefcase was acquired. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.AcquiredDate\")\n  public acquiredDate?: string;\n\n  /** Shows whether the user who acquired this briefcase can perform write operations. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IsReadOnly\")\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"isReadOnly\")\n  public isReadOnly?: boolean;\n\n  /** URL that can be used to download the latest copy of master file from iModelHub. See [[BriefcaseQuery.selectDownloadUrl]]. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl\")\n  public downloadUrl?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"accessMode\")\n  public accessMode?: BriefcaseAccessMode;\n\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"localPathname\")\n  public localPathname?: string;\n\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"lastAccessedAt\")\n  public lastAccessedAt?: Date;\n\n  @ECJsonTypeMap.propertyToJson(\"ecdb\", \"iModelId\")\n  public iModelId?: GuidString;\n}\n\n/**\n * Query object for getting [[Briefcase]]s. You can use this to modify the [[BriefcaseHandler.get]] results.\n * @internal\n */\nexport class BriefcaseQuery extends Query {\n  private _byId?: number;\n  /**\n   * Query single [[Briefcase]] by its id. If briefcase is not found, request will be rejected with a [[WsgError]] and status [WSStatus.InstanceNotFound]($bentley).\n   * @param id Id of the Briefcase.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid Briefcase id value.\n   */\n  public byId(id: number): this {\n    ArgumentCheck.validBriefcaseId(\"id\", id);\n    this._byId = id;\n    return this;\n  }\n\n  /**\n   * Used by handler to get the id that is queried.\n   * @returns Value that was set with byId method.\n   * @internal\n   */\n  public getId(): number | undefined {\n    return this._byId;\n  }\n\n  /**\n   * Query will additionally select [[Briefcase]] file download URL. This is needed to use the Briefcase object with [[BriefcaseHandler.download]].\n   * @returns This query.\n   */\n  public selectDownloadUrl(): this {\n    addSelectFileAccessKey(this._query);\n    return this;\n  }\n\n  /**\n   * Query will select [[Briefcase]]s owned by this user.\n   * @returns This query.\n   */\n  public ownedByMe(): this {\n    this.addFilter(\"UserOwned+eq+'@me'\");\n    return this;\n  }\n}\n\n/**\n * Handler for managing [[Briefcase]]s. Use [[IModelClient.Briefcases]] to get an instance of this class.\n * In most cases, you should use [IModelDb]($backend) methods instead.\n * @internal\n */\nexport class BriefcaseHandler {\n  private _handler: IModelBaseHandler;\n  private _fileHandler?: FileHandler;\n\n  /** Constructor for BriefcaseHandler. Use [[IModelClient]] instead of directly constructing this.\n   * @param handler Handler for WSG requests.\n   * @param fileHandler Handler for file system.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler, fileHandler?: FileHandler) {\n    this._handler = handler;\n    this._fileHandler = fileHandler;\n  }\n\n  /** Get relative url for Briefcase requests.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param briefcaseId Id of the briefcase.\n   * @internal\n   */\n  private getRelativeUrl(iModelId: GuidString, briefcaseId?: number) {\n    return `/Repositories/iModel--${iModelId}/iModelScope/Briefcase/${briefcaseId || \"\"}`;\n  }\n\n  /** Acquire a [[Briefcase]] for the specified iModel. This assigns you a new briefcaseId and returns you a download link.\n   * A briefcase is automatically acquired when calling [IModelDb.open]($backend) or [IModelDb.create]($backend). You should use this method only when you want to acquire the briefcaseId without downloading the file. If you need just the download link, you can call [[BriefcaseHandler.get]] with [[BriefcaseQuery.selectDownloadUrl]].\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @returns The acquired Briefcase instance.\n   * @throws [[IModelHubError]] with [IModelHubStatus.MaximumNumberOfBriefcasesPerUser]($bentley) or [IModelHubStatus.MaximumNumberOfBriefcasesPerUserPerMinute]($bentley) if a limit of Briefcases for that user was reached. Users should use the Briefcases they have previously acquired. If that is no longer possible, they should delete them, to be able to acquire new ones.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString): Promise<Briefcase> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Acquiring briefcase for iModel\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    let briefcase: Briefcase = new Briefcase();\n\n    briefcase = await this._handler.postInstance<Briefcase>(requestContext, Briefcase, this.getRelativeUrl(iModelId), briefcase);\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Acquired briefcase for iModel\", () => briefcase);\n    return briefcase;\n  }\n\n  /** Delete the [[Briefcase]] from iModelHub. This frees up the id to be reused later and allows user to acquire additional briefcases if one of the briefcase limits was reached.\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param briefcaseId Id of the Briefcase to be deleted.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async delete(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, briefcaseId: number): Promise<void> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Deleting briefcase from iModel\", () => ({ iModelId, briefcaseId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n\n    await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, briefcaseId));\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Deleted briefcase from iModel\", () => ({ iModelId, briefcaseId }));\n  }\n\n  /** Get the [[Briefcase]]s.\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param query Optional query object to filter the queried Briefcases or select different data from them.\n   * @returns Briefcases that match the query.\n   * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[BriefcaseQuery.byId]] is used and a Briefcase with the specified id could not be found.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: BriefcaseQuery = new BriefcaseQuery()): Promise<Briefcase[]> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Querying briefcases for iModel\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    const id = query.getId();\n\n    const briefcases = await this._handler.getInstances<Briefcase>(requestContext, Briefcase, this.getRelativeUrl(iModelId, id), query.getQueryOptions());\n    requestContext.enter();\n    for (const briefcase of briefcases) {\n      briefcase.iModelId = iModelId;\n    }\n\n    Logger.logTrace(loggerCategory, \"Queried briefcases for iModel\", () => ({ iModelId, count: briefcases.length }));\n    return briefcases;\n  }\n\n  /** Download the latest copy of master file. This only downloads the file and does not write the [[Briefcase]] id into it. Use [IModelDb.open]($backend) instead if you want to get a Briefcase file you can work with.\n   * This method does not work on the browser. Directory containing the Briefcase file is created if it does not exist. If there is an error during download, any partially downloaded file is deleted from disk.\n   * @param requestContext The client request context\n   * @param briefcase Briefcase to download. This needs to include a download link. See [[BriefcaseQuery.selectDownloadUrl]].\n   * @param path Path where briefcase file should be downloaded, including filename.\n   * @param progressCallback Callback for tracking progress.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.NotSupportedInBrowser]($bentley) if called in a browser.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.FileHandlerNotSet]($bentley) if [[FileHandler]] instance was not set for [[IModelClient]].\n   * @throws [[ResponseError]] if the briefcase cannot be downloaded.\n   */\n  public async download(requestContext: AuthorizedClientRequestContext, briefcase: Briefcase, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void> {\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Started downloading briefcase\", () => ({ ...briefcase, path }));\n    ArgumentCheck.defined(\"briefcase\", briefcase);\n    ArgumentCheck.defined(\"path\", path);\n\n    if (typeof window !== \"undefined\")\n      return Promise.reject(IModelHubClientError.browser());\n\n    if (!this._fileHandler)\n      return Promise.reject(IModelHubClientError.fileHandler());\n\n    if (!briefcase.downloadUrl)\n      return Promise.reject(IModelHubClientError.missingDownloadUrl(\"briefcase\"));\n\n    await this._fileHandler.downloadFile(requestContext, briefcase.downloadUrl, path, parseInt(briefcase.fileSize!, 10), progressCallback);\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Finished downloading briefcase\", () => ({ ...briefcase, path }));\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHub */\r\n\r\nimport { GuidString, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { FileHandler } from \"../FileHandler\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { ProgressInfo } from \"../Request\";\r\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { ArgumentCheck, IModelHubClientError } from \"./Errors\";\r\nimport { addSelectFileAccessKey, StringIdQuery } from \"./Query\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\r\n\r\n/**\r\n * Specifies types of changes in a [[ChangeSet]].\r\n * @beta\r\n */\r\nexport enum ChangesType {\r\n  /** [[ChangeSet]] contains regular file changes (e.g. changes to elements or models). */\r\n  Regular,\r\n  /** [[ChangeSet]] only contains schema changes. */\r\n  Schema,\r\n}\r\n\r\n/**\r\n * [ChangeSet]($docs/learning/Glossary.md#changeset) represents a file containing changes to the iModel. A single ChangeSet contains changes made on a single [[Briefcase]] file and pushed as a single file. ChangeSets form a linear change history of the iModel. If a user wants to push their changes to iModelHub, they first have to merge all ChangeSet they do not have yet. Only a single briefcase is allowed to push their changes at a time.\r\n * @beta\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.ChangeSet\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class ChangeSet extends WsgInstance {\r\n  /** Id of this ChangeSet. It has to be set during the push. It's a hash value based on the contents of ChangeSet file and its parentId. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Id\")\r\n  public id?: string;\r\n\r\n  /** Filename of the ChangeSet. It has to be set during the push. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileName\")\r\n  public fileName?: string;\r\n\r\n  /** Description of this ChangeSet. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Description\")\r\n  public description?: string;\r\n\r\n  /** Size of this ChangeSet file. It has to be set during the push. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileSize\")\r\n  public fileSize?: string;\r\n\r\n  /** Index of this ChangeSet (increasing, but not necessarily sequential). */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Index\")\r\n  public index?: string;\r\n\r\n  /** Id of this ChangeSet's parent ChangeSet. It has to be set during the push. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ParentId\")\r\n  public parentId?: string;\r\n\r\n  /** Id of the file that this ChangeSet belongs to. It has to be set during the push. See [IModelDb.getGuid]($backend). */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.SeedFileId\")\r\n  public seedFileId?: GuidString;\r\n\r\n  /** Id of the [[Briefcase]] that pushed this ChangeSet. It has to be set during the push. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.BriefcaseId\")\r\n  public briefcaseId?: number;\r\n\r\n  /** Id of the user that pushed this ChangeSet. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UserCreated\")\r\n  public userCreated?: string;\r\n\r\n  /** Date when this ChangeSet was pushed to iModelHub. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.PushDate\")\r\n  public pushDate?: string;\r\n\r\n  /** Shows what kind of changes are contained in this ChangeSet. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ContainingChanges\")\r\n  public changesType?: ChangesType;\r\n\r\n  /** Flag that needs to be marked true, when confirming successful ChangeSet upload. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IsUploaded\")\r\n  public isUploaded?: boolean;\r\n\r\n  /** URL from where the ChangeSet file can be downloaded. See [[ChangeSetQuery.selectDownloadUrl]]. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl\")\r\n  public downloadUrl?: string;\r\n\r\n  /** URL where the ChangeSet file has to be uploaded. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.UploadUrl\")\r\n  public uploadUrl?: string;\r\n\r\n  /** Path to the download ChangeSet file on disk. */\r\n  public pathname?: string;\r\n}\r\n\r\n/**\r\n * Query object for getting [[ChangeSet]]s. You can use this to modify the query. See [[ChangeSetHandler.get]].\r\n * @beta\r\n */\r\nexport class ChangeSetQuery extends StringIdQuery {\r\n  /**\r\n   * Default page size which is used when querying ChangeSets\r\n   * @internal\r\n   */\r\n  public static defaultPageSize: number = 1000;\r\n\r\n  /** Constructor that sets default page size. */\r\n  constructor() {\r\n    super();\r\n    this.pageSize(ChangeSetQuery.defaultPageSize);\r\n  }\r\n\r\n  /**\r\n   * Query will additionally select [[ChangeSet]] file download URL. This is needed to use the ChangeSet object with [[ChangeSetHandler.download]].\r\n   * @returns This query.\r\n   */\r\n  public selectDownloadUrl() {\r\n    addSelectFileAccessKey(this._query);\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  protected checkValue(id: string) {\r\n    ArgumentCheck.validChangeSetId(\"id\", id);\r\n  }\r\n\r\n  /**\r\n   * Query [[ChangeSet]]s that are after the specified ChangeSet. This overrides any previously applied ChangeSetQuery filters. Query will return all of the ChangeSets that are newer than the one specified by id. ChangeSet specified by the id will not be included in the results. Returned ChangeSets will be in an ascending order.\r\n   * @param id Id of a ChangeSet.\r\n   * @returns This query.\r\n   */\r\n  public fromId(id: string) {\r\n    ArgumentCheck.validChangeSetId(\"id\", id);\r\n    this._query.$filter = `FollowingChangeSet-backward-ChangeSet.Id+eq+'${id}'`;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Change the order of results to be from newest [[ChangeSet]]s to the oldest ones.\r\n   * @returns This query.\r\n   */\r\n  public latest() {\r\n    this._query.$orderby = \"Index+desc\";\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query [[ChangeSet]]s between two specified ChangeSets. This overrides any previously applied ChangeSetQuery filters. This query will work when either of the ChangeSet ids points to an earlier ChangeSet. Latest ChangeSet specified by this range will be included in the results, but the earliest will be excluded. If the second ChangeSet id is not specified, it's assumed that it's the same as an empty id, and query will return all ChangeSets from the start up to the ChangeSet with the first id. Returned ChangeSets will be in an ascending order.\r\n   * @param firstChangeSetId Id of the first changeSet.\r\n   * @param secondChangeSetId Id of the second changeSet.\r\n   * @returns This query.\r\n   */\r\n  public betweenChangeSets(firstChangeSetId: string, secondChangeSetId?: string) {\r\n    ArgumentCheck.validChangeSetId(\"firstChangeSetId\", firstChangeSetId);\r\n    if (secondChangeSetId)\r\n      ArgumentCheck.validChangeSetId(\"secondChangeSetId\", secondChangeSetId);\r\n    let query: string;\r\n    if (!secondChangeSetId) {\r\n      query = `CumulativeChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}'`;\r\n    } else {\r\n      query = `(CumulativeChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}'`;\r\n      query += `+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${secondChangeSetId}')`;\r\n      query += `+or+(CumulativeChangeSet-backward-ChangeSet.Id+eq+'${secondChangeSetId}'`;\r\n      query += `+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}')`;\r\n    }\r\n\r\n    this._query.$filter = query;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query [[ChangeSet]]s included in the specified [[Version]]. This overrides any previously applied ChangeSetQuery filters. Query will return all of the ChangeSets from the start up to the one specified by versionId. ChangeSet specified by versionId will be included in the results. Returned ChangeSets will be in an ascending order.\r\n   * @param versionId Id of the version.\r\n   * @returns This query.\r\n   */\r\n  public getVersionChangeSets(versionId: GuidString) {\r\n    ArgumentCheck.validGuid(\"versionId\", versionId);\r\n    this._query.$filter = `CumulativeChangeSet-backward-Version.Id+eq+'${versionId}'`;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query [[ChangeSet]]s after the specified [[Version]]. This overrides any previously applied ChangeSetQuery filters. Query will return all of the ChangeSets that are newer than the one specified by versionId. ChangeSet specified by versionId will not be included in the results. Returned ChangeSets will be in an ascending order.\r\n   * @param versionId Id of the version.\r\n   * @returns This query.\r\n   */\r\n  public afterVersion(versionId: GuidString) {\r\n    ArgumentCheck.validGuid(\"versionId\", versionId);\r\n    this._query.$filter = `FollowingChangeSet-backward-Version.Id+eq+'${versionId}'`;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query [[ChangeSet]]s between two specified [[Version]]s. This overrides any previously applied ChangeSetQuery filters. This query will work when either of the Version ids points to an earlier ChangeSet. Latest ChangeSet specified by this range will be included in the results, but the earliest will be excluded. Returned ChangeSets will be in an ascending order.\r\n   * @param sourceVersionId Id of the source version.\r\n   * @param destinationVersionId Id of the destination version.\r\n   * @returns This query.\r\n   */\r\n  public betweenVersions(sourceVersionId: GuidString, destinationVersionId: GuidString) {\r\n    ArgumentCheck.validGuid(\"sourceVersionId\", sourceVersionId);\r\n    ArgumentCheck.validGuid(\"destinationVersionId\", destinationVersionId);\r\n    let query: string;\r\n    query = `(FollowingChangeSet-backward-Version.Id+eq+'${sourceVersionId}'`;\r\n    query += `+and+CumulativeChangeSet-backward-Version.Id+eq+'${destinationVersionId}')`;\r\n    query += `+or+(FollowingChangeSet-backward-Version.Id+eq+'${destinationVersionId}'`;\r\n    query += `+and+CumulativeChangeSet-backward-Version.Id+eq+'${sourceVersionId}')`;\r\n\r\n    this._query.$filter = query;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query [[ChangeSet]]s between the specified [[Version]] and another [[ChangeSet]]. This overrides any previously applied ChangeSetQuery filters. This query will work when either versionId or changeSetId points to an earlier ChangeSet. Latest ChangeSet specified by this range will be included in the results, but the earliest will be excluded. Returned ChangeSets will be in an ascending order.\r\n   * @param versionId Id of the version.\r\n   * @param changeSetId Id of the changeSet.\r\n   * @returns This query.\r\n   */\r\n  public betweenVersionAndChangeSet(versionId: GuidString, changeSetId: string) {\r\n    ArgumentCheck.validGuid(\"versionId\", versionId);\r\n    ArgumentCheck.validChangeSetId(\"changeSetId\", changeSetId);\r\n    let query: string;\r\n    query = `(CumulativeChangeSet-backward-Version.Id+eq+'${versionId}'+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${changeSetId}')`;\r\n    query += `+or+`;\r\n    query += `(FollowingChangeSet-backward-Version.Id+eq+'${versionId}'+and+CumulativeChangeSet-backward-ChangeSet.Id+eq+'${changeSetId}')`;\r\n\r\n    this._query.$filter = query;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query changeSets by the seed file id. Should be obsolete, because seed file replacement is deprecated.\r\n   * @param seedFileId Id of the seed file.\r\n   * @returns This query.\r\n   * @internal\r\n   */\r\n  public bySeedFileId(seedFileId: GuidString) {\r\n    ArgumentCheck.validGuid(\"seedFileId\", seedFileId);\r\n    this.addFilter(`SeedFileId+eq+'${seedFileId}'`);\r\n    return this;\r\n  }\r\n}\r\n\r\n/** Queue for limiting number of promises executed in parallel. */\r\nclass ParallelQueue {\r\n  private _queue: Array<() => Promise<void>> = [];\r\n  private _parallelDownloads = 10;\r\n\r\n  /** Add a promise to the queue. */\r\n  public push(downloadFunc: () => Promise<void>) {\r\n    this._queue.push(downloadFunc);\r\n  }\r\n\r\n  /** Wait for all promises in the queue to finish. */\r\n  public async waitAll() {\r\n    let i = 0;\r\n    const promises = new Array<Promise<number>>();\r\n    const indexes = new Array<number>();\r\n    const completed = new Array<number>();\r\n\r\n    while (this._queue.length > 0 || promises.length > 0) {\r\n      while (this._queue.length > 0 && promises.length < this._parallelDownloads) {\r\n        const currentIndex = i++;\r\n        promises.push(this._queue[0]().then(() => completed.push(currentIndex)));\r\n        indexes.push(currentIndex);\r\n        this._queue.shift();\r\n      }\r\n      await Promise.race(promises);\r\n      while (completed.length > 0) {\r\n        const completedIndex = completed.shift()!;\r\n        const index = indexes.findIndex((value) => value === completedIndex);\r\n        if (index !== undefined) {\r\n          promises.splice(index, 1);\r\n          indexes.splice(index, 1);\r\n        }\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Handler for managing [[ChangeSet]]s. Use [[IModelClient.ChangeSets]] to get an instance of this class. In most cases, you should use [IModelDb]($backend) methods instead.\r\n * @beta\r\n */\r\nexport class ChangeSetHandler {\r\n  private _handler: IModelBaseHandler;\r\n  private _fileHandler?: FileHandler;\r\n\r\n  /**\r\n   * Constructor for ChangeSetHandler. Should use [[IModelClient]] instead of directly constructing this.\r\n   * @param handler Handler for WSG requests.\r\n   * @param fileHandler Handler for file system.\r\n   * @internal\r\n   */\r\n  constructor(handler: IModelBaseHandler, fileHandler?: FileHandler) {\r\n    this._handler = handler;\r\n    this._fileHandler = fileHandler;\r\n  }\r\n\r\n  /** Get relative url for ChangeSet requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param changeSetId Id of the ChangeSet.\r\n   * @internal\r\n   */\r\n  private getRelativeUrl(iModelId: GuidString, changeSetId?: string) {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/ChangeSet/${changeSetId || \"\"}`;\r\n  }\r\n\r\n  /** Get the [[ChangeSet]]s for the iModel.\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param query Optional query object to filter the queried ChangeSets or select different data from them.\r\n   * @returns ChangeSets that match the query.\r\n   * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[InstanceIdQuery.byId]] is used and a [[ChangeSet]] with the specified id could not be found.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: ChangeSetQuery = new ChangeSetQuery()): Promise<ChangeSet[]> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, `Started querying ChangeSets`, () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    const id = query.getId();\r\n    const changeSets = await this._handler.getInstances<ChangeSet>(requestContext, ChangeSet, this.getRelativeUrl(iModelId, id), query.getQueryOptions());\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, `Finished querying ChangeSets`, () => ({ iModelId, count: changeSets.length }));\r\n\r\n    return changeSets;\r\n  }\r\n\r\n  /**\r\n   * Download the specified [[ChangeSet]]s. If you want to [pull]($docs/learning/Glossary.md#pull) and [merge]($docs/learning/Glossary.md#merge) ChangeSets from iModelHub to your [[Briefcase]], you should use [IModelDb.pullAndMergeChanges]($backend) instead.\r\n   *\r\n   * This method creates the directory containing the ChangeSets if necessary. If there is an error in downloading some of the ChangeSets, all partially downloaded ChangeSets are deleted from disk.\r\n   * @param requestContext The client request context\r\n   * @param changeSets ChangeSets to download. These need to include a download link. See [[ChangeSetQuery.selectDownloadUrl]].\r\n   * @param path Path of directory where the ChangeSets should be downloaded.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley), if one of the required arguments is undefined or empty.\r\n   * @param progressCallback Callback for tracking progress.\r\n   * @throws [[ResponseError]] if the download fails.\r\n   */\r\n  public async download(requestContext: AuthorizedClientRequestContext, changeSets: ChangeSet[], path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, `Downloading ${changeSets.length} changesets`);\r\n    ArgumentCheck.nonEmptyArray(\"changeSets\", changeSets);\r\n    ArgumentCheck.defined(\"path\", path);\r\n\r\n    if (typeof window !== \"undefined\")\r\n      return Promise.reject(IModelHubClientError.browser());\r\n\r\n    if (!this._fileHandler)\r\n      return Promise.reject(IModelHubClientError.fileHandler());\r\n\r\n    changeSets.forEach((changeSet) => {\r\n      if (!changeSet.downloadUrl)\r\n        throw IModelHubClientError.missingDownloadUrl(\"changeSets\");\r\n    });\r\n\r\n    let totalSize = 0;\r\n    let downloadedSize = 0;\r\n    changeSets.forEach((value) => totalSize += parseInt(value.fileSize!, 10));\r\n\r\n    const queue = new ParallelQueue();\r\n    const fileHandler = this._fileHandler;\r\n    changeSets.forEach((changeSet) =>\r\n      queue.push(async () => {\r\n        const downloadUrl: string = changeSet.downloadUrl!;\r\n        const downloadPath: string = fileHandler.join(path, changeSet.fileName!);\r\n\r\n        let previouslyDownloaded = 0;\r\n        const callback = (progress: ProgressInfo) => {\r\n          downloadedSize += (progress.loaded - previouslyDownloaded);\r\n          previouslyDownloaded = progress.loaded;\r\n          progressCallback!({ loaded: downloadedSize, total: totalSize, percent: downloadedSize / totalSize });\r\n        };\r\n        return fileHandler.downloadFile(requestContext, downloadUrl, downloadPath, parseInt(changeSet.fileSize!, 10), progressCallback ? callback : undefined);\r\n      }));\r\n\r\n    await queue.waitAll();\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, `Downloaded ${changeSets.length} changesets`);\r\n  }\r\n\r\n  /**\r\n   * Upload a [[ChangeSet]] file. If you want to [push]($docs/learning/Glossary.md#push) your changes to iModelHub, use [IModelDb.pushChanges]($backend) instead. This method is only a part of that workflow.\r\n   *\r\n   * ChangeSets have to be uploaded in a linear order. If another user is uploading, or changeSet.parentId does not point to the latest ChangeSet on iModelHub, this method will fail. User will have to download all of the newer ChangeSets, merge them into their [[Briefcase]] and calculate a new ChangeSet id.\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param changeSet Information of the ChangeSet to be uploaded.\r\n   * @param path Path of the ChangeSet file to be uploaded.\r\n   * @param progressCallback Callback for tracking upload progress.\r\n   * @throws [IModelHubStatus.BriefcaseDoesNotBelongToUser]($bentley) if Briefcase specified by changeSet.briefcaseId belongs to another user.\r\n   * @throws [IModelHubStatus.AnotherUserPushing]($bentley) if another user is currently uploading a ChangeSet.\r\n   * @throws [IModelHubStatus.PullIsRequired]($bentley) if there are newer ChangeSets on iModelHub, that need to be downloaded and merged, before upload is possible.\r\n   * @throws [IModelHubStatus.ChangeSetAlreadyExists]($bentley) if a ChangeSet with this id already exists. This usually happens if previous upload attempt has succeeded.\r\n   * @throws [IModelHubStatus.ChangeSetPointsToBadSeed]($bentley) if changeSet.seedFileId is not set to the correct file id. That file id should match to the value written to the Briefcase file. See [IModelDb.setGuid]($backend).\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, changeSet: ChangeSet, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<ChangeSet> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Started uploading ChangeSet\", () => ({ iModelId, ...changeSet }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n    ArgumentCheck.defined(\"changeSet\", changeSet);\r\n    ArgumentCheck.defined(\"path\", path);\r\n\r\n    if (typeof window !== \"undefined\")\r\n      return Promise.reject(IModelHubClientError.browser());\r\n\r\n    if (!this._fileHandler)\r\n      return Promise.reject(IModelHubClientError.fileHandler());\r\n\r\n    if (!this._fileHandler.exists(path) || this._fileHandler.isDirectory(path))\r\n      return Promise.reject(IModelHubClientError.fileNotFound());\r\n\r\n    const postChangeSet = await this._handler.postInstance<ChangeSet>(requestContext, ChangeSet, this.getRelativeUrl(iModelId), changeSet);\r\n\r\n    await this._fileHandler.uploadFile(requestContext, postChangeSet.uploadUrl!, path, progressCallback);\r\n    requestContext.enter();\r\n\r\n    postChangeSet.uploadUrl = undefined;\r\n    postChangeSet.downloadUrl = undefined;\r\n    postChangeSet.isUploaded = true;\r\n\r\n    const confirmChangeSet = await this._handler.postInstance<ChangeSet>(requestContext, ChangeSet, this.getRelativeUrl(iModelId, postChangeSet.id!), postChangeSet);\r\n    requestContext.enter();\r\n\r\n    changeSet.isUploaded = true;\r\n\r\n    Logger.logInfo(loggerCategory, \"Finished uploading ChangeSet\", () => ({ iModelId, ...changeSet }));\r\n\r\n    return confirmChangeSet;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHub */\r\n\r\nimport { GuidString, Logger, PerfLogger } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { FileHandler } from \"../FileHandler\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { ProgressInfo } from \"../Request\";\r\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { ArgumentCheck, IModelHubClientError } from \"./Errors\";\r\nimport { addSelectFileAccessKey, Query } from \"./Query\";\r\nimport { InitializationState } from \"./iModels\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\r\n\r\n/**\r\n * Checkpoint is a copy of the master file, that is intended to be read-only and reduces amount of merging required to get an iModel to a specific previous state.\r\n *\r\n * File properties describe the file that would be downloaded through downloadUrl.\r\n * @alpha\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.Checkpoint\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class Checkpoint extends WsgInstance {\r\n  /** File name of the master file. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileName\")\r\n  public fileName?: string;\r\n\r\n  /** Description of the master file. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileDescription\")\r\n  public fileDescription?: string;\r\n\r\n  /** Size of the checkpoint file. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileSize\")\r\n  public fileSize?: string;\r\n\r\n  /** FileId of the master file. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileId\")\r\n  public fileId?: GuidString;\r\n\r\n  /** State of checkpoint generation. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.State\")\r\n  public state?: InitializationState;\r\n\r\n  /** Id of the last [[ChangeSet]] that was merged into this checkpoint file. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.MergedChangeSetId\")\r\n  public mergedChangeSetId?: string;\r\n\r\n  /** Date when this checkpoint file was created. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatedDate\")\r\n  public createdDate?: string;\r\n\r\n  /** URL that can be used to download the checkpoint file from iModelHub. See [[CheckpointQuery.selectDownloadUrl]]. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl\")\r\n  public downloadUrl?: string;\r\n}\r\n\r\n/**\r\n * Query object for getting [[Checkpoint]]s. You can use this to modify the [[CheckpointHandler.get]] results.\r\n * @alpha\r\n */\r\nexport class CheckpointQuery extends Query {\r\n  /** Query will return closest [[Checkpoint]] to target [[ChangeSet]], based on ChangeSets size.\r\n   * This query can return a Checkpoint that is ahead of the specified ChangeSet, if reversing ChangeSets would be faster than merging forward. This resets all previously set filters.\r\n   * @returns This query.\r\n   */\r\n  public nearestCheckpoint(targetChangeSetId: string): this {\r\n    this.filter(`NearestCheckpoint-backward-ChangeSet.Id+eq+'${targetChangeSetId}'`);\r\n    return this;\r\n  }\r\n\r\n  /** Query will return closest [[Checkpoint]] to target [[ChangeSet]] that does not exceed the specified ChangeSet.\r\n   * This query returns a closest Checkpoint that will reach target ChangeSet by only merging forward. This resets all previously set filters.\r\n   * @returns This query.\r\n   */\r\n  public precedingCheckpoint(targetChangeSetId: string): this {\r\n    this.filter(`PrecedingCheckpoint-backward-ChangeSet.Id+eq+'${targetChangeSetId}'`);\r\n    return this;\r\n  }\r\n\r\n  /** Query will return [[Checkpoint]] with specified [[ChangeSet]] id.\r\n   * @returns This query.\r\n   */\r\n  public byChangeSetId(changeSetId: string): this {\r\n    this.addFilter(`MergedChangeSetId+eq+'${changeSetId}'`, \"and\");\r\n    return this;\r\n  }\r\n\r\n  /** Query will additionally select [[Checkpoint]] file download URL. This is needed to use the Checkpoint object with [[CheckpointHandler.download]].\r\n   * @returns This query.\r\n   */\r\n  public selectDownloadUrl(): this {\r\n    addSelectFileAccessKey(this._query);\r\n    return this;\r\n  }\r\n}\r\n\r\n/**\r\n * Handler for managing [[Checkpoint]]s. Use [[IModelClient.checkpoints]] to get an instance of this class.\r\n * In most cases, you should use [IModelDb]($backend) methods instead.\r\n * @alpha\r\n */\r\nexport class CheckpointHandler {\r\n  private _handler: IModelBaseHandler;\r\n  private _fileHandler?: FileHandler;\r\n\r\n  /** Constructor for CheckpointHandler. Use [[IModelClient]] instead of directly constructing this.\r\n   * @param handler Handler for WSG requests.\r\n   * @param fileHandler Handler for file system.\r\n   * @alpha\r\n   */\r\n  constructor(handler: IModelBaseHandler, fileHandler?: FileHandler) {\r\n    this._handler = handler;\r\n    this._fileHandler = fileHandler;\r\n  }\r\n\r\n  /** Get relative url for Checkpoint requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @alpha\r\n   */\r\n  private getRelativeUrl(iModelId: GuidString) {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/Checkpoint/`;\r\n  }\r\n\r\n  /** Get the [[Checkpoint]]s.\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param query Optional query object to filter the queried Checkpoints or select different data from them.\r\n   * @returns Checkpoints that match the query.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: CheckpointQuery = new CheckpointQuery()): Promise<Checkpoint[]> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Querying checkpoints for iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    const checkpoints = await this._handler.getInstances<Checkpoint>(requestContext, Checkpoint, this.getRelativeUrl(iModelId), query.getQueryOptions());\r\n    requestContext.enter();\r\n\r\n    Logger.logTrace(loggerCategory, \"Queried checkpoints for iModel\", () => ({ iModelId, count: checkpoints.length }));\r\n    return checkpoints;\r\n  }\r\n\r\n  /** Download the specified checkpoint file. This only downloads the file and does not update the [[Checkpoint]] id. Use [IModelDb.open]($backend) instead if you want to get a usable checkpoint file.\r\n   * This method does not work on the browser. Directory containing the Checkpoint file is created if it does not exist. If there is an error during download, any partially downloaded file is deleted from disk.\r\n   * @param requestContext The client request context\r\n   * @param checkpoint Checkpoint to download. This needs to include a download link. See [[CheckpointQuery.selectDownloadUrl]].\r\n   * @param path Path where checkpoint file should be downloaded, including filename.\r\n   * @param progressCallback Callback for tracking progress.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.NotSupportedInBrowser]($bentley) if called in a browser.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.FileHandlerNotSet]($bentley) if [[FileHandler]] instance was not set for [[IModelClient]].\r\n   * @throws [[ResponseError]] if the checkpoint cannot be downloaded.\r\n   */\r\n  public async download(requestContext: AuthorizedClientRequestContext, checkpoint: Checkpoint, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void> {\r\n    requestContext.enter();\r\n    ArgumentCheck.defined(\"checkpoint\", checkpoint);\r\n    ArgumentCheck.defined(\"path\", path);\r\n\r\n    if (typeof window !== \"undefined\")\r\n      return Promise.reject(IModelHubClientError.browser());\r\n\r\n    if (!this._fileHandler)\r\n      return Promise.reject(IModelHubClientError.fileHandler());\r\n\r\n    if (!checkpoint.downloadUrl)\r\n      return Promise.reject(IModelHubClientError.missingDownloadUrl(\"checkpoint\"));\r\n\r\n    const perfLogger = new PerfLogger(\"Downloading checkpoint\", () => ({ ...checkpoint, path }));\r\n    await this._fileHandler.downloadFile(requestContext, checkpoint.downloadUrl, path, parseInt(checkpoint.fileSize!, 10), progressCallback);\r\n    requestContext.enter();\r\n    perfLogger.dispose();\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHub */\r\n\r\nimport { ClientRequestContext } from \"@bentley/bentleyjs-core\";\r\nimport { IModelClient } from \"../IModelClient\";\r\nimport { FileHandler } from \"../imodeljs-clients\";\r\nimport { AccessToken, AuthorizationToken } from \"../Token\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { ArgumentCheck } from \"./Errors\";\r\n\r\n/**\r\n * Class that allows access to different iModelHub class handlers. Handlers should be accessed through an instance of this class, rather than constructed directly.\r\n * @beta\r\n */\r\nexport class IModelHubClient extends IModelClient {\r\n  /**\r\n   * Create an instance of IModelHubClient.\r\n   * @param fileHandler File handler to handle file upload/download and file system operations.\r\n   * @param iModelBaseHandler WSG Client for iModel Hub operations.\r\n   */\r\n  public constructor(fileHandler?: FileHandler, iModelBaseHandler: IModelBaseHandler = new IModelBaseHandler()) {\r\n    super(iModelBaseHandler, fileHandler);\r\n  }\r\n\r\n  /**\r\n   * Get the (delegation) access token to access the service\r\n   * @param requestContext The client request context\r\n   * @param authorizationToken Authorization token.\r\n   * @returns Resolves to the (delegation) access token.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if authorizationToken is undefined.\r\n   * @throws [[ResponseError]] if request to delegation service failed.\r\n   * @throws Error if failed to parse response.\r\n   * @internal\r\n   */\r\n  public async getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken> {\r\n    ArgumentCheck.defined(\"authorizationToken\", authorizationToken);\r\n    return this._handler.getAccessToken(requestContext, authorizationToken);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { GuidString, Id64String, IModelHubStatus, Logger } from \"@bentley/bentleyjs-core\";\nimport * as deepAssign from \"deep-assign\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\nimport { ResponseError } from \"./../Request\";\nimport { WsgRequestOptions } from \"./../WsgClient\";\nimport { IModelBaseHandler } from \"./BaseHandler\";\nimport { AggregateResponseError, ArgumentCheck, IModelHubClientError, IModelHubError } from \"./Errors\";\nimport { Query } from \"./Query\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\n\n/**\n * [Code]($common) state describes whether the code is currently in use or owned by a [[Briefcase]].\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport enum CodeState {\n  /** Code with this state is not persisted in iModelHub. Code that is updated to 'Available' state is deleted from the iModelHub. */\n  Available = 0,\n  /** Code is reserved by the [[Briefcase]], no one else is allowed to change its state. */\n  Reserved = 1,\n  /** Code is used in a [[ChangeSet]] committed to the iModelHub. */\n  Used = 2,\n  /** Retired Code can not be reserved or used. It can only be deleted and then reserved again */\n  Retired = 3,\n}\n\n/** Base class for [Code]($common)s.\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport class CodeBase extends WsgInstance {\n  /** Code specification Id. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CodeSpecId\")\n  public codeSpecId?: Id64String;\n\n  /** Code scope. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CodeScope\")\n  public codeScope?: string;\n\n  /** Code state. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.State\")\n  public state?: CodeState;\n\n  /** Date the Code was created. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatedDate\")\n  public createdDate?: string;\n\n  /** Id of the Briefcase that owns the Code. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.BriefcaseId\")\n  public briefcaseId?: number;\n\n  /** If set to true in a request, it will only check whether code state can be modified, but will not actually change it. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.QueryOnly\")\n  public queryOnly?: boolean;\n}\n\n/**\n * Code instance. Codes ensure uniqueness of names in the file.\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.Code\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class HubCode extends CodeBase {\n  /** The unique string that can be used as a name value in iModel. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Value\")\n  public value?: string;\n}\n\n/**\n * MultiCode: Data about codes grouped by CodeSpecId, State and Briefcase\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.MultiCode\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class MultiCode extends CodeBase {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Values\")\n  public values?: string[];\n}\n\n/**\n * Encodes part of the code to be used in URI\n * @param str Part of the code.\n * @returns Encoded part of a code.\n */\nfunction encodeForCodeId(str: string): string {\n  return encodeURIComponent(str.replace(\"-\", \"_0x2D_\"))\n    .replace(\"~\", \"~7E\")\n    .replace(\"*\", \"~2A\")\n    .replace(\"%\", \"~\");\n}\n\n/**\n * Gets encoded instance id for a code to be used in an URI.\n * @param code Code to get instance id for.\n * @returns Encoded code instance id.\n */\nfunction getCodeInstanceId(code: HubCode): string | undefined {\n  if (!code || !code.codeSpecId || !code.codeScope || !code.value)\n    return undefined;\n\n  return `'${code.codeSpecId}-${encodeForCodeId(code.codeScope)}-${encodeForCodeId(code.value)}'`;\n}\n\n/**\n * Object for specifying options when sending [Code]($common) update requests. See [[CodeHandler.update]].\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport interface CodeUpdateOptions {\n  /** Return [Code]($common)s that could not be acquired. Conflicting Codes will be set to [[ConflictingCodesError.conflictingCodes]]. If unlimitedReporting is enabled and CodesPerRequest value is high, some conflicting Codes could be missed.  */\n  deniedCodes?: boolean;\n  /** Attempt to get all failed [Code]($common)s, ignoring iModelHub limits. Server responses might fail when trying to return large number of conflicting Codes. */\n  unlimitedReporting?: boolean;\n  /** Number of [Code]($common)s per single request. Multiple requests will be sent if there are more Codes. If an error happens on a subsequent request, previous successful updates will not be reverted. */\n  codesPerRequest?: number;\n  /** Don't fail request on a conflict. If conflict occurs, [Code]($common)s that didn't have conflicts will be updated and any remaining subsequent requests will still be sent. */\n  continueOnConflict?: boolean;\n}\n\n/**\n * Provider for default CodeUpdateOptions, used by CodeHandler to set defaults.\n * @internal\n */\nexport class DefaultCodeUpdateOptionsProvider {\n  protected _defaultOptions: CodeUpdateOptions;\n  /**  Creates an instance of DefaultRequestOptionsProvider and sets up the default options. */\n  constructor() {\n    this._defaultOptions = {\n      codesPerRequest: 2000,\n    };\n  }\n\n  /**\n   * Augments options with the provider's default values. The options passed in override any defaults where necessary.\n   * @param options Options that should be augmented.\n   */\n  public async assignOptions(options: CodeUpdateOptions): Promise<void> {\n    const clonedOptions: CodeUpdateOptions = Object.assign({}, options);\n    deepAssign(options, this._defaultOptions);\n    deepAssign(options, clonedOptions); // ensure the supplied options override the defaults\n    return Promise.resolve();\n  }\n}\n\n/**\n * Error for conflicting [Code]($common)s. It contains an array of Codes that failed to acquire. This is returned when calling [[CodeHandler.update]] with [[CodeUpdateOptions.deniedCodes]] set to true.\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport class ConflictingCodesError extends IModelHubError {\n  /** Codes that couldn't be updated due to other users owning them or setting them to [[CodeState.Retired]]. */\n  public conflictingCodes?: HubCode[];\n\n  /**\n   * Create ConflictingCodesError from IModelHubError instance.\n   * @param error IModelHubError to get error data from.\n   * @returns Undefined if the error is not for a code conflict, otherwise newly created error instance.\n   * @internal\n   */\n  public static fromError(error: IModelHubError): ConflictingCodesError | undefined {\n    if (error.errorNumber !== IModelHubStatus.CodeReservedByAnotherBriefcase &&\n      error.errorNumber !== IModelHubStatus.ConflictsAggregate) {\n      return undefined;\n    }\n    const result = new ConflictingCodesError(error.errorNumber!);\n    deepAssign(result, error);\n    result.addCodes(error);\n    return result;\n  }\n\n  /**\n   * Amend this error instance with conflicting codes from another IModelHubError.\n   * @param error Error to get additional conflicting codes from.\n   * @internal\n   */\n  public addCodes(error: IModelHubError) {\n    if (!error.data || !error.data.ConflictingCodes) {\n      return;\n    }\n    if (!this.conflictingCodes) {\n      this.conflictingCodes = [];\n    }\n    for (const value of (error.data.ConflictingCodes as any[])) {\n      const instance = { className: \"Code\", schemaName: \"iModelScope\", properties: value };\n      const code = ECJsonTypeMap.fromJson<HubCode>(HubCode, \"wsg\", instance);\n      if (code) {\n        this.conflictingCodes.push(code);\n      }\n    }\n  }\n}\n\n/**\n * Query object for getting [Code]($common)s. You can use this to modify the query. See [[CodeHandler.get]].\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport class CodeQuery extends Query {\n  private _isMultiCodeQuery = true;\n\n  /**\n   * Default page size which is used when querying Codes\n   * @internal\n   */\n  public static defaultPageSize: number = 10000;\n\n  /** Constructor that sets default page size. */\n  constructor() {\n    super();\n    this.pageSize(CodeQuery.defaultPageSize);\n  }\n\n  /**\n   * Used by the handler to check whether codes in query can be grouped.\n   * @internal\n   */\n  public get isMultiCodeQuery() {\n    return this._isMultiCodeQuery;\n  }\n\n  /**\n   * Query Codes by [[Briefcase]] id.\n   * @param briefcaseId Id of the Briefcase.\n   * @returns This query.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if briefcaseId is undefined or has an invalid [[Briefcase]] id value.\n   */\n  public byBriefcaseId(briefcaseId: number) {\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n    this.addFilter(`BriefcaseId+eq+${briefcaseId}`);\n    return this;\n  }\n\n  /**\n   * Query Codes by CodeSpec id.\n   * @param codeSpecId Id of the CodeSpec.\n   * @returns This query.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if codeSpecId is undefined or empty.\n   */\n  public byCodeSpecId(codeSpecId: Id64String) {\n    ArgumentCheck.defined(\"codeSpecId\", codeSpecId);\n    this.addFilter(`CodeSpecId+eq+'${codeSpecId}'`);\n    return this;\n  }\n\n  /**\n   * Query Codes by Code scope.\n   * @param codeScope Scope of the Code.\n   * @returns This query.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if codeScope is undefined or empty.\n   */\n  public byCodeScope(codeScope: string) {\n    ArgumentCheck.defined(\"codeScope\", codeScope);\n    this.addFilter(`CodeScope+eq+'${codeScope}'`);\n    return this;\n  }\n\n  /**\n   * Query [Code]($common)s by their instance ids.\n   * @param codes Codes to query. They must have their codeSpec, scope and value set.\n   * @returns This query.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if codes array is undefined, empty or it contains invalid [Code]($common) values.\n   */\n  public byCodes(codes: HubCode[]) {\n    ArgumentCheck.nonEmptyArray(\"codes\", codes);\n    this._isMultiCodeQuery = false;\n    if (codes.length < 1) {\n      throw IModelHubClientError.invalidArgument(\"codes\");\n    }\n\n    let filter = \"$id+in+[\";\n\n    let index = 0;\n    for (const code of codes) {\n      const id = getCodeInstanceId(code);\n      ArgumentCheck.valid(`codes[${index}]`, id);\n\n      if (0 !== index++)\n        filter += \",\";\n      filter += id;\n    }\n\n    filter += \"]\";\n\n    this.addFilter(filter);\n    return this;\n  }\n\n  /**\n   * Query unavailable [Code]($common)s. It will include all Codes owned by other [[Briefcase]]s.\n   * @param briefcaseId Id of the Briefcase.\n   * @returns This query.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if briefcaseId is undefined or has an invalid [[Briefcase]] id value.\n   */\n  public unavailableCodes(briefcaseId: number) {\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n    const filter = `BriefcaseId+ne+${briefcaseId}`;\n    this.addFilter(filter);\n    return this;\n  }\n}\n\n/** Type of [[CodeSequence]] results.\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport enum CodeSequenceType {\n  /** Return largest already used value. */\n  LargestUsed = 0,\n  /** Return next available value in the sequence. */\n  NextAvailable = 1,\n}\n\n/** Sequence of [Code]($common)s matching a pattern. This class allows getting next available index based [Code]($common)\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.CodeSequence\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class CodeSequence extends WsgInstance {\n  /** Code specification Id (hexadecimal (\"0XA\") or decimal (\"10\") string)). */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CodeSpecId\")\n  public codeSpecId?: Id64String;\n\n  /** Code scope. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CodeScope\")\n  public codeScope?: string;\n\n  /** Pattern describing the sequence. # characters will be replaced with the index. Only a single group of # characters is allowed in the pattern. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ValuePattern\")\n  public valuePattern?: string;\n\n  /** Suggested index value returned from the query. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Value\")\n  public value?: string;\n\n  /** Starting index of the sequence. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.StartIndex\")\n  public startIndex?: number;\n\n  /** Index difference between two consecutive members in this sequence. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IncrementBy\")\n  public incrementBy?: number;\n\n  /** Type of the sequence results. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Type\")\n  public type?: CodeSequenceType;\n}\n\n/**\n * Handler for querying [[CodeSequence]]s. Use [[CodeHandler.Sequences]] to get an instance of this class.\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport class CodeSequenceHandler {\n  private _handler: IModelBaseHandler;\n\n  /**\n   * Constructor for CodeHandler.\n   * @param handler Handler for WSG requests.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler) {\n    this._handler = handler;\n  }\n\n  /** Get relative url for Code sequence requests.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   */\n  private getRelativeUrl(iModelId: GuidString) {\n    return `/Repositories/iModel--${iModelId}/iModelScope/CodeSequence/`;\n  }\n\n  /** Get an index value based on the [[CodeSequence]]. This only suggests the last used or next available index value in the sequence and does not reserve the Code.\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param sequence Code sequence describing the format of the Code value.\n   * @returns Resolves to the suggested index value.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, sequence: CodeSequence): Promise<string> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Querying code sequence for iModel\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    const result = await this._handler.postInstance<CodeSequence>(requestContext, CodeSequence, this.getRelativeUrl(iModelId), sequence);\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Queried code sequence for iModel\", () => ({ iModelId }));\n\n    return result.value!;\n  }\n}\n\n/**\n * Handler for managing [Code]($common)s. Use [[IModelClient.Codes]] to get an instance of this class. In most cases, you should use [ConcurrencyControl]($backend) methods instead. You can read more about concurrency control [here]($docs/learning/backend/concurrencycontrol).\n * @alpha Hide Code API while focused on readonly viewing scenarios\n */\nexport class CodeHandler {\n  private _handler: IModelBaseHandler;\n  private static _defaultUpdateOptionsProvider: DefaultCodeUpdateOptionsProvider;\n\n  /**\n   * Constructor for CodeHandler.\n   * @param handler Handler for WSG requests.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler) {\n    this._handler = handler;\n  }\n\n  /** Get handler for querying [[CodeSequence]]s. */\n  public get sequences(): CodeSequenceHandler {\n    return new CodeSequenceHandler(this._handler);\n  }\n\n  /** Get relative url for Code requests.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param codeId Id of the code.\n   */\n  private getRelativeUrl(iModelId: GuidString, multiCode = true, codeId?: string) {\n    return `/Repositories/iModel--${iModelId}/iModelScope/${multiCode ? \"MultiCode\" : \"Code\"}/${codeId || \"\"}`;\n  }\n\n  /** Convert Codes to MultiCodes. */\n  private static convertCodesToMultiCodes(codes: HubCode[]): MultiCode[] {\n    const map = new Map<string, MultiCode>();\n    for (const code of codes) {\n      const id: string = `${code.codeScope}-${code.codeSpecId}-${code.state}`;\n\n      if (map.has(id)) {\n        map.get(id)!.values!.push(code.value!);\n      } else {\n        const multiCode = new MultiCode();\n        multiCode.changeState = \"new\";\n        multiCode.briefcaseId = code.briefcaseId;\n        multiCode.codeScope = code.codeScope;\n        multiCode.codeSpecId = code.codeSpecId;\n        multiCode.state = code.state;\n        multiCode.values = [code.value!];\n        map.set(id, multiCode);\n      }\n    }\n    return Array.from(map.values());\n  }\n\n  /** Convert MultiCodes to Codes. */\n  private static convertMultiCodesToCodes(multiCodes: MultiCode[]): HubCode[] {\n    const result: HubCode[] = [];\n\n    for (const multiCode of multiCodes) {\n      for (const value of multiCode.values!) {\n        const code = new HubCode();\n        code.briefcaseId = multiCode.briefcaseId;\n        code.codeScope = multiCode.codeScope;\n        code.codeSpecId = multiCode.codeSpecId;\n        code.state = multiCode.state;\n        code.value = value;\n        result.push(code);\n      }\n    }\n\n    return result;\n  }\n\n  /**\n   * Augment update options with defaults returned by the DefaultCodeUpdateOptionsProvider. The options passed in by clients override any defaults where necessary.\n   * @param options Options the caller wants to augment with the defaults.\n   * @returns Promise resolves after the defaults are setup.\n   */\n  private async setupOptionDefaults(options: CodeUpdateOptions): Promise<void> {\n    if (!CodeHandler._defaultUpdateOptionsProvider)\n      CodeHandler._defaultUpdateOptionsProvider = new DefaultCodeUpdateOptionsProvider();\n    return CodeHandler._defaultUpdateOptionsProvider.assignOptions(options);\n  }\n\n  /** Send partial request for code updates */\n  private async updateInternal(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, codes: HubCode[], updateOptions?: CodeUpdateOptions): Promise<HubCode[]> {\n    requestContext.enter();\n    let requestOptions: WsgRequestOptions | undefined;\n    if (updateOptions) {\n      requestOptions = {};\n      requestOptions.CustomOptions = {};\n      if (updateOptions.deniedCodes === false) {\n        requestOptions.CustomOptions.DetailedError_Codes = \"false\";\n      }\n      if (updateOptions.unlimitedReporting) {\n        requestOptions.CustomOptions.DetailedError_MaximumInstances = \"-1\";\n      }\n      if (updateOptions.continueOnConflict) {\n        requestOptions.CustomOptions.ConflictStrategy = \"Continue\";\n      }\n      if (Object.getOwnPropertyNames(requestOptions.CustomOptions).length === 0)\n        requestOptions = undefined;\n    }\n\n    const result = await this._handler.postInstances<MultiCode>(requestContext, MultiCode, `/Repositories/iModel--${iModelId}/$changeset`, CodeHandler.convertCodesToMultiCodes(codes), requestOptions);\n    return CodeHandler.convertMultiCodesToCodes(result);\n  }\n\n  /**\n   * Update multiple [Code]($common)s. This call can simultaneously reserve new Codes and update states of already owned Codes. If large amount of Codes are updated, they are split across multiple requests. See [[CodeUpdateOptions.codesPerRequest]]. Default is 2000 Codes per request.\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param codes Codes to update. Requires briefcaseId, state, codeSpecId, codeScope and value to be set on every instance. briefcaseId must be the same for every Code. Set queryOnly to true to just check if a Code can be reserved.\n   * @param updateOptions Options for the update request. You can set this to change how conflicts are handled or to handle different amount of Codes per request.\n   * @returns The code that was just obtained from the server.\n   * @throws [[ConflictingCodesError]] when [[CodeUpdateOptions.deniedCodes]] is set and conflicts occured. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) for more information.\n   * @throws [[AggregateResponseError]] when multiple requests where sent and more than 1 of the following errors occured.\n   * @throws [[IModelHubError]] with status indicating a conflict. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) section for more information.\n   * @throws [[IModelHubError]] with [IModelHubStatus.InvalidBriefcase]($bentley) when including Codes with different briefcaseId values in the request.\n   * @throws [[IModelHubError]] with [IModelHubStatus.OperationFailed]($bentley) when including multiple identical Codes in the request.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, codes: HubCode[], updateOptions?: CodeUpdateOptions): Promise<HubCode[]> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Requesting codes for iModel\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n    ArgumentCheck.nonEmptyArray(\"codes\", codes);\n\n    updateOptions = updateOptions || {};\n    await this.setupOptionDefaults(updateOptions);\n\n    const result: HubCode[] = [];\n    let conflictError: ConflictingCodesError | undefined;\n    const aggregateError = new AggregateResponseError();\n\n    for (let i = 0; i < codes.length; i += updateOptions.codesPerRequest!) {\n      const chunk = codes.slice(i, i + updateOptions.codesPerRequest!);\n      try {\n        result.push(...await this.updateInternal(requestContext, iModelId, chunk, updateOptions));\n        requestContext.enter();\n      } catch (error) {\n        requestContext.enter();\n        if (error instanceof ResponseError) {\n          if (updateOptions && updateOptions.deniedCodes && error instanceof IModelHubError && (\n            error.errorNumber === IModelHubStatus.CodeReservedByAnotherBriefcase ||\n            error.errorNumber === IModelHubStatus.ConflictsAggregate)) {\n            if (conflictError) {\n              conflictError.addCodes(error);\n            } else {\n              conflictError = ConflictingCodesError.fromError(error);\n            }\n            if (!updateOptions.continueOnConflict) {\n              return Promise.reject(conflictError);\n            }\n          } else {\n            aggregateError.errors.push(error);\n          }\n        }\n      }\n    }\n\n    if (conflictError) {\n      return Promise.reject(conflictError);\n    }\n\n    if (aggregateError.errors.length > 0) {\n      return Promise.reject(aggregateError.errors.length > 1 ? aggregateError : aggregateError.errors[0]);\n    }\n\n    Logger.logTrace(loggerCategory, `Requested ${codes.length} codes for iModel`, () => ({ iModelId }));\n    return result;\n  }\n\n  /**\n   * Get the [Code]($common)s that have been issued for the iModel.\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param query Optional query object to filter the queried Codes or select different data from them.\n   * @returns Resolves to an array of Codes matching the query.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: CodeQuery = new CodeQuery()): Promise<HubCode[]> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Querying codes for iModel\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    let codes: HubCode[];\n    if (query.isMultiCodeQuery) {\n      const multiCodes = await this._handler.getInstances<MultiCode>(requestContext, MultiCode, this.getRelativeUrl(iModelId), query.getQueryOptions());\n      requestContext.enter();\n      codes = CodeHandler.convertMultiCodesToCodes(multiCodes);\n    } else {\n      codes = await this._handler.postQuery<HubCode>(requestContext, HubCode, this.getRelativeUrl(iModelId, false), query.getQueryOptions());\n      requestContext.enter();\n    }\n\n    Logger.logTrace(loggerCategory, `Queried ${codes.length} codes for iModel`, () => ({ iModelId }));\n    return codes;\n  }\n\n  /** Delete all [Code]($common)s owned by the specified [[Briefcase]].\n   * @param requestContext The client request context\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param briefcaseId Id of the Briefcacase.\n   * @throws [[IModelHubError]] with [IModelHubStatus.BriefcaseDoesNotExist]($bentley) if [[Briefcase]] with specified briefcaseId does not exist. This can happen if number was not given as a Briefcase id yet, or Briefcase with that id was already deleted.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if [[Briefcase]] belongs to another user and user sending the request does not have ManageResources permission.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async deleteAll(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, briefcaseId: number): Promise<void> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Deleting all codes from briefcase\", () => ({ briefcaseId, iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n\n    await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, false, `DiscardReservedCodes-${briefcaseId}`));\n\n    Logger.logTrace(loggerCategory, \"Deleted all codes from briefcase\", () => ({ briefcaseId, iModelId }));\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\n/**\n * Class that provides custom request options for all future requests\n * @internal\n */\nexport class CustomRequestOptions {\n  private _customOptions?: { [index: string]: string };\n\n  public setCustomOptions(customOptions?: { [index: string]: string }): void {\n    this._customOptions = customOptions;\n  }\n\n  public insertCustomOptions(customOptions: any): { [index: string]: string } {\n    if (!this._customOptions) {\n      return customOptions;\n    }\n    if (!customOptions) {\n      customOptions = {};\n    }\n    customOptions = { ...customOptions, ...this._customOptions };\n    return customOptions;\n  }\n\n  public get isSet(): boolean {\n    return null != this._customOptions;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { GetMetaDataFunction, Guid, HttpStatus, IModelHubStatus, LogFunction, Logger, WSStatus } from \"@bentley/bentleyjs-core\";\nimport * as deepAssign from \"deep-assign\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { ResponseError } from \"./../Request\";\nimport { WsgError } from \"./../WsgClient\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\n\n/**\n * Error returned from iModelHub service.\n * @beta\n */\nexport class IModelHubError extends WsgError {\n  /** Extended data of the error. */\n  public data: any;\n  private static _idPrefix: string = \"iModelHub.\";\n\n  /** @internal */\n  public constructor(errorNumber: number | HttpStatus, message?: string, getMetaData?: GetMetaDataFunction) {\n    super(errorNumber, message, getMetaData);\n  }\n\n  /**\n   * Get IModelHubStatus from the string value returned by the service.\n   * @param error Error id returned by the service.\n   * @returns IModelHubStatus id\n   */\n  private static getErrorId(error: string): IModelHubStatus {\n    const id = IModelHubStatus[error.slice(IModelHubError._idPrefix.length) as keyof typeof IModelHubStatus];\n\n    return id ? id : IModelHubStatus.Unknown;\n  }\n\n  /**\n   * Check whether error could have extended data.\n   * @param id Id of the error.\n   * @returns True if service can return extended data for this error id.\n   */\n  private static requiresExtendedData(id: IModelHubStatus): boolean {\n    switch (id) {\n      case IModelHubStatus.LockOwnedByAnotherBriefcase:\n      case IModelHubStatus.iModelAlreadyExists:\n      case IModelHubStatus.FileAlreadyExists:\n      case IModelHubStatus.PullIsRequired:\n      case IModelHubStatus.CodeStateInvalid:\n      case IModelHubStatus.CodeReservedByAnotherBriefcase:\n      case IModelHubStatus.ConflictsAggregate:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Make extended data available publically.\n   */\n  private copyExtendedData(): void {\n    this.data = this._data;\n  }\n\n  /**\n   * Create IModelHubError from id.\n   * @param id Id of the error.\n   * @param message Message for the error.\n   * @returns Created error.\n   * @internal\n   */\n  public static fromId(id: IModelHubStatus, message: string): IModelHubError {\n    const error = new IModelHubError(id);\n    error.name = IModelHubStatus[id];\n    error.message = message;\n    return error;\n  }\n\n  /**\n   * Attempt to parse IModelHubError from server response.\n   * @param response Response from the server.\n   * @returns Parsed error.\n   * @internal\n   */\n  public static parse(response: any, log = true): ResponseError {\n    const wsgError = super.parse(response, false);\n    if (wsgError instanceof WsgError && wsgError.name && wsgError.name.startsWith(IModelHubError._idPrefix)) {\n      const errorId = IModelHubError.getErrorId(wsgError.name);\n      const error = new IModelHubError(errorId);\n\n      deepAssign(error, wsgError);\n      error.errorNumber = errorId;\n\n      if (IModelHubError.requiresExtendedData(error.errorNumber!)) {\n        error.copyExtendedData();\n      }\n      if (log)\n        error.log();\n      return error;\n    }\n    if (log)\n      wsgError.log();\n    return wsgError;\n  }\n\n  /**\n   * Decides whether request should be retried or not.\n   * @param error Error returned by request\n   * @param response Response returned by request\n   * @internal\n   */\n  public static shouldRetry(error: any, response: any): boolean {\n    if (response === undefined || response === null) {\n      return super.shouldRetry(error, response);\n    }\n\n    if (super.parseHttpStatus(response.statusType) === HttpStatus.Success) {\n      return false;\n    }\n    const parsedError = IModelHubError.parse({ response }, false);\n\n    if (!(parsedError instanceof WsgError)) {\n      return super.shouldRetry(error, response);\n    }\n\n    if ((parsedError instanceof IModelHubError)) {\n      return false;\n    }\n\n    const errorCodesToRetry: number[] = [HttpStatus.ServerError,\n    WSStatus.Unknown];\n\n    const errorStatus = super.getErrorStatus(parsedError.name !== undefined ?\n      super.getWSStatusId(parsedError.name) : WSStatus.Unknown, response.statusType);\n    return errorCodesToRetry.includes(errorStatus);\n  }\n\n  /**\n   * Get log function.\n   * @internal\n   */\n  public getLogLevel(): LogFunction {\n    switch (this.errorNumber) {\n      case IModelHubStatus.AnotherUserPushing:\n      case IModelHubStatus.PullIsRequired:\n      case IModelHubStatus.LockOwnedByAnotherBriefcase:\n      case IModelHubStatus.CodeReservedByAnotherBriefcase:\n        return Logger.logWarning;\n\n      default:\n        return Logger.logError;\n    }\n  }\n\n  /**\n   * Logs this error.\n   * @internal\n   */\n  public log(): void {\n    (this.getLogLevel())(loggerCategory, this.logMessage(), this.getMetaData());\n  }\n}\n\n/**\n * Errors for incorrect iModelHub requests.\n * @beta\n */\nexport class IModelHubClientError extends IModelHubError {\n  /** Creates IModelHubClientError from id.\n   * @param id Id of the error.\n   * @param message Message for the error.\n   * @returns Created error.\n   * @internal\n   */\n  public static fromId(id: IModelHubStatus, message: string): IModelHubClientError {\n    const error = new IModelHubClientError(id, message);\n    error.log();\n    return error;\n  }\n\n  /** Create error for undefined arguments being passed.\n   * @param argumentName Undefined argument name\n   * @returns Created error.\n   * @internal\n   */\n  public static undefinedArgument(argumentName: string): IModelHubClientError {\n    return this.fromId(IModelHubStatus.UndefinedArgumentError, `Argument ${argumentName} is null or undefined`);\n  }\n\n  /** Create error for invalid arguments being passed.\n   * @param argumentName Invalid argument name\n   * @returns Created error.\n   * @internal\n   */\n  public static invalidArgument(argumentName: string): IModelHubClientError {\n    return this.fromId(IModelHubStatus.InvalidArgumentError, `Argument ${argumentName} has an invalid value.`);\n  }\n\n  /** Create error for arguments being passed that are missing download URL.\n   * @param argumentName Argument name\n   * @returns Created error.\n   * @internal\n   */\n  public static missingDownloadUrl(argumentName: string): IModelHubClientError {\n    return this.fromId(IModelHubStatus.MissingDownloadUrlError,\n      `Supplied ${argumentName} must include download URL. Use selectDownloadUrl() when getting ${argumentName}.`);\n  }\n\n  /** Create error for seed file initialization timing out.\n   * @returns Created error.\n   * @internal\n   */\n  public static initializationTimeout(): IModelHubClientError {\n    return this.fromId(IModelHubStatus.InitializationTimeout, `Timed out waiting for Seed File initialization.`);\n  }\n\n  /** Create error for incompatible operation being used in browser.\n   * @returns Created error.\n   * @internal\n   */\n  public static browser(): IModelHubClientError {\n    return this.fromId(IModelHubStatus.NotSupportedInBrowser, \"Operation is not supported in browser.\");\n  }\n\n  /** Create error for incompatible operation being used in browser.\n   * @returns Created error.\n   * @internal\n   */\n  public static fileHandler(): IModelHubClientError {\n    return this.fromId(IModelHubStatus.FileHandlerNotSet, \"File handler is required to be set for file download / upload.\");\n  }\n\n  /** Create error for a missing file.\n   * @returns Created error.\n   * @internal\n   */\n  public static fileNotFound(): IModelHubClientError {\n    return this.fromId(IModelHubStatus.FileNotFound, \"Could not find the file to upload.\");\n  }\n}\n\n/** @internal */\nexport class ArgumentCheck {\n  public static defined(argumentName: string, argument?: any) {\n    if (!argument)\n      throw IModelHubClientError.undefinedArgument(argumentName);\n  }\n\n  public static definedNumber(argumentName: string, argument?: number) {\n    if (typeof argument !== \"number\")\n      throw IModelHubClientError.undefinedArgument(argumentName);\n  }\n\n  public static valid(argumentName: string, argument?: any) {\n    if (!argument)\n      throw IModelHubClientError.invalidArgument(argumentName);\n  }\n\n  public static validGuid(argumentName: string, argument?: string) {\n    this.defined(argumentName, argument);\n    if (!Guid.isGuid(argument!))\n      throw IModelHubClientError.invalidArgument(argumentName);\n  }\n\n  public static nonEmptyArray(argumentName: string, argument?: any[]) {\n    this.defined(argumentName, argument);\n    if (argument!.length < 1)\n      throw IModelHubClientError.invalidArgument(argumentName);\n  }\n\n  /** Check if Briefcase Id is valid. */\n  private static isBriefcaseIdValid(briefcaseId: number): boolean {\n    return briefcaseId > 1 && briefcaseId < 16 * 1024 * 1024;\n  }\n\n  /** Check if Briefcase Id argument is valid. */\n  public static validBriefcaseId(argumentName: string, argument?: number) {\n    this.definedNumber(argumentName, argument);\n    if (!this.isBriefcaseIdValid(argument!))\n      throw IModelHubClientError.invalidArgument(argumentName);\n  }\n\n  private static isValidChangeSetId(changeSetId: string) {\n    const pattern = new RegExp(\"^[0-9A-Fa-f]+$\");\n    return changeSetId.length === 40 && pattern.test(changeSetId);\n  }\n\n  public static validChangeSetId(argumentName: string, argument?: string) {\n    this.defined(argumentName, argument);\n    if (!this.isValidChangeSetId(argument!))\n      throw IModelHubClientError.invalidArgument(argumentName);\n  }\n}\n\n/** Class for aggregating errors from multiple requests. Only thrown when more than 1 error has occurred.\n * @internal\n */\nexport class AggregateResponseError extends Error {\n  /** Errors that happened over multiple requests. */\n  public errors: ResponseError[] = [];\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHubEvents */\r\nimport { ClientRequestContext, GuidString, Id64, Id64String, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { AccessToken } from \"../Token\";\r\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\r\nimport { request, Response } from \"./../Request\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { CodeState } from \"./Codes\";\r\nimport { ArgumentCheck } from \"./Errors\";\r\nimport { BaseEventSAS, EventBaseHandler, EventListener, GetEventOperationToRequestType, IModelHubBaseEvent, ListenerSubscription } from \"./EventsBase\";\r\nimport { LockLevel, LockType } from \"./Locks\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\r\n\r\n/** Type of [[IModelHubEvent]]. Event type is used to define which events you wish to receive from your [[EventSubscription]]. See [[EventSubscriptionHandler.create]] and [[EventSubscriptionHandler.update]].\r\n * @beta\r\n */\r\nexport type EventType =\r\n  /** Sent when one or more [[Lock]]s are updated. See [[LockEvent]].\r\n   * @alpha Hide Lock API while focused on readonly viewing scenarios\r\n   */\r\n  \"LockEvent\" |\r\n  /** Sent when all [[Lock]]s for a [[Briefcase]] are deleted. See [[AllLocksDeletedEvent]].\r\n   * @alpha Hide Lock API while focused on readonly viewing scenarios\r\n   */\r\n  \"AllLocksDeletedEvent\" |\r\n  /** Sent when a [[ChangeSet]] is successfully pushed. See [[ChangeSetPostPushEvent]]. */\r\n  \"ChangeSetPostPushEvent\" |\r\n  /** Sent when a [[ChangeSet]] push has started. See [[ChangeSetPrePushEvent]]. */\r\n  \"ChangeSetPrePushEvent\" |\r\n  /** Sent when one or more [Code]($common)s are updated. See [[CodeEvent]].\r\n   * @alpha Hide Code API while focused on readonly viewing scenarios\r\n   */\r\n  \"CodeEvent\" |\r\n  /** Sent when all [Code]($common)s for a [[Briefcase]] are deleted. See [[AllCodesDeletedEvent]].\r\n   * @alpha Hide Code API while focused on readonly viewing scenarios\r\n   */\r\n  \"AllCodesDeletedEvent\" |\r\n  /** Sent when a [[Briefcase]] is deleted. See [[BriefcaseDeletedEvent]].\r\n   * @internal\r\n   */\r\n  \"BriefcaseDeletedEvent\" |\r\n  /** Sent when an iModel is deleted. See [[iModelDeletedEvent]]. */\r\n  \"iModelDeletedEvent\" |\r\n  /** Sent when a new named [[Version]] is created. See [[VersionEvent]]. */\r\n  \"VersionEvent\";\r\n\r\n/** Base type for all iModelHub events.\r\n * @beta\r\n */\r\nexport abstract class IModelHubEvent extends IModelHubBaseEvent {\r\n  /** Id of the iModel where the event occured. */\r\n  public iModelId?: GuidString;\r\n\r\n  /** Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    super.fromJson(obj);\r\n    this.iModelId = this.eventTopic;\r\n  }\r\n}\r\n\r\n/** Base type for iModelHub events that have BriefcaseId.\r\n * @beta\r\n */\r\nexport abstract class BriefcaseEvent extends IModelHubEvent {\r\n  /** Id of the [[Briefcase]] involved in this event. */\r\n  public briefcaseId?: number;\r\n\r\n  /** Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    super.fromJson(obj);\r\n    this.briefcaseId = obj.BriefcaseId;\r\n  }\r\n}\r\n\r\n/** Sent when one or more [[Lock]]s are updated. Lock updates can be very frequent, so it's recommended to not to subscribe to LockEvents, if it's not necessary.\r\n * @alpha Hide Lock API while focused on readonly viewing scenarios\r\n */\r\nexport class LockEvent extends BriefcaseEvent {\r\n  /** [[LockType]] of the updated Locks. */\r\n  public lockType?: LockType;\r\n  /** [[LockLevel]] of the updated Locks. */\r\n  public lockLevel?: LockLevel;\r\n  /** Id's of the updated Locks. */\r\n  public objectIds?: Id64String[];\r\n  /** Id of the [[ChangeSet]] Locks were released with. */\r\n  public releasedWithChangeSet?: string;\r\n\r\n  /** Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    super.fromJson(obj);\r\n    this.lockType = parseInt(obj.LockType, 10) as LockType;\r\n    this.lockLevel = parseInt(obj.LockLevel, 10) as LockLevel;\r\n    this.objectIds = (obj.ObjectIds as string[]).map((value: string) => Id64.fromJSON(value));\r\n    this.releasedWithChangeSet = obj.ReleasedWithChangeSet;\r\n  }\r\n}\r\n\r\n/** Sent when all [[Lock]]s for a [[Briefcase]] are deleted. Can occur when calling [[LockHandler.deleteAll]] or [[BriefcaseHandler.delete]].\r\n * @alpha Hide Lock API while focused on readonly viewing scenarios\r\n */\r\nexport class AllLocksDeletedEvent extends BriefcaseEvent {\r\n}\r\n\r\n/** Sent when a [[ChangeSet]] is successfully pushed. See [[ChangeSetHandler.create]]. It's sent when a new [[ChangeSet]] is successfully pushed to an iModel. See [[ChangeSetPrePushEvent]] for the event indicating the start of a ChangeSet push.\r\n * @beta\r\n */\r\nexport class ChangeSetPostPushEvent extends BriefcaseEvent {\r\n  /** Id of the ChangeSet that was pushed. */\r\n  public changeSetId?: string;\r\n  /** Index of the ChangeSet that was pushed. */\r\n  public changeSetIndex?: string;\r\n\r\n  /** Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    super.fromJson(obj);\r\n    this.changeSetId = obj.ChangeSetId;\r\n    this.changeSetIndex = obj.ChangeSetIndex;\r\n  }\r\n}\r\n\r\n/** Sent when a [[ChangeSet]] push has started. See [[ChangeSetHandler.create]]. ChangeSetPrePushEvent indicates that iModelHub allowed one of the [[Briefcase]]s to push a ChangeSet and all other push attempts will fail, until this push times out or succeeds. See [[ChangeSetPostPushEvent]] for an event indicating a successful push.\r\n * @beta\r\n */\r\nexport class ChangeSetPrePushEvent extends IModelHubEvent {\r\n}\r\n\r\n/** Sent when one or more [Code]($common)s are updated. See [[CodeHandler.update]]. Code updates can be very frequent, so it's recommended to not to subscribe to CodeEvents, if it's not necessary.\r\n * @alpha Hide Code API while focused on readonly viewing scenarios\r\n */\r\nexport class CodeEvent extends BriefcaseEvent {\r\n  /** Id of the [CodeSpec]($common) for the updated Codes. */\r\n  public codeSpecId?: Id64String;\r\n  /** Scope of the updated Codes. */\r\n  public codeScope?: string;\r\n  /** Array of the updated Code values. */\r\n  public values?: string[];\r\n  /** State Codes were updated to. */\r\n  public state?: CodeState = CodeState.Reserved;\r\n\r\n  /** Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    super.fromJson(obj);\r\n    this.codeSpecId = Id64.fromJSON(obj.CodeSpecId);\r\n    this.codeScope = obj.CodeScope;\r\n    this.values = obj.Values;\r\n    this.state = obj.State;\r\n  }\r\n}\r\n\r\n/** Sent when all [Code]($common)s for a [[Briefcase]] are deleted. Can occur when calling [[CodeHandler.deleteAll]] or [[BriefcaseHandler.delete]].\r\n * @alpha Hide Code API while focused on readonly viewing scenarios\r\n */\r\nexport class AllCodesDeletedEvent extends BriefcaseEvent {\r\n}\r\n\r\n/** Sent when a [[Briefcase]] is deleted. See [[BriefcaseHandler.delete]].\r\n * @internal\r\n */\r\nexport class BriefcaseDeletedEvent extends BriefcaseEvent {\r\n}\r\n\r\n/** Sent when an iModel is deleted. See [[IModelHandler.delete]]. [[EventSubscription]] will be deleted 5 minutes after iModel is deleted, removing all events from subscription queues, making it possible for this event to be missed if not retrieved immediately.\r\n * @beta\r\n */\r\nexport class IModelDeletedEvent extends IModelHubEvent {\r\n}\r\n\r\n/** Sent when a new named [[Version]] is created. See [[VersionHandler.create]].\r\n * @beta\r\n */\r\nexport class VersionEvent extends IModelHubEvent {\r\n  /** Id of the created Version. */\r\n  public versionId?: GuidString;\r\n  /** Name of the created Version. */\r\n  public versionName?: string;\r\n  /** Id of the [[ChangeSet]] that this Version was created for.  */\r\n  public changeSetId?: string;\r\n\r\n  /** Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    super.fromJson(obj);\r\n    this.versionId = obj.VersionId;\r\n    this.versionName = obj.VersionName;\r\n    this.changeSetId = obj.ChangeSetId;\r\n  }\r\n}\r\n\r\ntype EventConstructor = (new () => IModelHubEvent);\r\n/** Get constructor from EventType name. */\r\nfunction ConstructorFromEventType(type: EventType): EventConstructor {\r\n  switch (type) {\r\n    case \"LockEvent\":\r\n      return LockEvent;\r\n    case \"AllLocksDeletedEvent\":\r\n      return AllLocksDeletedEvent;\r\n    case \"ChangeSetPostPushEvent\":\r\n      return ChangeSetPostPushEvent;\r\n    case \"ChangeSetPrePushEvent\":\r\n      return ChangeSetPrePushEvent;\r\n    case \"CodeEvent\":\r\n      return CodeEvent;\r\n    case \"AllCodesDeletedEvent\":\r\n      return AllCodesDeletedEvent;\r\n    case \"BriefcaseDeletedEvent\":\r\n      return BriefcaseDeletedEvent;\r\n    case \"iModelDeletedEvent\":\r\n      return IModelDeletedEvent;\r\n    case \"VersionEvent\":\r\n      return VersionEvent;\r\n  }\r\n}\r\n\r\n/** Parse [[IModelHubEvent]] from response object.\r\n * @param response Response object to parse.\r\n * @returns Appropriate event object.\r\n * @internal\r\n */\r\nexport function ParseEvent(response: Response) {\r\n  const constructor: EventConstructor = ConstructorFromEventType(response.header[\"content-type\"]);\r\n  const event = new constructor();\r\n  event.fromJson(response.body);\r\n  return event;\r\n}\r\n\r\n/** Subscription to receive [[IModelHubEvent]]s. Each subscription has a separate queue for events that it hasn't read yet. Subscriptions are deleted, if they are inactive for an hour. Use wsgId of this instance for the methods that require subscriptionId. See [[EventSubscriptionHandler]].\r\n * @beta\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.EventSubscription\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class EventSubscription extends WsgInstance {\r\n  /** Types of the [[IModelHubEvent]]s that this subscription listens to. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.EventTypes\")\r\n  public eventTypes?: EventType[];\r\n}\r\n\r\n/** Shared access signature token for getting [[IModelHubEvent]]s. It's used to authenticate for [[EventHandler.getEvent]]. To receive an instance call [[EventHandler.getSASToken]].\r\n * @beta\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.EventSAS\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class EventSAS extends BaseEventSAS {\r\n}\r\n\r\n/** Handler for managing [[EventSubscription]]s. Use [[EventHandler.Subscriptions]] to get an instance of this class.\r\n * @beta\r\n */\r\nexport class EventSubscriptionHandler {\r\n  private _handler: IModelBaseHandler;\r\n\r\n  /** Constructor for EventSubscriptionHandler.\r\n   * @param handler Handler for WSG requests.\r\n   */\r\n  constructor(handler: IModelBaseHandler) {\r\n    this._handler = handler;\r\n  }\r\n\r\n  /** Get relative url for EventSubscription requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param instanceId Id of the subscription.\r\n   */\r\n  private getRelativeUrl(iModelId: GuidString, instanceId?: string) {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/EventSubscription/${instanceId || \"\"}`;\r\n  }\r\n\r\n  /** Create an [[EventSubscription]].\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param events Array of EventTypes to subscribe to.\r\n   * @return Created EventSubscription instance.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, events: EventType[]) {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Creating event subscription on iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n    ArgumentCheck.nonEmptyArray(\"events\", events);\r\n\r\n    let subscription = new EventSubscription();\r\n    subscription.eventTypes = events;\r\n\r\n    subscription = await this._handler.postInstance<EventSubscription>(requestContext, EventSubscription, this.getRelativeUrl(iModelId), subscription);\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Created event subscription on iModel\", () => ({ iModelId }));\r\n    return subscription;\r\n  }\r\n\r\n  /** Update an [[EventSubscription]]. Can change the [[EventType]]s specified in the subscription. Must be a valid subscription that was previously created with [[EventSubscriptionHandler.create]] that hasn't expired.\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param subscription Updated EventSubscription.\r\n   * @return EventSubscription instance from iModelHub after update.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if [[EventSubscription]] does not exist with the specified subscription.wsgId.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, subscription: EventSubscription): Promise<EventSubscription> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Updating event subscription on iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n    ArgumentCheck.defined(\"subscription\", subscription);\r\n    ArgumentCheck.validGuid(\"subscription.wsgId\", subscription.wsgId);\r\n\r\n    const updatedSubscription = await this._handler.postInstance<EventSubscription>(requestContext, EventSubscription, this.getRelativeUrl(iModelId, subscription.wsgId), subscription);\r\n    requestContext.enter();\r\n\r\n    Logger.logTrace(loggerCategory, \"Updated event subscription on iModel\", () => ({ iModelId }));\r\n    return updatedSubscription;\r\n  }\r\n\r\n  /** Delete an [[EventSubscription]].\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param eventSubscriptionId Id of the EventSubscription.\r\n   * @returns Resolves if the EventSubscription has been successfully deleted.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if EventSubscription does not exist with the specified subscription.wsgId.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async delete(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, eventSubscriptionId: string): Promise<void> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, `Deleting event subscription ${eventSubscriptionId} from iModel`, () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n    ArgumentCheck.validGuid(\"eventSubscriptionId\", eventSubscriptionId);\r\n\r\n    await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, eventSubscriptionId));\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, `Deleted event subscription ${eventSubscriptionId} from iModel`, () => ({ iModelId }));\r\n  }\r\n}\r\n\r\n/** Handler for receiving [[IModelHubEvent]]s. Use [[IModelClient.Events]] to get an instance of this class.\r\n * @beta\r\n */\r\nexport class EventHandler extends EventBaseHandler {\r\n  private _subscriptionHandler: EventSubscriptionHandler | undefined;\r\n\r\n  /** Constructor for EventHandler.\r\n   * @param handler Handler for WSG requests.\r\n   * @internal\r\n   */\r\n  constructor(handler: IModelBaseHandler) {\r\n    super();\r\n    this._handler = handler;\r\n  }\r\n\r\n  /** Get a handler for managing [[EventSubscription]]s. */\r\n  public get subscriptions(): EventSubscriptionHandler {\r\n    if (!this._subscriptionHandler) {\r\n      this._subscriptionHandler = new EventSubscriptionHandler(this._handler);\r\n    }\r\n\r\n    return this._subscriptionHandler;\r\n  }\r\n\r\n  /** Get relative url for EventSAS requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   */\r\n  private getEventSASRelativeUrl(iModelId: GuidString): string {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/EventSAS/`;\r\n  }\r\n\r\n  /** Get event SAS Token. Used to authenticate for [[EventHandler.getEvent]].\r\n   * @param requestContext The client request context\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @return SAS Token to connect to the topic.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async getSASToken(requestContext: AuthorizedClientRequestContext, iModelId: GuidString): Promise<EventSAS> {\r\n    Logger.logInfo(loggerCategory, \"Getting event SAS token from iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    const eventSAS = await this._handler.postInstance<EventSAS>(requestContext, EventSAS, this.getEventSASRelativeUrl(iModelId), new EventSAS());\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Got event SAS token from iModel\", () => ({ iModelId }));\r\n    return eventSAS;\r\n  }\r\n\r\n  /** Get absolute url for event requests.\r\n   * @param baseAddress Base address for the serviceBus.\r\n   * @param subscriptionId Id of the subscription.\r\n   * @param timeout Optional timeout for long polling.\r\n   */\r\n  private getEventUrl(baseAddress: string, subscriptionId: string, timeout?: number): string {\r\n    let url: string = `${baseAddress}/Subscriptions/${subscriptionId}/messages/head`;\r\n\r\n    if (timeout) {\r\n      url = url + `?timeout=${timeout}`;\r\n    }\r\n\r\n    return url;\r\n  }\r\n\r\n  /** Get [[IModelHubEvent]] from the [[EventSubscription]]. You can use long polling timeout, to have requests return when events are available (or request times out), rather than returning immediately when no events are found.\r\n   * @param requestContext The client request context\r\n   * @param sasToken SAS Token used to authenticate. See [[EventSAS.sasToken]].\r\n   * @param baseAddress Address for the events. See [[EventSAS.baseAddress]].\r\n   * @param subscriptionId Id of the subscription to the topic. See [[EventSubscription]].\r\n   * @param timeout Optional timeout duration in seconds for request, when using long polling.\r\n   * @return IModelHubEvent if it exists, undefined otherwise.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\r\n   * @throws [[ResponseError]] if request has failed.\r\n   */\r\n  public async getEvent(requestContext: ClientRequestContext, sasToken: string, baseAddress: string, subscriptionId: string, timeout?: number): Promise<IModelHubEvent | undefined> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Getting event from subscription\", () => ({ subscriptionId }));\r\n    ArgumentCheck.defined(\"sasToken\", sasToken);\r\n    ArgumentCheck.defined(\"baseAddress\", baseAddress);\r\n    ArgumentCheck.validGuid(\"subscriptionId\", subscriptionId);\r\n\r\n    const options = await this.getEventRequestOptions(GetEventOperationToRequestType.GetDestructive, sasToken, timeout);\r\n\r\n    const result = await request(requestContext, this.getEventUrl(baseAddress, subscriptionId, timeout), options);\r\n    requestContext.enter();\r\n    if (result.status === 204) {\r\n      Logger.logTrace(loggerCategory, \"No events found on subscription\", () => ({ subscriptionId }));\r\n      return undefined;\r\n    }\r\n\r\n    const event = ParseEvent(result);\r\n    Logger.logTrace(loggerCategory, \"Got event from subscription\", () => ({ subscriptionId }));\r\n    return Promise.resolve(event);\r\n  }\r\n\r\n  /** Create a listener for long polling events from an [[EventSubscription]]. When event is received from the subscription, every registered listener callback is called. This continuously waits for events until all created listeners for that subscriptionId are deleted. [[EventSAS]] token expirations are handled automatically, [[AccessToken]] expiration is handled by calling authenticationCallback to get a new token.\r\n   * @param requestContext The client request context\r\n   * @param authenticationCallback Callback used to get AccessToken. Only the first registered authenticationCallback for this subscriptionId will be used.\r\n   * @param subscriptionId Id of EventSubscription.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param listener Callback that is called when an [[IModelHubEvent]] is received.\r\n   * @returns Function that deletes the created listener.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\r\n   */\r\n  public createListener(requestContext: ClientRequestContext, authenticationCallback: () => Promise<AccessToken>, subscriptionId: string, iModelId: GuidString, listener: (event: IModelHubEvent) => void): () => void {\r\n    requestContext.enter();\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.defined(\"authenticationCallback\", authenticationCallback);\r\n    ArgumentCheck.validGuid(\"subscriptionId\", subscriptionId);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    const subscription = new ListenerSubscription();\r\n    subscription.authenticationCallback = authenticationCallback;\r\n    subscription.getEvent = async (sasToken: string, baseAddress: string, id: string, timeout?: number) =>\r\n      this.getEvent(requestContext, sasToken, baseAddress, id, timeout);\r\n    subscription.getSASToken = async (requestContextArg: AuthorizedClientRequestContext) => this.getSASToken(requestContextArg, iModelId);\r\n    subscription.id = subscriptionId;\r\n    return EventListener.create(subscription, listener);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHubEvents */\r\n\r\nimport { request, RequestOptions } from \"../Request\";\r\nimport { DefaultRequestOptionsProvider } from \"../Client\";\r\nimport { ECJsonTypeMap, WsgInstance } from \"../ECJsonTypeMap\";\r\nimport { BeEvent } from \"@bentley/bentleyjs-core\";\r\nimport { AccessToken } from \"../Token\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\n\r\n/** Base class for event shared access signatures. */\r\nexport abstract class BaseEventSAS extends WsgInstance {\r\n  /** Base address for event requests. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.BaseAddress\")\r\n  public baseAddress?: string;\r\n\r\n  /** SAS token used to authenticate for event requests. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.EventServiceSASToken\")\r\n  public sasToken?: string;\r\n}\r\n\r\n/** Base type for all iModelHub global events\r\n * @beta\r\n */\r\nexport abstract class IModelHubBaseEvent {\r\n  /** Topic of this event. For [[IModelHubEvent]]s this is iModelId. */\r\n  public eventTopic?: string;\r\n  /** User that has sent this event. */\r\n  public fromEventSubscriptionId?: string;\r\n  /** User that is intended recipient of this event. iModelHub events always have this value empty. */\r\n  public toEventSubscriptionId?: string;\r\n  /** @internal */\r\n  protected _handler?: IModelBaseHandler;\r\n  /** @internal */\r\n  protected _sasToken?: string;\r\n  /** @internal */\r\n  protected _lockUrl?: string;\r\n\r\n  /**\r\n   * Constructor for an event to pass members required for non-destructive reads.\r\n   * @param handler Base handler for WSG requests.\r\n   * @param sasToken Token for authenticating for event requests.\r\n   * @internal\r\n   */\r\n  constructor(handler?: IModelBaseHandler, sasToken?: string) {\r\n    this._handler = handler;\r\n    this._sasToken = sasToken;\r\n  }\r\n\r\n  /**\r\n   * Construct this event from object instance.\r\n   * @param obj Object instance.\r\n   * @internal\r\n   */\r\n  public fromJson(obj: any) {\r\n    this.eventTopic = obj.EventTopic;\r\n    this.fromEventSubscriptionId = obj.FromEventSubscriptionId;\r\n    this.toEventSubscriptionId = obj.ToEventSubscriptionId;\r\n    this._lockUrl = obj.location;\r\n  }\r\n\r\n  /**\r\n   * Remove a single event from queue.\r\n   * @returns true if operation succeeded, false otherwise.\r\n   */\r\n  public async delete(requestContext: AuthorizedClientRequestContext): Promise<boolean> {\r\n    if (this._handler && this._lockUrl && this._sasToken) {\r\n      const options = await getEventBaseOperationRequestOptions(this._handler, ModifyEventOperationToRequestType.Delete, this._sasToken);\r\n      const result = await request(requestContext, this._lockUrl, options);\r\n\r\n      if (result.status === 200)\r\n        return Promise.resolve(true);\r\n    }\r\n    return Promise.resolve(false);\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport enum ModifyEventOperationToRequestType {\r\n  /** Deleted event from queue */\r\n  Delete = \"DELETE\",\r\n}\r\n\r\n/** @internal */\r\nexport enum GetEventOperationToRequestType {\r\n  /** Get event request options, destructive get. */\r\n  GetDestructive = \"DELETE\",\r\n  /** Get event request options, non destructive get. */\r\n  GetPeek = \"POST\",\r\n}\r\n\r\n/**\r\n * Get base request options for event operations.\r\n * @param method Method for request.\r\n * @param sasToken Service Bus SAS Token.\r\n * @param requestTimeout Timeout for the request.\r\n * @return Event if it exists.\r\n * @internal\r\n */\r\nexport async function getEventBaseOperationRequestOptions(handler: IModelBaseHandler, method: string, sasToken: string, requestTimeout?: number): Promise<RequestOptions> {\r\n  const options: RequestOptions = {\r\n    method,\r\n    headers: { authorization: sasToken },\r\n    agent: handler.getAgent(),\r\n    retries: 0,\r\n  };\r\n\r\n  // Request timeout is in seconds, wait 50% more than the expected timeout from server\r\n  if (requestTimeout)\r\n    options.timeout = {\r\n      deadline: requestTimeout * 1500,\r\n      response: requestTimeout * 1500,\r\n    };\r\n\r\n  await new DefaultRequestOptionsProvider().assignOptions(options);\r\n\r\n  return options;\r\n}\r\n\r\n/** @internal */\r\nexport abstract class EventBaseHandler {\r\n  protected _handler: IModelBaseHandler;\r\n  /** Get service bus parser depending on the environment. */\r\n  protected setServiceBusOptions(options: RequestOptions) {\r\n    const parse: (str: string) => any = (message: string) => {\r\n      if (!message)\r\n        return undefined;\r\n      return JSON.parse(message.substring(message.indexOf(\"{\"), message.lastIndexOf(\"}\") + 1));\r\n    };\r\n\r\n    if (typeof window !== \"undefined\") {\r\n      options.parser = (_: any, message: any) => parse(message);\r\n    } else {\r\n      options.buffer = true;\r\n      options.parser = (res: any, cb: any) => {\r\n        res.on(\"data\", (chunk: any) => { res.text += chunk; });\r\n        res.on(\"end\", () => {\r\n          try {\r\n            if (res.statusCode === 200 || res.statusCode === 201) {\r\n              cb(null, parse(res.text));\r\n            } else if (res.statusCode === 204) {\r\n              cb(null, \"\");\r\n            } else {\r\n              cb(res, null);\r\n            }\r\n          } catch (err) {\r\n            cb(err, null);\r\n          }\r\n        });\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get event request options, gets event from queue.\r\n   * @param sasToken Service Bus SAS Token.\r\n   * @param requestTimeout Timeout for the request.\r\n   * @return Event if it exists.\r\n   */\r\n  protected async getEventRequestOptions(operation: GetEventOperationToRequestType, sasToken: string, requestTimeout?: number): Promise<RequestOptions> {\r\n    const options = await getEventBaseOperationRequestOptions(this._handler, operation, sasToken, requestTimeout);\r\n\r\n    this.setServiceBusOptions(options);\r\n\r\n    return options;\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class ListenerSubscription {\r\n  public listeners: BeEvent<(event: IModelHubBaseEvent) => void>;\r\n  public authenticationCallback: () => Promise<AccessToken>;\r\n  public getEvent: (token: string, baseAddress: string, subscriptionId: string, timeout?: number) => Promise<IModelHubBaseEvent | undefined>;\r\n  public getSASToken: (requestContext: AuthorizedClientRequestContext) => Promise<BaseEventSAS>;\r\n  public id: string;\r\n}\r\n\r\n/** @internal */\r\nexport class EventListener {\r\n  private static _subscriptions: Map<string, ListenerSubscription>;\r\n\r\n  /** @internal */\r\n  public static create(subscription: ListenerSubscription, listener: (event: IModelHubBaseEvent) => void): () => void {\r\n    if (!this._subscriptions) {\r\n      this._subscriptions = new Map<string, ListenerSubscription>();\r\n    }\r\n    let existingSubscription = this._subscriptions.get(subscription.id);\r\n    let deleteListener: () => void;\r\n    if (!existingSubscription) {\r\n      existingSubscription = subscription;\r\n      existingSubscription.listeners = new BeEvent<(event: IModelHubBaseEvent) => void>();\r\n      deleteListener = subscription.listeners.addListener(listener);\r\n      this.getEvents(subscription); // tslint:disable-line:no-floating-promises\r\n    } else {\r\n      deleteListener = subscription.listeners.addListener(listener);\r\n    }\r\n\r\n    this._subscriptions.set(subscription.id, existingSubscription);\r\n    const subscriptionId = subscription.id;\r\n    return () => {\r\n      deleteListener();\r\n      const sub = this._subscriptions.get(subscriptionId);\r\n      if (sub) {\r\n        if (sub.listeners && sub.listeners.numberOfListeners === 0)\r\n          this._subscriptions.delete(subscription.id);\r\n      }\r\n    };\r\n  }\r\n\r\n  private static async getEvents(subscription: ListenerSubscription) {\r\n    let accessToken: AccessToken = await subscription.authenticationCallback();\r\n    let eventSAS: BaseEventSAS | undefined;\r\n\r\n    mainLoop:\r\n    while (subscription.listeners.numberOfListeners > 0) {\r\n      try {\r\n        const requestContext = new AuthorizedClientRequestContext(accessToken);\r\n        eventSAS = (await subscription.getSASToken(requestContext));\r\n      } catch (err) {\r\n        if (err.status === 401) {\r\n          try {\r\n            accessToken = await subscription.authenticationCallback();\r\n          } catch {\r\n            break;\r\n          }\r\n        } else {\r\n          break;\r\n        }\r\n      }\r\n\r\n      while (subscription.listeners.numberOfListeners > 0) {\r\n        try {\r\n          const event = await subscription.getEvent(eventSAS!.sasToken!, eventSAS!.baseAddress!, subscription.id, 60);\r\n          if (event)\r\n            subscription.listeners.raiseEvent(event);\r\n        } catch (err) {\r\n          if (err.status === 401) {\r\n            break;\r\n          } else {\r\n            break mainLoop;\r\n          }\r\n        }\r\n      }\r\n    }\r\n    this._subscriptions.delete(subscription.id);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHubGlobalEvents */\nimport { ClientRequestContext, GuidString, Logger } from \"@bentley/bentleyjs-core\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { AccessToken } from \"../Token\";\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\nimport { request, RequestOptions, Response } from \"./../Request\";\nimport { IModelBaseHandler } from \"./BaseHandler\";\nimport { ArgumentCheck } from \"./Errors\";\nimport { BaseEventSAS, EventBaseHandler, EventListener, GetEventOperationToRequestType, IModelHubBaseEvent, ListenerSubscription } from \"./EventsBase\";\nimport { ContextType } from \"../ConnectClients\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\n\n/** Type of [[IModelHubGlobalEvent]]. Global Event type is used to define which events you wish to receive from your [[GlobalEventSubscription]]. See [[GlobalEventSubscriptionHandler.create]] and [[GlobalEventSubscriptionHandler.update]].\n * @beta\n */\nexport type GlobalEventType =\n  /** Sent when an iModel is put into the archive. See [[SoftiModelDeleteEvent]].\n   * @beta Rename to SoftIModelDeleteEvent\n   */\n  \"SoftiModelDeleteEvent\" |\n  /** Sent when an archived iModel is completely deleted from the storage. See [[HardiModelDeleteEvent]].\n   * @beta Rename to HardIModelDeleteEvent\n   */\n  \"HardiModelDeleteEvent\" |\n  /** Sent when an iModel is created. See [[IModelCreatedEvent]].\n   * @beta Rename to IModelCreatedEvent\n   */\n  \"iModelCreatedEvent\" |\n  /** Sent when a [[ChangeSet]] is pushed. See [[ChangeSetCreatedEvent]]. */\n  \"ChangeSetCreatedEvent\" |\n  /** Sent when a named [[Version]] is created. See [[NamedVersionCreatedEvent]]. */\n  \"NamedVersionCreatedEvent\";\n\n/** Base type for all iModelHub global events.\n * @beta\n */\nexport abstract class IModelHubGlobalEvent extends IModelHubBaseEvent {\n  /** Id of the iModel that caused this event. */\n  public iModelId?: GuidString;\n  /** Id of the [[Project]] that this iModel belongs to. */\n  public projectId?: string;\n  /** Id of the context ([[Project]] or [[Asset]]) that this iModel belongs to. */\n  public contextId?: string;\n  /** Type of the context ([[Project]] or [[Asset]]) that this iModel belongs to. */\n  public contextTypeId?: ContextType;\n\n  /** Construct this global event from object instance.\n   * @param obj Object instance.\n   * @internal\n   */\n  public fromJson(obj: any) {\n    super.fromJson(obj);\n    this.iModelId = obj.iModelId;\n    this.projectId = obj.ProjectId;\n    this.contextId = obj.ContextId;\n\n    const contextTypeId = obj.ContextTypeId as number;\n    switch (contextTypeId) {\n      case ContextType.Asset:\n      case ContextType.Project:\n        this.contextTypeId = contextTypeId;\n        break;\n      default:\n        this.contextTypeId = ContextType.Unknown;\n    }\n  }\n}\n\n/** Sent when an iModel is put into the archive. See [[IModelHandler.delete]].\n * @beta Rename to SoftIModelDeleteEvent\n */\nexport class SoftiModelDeleteEvent extends IModelHubGlobalEvent {\n}\n\n/** Sent when an archived iModel is completely deleted from the storage. Sent after some time passes after [[IModelHandler.delete]] and iModel is no longer kept in the archive. iModel is kept at least 30 days in the archive.\n * @beta Rename to HardIModelDeleteEvent\n */\nexport class HardiModelDeleteEvent extends IModelHubGlobalEvent {\n}\n\n/** Sent when an iModel is created. See [[IModelHandler.create]].\n * @beta\n */\nexport class IModelCreatedEvent extends IModelHubGlobalEvent {\n}\n\n/** Sent when a [[ChangeSet]] is pushed. See [[ChangeSetHandler.create]]. Sent together with [[ChangeSetPostPushEvent]].\n * @beta\n */\nexport class ChangeSetCreatedEvent extends IModelHubGlobalEvent {\n  public changeSetId?: string;\n  public changeSetIndex?: string;\n  public briefcaseId?: number;\n\n  /** Construct this event from object instance.\n   * @param obj Object instance.\n   */\n  public fromJson(obj: any) {\n    super.fromJson(obj);\n    this.changeSetId = obj.ChangeSetId;\n    this.changeSetIndex = obj.ChangeSetIndex;\n    this.briefcaseId = obj.BriefcaseId;\n  }\n}\n\n/** Sent when a named [[Version]] is created. See [[VersionHandler.create]].\n * @beta\n */\nexport class NamedVersionCreatedEvent extends IModelHubGlobalEvent {\n  public versionId?: GuidString;\n  public versionName?: string;\n  public changeSetId?: string;\n\n  /** Construct this event from object instance.\n   * @param obj Object instance.\n   */\n  public fromJson(obj: any) {\n    super.fromJson(obj);\n    this.versionId = obj.VersionId;\n    this.versionName = obj.VersionName;\n    this.changeSetId = obj.ChangeSetId;\n  }\n}\n\ntype GlobalEventConstructor = (new (handler?: IModelBaseHandler, sasToken?: string) => IModelHubGlobalEvent);\n/** Get constructor from GlobalEventType name. */\nfunction ConstructorFromEventType(type: GlobalEventType): GlobalEventConstructor {\n  switch (type) {\n    case \"SoftiModelDeleteEvent\":\n      return SoftiModelDeleteEvent;\n    case \"HardiModelDeleteEvent\":\n      return HardiModelDeleteEvent;\n    case \"iModelCreatedEvent\":\n      return IModelCreatedEvent;\n    case \"ChangeSetCreatedEvent\":\n      return ChangeSetCreatedEvent;\n    case \"NamedVersionCreatedEvent\":\n      return NamedVersionCreatedEvent;\n  }\n}\n\n/** Parse [[IModelHubGlobalEvent]] from response object.\n * @param response Response object to parse.\n * @returns Appropriate global event object.\n * @internal\n */\nexport function ParseGlobalEvent(response: Response, handler?: IModelBaseHandler, sasToken?: string): IModelHubGlobalEvent {\n  const constructor: GlobalEventConstructor = ConstructorFromEventType(response.header[\"content-type\"]);\n  const globalEvent = new constructor(handler, sasToken);\n  globalEvent.fromJson({ ...response.header, ...response.body });\n  return globalEvent;\n}\n\n/** Subscription to receive [[IModelHubGlobalEvent]]s. Each subscription has a separate queue for events that it hasn't read yet. Global event subscriptions do not expire and must be deleted by the user. Use wsgId of this instance for the methods that require subscriptionId. See [[GlobalEventSubscriptionHandler]].\n * @beta\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"GlobalScope.GlobalEventSubscription\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class GlobalEventSubscription extends WsgInstance {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.EventTypes\")\n  public eventTypes?: GlobalEventType[];\n\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.SubscriptionId\")\n  public subscriptionId?: string;\n}\n\n/** Shared access signature token for getting [[IModelHubGlobalEvent]]s. It's used to authenticate for [[GlobalEventHandler.getEvent]]. To receive an instance call [[GlobalEventHandler.getSASToken]].\n * @beta\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"GlobalScope.GlobalEventSAS\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class GlobalEventSAS extends BaseEventSAS {\n}\n\n/** Handler for managing [[GlobalEventSubscription]]s.\n * Use [[GlobalEventHandler.Subscriptions]] to get an instance of this class.\n * @beta\n */\nexport class GlobalEventSubscriptionHandler {\n  private _handler: IModelBaseHandler;\n\n  /** Constructor for GlobalEventSubscriptionHandler.\n   * @param handler Handler for WSG requests.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler) {\n    this._handler = handler;\n  }\n\n  /** Get relative url for GlobalEventSubscription requests.\n   * @param instanceId Id of the subscription.\n   */\n  private getRelativeUrl(instanceId?: string) {\n    return `/Repositories/Global--Global/GlobalScope/GlobalEventSubscription/${instanceId || \"\"}`;\n  }\n\n  /** Create a [[GlobalEventSubscription]]. You can use this to get or update the existing subscription instance, if you only have the original subscriptionId.\n   * @param requestContext The client request context\n   * @param subscriptionId Guid to be used by global event subscription. It will be a part of the resulting subscription id.\n   * @param globalEvents Array of GlobalEventTypes to subscribe to.\n   * @return Created GlobalEventSubscription instance.\n   * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionAlreadyExists]($bentley) if [[GlobalEventSubscription]] already exists with the specified subscriptionId.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async create(requestContext: AuthorizedClientRequestContext, subscriptionId: GuidString, globalEvents: GlobalEventType[]) {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Creating global event subscription\", () => ({ subscriptionId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"subscriptionId\", subscriptionId);\n\n    let subscription = new GlobalEventSubscription();\n    subscription.eventTypes = globalEvents;\n    subscription.subscriptionId = subscriptionId;\n\n    subscription = await this._handler.postInstance<GlobalEventSubscription>(requestContext, GlobalEventSubscription, this.getRelativeUrl(), subscription);\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Created global event subscription\", () => ({ subscriptionId }));\n    return subscription;\n  }\n\n  /** Update a [[GlobalEventSubscription]]. Can change the [[GlobalEventType]]s specified in the subscription. Must be a valid subscription that was previously created with [[GlobalEventSubscriptionHandler.create]].\n   * @param requestContext The client request context.\n   * @param subscription Updated GlobalEventSubscription.\n   * @return GlobalEventSubscription instance from iModelHub after update.\n   * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if [[GlobalEventSubscription]] does not exist with the specified subscription.wsgId.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async update(requestContext: AuthorizedClientRequestContext, subscription: GlobalEventSubscription): Promise<GlobalEventSubscription> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, `Updating global event subscription with instance id: ${subscription.wsgId}`, () => ({ subscriptionId: subscription.subscriptionId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.defined(\"subscription\", subscription);\n    ArgumentCheck.validGuid(\"subscription.wsgId\", subscription.wsgId);\n\n    const updatedSubscription = await this._handler.postInstance<GlobalEventSubscription>(requestContext, GlobalEventSubscription, this.getRelativeUrl(subscription.wsgId), subscription);\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, `Updated global event subscription with instance id: ${subscription.wsgId}`, () => ({ subscriptionId: subscription.subscriptionId }));\n    return updatedSubscription;\n  }\n\n  /** Delete a [[GlobalEventSubscription]].\n   * @param requestContext The client request context.\n   * @param subscriptionId WSG Id of the GlobalEventSubscription.\n   * @returns Resolves if the GlobalEventSubscription has been successfully deleted.\n   * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if GlobalEventSubscription does not exist with the specified subscription.wsgId.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async delete(requestContext: AuthorizedClientRequestContext, subscriptionId: string): Promise<void> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Deleting global event subscription\", () => ({ subscriptionId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"subscriptionInstanceId\", subscriptionId);\n\n    await this._handler.delete(requestContext, this.getRelativeUrl(subscriptionId));\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Deleted global event subscription\", () => ({ subscriptionId }));\n  }\n}\n\n/** Type of [[GlobalEventHandler.getEvent]] operations.\n * @beta\n */\nexport enum GetEventOperationType {\n  /** Event will be immediately removed from queue. */\n  Destructive = 0,\n  /** Event will be locked instead of removed. It has to be later removed via [[IModelHubBaseEvent.delete]]. */\n  Peek,\n}\n\n/** Handler for receiving [[IModelHubGlobalEvent]]s.\n * Use [[IModelClient.GlobalEvents]] to get an instance of this class.\n * @beta\n */\nexport class GlobalEventHandler extends EventBaseHandler {\n  private _subscriptionHandler: GlobalEventSubscriptionHandler | undefined;\n\n  /** Constructor for GlobalEventHandler.\n   * @param handler Handler for WSG requests.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler) {\n    super();\n    this._handler = handler;\n  }\n\n  /** Get a handler for managing [[GlobalEventSubscription]]s. */\n  public get subscriptions(): GlobalEventSubscriptionHandler {\n    if (!this._subscriptionHandler) {\n      this._subscriptionHandler = new GlobalEventSubscriptionHandler(this._handler);\n    }\n\n    return this._subscriptionHandler;\n  }\n\n  /** Get relative url for GlobalEventSAS requests. */\n  private getGlobalEventSASRelativeUrl(): string {\n    return `/Repositories/Global--Global/GlobalScope/GlobalEventSAS/`;\n  }\n\n  /** Get global event SAS Token. Used to authenticate for [[GlobalEventHandler.getEvent]].\n   * @param requestContext The client request context\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async getSASToken(requestContext: AuthorizedClientRequestContext): Promise<GlobalEventSAS> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Getting global event SAS token\");\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n\n    const globalEventSAS = await this._handler.postInstance<GlobalEventSAS>(requestContext, GlobalEventSAS, this.getGlobalEventSASRelativeUrl(), new GlobalEventSAS());\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Got global event SAS token\");\n    return globalEventSAS;\n  }\n\n  /** Get absolute url for global event requests.\n   * @param baseAddress Base address for the serviceBus.\n   * @param subscriptionId Id of the subscription instance.\n   * @param timeout Optional timeout for long polling.\n   */\n  private getGlobalEventUrl(baseAddress: string, subscriptionId: string, timeout?: number): string {\n    let url: string = `${baseAddress}/Subscriptions/${subscriptionId}/messages/head`;\n\n    if (timeout) {\n      url = url + `?timeout=${timeout}`;\n    }\n\n    return url;\n  }\n\n  /** Get an [[IModelHubGlobalEvent]] from the [[GlobalEventSubscription]]. You can use long polling timeout, to have requests return when events are available (or request times out), rather than returning immediately when no events are found.\n   * @param requestContext The client request context\n   * @param sasToken SAS Token used to authenticate. See [[GlobalEventSAS.sasToken]].\n   * @param baseAddress Address for the events. See [[GlobalEventSAS.baseAddress]].\n   * @param subscriptionId Id of the subscription to the topic. See [[GlobalEventSubscription]].\n   * @param timeout Optional timeout duration in seconds for request, when using long polling.\n   * @return IModelHubGlobalEvent if it exists, undefined otherwise.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\n   * @throws [[ResponseError]] if request has failed.\n   */\n  public async getEvent(requestContext: ClientRequestContext, sasToken: string, baseAddress: string, subscriptionId: string, timeout?: number, getOperation: GetEventOperationType = GetEventOperationType.Destructive): Promise<IModelHubGlobalEvent | undefined> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Getting global event from subscription\", () => ({ subscriptionId }));\n    ArgumentCheck.defined(\"sasToken\", sasToken);\n    ArgumentCheck.defined(\"baseAddress\", baseAddress);\n    ArgumentCheck.defined(\"subscriptionInstanceId\", subscriptionId);\n\n    let options: RequestOptions;\n    if (getOperation === GetEventOperationType.Destructive)\n      options = await this.getEventRequestOptions(GetEventOperationToRequestType.GetDestructive, sasToken, timeout);\n    else if (getOperation === GetEventOperationType.Peek)\n      options = await this.getEventRequestOptions(GetEventOperationToRequestType.GetPeek, sasToken, timeout);\n    else // Unknown operation type.\n      return undefined;\n\n    const result = await request(requestContext, this.getGlobalEventUrl(baseAddress, subscriptionId, timeout), options);\n    requestContext.enter();\n    if (result.status === 204) {\n      Logger.logTrace(loggerCategory, \"No events found on subscription\", () => ({ subscriptionId }));\n      return undefined;\n    }\n\n    const event = ParseGlobalEvent(result, this._handler, sasToken);\n    Logger.logTrace(loggerCategory, \"Got Global Event from subscription\", () => ({ subscriptionId }));\n    return Promise.resolve(event);\n  }\n\n  /** Create a listener for long polling events from a [[GlobalEventSubscription]]. When event is received from the subscription, every registered listener callback is called. This continuously waits for events until all created listeners for that subscriptionInstanceId are deleted. [[GlobalEventSAS]] token expirations are handled automatically, [[AccessToken]] expiration is handled by calling authenticationCallback to get a new token.\n   * @param authenticationCallback Callback used to get AccessToken. Only the first registered authenticationCallback for this subscriptionId will be used.\n   * @param subscriptionInstanceId Id of GlobalEventSubscription.\n   * @param listener Callback that is called when an [[IModelHubGlobalEvent]] is received.\n   * @returns Function that deletes the created listener.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\n   */\n  public createListener(requestContext: AuthorizedClientRequestContext, authenticationCallback: () => Promise<AccessToken>, subscriptionInstanceId: string, listener: (event: IModelHubGlobalEvent) => void): () => void {\n    requestContext.enter();\n    ArgumentCheck.defined(\"subscriptionInstanceId\", subscriptionInstanceId);\n    const subscription = new ListenerSubscription();\n    subscription.authenticationCallback = authenticationCallback;\n    subscription.getEvent = async (sasToken: string, baseAddress: string, id: string, timeout?: number) =>\n      this.getEvent(requestContext, sasToken, baseAddress, id, timeout);\n    subscription.getSASToken = async (reqContext: AuthorizedClientRequestContext) => this.getSASToken(reqContext);\n    subscription.id = subscriptionInstanceId;\n    return EventListener.create(subscription, listener);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { GuidString, Id64String, IModelHubStatus, Logger } from \"@bentley/bentleyjs-core\";\nimport * as deepAssign from \"deep-assign\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { WsgRequestOptions } from \"../WsgClient\";\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\nimport { ResponseError } from \"./../Request\";\nimport { IModelBaseHandler } from \"./BaseHandler\";\nimport { AggregateResponseError, ArgumentCheck, IModelHubError } from \"./Errors\";\nimport { Query } from \"./Query\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\n\n/**\n * [[Lock]] type describes the kind of object that is locked.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport enum LockType {\n  /** Lock for the entire file. This is a global Lock that can only be taken with objectId 1. */\n  Db,\n  /** Lock for a model. It should be acquired together with a [[LockLevel.Shared]] Db Lock. */\n  Model,\n  /** Lock for a single element. It should be acquired together with a [[LockLevel.Shared]] Model Lock. */\n  Element,\n  /** Lock used to change schemas. This is a global Lock that can only be taken with objectId 1. This lock cannot have [[LockLevel.Shared]]. */\n  Schemas,\n  /** Lock used to change CodeSpecs. This is a global Lock that can only be taken with objectId 1. This lock cannot have [[LockLevel.Shared]]. */\n  CodeSpecs,\n}\n\n/**\n * [[Lock]] level describes how restrictive the Lock is.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport enum LockLevel {\n  /** Lock is not owned. */\n  None,\n  /** Lock can be owned by multiple [[Briefcase]]s. Shared Lock is usually acquired together with Locks for lower level objects that depend on this object. */\n  Shared,\n  /** Lock can only be owned by a single briefcase. Exclusive Lock is required to modify model or element when using pessimistic concurrency. */\n  Exclusive,\n}\n\n/**\n * Gets encoded instance id for a lock to be used in an URI.\n * @param lock Lock to get instance id for.\n * @returns Encoded lock instance id.\n * @internal\n */\nfunction getLockInstanceId(lock: Lock): string | undefined {\n  if (!lock || lock.briefcaseId === undefined || lock.lockType === undefined || !lock.objectId)\n    return undefined;\n\n  return `${lock.lockType}-${lock.objectId}-${lock.briefcaseId}`;\n}\n\n/**\n * Object for specifying options when sending [[Lock]]s update requests. See [[LockHandler.update]].\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport interface LockUpdateOptions {\n  /** Return [[Lock]]s that could not be acquired. Conflicting Locks will be set to [[ConflictingLocksError.conflictingLocks]]. If unlimitedReporting is enabled and locksPerRequest value is high, some conflicting Locks could be missed. */\n  deniedLocks?: boolean;\n  /** Attempt to get all failed [[Lock]]s, ignoring iModelHub limits. Server responses might fail when trying to return large number of conflicting Locks. */\n  unlimitedReporting?: boolean;\n  /** Number of [[Lock]]s per single request. Multiple requests will be sent if there are more Locks. If an error happens on a subsequent request, previous successful updates will not be reverted. */\n  locksPerRequest?: number;\n  /** Don't fail request on a conflict. If conflict occurs, [[Lock]]s that didn't have conflicts will be updated and any remaining subsequent requests will still be sent. */\n  continueOnConflict?: boolean;\n}\n\n/** Provider for default LockUpdateOptions, used by LockHandler to set defaults.\n * @internal\n */\nexport class DefaultLockUpdateOptionsProvider {\n  protected _defaultOptions: LockUpdateOptions;\n  /** Creates an instance of DefaultRequestOptionsProvider and sets up the default options. */\n  constructor() {\n    this._defaultOptions = {\n      locksPerRequest: 2000,\n    };\n  }\n\n  /** Augments options with the provider's default values.\n   * @note The options passed in override any defaults where necessary.\n   * @param options Options that should be augmented.\n   */\n  public async assignOptions(options: LockUpdateOptions): Promise<void> {\n    const clonedOptions: LockUpdateOptions = Object.assign({}, options);\n    deepAssign(options, this._defaultOptions);\n    deepAssign(options, clonedOptions); // ensure the supplied options override the defaults\n    return Promise.resolve();\n  }\n}\n\n/**\n * Error for conflicting [[Lock]]s. It contains an array of Locks that failed to acquire. This is returned when calling [[LockHandler.update]] with [[LockUpdateOptions.deniedLocks]] set to true.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport class ConflictingLocksError extends IModelHubError {\n  /** Locks that couldn't be updated due to other users owning them. */\n  public conflictingLocks?: Lock[];\n\n  /** Create ConflictingLocksError from IModelHubError instance.\n   * @param error IModelHubError to get error data from.\n   * @returns Undefined if the error is not for a lock conflict, otherwise newly created error instance.\n   * @internal\n   */\n  public static fromError(error: IModelHubError): ConflictingLocksError | undefined {\n    if (error.errorNumber !== IModelHubStatus.LockOwnedByAnotherBriefcase\n      && error.errorNumber !== IModelHubStatus.ConflictsAggregate) {\n      return undefined;\n    }\n    const result = new ConflictingLocksError(error.errorNumber);\n    deepAssign(result, error);\n    result.addLocks(error);\n    return result;\n  }\n\n  /**\n   * Amends this error instance with conflicting locks from another IModelHubError.\n   * @param error Error to get additional conflicting locks from.\n   * @internal\n   */\n  public addLocks(error: IModelHubError) {\n    if (!error.data || !error.data.ConflictingLocks) {\n      return;\n    }\n    if (!this.conflictingLocks) {\n      this.conflictingLocks = [];\n    }\n    for (const value of (error.data.ConflictingLocks as any[])) {\n      const instance = { className: \"Lock\", schemaName: \"iModelScope\", properties: value };\n      const lock = ECJsonTypeMap.fromJson<Lock>(Lock, \"wsg\", instance);\n      if (lock) {\n        this.conflictingLocks.push(lock);\n      }\n    }\n  }\n}\n\n/**\n * Base class for [[Lock]]s.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport class LockBase extends WsgInstance {\n  /** Type of the Lock. It describes what kind of object is locked. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.LockType\")\n  public lockType?: LockType;\n\n  /** Level of the Lock. It describes how restrictive the Lock is. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.LockLevel\")\n  public lockLevel?: LockLevel;\n\n  /** Id of the [[Briefcase]] that owns the Lock. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.BriefcaseId\")\n  public briefcaseId?: number;\n\n  /** Id of the file, that the Lock belongs to. See [[Briefcase.fileId]]. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.SeedFileId\")\n  public seedFileId?: GuidString;\n\n  /** Id of the [[ChangeSet]] that the Lock was last used with. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ReleasedWithChangeSet\")\n  public releasedWithChangeSet?: string;\n\n  /** Index of the [[ChangeSet]] that the Lock was last used with. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ReleasedWithChangeSetIndex\")\n  public releasedWithChangeSetIndex?: string;\n}\n\n/**\n * Lock instance. When using pessimistic concurrency, locks ensure that only a single user can modify an object at a time.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.Lock\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class Lock extends LockBase {\n  /** Id of the locked object. */\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ObjectId\")\n  public objectId?: Id64String;\n}\n\n/**\n * MultiLock: data about locks grouped by BriefcaseId, LockLevel and LockType.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.MultiLock\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class MultiLock extends LockBase {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ObjectIds\")\n  public objectIds?: Id64String[];\n}\n\n/**\n * Query object for getting [[Lock]]s. You can use this to modify the [[LockHandler.get]] results.\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport class LockQuery extends Query {\n  private _isMultiLockQuery = true;\n\n  /**\n   * Default page size which is used when querying Locks\n   * @internal\n   */\n  public static defaultPageSize: number = 10000;\n\n  /** Constructor that sets default page size. */\n  constructor() {\n    super();\n    this.pageSize(LockQuery.defaultPageSize);\n  }\n\n  /**\n   * Used by the handler to check whether locks in query can be grouped.\n   * @internal\n   */\n  public get isMultiLockQuery() {\n    return this._isMultiLockQuery;\n  }\n\n  /**\n   * Query [[Lock]]s by [[Briefcase]] id.\n   * @param briefcaseId Id of the Briefcase.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if briefcaseId is undefined or it contains an invalid [[Briefcase]] id value.\n   */\n  public byBriefcaseId(briefcaseId: number) {\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n    this.addFilter(`BriefcaseId+eq+${briefcaseId}`);\n    return this;\n  }\n\n  /**\n   * Query [[Lock]]s by [[LockType]].\n   * @param lockType Lock type to query.\n   * @returns This query.\n   */\n  public byLockType(lockType: LockType) {\n    this.addFilter(`LockType+eq+${lockType}`);\n    return this;\n  }\n\n  /**\n   * Query [[Lock]]s by [[LockLevel]].\n   * @param lockLevel Lock level to query.\n   * @returns This query.\n   */\n  public byLockLevel(lockLevel: LockLevel) {\n    this.addFilter(`LockLevel+eq+${lockLevel}`);\n    return this;\n  }\n\n  /**\n   * Query [[Lock]]s by ObjectId.\n   * @param objectId Id of the object.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if objectId is undefined.\n   */\n  public byObjectId(objectId: Id64String) {\n    ArgumentCheck.defined(\"objectId\", objectId);\n    this._isMultiLockQuery = false;\n    this.addFilter(`ObjectId+eq+'${objectId}'`);\n    return this;\n  }\n\n  /**\n   * Query [[Lock]]s by [[ChangeSet]] id that it was released with.\n   * @param changesetId Id of the ChangeSet.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if changeSetId is undefined or empty, or it contains an invalid [[ChangeSet]] id value.\n   */\n  public byReleasedWithChangeSet(changeSetId: string) {\n    ArgumentCheck.validChangeSetId(\"changeSetId\", changeSetId);\n    this.addFilter(`ReleasedWithChangeSet+eq+'${changeSetId}'`);\n    return this;\n  }\n\n  /**\n   * Query [[Lock]]s by [[ChangeSet]] index that it was released with.\n   * @param changeSetIndex Index of the changeSet.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley)\n   * if changeSetIndex is undefined.\n   */\n  public byReleasedWithChangeSetIndex(changeSetIndex: number) {\n    ArgumentCheck.definedNumber(\"changeSetIndex\", changeSetIndex);\n    this.addFilter(`ReleasedWithChangeSetIndex+eq+${changeSetIndex}`);\n    return this;\n  }\n\n  /**\n   * Query [[Lock]]s by their instance ids.\n   * @param locks Locks to query. They must have their BriefcaseId, LockType and ObjectId set.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if locks array is undefined or empty, or it contains invalid [[Lock]] values.\n   */\n  public byLocks(locks: Lock[]) {\n    ArgumentCheck.nonEmptyArray(\"locks\", locks);\n\n    let filter = \"$id+in+[\";\n\n    let index = 0;\n    for (const lock of locks) {\n      const id = getLockInstanceId(lock);\n      ArgumentCheck.valid(`locks[${index}]`, id);\n\n      if (0 !== index++)\n        filter += \",\";\n      filter += `'${id}'`;\n    }\n\n    filter += \"]\";\n    this.addFilter(filter);\n    this._isMultiLockQuery = false;\n    return this;\n  }\n\n  /**\n   * Query unavailable [[Lock]]s. It will include all Locks owned by other [[Briefcase]]s and locks that were released with a newer [[ChangeSet]].\n   * @param briefcaseId Id of the Briefcase.\n   * @param lastChangeSetIndex Index of the last ChangeSet that user has pulled.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the values is undefined or briefcaseId is not in a valid [[Briefcase]] id value.\n   */\n  public unavailableLocks(briefcaseId: number, lastChangeSetIndex: string) {\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n    ArgumentCheck.defined(\"lastChangeSetIndex\", lastChangeSetIndex);\n    let filter = `BriefcaseId+ne+${briefcaseId}`;\n    filter += `+and+(LockLevel+gt+0+or+ReleasedWithChangeSetIndex+gt+${lastChangeSetIndex})`;\n    this.addFilter(filter);\n    return this;\n  }\n}\n\n/**\n * Handler for managing [[Lock]]s. Use [[IModelClient.Locks]] to get an instance of this class.\n * In most cases, you should use [ConcurrencyControl]($backend) methods instead. You can read more about concurrency control [here]($docs/learning/backend/concurrencycontrol).\n * @alpha Hide Lock API while focused on readonly viewing scenarios\n */\nexport class LockHandler {\n  private _handler: IModelBaseHandler;\n  private static _defaultUpdateOptionsProvider: DefaultLockUpdateOptionsProvider;\n\n  /**\n   * Constructor for LockHandler.\n   * @param handler Handler for WSG requests.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler) {\n    this._handler = handler;\n  }\n\n  private getRelativeUrl(iModelId: GuidString, multilock = true, lockId?: string) {\n    return `/Repositories/iModel--${iModelId}/iModelScope/${multilock ? \"MultiLock\" : \"Lock\"}/${lockId || \"\"}`;\n  }\n\n  private static convertLocksToMultiLocks(locks: Lock[]): MultiLock[] {\n    const map = new Map<string, MultiLock>();\n    for (const lock of locks) {\n      const id: string = `${lock.lockType}-${lock.lockLevel}`;\n\n      if (map.has(id)) {\n        map.get(id)!.objectIds!.push(lock.objectId!);\n      } else {\n        const multiLock = new MultiLock();\n        multiLock.changeState = \"new\";\n        multiLock.briefcaseId = lock.briefcaseId;\n        multiLock.seedFileId = lock.seedFileId;\n        multiLock.releasedWithChangeSet = lock.releasedWithChangeSet;\n        multiLock.releasedWithChangeSetIndex = lock.releasedWithChangeSetIndex;\n        multiLock.lockLevel = lock.lockLevel;\n        multiLock.lockType = lock.lockType;\n        multiLock.objectIds = [lock.objectId!];\n        map.set(id, multiLock);\n      }\n    }\n    return Array.from(map.values());\n  }\n\n  private static convertMultiLocksToLocks(multiLocks: MultiLock[]): Lock[] {\n    const result: Lock[] = [];\n\n    for (const multiLock of multiLocks) {\n      for (const value of multiLock.objectIds!) {\n        const lock = new Lock();\n        lock.objectId = value;\n        lock.briefcaseId = multiLock.briefcaseId;\n        if (lock.seedFileId)\n          lock.seedFileId = multiLock.seedFileId;\n        lock.lockLevel = multiLock.lockLevel;\n        lock.lockType = multiLock.lockType;\n        result.push(lock);\n      }\n    }\n\n    return result;\n  }\n\n  /** Augment update options with defaults returned by the DefaultLockUpdateOptionsProvider.\n   * The options passed in by clients override any defaults where necessary.\n   * @param options Options the caller wants to eaugment with the defaults.\n   */\n  private async setupOptionDefaults(options: LockUpdateOptions): Promise<void> {\n    if (!LockHandler._defaultUpdateOptionsProvider)\n      LockHandler._defaultUpdateOptionsProvider = new DefaultLockUpdateOptionsProvider();\n    return LockHandler._defaultUpdateOptionsProvider.assignOptions(options);\n  }\n\n  /** Send partial request for lock updates */\n  private async updateInternal(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, locks: Lock[], updateOptions?: LockUpdateOptions): Promise<Lock[]> {\n    requestContext.enter();\n    let requestOptions: WsgRequestOptions | undefined;\n    if (updateOptions) {\n      requestOptions = {};\n      requestOptions.CustomOptions = {};\n      if (updateOptions.deniedLocks === false) {\n        requestOptions.CustomOptions.DetailedError_Codes = \"false\";\n      }\n      if (updateOptions.unlimitedReporting) {\n        requestOptions.CustomOptions.DetailedError_MaximumInstances = \"-1\";\n      }\n      if (updateOptions.continueOnConflict) {\n        requestOptions.CustomOptions.ConflictStrategy = \"Continue\";\n      }\n      if (Object.getOwnPropertyNames(requestOptions.CustomOptions).length === 0) {\n        requestOptions = undefined;\n      }\n    }\n\n    const result = await this._handler.postInstances<MultiLock>(requestContext, MultiLock, `/Repositories/iModel--${iModelId}/$changeset`, LockHandler.convertLocksToMultiLocks(locks), requestOptions);\n    requestContext.enter();\n    return LockHandler.convertMultiLocksToLocks(result);\n  }\n\n  /** Update multiple [[Lock]]s. This call can simultaneously acquire new Locks and update states of already owned Locks. If large amount of Locks are updated, they are split across multiple requests. See [[LockUpdateOptions.locksPerRequest]]. Default is 2000 Locks per request.\n   * @param requestContext The client request context.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param locks Locks to acquire. Requires briefcaseId, seedFileId to be set for every\n   * Lock instance. They must be consistent throughout all of the Locks.\n   * @param updateOptions Options for the update request. You can set this to change\n   * how conflicts are handled or to handle different amount of Locks per request.\n   * @returns Updated Lock values.\n   * @throws [[ConflictingLocksError]] when [[LockUpdateOptions.deniedLocks]] is set and conflicts occured. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) for more information.\n   * @throws [[AggregateResponseError]] when multiple requests where sent and more than 1 of the following errors occured.\n   * @throws [[IModelHubError]] with status indicating a conflict. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) section for more information.\n   * @throws [[IModelHubError]] with [IModelHubStatus.InvalidBriefcase]($bentley) when including locks with different briefcaseId values in the request.\n   * @throws [[IModelHubError]] with [IModelHubStatus.OperationFailed]($bentley) when including multiple identical locks in the request.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, locks: Lock[], updateOptions?: LockUpdateOptions): Promise<Lock[]> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Requesting locks\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n    ArgumentCheck.nonEmptyArray(\"locks\", locks);\n\n    updateOptions = updateOptions || {};\n    await this.setupOptionDefaults(updateOptions);\n\n    const result: Lock[] = [];\n    let conflictError: ConflictingLocksError | undefined;\n    const aggregateError = new AggregateResponseError();\n\n    for (let i = 0; i < locks.length; i += updateOptions.locksPerRequest!) {\n      const chunk = locks.slice(i, i + updateOptions.locksPerRequest!);\n      try {\n        result.push(...await this.updateInternal(requestContext, iModelId, chunk, updateOptions));\n        requestContext.enter();\n      } catch (error) {\n        requestContext.enter();\n        if (error instanceof ResponseError) {\n          if (updateOptions && updateOptions.deniedLocks && error instanceof IModelHubError\n            && (error.errorNumber === IModelHubStatus.LockOwnedByAnotherBriefcase || error.errorNumber === IModelHubStatus.ConflictsAggregate)) {\n            if (conflictError) {\n              conflictError.addLocks(error);\n            } else {\n              conflictError = ConflictingLocksError.fromError(error);\n            }\n            if (!updateOptions.continueOnConflict) {\n              return Promise.reject(conflictError);\n            }\n          } else {\n            aggregateError.errors.push(error);\n          }\n        }\n      }\n    }\n\n    if (conflictError) {\n      return Promise.reject(conflictError);\n    }\n\n    if (aggregateError.errors.length > 0) {\n      return Promise.reject(aggregateError.errors.length > 1 ? aggregateError : aggregateError.errors[0]);\n    }\n\n    Logger.logTrace(loggerCategory, `Requested ${locks.length} locks for iModel`, () => ({ iModelId }));\n\n    return result;\n  }\n\n  /** Get the [[Lock]]s that have been issued for the iModel.\n   * @param requestContext The client request context.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param query Optional query object to filter the queried Locks or select different data from them.\n   * @returns Resolves to an array of Locks matching the query.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: LockQuery = new LockQuery()): Promise<Lock[]> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Querying locks\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    let locks: Lock[];\n    if (query.isMultiLockQuery) {\n      const result = await this._handler.getInstances<MultiLock>(requestContext, MultiLock, this.getRelativeUrl(iModelId), query.getQueryOptions());\n      requestContext.enter();\n      locks = LockHandler.convertMultiLocksToLocks(result);\n    } else {\n      locks = await this._handler.postQuery<Lock>(requestContext, Lock, this.getRelativeUrl(iModelId, false), query.getQueryOptions());\n      requestContext.enter();\n      locks = locks.map((value: Lock) => {\n        const result = new Lock();\n        result.briefcaseId = value.briefcaseId;\n        result.lockLevel = value.lockLevel;\n        result.lockType = value.lockType;\n        result.objectId = value.objectId;\n        if (value.seedFileId)\n          result.seedFileId = value.seedFileId;\n        return result;\n      });\n    }\n\n    Logger.logTrace(loggerCategory, `Queried ${locks.length} locks for iModel`, () => ({ iModelId }));\n    return locks;\n  }\n\n  /** Delete all [[Lock]]s owned by the specified [[Briefcase]].\n   * @param requestContext The client request context.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param briefcaseId Id of the Briefcacase.\n   * @throws [[IModelHubError]] with [IModelHubStatus.BriefcaseDoesNotExist]($bentley) if [[Briefcase]] with specified briefcaseId does not exist. This can happen if number was not given as a Briefcase id yet, or Briefcase with that id was already deleted.\n   * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if [[Briefcase]] belongs to another user and user sending the request does not have ManageResources permission.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async deleteAll(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, briefcaseId: number): Promise<void> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Deleting all locks from briefcase\", () => ({ iModelId, briefcaseId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n    ArgumentCheck.validBriefcaseId(\"briefcaseId\", briefcaseId);\n\n    await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, false, `DeleteAll-${briefcaseId}`));\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, \"Deleted all locks from briefcase\", () => ({ iModelId, briefcaseId }));\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { RequestQueryOptions } from \"./../Request\";\nimport { ArgumentCheck } from \"./Errors\";\nimport { GuidString } from \"@bentley/bentleyjs-core\";\n\n/** Base class for iModelHub Query objects. Query objects are used to modify the results when getting instances from iModelHub.\n * @beta\n */\nexport class Query {\n  protected _query: RequestQueryOptions = {};\n  /**\n   * Translate this object into QueryOptions.\n   * @internal\n   */\n  public getQueryOptions() {\n    return this._query;\n  }\n\n  /**\n   * Reset QueryOptions.\n   * @internal\n   */\n  public resetQueryOptions() {\n    this._query = {};\n  }\n\n  /**\n   * Append a part of the filter.\n   * @internal\n   */\n  protected addFilter(filter: string, operator: \"and\" | \"or\" = \"and\") {\n    if (!this._query.$filter) {\n      this._query.$filter = \"\";\n    } else {\n      this._query.$filter += `+${operator}+`;\n    }\n    this._query.$filter += filter;\n  }\n\n  /**\n   * Set filter to the specified filter string. This resets all previously set filters.\n   * @param filter Filter string to set for the query.\n   * @returns This query.\n   */\n  public filter(filter: string) {\n    this._query.$filter = filter;\n    return this;\n  }\n\n  /**\n   * Append a part of the select.\n   * @internal\n   */\n  protected addSelect(select: string) {\n    if (this._query.$select) {\n      this._query.$select += \",\";\n    }\n    this._query.$select += select;\n    return this;\n  }\n\n  /**\n   * Set select to specified select string. This resets all previously set selects.\n   * @param select Select string to set for the query.\n   * @returns This query.\n   */\n  public select(select: string) {\n    this._query.$select = select;\n    return this;\n  }\n\n  /**\n   * Select only top entries from the query. This is applied after [[Query.skip]].\n   * @param n Number of top entries to select.\n   * @returns This query.\n   */\n  public top(n: number) {\n    this._query.$top = n;\n    return this;\n  }\n\n  /**\n   * Skip first entries in the query. This is applied before [[Query.top]].\n   * @param n Number of entries to skip.\n   * @returns This query.\n   */\n  public skip(n: number) {\n    this._query.$skip = n;\n    return this;\n  }\n\n  /**\n   * Set order for the query. This resets any other orders set.\n   * @param orderBy Order string to set.\n   * @returns This query.\n   */\n  public orderBy(orderBy: string) {\n    this._query.$orderby = orderBy;\n    return this;\n  }\n\n  /**\n   * Select all entries from the query by pages.\n   * @param n Maximum number of entries in a single response.\n   * @returns This query.\n   */\n  public pageSize(n: number) {\n    this._query.$pageSize = n;\n    return this;\n  }\n}\n\n/** Query for instances with string based instance ids.\n * @beta\n */\nexport class StringIdQuery extends Query {\n  /** @internal */\n  protected _byId?: string;\n\n  /**\n   * Query single instance by its id.\n   * @param id Id of the instance to query.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.\n   */\n  public byId(id: string) {\n    this.checkValue(id);\n    this._byId = id;\n    this._query.$pageSize = undefined;\n    return this;\n  }\n\n  /** @internal */\n  protected checkValue(id: string) {\n    ArgumentCheck.valid(\"id\", id);\n  }\n\n  /**\n   * Used by iModelHub handlers to get the id that is queried.\n   * @internal\n   */\n  public getId() {\n    return this._byId;\n  }\n}\n\n/** Query for instances with Guid based instance ids.\n * @beta\n */\nexport class InstanceIdQuery extends Query {\n  /** @internal */\n  protected _byId?: GuidString;\n\n  /**\n   * Query single instance by its id.\n   * @param id Id of the instance to query.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.\n   */\n  public byId(id: GuidString) {\n    ArgumentCheck.validGuid(\"id\", id);\n    this._byId = id;\n    this._query.$pageSize = undefined;\n    return this;\n  }\n\n  /**\n   * Used by iModelHub handlers to get the id that is queried.\n   * @internal\n   */\n  public getId() {\n    return this._byId;\n  }\n}\n\n/**\n * Add select for the download URL to the query.\n * @internal\n */\nexport function addSelectFileAccessKey(query: RequestQueryOptions) {\n  if (!query.$select)\n    query.$select = \"*\";\n\n  query.$select += \",FileAccessKey-forward-AccessKey.DownloadURL\";\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { GuidString, Logger } from \"@bentley/bentleyjs-core\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\nimport { request, RequestOptions } from \"./../Request\";\nimport { IModelBaseHandler } from \"./BaseHandler\";\nimport { ArgumentCheck } from \"./Errors\";\nimport { InstanceIdQuery } from \"./Query\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\n\n/** Thumbnail size. 'Small' is 400x250 PNG image and 'Large' is a 800x500 PNG image.\n * @alpha\n */\nexport type ThumbnailSize = \"Small\" | \"Large\";\n\n/** Base class for Thumbnails.\n * @alpha\n */\nexport abstract class Thumbnail extends WsgInstance {\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\n  public id?: GuidString;\n}\n\n/** Small [[Thumbnail]] class. Small Thumbnail is a 400x250 PNG image.\n * @alpha\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.SmallThumbnail\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class SmallThumbnail extends Thumbnail { }\n\n/** Large [[Thumbnail]] class. Large Thumbnail is a 800x500 PNG image.\n * @alpha\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.LargeThumbnail\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class LargeThumbnail extends Thumbnail { }\n\n/** Tip [[Thumbnail]] download parameters. See [[ThumbnailHandler.download]]. Tip Thumbnail is generated for the periodically updated master file copy on iModelHub.\n * @alpha\n */\nexport interface TipThumbnail {\n  /** Id of the iModel's context ([[Project]] or [[Asset]]). */\n  contextId: string;\n  /** Size of the [[Thumbnail]]. */\n  size: ThumbnailSize;\n}\n\n/**\n * Query object for getting [[Thumbnail]]s. You can use this to modify the [[ThumbnailHandler.get]] results.\n * @alpha\n */\nexport class ThumbnailQuery extends InstanceIdQuery {\n  /**\n   * Query [[Thumbnail]]s by [[Version]] id.\n   * @param versionId Id of the version.\n   * @returns This query.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if versionId is undefined or it is not a valid [GuidString]($bentley) value.\n   */\n  public byVersionId(versionId: GuidString) {\n    ArgumentCheck.validGuid(\"versionId\", versionId);\n    this.addFilter(`HasThumbnail-backward-Version.Id+eq+'${versionId}'`);\n    return this;\n  }\n}\n\n/**\n * Handler for retrieving [[Thumbnail]]s. Use [[IModelClient.Thumbnails]] to get an instance of this class.\n * @alpha\n */\nexport class ThumbnailHandler {\n  private _handler: IModelBaseHandler;\n\n  /**\n   * Constructor for ThumbnailHandler.\n   * @param handler Handler for WSG requests.\n   * @internal\n   */\n  constructor(handler: IModelBaseHandler) {\n    this._handler = handler;\n  }\n\n  /** Get relative url for tip Thumbnail requests.\n   * @param contextId Id of the context ([[Project]] or [[Asset]]).\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param size Size of the thumbnail.\n   */\n  private getRelativeContextUrl(contextId: string, iModelId: GuidString, size: ThumbnailSize) {\n    return `/Repositories/Context--${this._handler.formatContextIdForUrl(contextId)}/ContextScope/${size}Thumbnail/${iModelId.toString()}/$file`;\n  }\n\n  /** Get relative url for Thumbnail requests.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param size Size of the thumbnail.\n   * @param thumbnailId Id of the thumbnail.\n   */\n  private getRelativeUrl(iModelId: GuidString, size: ThumbnailSize, thumbnailId?: GuidString) {\n    return `/Repositories/iModel--${iModelId}/iModelScope/${size}Thumbnail/${thumbnailId || \"\"}`;\n  }\n\n  /** Check if given thumbnail is TipThumbnail.\n   * @param thumbnail SmallThumbnail, LargeThumbnail or TipThumbnail.\n   */\n  private isTipThumbnail(thumbnail: Thumbnail | TipThumbnail): thumbnail is TipThumbnail {\n    return (thumbnail as TipThumbnail).contextId !== undefined;\n  }\n\n  /** Download the thumbnail.\n   * @param requestContext The client request context.\n   * @param url Url to download thumbnail.\n   * @return String for the PNG image that includes the base64 encoded array of the image bytes.\n   */\n  private async downloadThumbnail(requestContext: AuthorizedClientRequestContext, url: string): Promise<string> {\n    requestContext.enter();\n    const options: RequestOptions = {\n      method: \"GET\",\n      headers: { authorization: requestContext.accessToken.toTokenString() },\n      responseType: \"arraybuffer\",\n      agent: this._handler.getAgent(),\n    };\n\n    const response = await request(requestContext, url, options);\n    requestContext.enter();\n\n    const byteArray = new Uint8Array(response.body);\n    if (!byteArray || byteArray.length === 0) {\n      return Promise.reject(new Error(\"Expected an image to be returned from the query\"));\n    }\n\n    const base64Data = Base64.btoa(String.fromCharCode(...byteArray));\n    return \"data:image/png;base64,\" + base64Data;\n  }\n\n  /** Download the latest iModel's thumbnail.\n   * @param requestContext The client request context.\n   * @param contextId Id of the connect context.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param size Size of the thumbnail. Pass 'Small' for 400x250 PNG image, and 'Large' for a 800x500 PNG image.\n   * @return String for the PNG image that includes the base64 encoded array of the image bytes.\n   */\n  private async downloadTipThumbnail(requestContext: AuthorizedClientRequestContext, contextId: string, iModelId: GuidString, size: ThumbnailSize): Promise<string> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, `Downloading tip ${size}Thumbnail`, () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"contextId\", contextId);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    const url: string = await this._handler.getUrl(requestContext) + this.getRelativeContextUrl(contextId, iModelId, size);\n    const pngImage = await this.downloadThumbnail(requestContext, url);\n    requestContext.enter();\n\n    Logger.logTrace(loggerCategory, `Downloaded tip ${size}Thumbnail`, () => ({ iModelId }));\n    return pngImage;\n  }\n\n  /** Get the [[Thumbnail]]s. Returned Thumbnails are ordered from the latest [[ChangeSet]] to the oldest.\n   * @param requestContext The client request context.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param size Size of the thumbnail.\n   * @param query Optional query object to filter the queried Thumbnails.\n   * @return Array of Thumbnails of the specified size that match the query.\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n   */\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, size: ThumbnailSize, query: ThumbnailQuery = new ThumbnailQuery()): Promise<Thumbnail[]> {\n    requestContext.enter();\n    Logger.logInfo(loggerCategory, \"Querying iModel thumbnails\", () => ({ iModelId }));\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    let thumbnails = [];\n    if (size === \"Small\")\n      thumbnails = await this._handler.getInstances<SmallThumbnail>(requestContext, SmallThumbnail, this.getRelativeUrl(iModelId, size, query.getId()), query.getQueryOptions());\n    else\n      thumbnails = await this._handler.getInstances<LargeThumbnail>(requestContext, LargeThumbnail, this.getRelativeUrl(iModelId, size, query.getId()), query.getQueryOptions());\n\n    Logger.logTrace(loggerCategory, \"Queried iModel thumbnails\", () => ({ iModelId }));\n    return thumbnails;\n  }\n\n  /** Download a [[Thumbnail]].\n   * @param requestContext The client request context.\n   * @param iModelId Id of the iModel. See [[HubIModel]].\n   * @param thumbnail Small, Large or Tip thumbnail. Use [[ThumbnailHandler.get]] to get a [[SmallThumbnail]] or [[LargeThumbnail]] instance or provide Tip thumbnail information by constructing a [[TipThumbnail]] instance.\n   * @return Base64 encoded string containing the PNG image.\n   * @throws Error if a successful server response contains no content.\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.\n   * @throws [[ResponseError]] if a network issue occurs.\n   */\n  public async download(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, thumbnail: Thumbnail | TipThumbnail): Promise<string> {\n    requestContext.enter();\n    ArgumentCheck.defined(\"requestContext\", requestContext);\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n    if (this.isTipThumbnail(thumbnail)) {\n      return this.downloadTipThumbnail(requestContext, thumbnail.contextId, iModelId, thumbnail.size);\n    }\n\n    const size: ThumbnailSize = thumbnail instanceof SmallThumbnail ? \"Small\" : \"Large\";\n    const thumbnailId: GuidString = thumbnail.id!;\n\n    Logger.logInfo(loggerCategory, `Downloading ${size}Thumbnail ${thumbnailId} for iModel`, () => ({ iModelId }));\n\n    const url: string = await this._handler.getUrl(requestContext) + this.getRelativeUrl(iModelId, size, thumbnailId) + \"/$file\";\n    const pngImage = await this.downloadThumbnail(requestContext, url);\n    requestContext.enter();\n    Logger.logTrace(loggerCategory, `Downloaded ${size}Thumbnail ${thumbnailId} for iModel`, () => ({ iModelId }));\n    return pngImage;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHub */\r\n\r\nimport { GuidString, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { ArgumentCheck } from \"./Errors\";\r\nimport { Query } from \"./Query\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\r\n\r\n/** Information about the user, allowing to identify them based on their id.\r\n * @alpha\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.UserInfo\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class HubUserInfo extends WsgInstance {\r\n  /** Id of the user. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Id\")\r\n  public id?: string;\r\n\r\n  /** First name of the user. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Name\")\r\n  public firstName?: string;\r\n\r\n  /** Last name of the user. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Surname\")\r\n  public lastName?: string;\r\n\r\n  /** Email address of the user. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Email\")\r\n  public email?: string;\r\n}\r\n\r\n/** Statistics of user created and owned instances on the iModel.\r\n * @alpha\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.UserInfo\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class UserStatistics extends HubUserInfo {\r\n  /** Number of [[Briefcase]]s the user currently owns. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.BriefcasesCount\")\r\n  public briefcasesCount?: number;\r\n\r\n  /** Number of [[Lock]]s the user currently owns. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.OwnedLocksCount\")\r\n  public ownedLocksCount?: number;\r\n\r\n  /** Number of [[ChangeSet]]s the user has pushed. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.PushedChangeSetsCount\")\r\n  public pushedChangeSetsCount?: number;\r\n\r\n  /** Date of the last [[ChangeSet]] the user has pushed to this iModel. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.LastChangeSetPushDate\")\r\n  public lastChangeSetPushDate?: string;\r\n}\r\n\r\n/**\r\n * Query object for getting User Statistics. You can use this to modify the [[UserStatisticsHandler.get]] results.\r\n * @alpha\r\n */\r\nexport class UserStatisticsQuery extends Query {\r\n  /** @internal */\r\n  protected _byId?: string;\r\n\r\n  private _statisticsPrefix = \"HasStatistics-forward-Statistics\";\r\n  private _queriedByIds = false;\r\n  /**\r\n   * Constructor for UserStatisticsQuery.\r\n   * @internal\r\n   */\r\n  constructor() {\r\n    super();\r\n    this.select(`*`);\r\n  }\r\n\r\n  /**\r\n   * Query single instance by its id.\r\n   * @param id Id of the instance to query.\r\n   * @returns This query.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.\r\n   */\r\n  public byId(id: string) {\r\n    ArgumentCheck.validGuid(\"id\", id);\r\n    this._byId = id;\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Used by iModelHub handlers to get the id that is queried.\r\n   * @internal\r\n   */\r\n  public getId() {\r\n    return this._byId;\r\n  }\r\n\r\n  /**\r\n   * Query User Statistics by ids.\r\n   * @param ids Ids of the users.\r\n   * @returns This query.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if ids array is undefined or empty, or it contains invalid [GuidString]($bentley) values.\r\n   */\r\n  public byIds(ids: string[]) {\r\n    ArgumentCheck.nonEmptyArray(\"ids\", ids);\r\n\r\n    let filter = \"$id+in+[\";\r\n    ids.forEach((id, index) => {\r\n      ArgumentCheck.validGuid(`ids[${index}]`, id);\r\n      if (index > 0)\r\n        filter += \",\";\r\n      filter += `'${id}'`;\r\n    });\r\n    filter += \"]\";\r\n\r\n    this.addFilter(filter);\r\n    this._queriedByIds = true;\r\n    return this;\r\n  }\r\n\r\n  /** Select all statistics. */\r\n  public selectAll() {\r\n    return this.addSelect(`${this._statisticsPrefix}.*`);\r\n  }\r\n\r\n  /** Select currently owned [[Briefcase]]s count. */\r\n  public selectBriefcasesCount() {\r\n    return this.addSelect(`${this._statisticsPrefix}.BriefcasesCount`);\r\n  }\r\n\r\n  /** Select total pushed [[ChangeSet]]s count. */\r\n  public selectPushedChangeSetsCount() {\r\n    return this.addSelect(`${this._statisticsPrefix}.PushedChangeSetsCount`);\r\n  }\r\n\r\n  /** Select currently owned [[Lock]]s count. */\r\n  public selectOwnedLocksCount() {\r\n    return this.addSelect(`${this._statisticsPrefix}.OwnedLocksCount`);\r\n  }\r\n\r\n  /** Select the last [[ChangeSet]] push date. */\r\n  public selectLastChangeSetPushDate() {\r\n    return this.addSelect(`${this._statisticsPrefix}.LastChangeSetPushDate`);\r\n  }\r\n\r\n  /**\r\n   * Returns whether was object queried by ids or no\r\n   * @internal\r\n   */\r\n  public get isQueriedByIds() {\r\n    return this._queriedByIds;\r\n  }\r\n}\r\n\r\n/**\r\n * Handler for querying [[UserStatistics]]. Use [[UserInfoHandler.Statistics]] to get an instance of this class.\r\n * @alpha\r\n */\r\nexport class UserStatisticsHandler {\r\n  private _handler: IModelBaseHandler;\r\n  /**\r\n   * Constructor for UserStatistics. Should use @see IModelClient instead of directly constructing this.\r\n   * @param handler Handler for WSG requests.\r\n   * @internal\r\n   */\r\n  constructor(handler: IModelBaseHandler) {\r\n    this._handler = handler;\r\n  }\r\n\r\n  /** Get relative url for UserStatistics requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param userId Id of the user.\r\n   */\r\n  private getRelativeUrl(iModelId: GuidString, userId?: string) {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/UserInfo/${userId ? userId : \"\"}`;\r\n  }\r\n\r\n  /** Get [[UserStatistics]].\r\n   * @param requestContext The client request context.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param query Optional query object to filter the queried [[UserStatistics]] or select different data from them.\r\n   * @returns Array of [[UserStatistics]] for users matching the query.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString,\r\n    query: UserStatisticsQuery = new UserStatisticsQuery()): Promise<UserStatistics[]> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Querying user statistics for iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    // if there are no specific selects defined, select all statistics\r\n    if (query.getQueryOptions().$select === \"*\") {\r\n      query.selectAll();\r\n    }\r\n\r\n    let userStatistics: UserStatistics[];\r\n    if (query.isQueriedByIds) {\r\n      userStatistics = await this._handler.postQuery<UserStatistics>(requestContext, UserStatistics,\r\n        this.getRelativeUrl(iModelId), query.getQueryOptions());\r\n    } else {\r\n      userStatistics = await this._handler.getInstances<UserStatistics>(requestContext, UserStatistics,\r\n        this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());\r\n    }\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, `Queried ${userStatistics.length} user statistics for iModel`, () => ({ iModelId }));\r\n    return userStatistics;\r\n  }\r\n}\r\n\r\n/** Query object for getting [[HubUserInfo]]. You can use this to modify the [[UserInfoHandler.get]] results.\r\n * @alpha\r\n */\r\nexport class UserInfoQuery extends Query {\r\n  private _queriedByIds = false;\r\n  /** @internal */\r\n  protected _byId?: string;\r\n\r\n  /** Query UserInfo by user ids.\r\n   * @param ids Ids of the users.\r\n   * @returns This query.\r\n   * @throws [[IModelHubClientError]] if ids array is empty.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if ids array is undefined or empty, or it contains non-Guid values.\r\n   */\r\n  public byIds(ids: string[]) {\r\n    ArgumentCheck.nonEmptyArray(\"ids\", ids);\r\n\r\n    let filter = \"$id+in+[\";\r\n    ids.forEach((id, index) => {\r\n      ArgumentCheck.validGuid(`id[${index}]`, id);\r\n      if (index > 0)\r\n        filter += \",\";\r\n      filter += `'${id}'`;\r\n    });\r\n    filter += \"]\";\r\n\r\n    this.addFilter(filter);\r\n    this._queriedByIds = true;\r\n    return this;\r\n  }\r\n\r\n  /** @internal */\r\n  public get isQueriedByIds() {\r\n    return this._queriedByIds;\r\n  }\r\n\r\n  /** Query single instance by its id.\r\n   * @param id Id of the instance to query.\r\n   * @returns This query.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.\r\n   */\r\n  public byId(id: string) {\r\n    ArgumentCheck.validGuid(\"id\", id);\r\n    this._byId = id;\r\n    return this;\r\n  }\r\n\r\n  /** Used by iModelHub handlers to get the id that is queried.\r\n   * @internal\r\n   */\r\n  public getId() {\r\n    return this._byId;\r\n  }\r\n}\r\n\r\n/** Handler for querying [[HubUserInfo]]. Use [[IModelClient.Users]] to get an instance of this class.\r\n * @alpha\r\n */\r\nexport class UserInfoHandler {\r\n  private _handler: IModelBaseHandler;\r\n\r\n  /** Constructor for UserInfoHandler.\r\n   * @param handler Handler for WSG requests.\r\n   * @internal\r\n   */\r\n  constructor(handler: IModelBaseHandler) {\r\n    this._handler = handler;\r\n  }\r\n\r\n  /** Get the handler for querying [[UserStatistics]]. */\r\n  public get statistics(): UserStatisticsHandler {\r\n    return new UserStatisticsHandler(this._handler);\r\n  }\r\n\r\n  /** Get relative url for UserInfo requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param userId Id of the user.\r\n   */\r\n  private getRelativeUrl(iModelId: GuidString, userId?: string) {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/UserInfo/${userId || \"\"}`;\r\n  }\r\n\r\n  /** Get the information on users who have accessed the iModel.\r\n   * @param requestContext The client request context.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param query Optional query object to filter the queried users or select different data from them.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: UserInfoQuery = new UserInfoQuery()): Promise<HubUserInfo[]> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Querying users for iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    let users: HubUserInfo[];\r\n    if (query.isQueriedByIds) {\r\n      users = await this._handler.postQuery<HubUserInfo>(requestContext, HubUserInfo, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());\r\n    } else {\r\n      users = await this._handler.getInstances<HubUserInfo>(requestContext, HubUserInfo, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());\r\n    }\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Queried users for iModel\", () => ({ iModelId }));\r\n    return users;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module iModelHub */\r\n\r\nimport { GuidString, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\r\nimport { IModelBaseHandler } from \"./BaseHandler\";\r\nimport { ArgumentCheck } from \"./Errors\";\r\nimport { InstanceIdQuery } from \"./Query\";\r\nimport { ThumbnailSize } from \"./Thumbnails\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\r\n\r\n/**\r\n * Named Version is a specific [[ChangeSet]] given a name to differentiate it from others. It can be used to represent some significant milestone for the iModel (e.g. a review version).\r\n * @beta\r\n */\r\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.Version\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\r\nexport class Version extends WsgInstance {\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\r\n  public id?: GuidString;\r\n\r\n  /** Description of the named Version. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Description\")\r\n  public description?: string;\r\n\r\n  /** Name of the named Version. Must be unique per iModel. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Name\")\r\n  public name?: string;\r\n\r\n  /** Id of the user that created the named Version. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UserCreated\")\r\n  public userCreated?: string;\r\n\r\n  /** Date when the named Version was created. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatedDate\")\r\n  public createdDate?: string;\r\n\r\n  /** Id of the [[ChangeSet]] that the named Version was created for. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.ChangeSetId\")\r\n  public changeSetId?: GuidString;\r\n\r\n  /** Id of the [[SmallThumbnail]] of the named Version. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId\")\r\n  public smallThumbnailId?: GuidString;\r\n\r\n  /** Id of the [[LargeThumbnail]] of the named Version. */\r\n  @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[HasThumbnail].relatedInstance[LargeThumbnail].instanceId\")\r\n  public largeThumbnailId?: GuidString;\r\n}\r\n\r\n/**\r\n * Query object for getting [[Version]]s. You can use this to modify the [[VersionHandler.get]] results.\r\n * @beta\r\n */\r\nexport class VersionQuery extends InstanceIdQuery {\r\n  /**\r\n   * Query [[Version]] by its name.\r\n   * @param name Name of the Version.\r\n   * @returns This query.\r\n   * @throws [IModelHubClientError]($clients) with [IModelHubStatus.UndefinedArgumentError]($bentley) if name is undefined or empty.\r\n   */\r\n  public byName(name: string) {\r\n    ArgumentCheck.defined(\"name\", name);\r\n    this.addFilter(`Name+eq+'${name}'`);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query version by its [[ChangeSet]] id.\r\n   * @param changesetId Id of the ChangeSet.\r\n   * @returns This query.\r\n   * @throws [IModelHubClientError]($clients) with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if changeSetId is undefined or not a valid [[ChangeSet.id]] format.\r\n   */\r\n  public byChangeSet(changesetId: string) {\r\n    ArgumentCheck.validChangeSetId(\"changesetId\", changesetId);\r\n    this.addFilter(`ChangeSetId+eq+'${changesetId}'`);\r\n    return this;\r\n  }\r\n\r\n  /**\r\n   * Query will additionally select ids of [[Thumbnail]]s for given [[ThumbnailSize]]s.\r\n   * @returns This query.\r\n   * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if sizes array is undefined or empty.\r\n   * @alpha\r\n   */\r\n  public selectThumbnailId(...sizes: ThumbnailSize[]): this {\r\n    ArgumentCheck.nonEmptyArray(\"sizes\", sizes);\r\n    if (!this._query.$select)\r\n      this._query.$select = \"*\";\r\n\r\n    for (const size of sizes) {\r\n      this._query.$select += `,HasThumbnail-forward-${size}Thumbnail.*`;\r\n    }\r\n\r\n    return this;\r\n  }\r\n}\r\n\r\n/**\r\n * Handler for managing [[Version]]s. Use [[IModelClient.Versions]] to get an instance of this class.\r\n * @beta\r\n */\r\nexport class VersionHandler {\r\n  private _handler: IModelBaseHandler;\r\n  /**\r\n   * Constructor for VersionHandler.\r\n   * @param handler Handler for WSG requests.\r\n   * @internal\r\n   */\r\n  constructor(handler: IModelBaseHandler) {\r\n    this._handler = handler;\r\n  }\r\n\r\n  /** Get relative url for Version requests.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param versionId Id of the version.\r\n   */\r\n  private getRelativeUrl(iModelId: GuidString, versionId?: GuidString) {\r\n    return `/Repositories/iModel--${iModelId}/iModelScope/Version/${versionId || \"\"}`;\r\n  }\r\n\r\n  /** Get the named [[Version]]s of an iModel. Returned Versions are ordered from the latest [[ChangeSet]] to the oldest.\r\n   * @param requestContext The client request context.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param query Optional query object to filter the queried Versions or select different data from them.\r\n   * @returns Versions that match the query.\r\n   * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[InstanceIdQuery.byId]] is used and a [[Version]] with the specified id could not be found.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: VersionQuery = new VersionQuery()): Promise<Version[]> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Querying named versions for iModel\", () => ({ iModelId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n\r\n    const versions = await this._handler.getInstances<Version>(requestContext, Version, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Queried named versions for iModel\", () => ({ iModelId }));\r\n    return versions;\r\n  }\r\n\r\n  /** Create a named [[Version]] of an iModel.\r\n   * @param requestContext The client request context.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param changeSetId Id of the [[ChangeSet]] to create a named Version for.\r\n   * @param name Name of the new named Version.\r\n   * @param description Description of the new named Version.\r\n   * @returns Created Version instance.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have ManageVersions permission.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.ChangeSetDoesNotExist]($bentley) if the [[ChangeSet]] with specified changeSetId does not exist.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.VersionAlreadyExists]($bentley) if a named [[Version]] already exists with the specified name.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.ChangeSetAlreadyHasVersion]($bentley) if the [[ChangeSet]] with specified changeSetId already has a named [[Version]] associated with it.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async create(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, changeSetId: string, name: string, description?: string): Promise<Version> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Creating named version for iModel\", () => ({ iModelId, changeSetId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n    ArgumentCheck.validChangeSetId(\"changeSetId\", changeSetId);\r\n    ArgumentCheck.defined(\"name\", name);\r\n\r\n    let version = new Version();\r\n    version.changeSetId = changeSetId;\r\n    version.name = name;\r\n    version.description = description;\r\n\r\n    version = await this._handler.postInstance<Version>(requestContext, Version, this.getRelativeUrl(iModelId), version);\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Created named version for iModel\", () => ({ iModelId, changeSetId }));\r\n    return version;\r\n  }\r\n\r\n  /** Update the named [[Version]] of an iModel. Only the description can be changed when updating the named Version.\r\n   * @param requestContext The client request context.\r\n   * @param iModelId Id of the iModel. See [[HubIModel]].\r\n   * @param version Named version to update.\r\n   * @returns Updated Version instance from iModelHub.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have ManageVersions permission.\r\n   * @throws [[IModelHubError]] with [IModelHubStatus.VersionAlreadyExists]($bentley) if a named [[Version]] already exists with the specified name.\r\n   * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\r\n   */\r\n  public async update(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, version: Version): Promise<Version> {\r\n    requestContext.enter();\r\n    Logger.logInfo(loggerCategory, \"Updating named version for iModel\", () => ({ iModelId, changeSetId: version.changeSetId }));\r\n    ArgumentCheck.defined(\"requestContext\", requestContext);\r\n    ArgumentCheck.validGuid(\"iModelId\", iModelId);\r\n    ArgumentCheck.validGuid(\"version.wsgId\", version.wsgId);\r\n\r\n    const updatedVersion = await this._handler.postInstance<Version>(requestContext, Version, this.getRelativeUrl(iModelId, version.id), version);\r\n    requestContext.enter();\r\n    Logger.logTrace(loggerCategory, \"Updated named version for iModel\", () => ({ iModelId, changeSetId: version.changeSetId }));\r\n    return updatedVersion;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module iModelHub */\n\nimport { GuidString, IModelHubStatus, Logger } from \"@bentley/bentleyjs-core\";\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\nimport { FileHandler } from \"../FileHandler\";\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\nimport { ProgressInfo } from \"../Request\";\nimport { ECJsonTypeMap, WsgInstance } from \"./../ECJsonTypeMap\";\nimport { IModelBaseHandler } from \"./BaseHandler\";\nimport { ArgumentCheck, IModelHubClientError, IModelHubError } from \"./Errors\";\nimport { addSelectFileAccessKey, InstanceIdQuery } from \"./Query\";\n\nconst loggerCategory: string = ClientsLoggerCategory.IModelHub;\nconst iModelTemplateEmpty = \"Empty\";\n\n/**\n * HubIModel represents an iModel on iModelHub. Getting a valid HubIModel instance from iModelHub is required for majority of iModelHub method calls, as wsgId of this object needs to be passed as iModelId argument to those methods.\n *\n * For iModel representation in iModel.js, see [IModel]($common). For the file that is used for that iModel, see [IModelDb]($backend).\n * @beta\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"ContextScope.iModel\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class HubIModel extends WsgInstance {\n    /** Id of the iModel. */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\n    public id?: GuidString;\n\n    /** Description of the iModel. */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Description\")\n    public description?: string;\n\n    /** Name of the iModel. iModels must have unique names per context ([[Project]] or [[Asset]]). */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Name\")\n    public name?: string;\n\n    /** Id of the user that created the iModel. */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UserCreated\")\n    public userCreated?: string;\n\n    /** Date when iModel was created. */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.CreatedDate\")\n    public createdDate?: string;\n\n    /** Set to true, when iModel is ready to be used. See [[IModelHandler.create]]. */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Initialized\")\n    public initialized?: boolean;\n\n    /** Set when creating iModel from empty seed file\n     * @internal\n     */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.iModelTemplate\")\n    public iModelTemplate?: string;\n}\n\n/** Initialization state of seed file. Can be queried with [[IModelHandler.getInitializationState]]. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).\n * @beta\n */\nexport enum InitializationState {\n    /** Initialization was successful. */\n    Successful = 0,\n    /** Initialization has not started, seed file has not yet been uploaded. */\n    NotStarted = 1,\n    /** Initialization has been scheduled and has not completed yet. */\n    Scheduled = 2,\n    /** Initialization failed with a generic error. */\n    Failed = 3,\n    /** Initialization failed due to file having outdated schemas. */\n    OutdatedFile = 4,\n    /** Initialization failed due to file having [[Code]] values that are too long. */\n    CodeTooLong = 5,\n    /** Initialization failed due to file being a [[Briefcase]]. Only standalone and master files are supported for iModel creation, see [BriefcaseId]($backend). */\n    SeedFileIsBriefcase = 6,\n}\n\n/** SeedFile\n * @internal\n */\n@ECJsonTypeMap.classToJson(\"wsg\", \"iModelScope.SeedFile\", { schemaPropertyName: \"schemaName\", classPropertyName: \"className\" })\nexport class SeedFile extends WsgInstance {\n    /** Id of the iModel. */\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"instanceId\")\n    public id?: GuidString;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileName\")\n    public fileName?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileDescription\")\n    public fileDescription?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileSize\")\n    public fileSize?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.FileId\")\n    public fileId?: GuidString;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.Index\")\n    public index?: number;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IModelName\")\n    public iModelName?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.MergedChangeSetId\")\n    public mergedChangeSetId?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UserUploaded\")\n    public userUploaded?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.UploadedDate\")\n    public uploadedDate?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.IsUploaded\")\n    public isUploaded?: boolean;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"properties.InitializationState\")\n    public initializationState?: InitializationState;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl\")\n    public downloadUrl?: string;\n\n    @ECJsonTypeMap.propertyToJson(\"wsg\", \"relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.UploadUrl\")\n    public uploadUrl?: string;\n}\n\n/** Query object for getting SeedFiles. You can use this to modify the query. See [[SeedFileHandler.get]]. */\nclass SeedFileQuery extends InstanceIdQuery {\n    /**\n     * Query will additionally select SeedFile file download URL.\n     * @returns This query.\n     */\n    public selectDownloadUrl() {\n        addSelectFileAccessKey(this._query);\n        return this;\n    }\n\n    /**\n     * Change the order to latest changesets first in the query.\n     * @returns This query.\n     */\n    public latest() {\n        this._query.$orderby = \"Index+desc\";\n        return this;\n    }\n}\n\n/** Handler for all methods related to @see SeedFile instances. */\nclass SeedFileHandler {\n    private _handler: IModelBaseHandler;\n    private _fileHandler?: FileHandler;\n\n    /** Constructor for SeedFileHandler. Should use @see IModelHandler instead of directly constructing this.\n     * @param handler Handler for WSG requests.\n     * @param fileHandler Handler for file system.\n     */\n    constructor(handler: IModelBaseHandler, fileHandler?: FileHandler) {\n        this._handler = handler;\n        this._fileHandler = fileHandler;\n    }\n\n    /** Get relative url for SeedFile requests.\n     * @param iModelId Id of the iModel. See [[HubIModel]].\n     * @param fileId Id of the Seed File.\n     */\n    private getRelativeUrl(iModelId: GuidString, fileId?: GuidString) {\n        return `/Repositories/iModel--${iModelId}/iModelScope/SeedFile/${fileId || \"\"}`;\n    }\n\n    /** Get the seed files given the id of the iModel.\n     * @param requestContext The client request context.\n     * @param iModelId Id of the iModel. See [[HubIModel]].\n     * @param query Optional query object to filter the queried SeedFiles or select different data from them.\n     * @returns Resolves to the seed file.\n     */\n    public async get(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, query: SeedFileQuery = new SeedFileQuery()): Promise<SeedFile[]> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Started querying seed files\", () => ({ iModelId }));\n\n        const seedFiles = await this._handler.getInstances<SeedFile>(requestContext, SeedFile, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());\n        requestContext.enter();\n\n        Logger.logInfo(loggerCategory, \"Finished querying seed files\", () => ({ iModelId, count: seedFiles.length }));\n        return seedFiles;\n    }\n\n    /** Upload the seed file. Use [[confirmUploadSeedFile]] to confirm the completion of the upload.\n     * @param requestContext The client request context.\n     * @param iModelId Id of the iModel. See [[HubIModel]].\n     * @param seedFile Information of the SeedFile to be uploaded.\n     * @param seedPath Path of the SeedFile to be uploaded.\n     * @param progressCallback Callback for tracking progress.\n     */\n    public async uploadSeedFile(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, seedPath: string, seedFileDescription?: string, progressCallback?: (progress: ProgressInfo) => void): Promise<SeedFile> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Started uploading seed file\", () => ({ iModelId, seedPath }));\n\n        const seedFile = new SeedFile();\n        seedFile.fileName = this._fileHandler!.basename(seedPath);\n        seedFile.fileSize = this._fileHandler!.getFileSize(seedPath).toString();\n        if (seedFileDescription)\n            seedFile.fileDescription = seedFileDescription;\n\n        const createdSeedFile: SeedFile = await this._handler.postInstance<SeedFile>(requestContext, SeedFile, this.getRelativeUrl(iModelId), seedFile);\n        requestContext.enter();\n        await this._fileHandler!.uploadFile(requestContext, createdSeedFile.uploadUrl!, seedPath, progressCallback);\n        requestContext.enter();\n        createdSeedFile.uploadUrl = undefined;\n        createdSeedFile.downloadUrl = undefined;\n        createdSeedFile.isUploaded = true;\n\n        const confirmSeedFile: SeedFile = await this._handler.postInstance<SeedFile>(requestContext, SeedFile, this.getRelativeUrl(iModelId, createdSeedFile.id), createdSeedFile);\n        requestContext.enter();\n        Logger.logTrace(loggerCategory, \"Finished uploading seed file\", () => confirmSeedFile);\n\n        return confirmSeedFile;\n    }\n}\n\n/**\n * Query object for getting [[HubIModel]] instances. You can use this to modify the [[IModelsHandler.get]] results.\n * @beta\n */\nexport class IModelQuery extends InstanceIdQuery {\n    /**\n     * Query iModel by its name.\n     * @param name Name of the iModel.\n     * @returns This query.\n     * @throws [IModelHubClientError]($clients) with [IModelHubStatus.UndefinedArgumentError]($bentley) if name is undefined or empty.\n     */\n    public byName(name: string) {\n        ArgumentCheck.defined(\"name\", name);\n        this.addFilter(`Name+eq+'${name}'`);\n        return this;\n    }\n}\n\n/**\n * Handler for managing [[HubIModel]] instances. Use [[IModelHubClient.IModels]] to get an instance of this handler.\n * @note Use [[IModelHubClient.IModel]] for the preferred single iModel per context workflow.\n * @beta\n */\nexport class IModelsHandler {\n    private _handler: IModelBaseHandler;\n    private _fileHandler?: FileHandler;\n    private _seedFileHandler: SeedFileHandler;\n\n    /** Constructor for IModelsHandler. Should use @see IModelClient instead of directly constructing this.\n     * @param handler Handler for WSG requests.\n     * @param fileHandler Handler for file system.\n     * @note Use [[IModelHubClient.IModel]] for the preferred single iModel per context workflow.\n     * @internal\n     */\n    constructor(handler: IModelBaseHandler, fileHandler?: FileHandler) {\n        this._handler = handler;\n        this._fileHandler = fileHandler;\n        this._seedFileHandler = new SeedFileHandler(this._handler, this._fileHandler);\n    }\n\n    /** Get relative url for iModel requests.\n     * @param contextId Id of the context.\n     * @param iModelId Id of the iModel. See [[HubIModel]].\n     */\n    private getRelativeUrl(contextId: string, iModelId?: GuidString) {\n        return `/Repositories/Context--${this._handler.formatContextIdForUrl(contextId)}/ContextScope/iModel/${iModelId || \"\"}`;\n    }\n\n    /** Get iModels that belong to the specified context.\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param query Optional query object to filter the queried iModels or select different data from them.\n     * @returns [[HubIModel]] instances that match the query.\n     * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[InstanceIdQuery.byId]] is used and an HubIModel with the specified id could not be found.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async get(requestContext: AuthorizedClientRequestContext, contextId: string, query: IModelQuery = new IModelQuery()): Promise<HubIModel[]> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, `Started querying iModels in context`, () => ({ contextId }));\n        ArgumentCheck.defined(\"requestContext\", requestContext);\n        ArgumentCheck.defined(\"contextId\", contextId); // contextId is a GUID for iModelHub and a JSON representation of an IModelBankAccessContext for iModelBank.\n\n        const imodels = await this._handler.getInstances<HubIModel>(requestContext, HubIModel, this.getRelativeUrl(contextId, query.getId()), query.getQueryOptions());\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, `Finished querying iModels in context`, () => ({ contextId, count: imodels.length }));\n\n        return imodels;\n    }\n\n    /**\n     * Delete an iModel with specified id from a context. This method is not supported in iModelBank.\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param iModelId Id of the iModel to be deleted. See [[HubIModel]].\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel with specified id does not exist.\n     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have DeleteiModel permission.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async delete(requestContext: AuthorizedClientRequestContext, contextId: string, iModelId: GuidString): Promise<void> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Started deleting iModel\", () => ({ iModelId, contextId }));\n        ArgumentCheck.defined(\"requestContext\", requestContext);\n        ArgumentCheck.validGuid(\"contextId\", contextId);\n        ArgumentCheck.validGuid(\"iModelId\", iModelId);\n\n        if (this._handler.getCustomRequestOptions().isSet) {\n            // to add custom request options, request with body is needed.\n            const imodel = new HubIModel();\n            imodel.id = iModelId;\n            imodel.changeState = \"deleted\";\n            await this._handler.deleteInstance(requestContext, this.getRelativeUrl(contextId, iModelId), imodel);\n        } else {\n            await this._handler.delete(requestContext, this.getRelativeUrl(contextId, iModelId));\n        }\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Finished deleting iModel\", () => ({ iModelId, contextId }));\n    }\n\n    /** Create an iModel instance\n     * @param requestContext The client request context.\n     * @param contextId Id of the connect context.\n     * @param iModelName Name of the iModel on the Hub.\n     * @param description Description of the iModel on the Hub.\n     * @param iModelTemplate iModel template.\n     * @internal\n     */\n    private async createIModelInstance(requestContext: AuthorizedClientRequestContext, contextId: string, iModelName: string, description?: string, iModelTemplate?: string): Promise<HubIModel> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, `Creating iModel with name ${iModelName}`, () => ({ contextId }));\n\n        let imodel: HubIModel;\n        const iModel = new HubIModel();\n        iModel.name = iModelName;\n        if (description)\n            iModel.description = description;\n        if (iModelTemplate)\n            iModel.iModelTemplate = iModelTemplate;\n\n        try {\n            imodel = await this._handler.postInstance<HubIModel>(requestContext, HubIModel, this.getRelativeUrl(contextId), iModel);\n            requestContext.enter();\n            Logger.logTrace(loggerCategory, `Created iModel instance with name ${iModelName}`, () => ({ contextId }));\n        } catch (err) {\n            requestContext.enter();\n            if (!(err instanceof IModelHubError) || IModelHubStatus.iModelAlreadyExists !== err.errorNumber) {\n                Logger.logWarning(loggerCategory, `Can not create iModel: ${err.message}`, () => ({ contextId }));\n\n                return Promise.reject(err);\n            }\n\n            const initialized: boolean = err.data.iModelInitialized;\n            if (initialized) {\n                Logger.logWarning(loggerCategory, `Error creating iModel: iModel with name ${iModelName} already exists and is initialized`, () => ({ contextId }));\n\n                return Promise.reject(err);\n            }\n\n            Logger.logInfo(loggerCategory, `Querying iModel by name ${iModelName}`, () => ({ contextId }));\n\n            const imodels = await this.get(requestContext, contextId, new IModelQuery().byName(iModelName));\n            requestContext.enter();\n            Logger.logTrace(loggerCategory, `Queried iModel by name ${iModelName}`, () => ({ contextId }));\n\n            if (imodels.length > 0) {\n                imodel = imodels[0];\n            } else {\n                Logger.logTrace(loggerCategory, `iModel by name: iModel ${iModelName} not found`, () => ({ contextId }));\n\n                return Promise.reject(new Error(`iModel by name: iModel ${iModelName} not found`));\n            }\n        }\n\n        return imodel;\n    }\n\n    /** Get the [[InitializationState]] for the specified iModel. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).\n     * @param requestContext The client request context.\n     * @param iModelId Id of the iModel. See [[HubIModel]].\n     * @returns State of the seed file initialization.\n     * @throws [[IModelHubError]] with [IModelHubStatus.FileDoesNotExist]($bentley) if the seed file was not found.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async getInitializationState(requestContext: AuthorizedClientRequestContext, iModelId: GuidString): Promise<InitializationState> {\n        const seedFiles: SeedFile[] = await this._seedFileHandler.get(requestContext, iModelId, new SeedFileQuery().latest());\n        requestContext.enter();\n        if (seedFiles.length < 1)\n            return Promise.reject(new IModelHubError(IModelHubStatus.FileDoesNotExist));\n\n        return seedFiles[0].initializationState!;\n    }\n\n    /** Create an iModel from given seed file. In most cases [IModelDb.create]($backend) should be used instead. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).\n     * This method does not work on browsers. If iModel creation fails before finishing file upload, partially created iModel is deleted. This method is not supported in iModelBank.\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param name Name of the iModel on the Hub.\n     * @param path iModel seed file path. If not defined, iModel will be created from an empty file.\n     * @param description Description of the iModel on the Hub.\n     * @param progressCallback Callback for tracking progress.\n     * @param timeOutInMiliseconds Time to wait for iModel initialization.\n     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async create(requestContext: AuthorizedClientRequestContext, contextId: string, name: string, path?: string,\n        description?: string, progressCallback?: (progress: ProgressInfo) => void,\n        timeOutInMilliseconds: number = 120000): Promise<HubIModel> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Creating iModel\", () => ({ contextId }));\n        ArgumentCheck.defined(\"requestContext\", requestContext);\n        ArgumentCheck.validGuid(\"contextId\", contextId);\n        ArgumentCheck.defined(\"name\", name);\n\n        const imodelFromTemplate = !path;\n\n        if (typeof window !== \"undefined\")\n            return Promise.reject(IModelHubClientError.browser());\n\n        if (!this._fileHandler)\n            return Promise.reject(IModelHubClientError.fileHandler());\n\n        if (!!path && (!this._fileHandler.exists(path) || this._fileHandler.isDirectory(path)))\n            return Promise.reject(IModelHubClientError.fileNotFound());\n\n        const imodelTemplate = imodelFromTemplate ? iModelTemplateEmpty : undefined;\n        const imodel = await this.createIModelInstance(requestContext, contextId, name, description, imodelTemplate);\n        requestContext.enter();\n\n        if (imodelFromTemplate) {\n            return imodel;\n        }\n\n        try {\n            await this._seedFileHandler.uploadSeedFile(requestContext, imodel.id!, path!, description, progressCallback);\n        } catch (err) {\n            await this.delete(requestContext, contextId, imodel.id!);\n            return Promise.reject(err);\n        }\n        requestContext.enter();\n\n        const errorMessage = \"Cannot upload SeedFile \" + path;\n        const retryDelay = timeOutInMilliseconds / 10;\n        for (let retries = 10; retries > 0; --retries) {\n            try {\n                const initState = await this.getInitializationState(requestContext, imodel.id!);\n                requestContext.enter();\n                if (initState === InitializationState.Successful) {\n                    Logger.logTrace(loggerCategory, \"Created iModel\", () => ({ contextId, iModelId: imodel.id }));\n                    imodel.initialized = true;\n                    return imodel;\n                }\n\n                if (initState !== InitializationState.NotStarted && initState !== InitializationState.Scheduled) {\n                    Logger.logWarning(loggerCategory, errorMessage);\n                    return Promise.reject(new IModelHubError(IModelHubStatus.SeedFileInitializationFailed,\n                        `Seed file initialization failed with status ${InitializationState[initState]}`));\n                }\n\n                await new Promise((resolve) => setTimeout(resolve, retryDelay));\n                requestContext.enter();\n            } catch (err) {\n                requestContext.enter();\n                Logger.logWarning(loggerCategory, errorMessage);\n                return Promise.reject(err);\n            }\n        }\n\n        Logger.logWarning(loggerCategory, errorMessage);\n        return Promise.reject(IModelHubClientError.initializationTimeout());\n    }\n\n    /** Update iModel's name and/or description\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param imodel iModel to update. See [[HubIModel]].\n     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelIsNotInitialized]$(bentley) if iModel is not initialized.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelAlreadyExists]$(bentley) if iModel with specified name already exists.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async update(requestContext: AuthorizedClientRequestContext, contextId: string, imodel: HubIModel): Promise<HubIModel> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Updating iModel\", () => ({ contextId, iModelId: imodel.id }));\n        ArgumentCheck.defined(\"requestContext\", requestContext);\n        ArgumentCheck.validGuid(\"contextId\", contextId);\n\n        const updatedIModel = await this._handler.postInstance<HubIModel>(requestContext, HubIModel, this.getRelativeUrl(contextId, imodel.id), imodel);\n\n        Logger.logTrace(loggerCategory, \"Updated iModel\", () => ({ contextId, iModelId: imodel.id }));\n        return updatedIModel;\n    }\n\n    /** Method to download the seed file for iModel. This will download the original seed file, that was uploaded when creating iModel. To download a file that was updated with ChangeSets on iModelHub, see [[BriefcaseHandler.download]].\n     * @param requestContext The client request context.\n     * @param iModelId Id of the iModel. See [[HubIModel]].\n     * @param path Path to download the seed file to, including file name.\n     * @param progressCallback Callback for tracking progress.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async download(requestContext: AuthorizedClientRequestContext, iModelId: GuidString, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void> {\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Started downloading seed file\", () => ({ iModelId }));\n        ArgumentCheck.defined(\"requestContext\", requestContext);\n        ArgumentCheck.validGuid(\"iModelId\", iModelId);\n        ArgumentCheck.defined(\"path\", path);\n\n        if (typeof window !== \"undefined\")\n            return Promise.reject(IModelHubClientError.browser());\n\n        if (!this._fileHandler)\n            return Promise.reject(IModelHubClientError.fileHandler());\n\n        const seedFiles: SeedFile[] = await this._seedFileHandler.get(requestContext, iModelId, new SeedFileQuery().selectDownloadUrl().latest());\n        requestContext.enter();\n\n        if (!seedFiles || !seedFiles[0] || !seedFiles[0].downloadUrl)\n            return Promise.reject(IModelHubError.fromId(IModelHubStatus.FileDoesNotExist, \"Failed to get seed file.\"));\n\n        await this._fileHandler.downloadFile(requestContext, seedFiles[0].downloadUrl!, path, parseInt(seedFiles[0].fileSize!, 10), progressCallback);\n        requestContext.enter();\n        Logger.logInfo(loggerCategory, \"Finished downloading seed file\", () => ({ iModelId }));\n    }\n}\n\n/**\n * Handler for managing [[HubIModel]] instance. Use [[IModelHubClient.IModel]] to get an instance of this handler.\n * @note Use [[IModelHubClient.IModels]] if multiple iModels per context are supported.\n * @beta\n */\nexport class IModelHandler {\n    private _handler: IModelsHandler;\n\n    /**\n     * Constructor for IModelHandler. Should use @see IModelClient instead of directly constructing this.\n     * @param handler Handler for managing [[HubIModel]] instances.\n     * @note Use [[IModelHubClient.IModels]] if multiple iModels per context are supported.\n     * @internal\n     */\n    constructor(handler: IModelsHandler) {\n        this._handler = handler;\n    }\n\n    /**\n     * Get iModel that belong to the specified context.\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @returns [[HubIModel]] instances that match the query.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async get(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<HubIModel> {\n        requestContext.enter();\n\n        Logger.logInfo(loggerCategory, \"Querying iModel\", () => ({ contextId }));\n        const query = new IModelQuery().orderBy(\"CreatedDate+asc\").top(1);\n        const imodels = await this._handler.get(requestContext, contextId, query);\n\n        if (imodels.length < 1)\n            return Promise.reject(new IModelHubError(IModelHubStatus.iModelDoesNotExist));\n\n        return imodels[0];\n    }\n\n    /**\n     * Delete an iModel from a context. This method is not supported in iModelBank.\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.\n     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have DeleteiModel permission.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async delete(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<void> {\n        const imodel = await this.get(requestContext, contextId);\n        await this._handler.delete(requestContext, contextId, imodel.id!);\n    }\n\n    /**\n     * Get the [[InitializationState]] for the specified iModel. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @returns State of the seed file initialization.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.\n     * @throws [[IModelHubError]] with [IModelHubStatus.FileDoesNotExist]($bentley) if the seed file was not found.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async getInitializationState(requestContext: AuthorizedClientRequestContext, contextId: string): Promise<InitializationState> {\n        const imodel = await this.get(requestContext, contextId);\n        return this._handler.getInitializationState(requestContext, imodel.id!);\n    }\n\n    /**\n     * Create an iModel from given seed file. In most cases [IModelDb.create]($backend) should be used instead. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).\n     *\n     * This method does not work on browsers. If iModel creation fails before finishing file upload, partially created iModel is deleted. This method is not supported in iModelBank.\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param name Name of the iModel on the Hub.\n     * @param path iModel seed file path. If not defined, iModel will be created from an empty file.\n     * @param description Description of the iModel on the Hub.\n     * @param progressCallback Callback for tracking progress.\n     * @param timeOutInMiliseconds Time to wait for iModel initialization.\n     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async create(requestContext: AuthorizedClientRequestContext, contextId: string, name: string, path?: string, description?: string, progressCallback?: (progress: ProgressInfo) => void, timeOutInMilliseconds: number = 120000): Promise<HubIModel> {\n        requestContext.enter();\n\n        let imodelExists = true;\n        try {\n            await this.get(requestContext, contextId);\n            requestContext.enter();\n        } catch (err) {\n            if (err instanceof IModelHubError && err.errorNumber === IModelHubStatus.iModelDoesNotExist)\n                imodelExists = false;\n            else\n                throw err;\n        }\n\n        if (imodelExists)\n            return Promise.reject(new IModelHubError(IModelHubStatus.iModelAlreadyExists));\n\n        return this._handler.create(requestContext, contextId, name, path, description, progressCallback, timeOutInMilliseconds);\n    }\n\n    /**\n     * Update iModel's name and/or description\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param imodel iModel to update. See [[HubIModel]].\n     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelIsNotInitialized]$(bentley) if iModel is not initialized.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelAlreadyExists]$(bentley) if iModel with specified name already exists.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async update(requestContext: AuthorizedClientRequestContext, contextId: string, imodel: HubIModel): Promise<HubIModel> {\n        return this._handler.update(requestContext, contextId, imodel);\n    }\n\n    /**\n     * Method to download the seed file for iModel. This will download the original seed file, that was uploaded when creating iModel. To download a file that was updated with ChangeSets on iModelHub, see [[BriefcaseHandler.download]].\n     * @param requestContext The client request context.\n     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).\n     * @param path Path where seed file should be downloaded, including filename.\n     * @param progressCallback Callback for tracking progress.\n     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.\n     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)\n     */\n    public async download(requestContext: AuthorizedClientRequestContext, contextId: string, path: string, progressCallback?: (progress: ProgressInfo) => void): Promise<void> {\n        const imodel = await this.get(requestContext, contextId);\n        await this._handler.download(requestContext, imodel.id!, path, progressCallback);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nexport * from \"./ECJsonTypeMap\";\nexport * from \"./Client\";\nexport * from \"./Config\";\nexport * from \"./Token\";\nexport * from \"./AuthorizationClient\";\nexport * from \"./UserInfo\";\nexport * from \"./ConnectClients\";\nexport * from \"./WsgClient\";\nexport * from \"./FileHandler\";\nexport * from \"./IModelClient\";\nexport * from \"./ImsClients\";\nexport * from \"./ClientsLoggerCategory\";\nexport * from \"./Config\";\nexport * from \"./Request\";\nexport * from \"./RealityDataServicesClient\";\nexport * from \"./SettingsAdmin\";\nexport * from \"./SettingsClient\";\nexport * from \"./AuthorizedClientRequestContext\";\n\nexport * from \"./imodelbank/IModelBankClient\";\nexport * from \"./imodelbank/IModelBankHandler\";\nexport * from \"./imodelbank/IModelBankFileSystemContextClient\";\n\nexport * from \"./imodelhub/BaseHandler\";\nexport * from \"./imodelhub/Client\";\nexport * from \"./imodelhub/Query\";\nexport * from \"./imodelhub/Errors\";\nexport * from \"./imodelhub/Briefcases\";\nexport * from \"./imodelhub/ChangeSets\";\nexport * from \"./imodelhub/Checkpoints\";\nexport * from \"./imodelhub/Codes\";\nexport * from \"./imodelhub/Events\";\nexport * from \"./imodelhub/GlobalEvents\";\nexport * from \"./imodelhub/iModels\";\nexport * from \"./imodelhub/Locks\";\nexport * from \"./imodelhub/Users\";\nexport * from \"./imodelhub/Versions\";\nexport * from \"./imodelhub/Thumbnails\";\n\nexport * from \"./oidc/OidcClient\";\nexport * from \"./oidc/OidcFrontendClient\";\nexport * from \"./oidc/AngularOidcFrontendClient\";\n\nexport * from \"./ulas/LogEntryConverter\";\nexport * from \"./ulas/UlasClient\";\n\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\ndeclare var BUILD_SEMVER: string;\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\n  if (!(window as any).iModelJsVersions)\n    (window as any).iModelJsVersions = new Map<string, string>();\n  (window as any).iModelJsVersions.set(\"imodeljs-clients\", BUILD_SEMVER);\n}\n\n/** @docs-package-description\n * The imodeljs-clients package allows sending requests to various CONNECT services.\n *\n * It works both on [backend]($docs/learning/backend/index.md) and [frontend]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description Authentication\n * Classes for managing [AccessToken]($clients) used for all requests in other classes.\n */\n/**\n * @docs-group-description BaseClients\n * Base classes for creating service clients.\n */\n/**\n * @docs-group-description ConnectServices\n * Classes for communicating with various CONNECT services.\n */\n/**\n * @docs-group-description iModelHub\n * Classes for communicating directly with [iModelHub]($docs/learning/iModelHub/index.md).\n */\n/**\n * @docs-group-description iModelHubEvents\n * Classes for receiving [IModelHubEvent]($clients)s. See [working with events]($docs/learning/iModelHub/Events).\n */\n/**\n * @docs-group-description iModelHubGlobalEvents\n * Classes for receiving [IModelHubGlobalEvent]($clients)s. See [working with global events]($docs/learning/iModelHub/GlobalEvents). **Currently only available to internal Bentley products.**\n */\n/**\n * @docs-group-description iModels\n * Classes for abstracting access to [iModelHub]($docs/learning/iModelHub/index.md). See [iModelBank]($docs/reference/imodeljs-clients/imodelbank).\n */\n/**\n * @docs-group-description Settings\n * Classes for saving and retrieving application-, project-, and iModel- specific [Settings]($docs/learning/frontend/Settings.md)\n */\n/**\n * @docs-group-description OtherServices\n * Classes for communicating with various other services.\n */\n/**\n * @docs-group-description Utils\n * Utilities for implementing clients.\n */\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { Client } from \"../Client\";\n\n/** @beta */\nexport abstract class OidcClient extends Client {\n  public static readonly searchKey: string = \"IMSOpenID\";\n\n  public constructor() {\n    super();\n  }\n\n  /**\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\n   * @returns Search key for the URL.\n   */\n  protected getUrlSearchKey(): string {\n    return OidcClient.searchKey;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Guid, GuidString, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { UsageLogEntry, FeatureLogEntry, FeatureStartedLogEntry, FeatureEndedLogEntry, ProductVersion, UsageType } from \"./UlasClient\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.UlasClient;\r\n\r\n/** Specifies the JSON format for a UsageLogEntry as expected by the ULAS REST API\r\n * (see https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n * @internal\r\n */\r\nexport interface UsageLogEntryJson {\r\n  /** Ultimate ID, i.e. company ID in SAP */\r\n  ultID?: number;\r\n  /** The ID of the Principal that was granted access to the application */\r\n  pid?: GuidString;\r\n  /** The GUID of the IMS user accessing the product, maybe the same as the Principal. */\r\n  imsID?: GuidString;\r\n  /** The client’s machine name excluding domain information. */\r\n  hID: string;\r\n  /** The client’s login name excluding domain information */\r\n  uID?: string;\r\n  /** The GUID embedded in the policy file that allows us to track the entitlement history. */\r\n  polID: GuidString;\r\n  /** The ID of the securable. */\r\n  secID: string;\r\n  /** The product ID for which usage is being submitted. It is a 4-digit Product ID from the GPR. */\r\n  prdid: number;\r\n  /** A feature string further identifying the product for which available usage is being submitted. Not to be confused with feature IDs. */\r\n  fstr: string;\r\n  /** The version of the application producing the usage.\r\n   *  Format: Pad all sections out to 4 digits padding is with zeros, e.g. 9.10.2.113 becomes 9001000020113.\r\n   */\r\n  ver: number;\r\n  /** The GUID of the project that the usage should be associated with.\r\n   *  If no project is selected, omit the field.\r\n   */\r\n  projID?: GuidString;\r\n  /** The GUID that identifies a unique usage session, used to correlate data between feature usage and usage logs. */\r\n  corID?: GuidString;\r\n  /** The UTC time of the event. */\r\n  evTimeZ?: string;\r\n  /** The version of the schema which this log entry represents. */\r\n  lVer: number;\r\n  /** Identifies the source of the usage log entry: RealTime, Offline, Checkout */\r\n  lSrc: string;\r\n  /** Identifies the country where the client reporting the usage belongs to. */\r\n  country?: string;\r\n  /** The type of usage that occurred on the client. It is acting as a filter to eliminate records from log processing that\r\n   *  should not count towards a customer’s peak processing. One of: Production, Trial, Beta, HomeUse, PreActivation\r\n   */\r\n  uType: string;\r\n}\r\n\r\n/** @internal */\r\nexport interface FeatureLogEntryAttributeJson {\r\n  name: string;\r\n  value: string;\r\n}\r\n\r\n/** Specifies the JSON format for a FeatureLogEntry as expected by the ULAS REST API\r\n * (see https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n * @internal\r\n */\r\nexport interface FeatureLogEntryJson extends UsageLogEntryJson {\r\n  /** Gets the ID of the feature used (from the Global Feature Registry) */\r\n  ftrID: GuidString;\r\n  /** The start date in UTC when feature usage has started (for duration feature log entries) */\r\n  sDateZ: string;\r\n  /** The end date in UTC when feature usage has started (for duration feature log entries) */\r\n  eDateZ: string;\r\n  /** Additional user-defined metadata for the feature usage */\r\n  uData: FeatureLogEntryAttributeJson[];\r\n}\r\n\r\n/** @internal */\r\nexport class LogEntryConverter {\r\n  // for now this is always 1\r\n  private static readonly _logEntryVersion: number = 1;\r\n  // this is a real-time client, i.e. it sends the requests right away without caching or aggregating.\r\n  private static readonly _logPostingSource: string = \"RealTime\";\r\n  // fStr argument is empty for now\r\n  private static readonly _featureString: string = \"\";\r\n  private static readonly _policyFileId: GuidString = Guid.createValue();\r\n  private static readonly _securableId: string = Guid.createValue();\r\n\r\n  /**\r\n   * Extracts the application version from the supplied request context\r\n   * @param requestContext The client request context\r\n   * @returns The application version for the request context\r\n   */\r\n  private static getApplicationVersion(requestContext: AuthorizedClientRequestContext): ProductVersion {\r\n    const applicationVersion = requestContext.applicationVersion;\r\n    const defaultVersion = { major: 1, minor: 0 };\r\n    if (!applicationVersion) {\r\n      Logger.logWarning(loggerCategory, \"ApplicationVersion was not specified. Set up IModelApp.applicationVersion for frontend applications, or IModelHost.applicationVersion for agents\", () => ({ applicationVersion }));\r\n      return defaultVersion;\r\n    }\r\n\r\n    const versionSplit = applicationVersion.split(\".\");\r\n    const length = versionSplit.length;\r\n    if (length < 2) {\r\n      Logger.logWarning(loggerCategory, \"ApplicationVersion is not valid\", () => ({ applicationVersion }));\r\n      return defaultVersion;\r\n    }\r\n\r\n    const major = parseInt(versionSplit[0], 10);\r\n    if (typeof major === \"undefined\") {\r\n      Logger.logWarning(loggerCategory, \"ApplicationVersion is not valid\", () => ({ applicationVersion }));\r\n      return defaultVersion;\r\n    }\r\n\r\n    const minor = parseInt(versionSplit[1], 10);\r\n    if (typeof minor === \"undefined\") {\r\n      Logger.logWarning(loggerCategory, \"ApplicationVersion is not valid\", () => ({ applicationVersion }));\r\n      return { major, minor: 0 };\r\n    }\r\n\r\n    let sub1: number | undefined;\r\n    let sub2: number | undefined;\r\n    if (length > 2) {\r\n      sub1 = parseInt(versionSplit[2], 10) || undefined;\r\n      if (length > 3 && sub1) {\r\n        sub2 = parseInt(versionSplit[3], 10) || undefined;\r\n      }\r\n    }\r\n\r\n    return { major, minor, sub1, sub2 };\r\n  }\r\n\r\n  /**\r\n   * Extracts the application id from the supplied request context\r\n   * @param requestContext The client request context\r\n   * @returns The application id for the request context\r\n   */\r\n  private static getApplicationId(requestContext: AuthorizedClientRequestContext): number {\r\n    const defaultId = 2686; // iModel.js\r\n    if (!requestContext.applicationId) {\r\n      Logger.logWarning(loggerCategory, \"ApplicationId was not specified. Set up IModelApp.applicationId for frontend applications, or IModelHost.applicationId for agents\");\r\n      return defaultId;\r\n    }\r\n\r\n    return parseInt(requestContext.applicationId, 10) || defaultId;\r\n  }\r\n\r\n  /**\r\n   * Extracts the session id from the supplied request context\r\n   * @param requestContext The client request context\r\n   * @returns The session id for the request context\r\n   */\r\n  private static getSessionId(requestContext: AuthorizedClientRequestContext): GuidString {\r\n    if (!Guid.isGuid(requestContext.sessionId)) {\r\n      Logger.logWarning(loggerCategory, \"Specified sessionId is not a valid Guid. Set up IModelApp.sessionId for frontend applications, or IModelHost.sessionId for agents\");\r\n      return Guid.empty;\r\n    }\r\n\r\n    return requestContext.sessionId;\r\n  }\r\n\r\n  public static toUsageLogJson(requestContext: AuthorizedClientRequestContext, entry: UsageLogEntry): UsageLogEntryJson {\r\n    const productId: number = LogEntryConverter.getApplicationId(requestContext);\r\n    const productVersion: ProductVersion = LogEntryConverter.getApplicationVersion(requestContext);\r\n    const sessionId: GuidString = LogEntryConverter.getSessionId(requestContext);\r\n\r\n    const hID: string = LogEntryConverter.prepareMachineName(entry.hostName);\r\n    const ver: number = LogEntryConverter.toVersionNumber(productVersion);\r\n    const uType: string = LogEntryConverter.usageTypeToString(entry.usageType);\r\n\r\n    return {\r\n      hID,\r\n      polID: LogEntryConverter._policyFileId,\r\n      secID: LogEntryConverter._securableId,\r\n      prdid: productId,\r\n      fstr: LogEntryConverter._featureString,\r\n      ver,\r\n      projID: entry.contextId,\r\n      corID: sessionId,\r\n      lVer: LogEntryConverter._logEntryVersion,\r\n      lSrc: LogEntryConverter._logPostingSource,\r\n      uType,\r\n    };\r\n  }\r\n\r\n  public static toFeatureLogJson(requestContext: AuthorizedClientRequestContext, entries: FeatureLogEntry[]): FeatureLogEntryJson[] {\r\n    const json: FeatureLogEntryJson[] = [];\r\n    const productId: number = LogEntryConverter.getApplicationId(requestContext);\r\n    const productVersion: ProductVersion = LogEntryConverter.getApplicationVersion(requestContext);\r\n    const sessionId: GuidString = LogEntryConverter.getSessionId(requestContext);\r\n\r\n    const ver: number | undefined = LogEntryConverter.toVersionNumber(productVersion);\r\n\r\n    for (const entry of entries) {\r\n      const hID: string = LogEntryConverter.prepareMachineName(entry.hostName);\r\n\r\n      const evTimeZ: string = entry.timestamp;\r\n      let sDateZ: string;\r\n      let eDateZ: string;\r\n      let corID: GuidString | undefined;\r\n      const startEntry: FeatureStartedLogEntry = entry as FeatureStartedLogEntry;\r\n      const endEntry: FeatureEndedLogEntry = entry as FeatureEndedLogEntry;\r\n      const defaultDate: string = \"0001-01-01T00:00:00Z\";\r\n      if (!!startEntry.entryId) {\r\n        sDateZ = evTimeZ;\r\n        eDateZ = defaultDate;\r\n        corID = startEntry.entryId;\r\n      } else if (!!endEntry.startEntryId) {\r\n        sDateZ = defaultDate;\r\n        eDateZ = evTimeZ;\r\n        corID = endEntry.startEntryId;\r\n      } else {\r\n        sDateZ = evTimeZ;\r\n        eDateZ = evTimeZ;\r\n        corID = sessionId;\r\n      }\r\n\r\n      const uType: string = LogEntryConverter.usageTypeToString(entry.usageType);\r\n\r\n      const uData: FeatureLogEntryAttributeJson[] = [];\r\n      for (const att of entry.usageData) {\r\n        uData.push({ name: att.name, value: att.value.toString() });\r\n      }\r\n\r\n      const entryJson: FeatureLogEntryJson = {\r\n        hID,\r\n        polID: LogEntryConverter._policyFileId,\r\n        secID: LogEntryConverter._securableId,\r\n        prdid: productId,\r\n        fstr: LogEntryConverter._featureString,\r\n        ver,\r\n        projID: entry.contextId,\r\n        corID,\r\n        lVer: LogEntryConverter._logEntryVersion,\r\n        lSrc: LogEntryConverter._logPostingSource,\r\n        uType,\r\n        ftrID: entry.featureId,\r\n        sDateZ,\r\n        eDateZ,\r\n        uData,\r\n      };\r\n\r\n      json.push(entryJson);\r\n    }\r\n    return json;\r\n  }\r\n\r\n  private static toVersionNumber(version: ProductVersion): number {\r\n    // version must be encoded into a single number where each version digit is padded out to 4 digits\r\n    // and the version is always considered to have 4 digits.\r\n    // Ex: 3.99.4 -> 3.99.4.0 -> 3009900040000\r\n    let verNumber: number = !!version.sub2 ? version.sub2 : 0;\r\n    verNumber += 10000 * (!!version.sub1 ? version.sub1 : 0);\r\n    verNumber += Math.pow(10000, 2) * version.minor;\r\n    verNumber += Math.pow(10000, 3) * version.major;\r\n    return verNumber;\r\n  }\r\n\r\n  private static prepareMachineName(machineName: string): string {\r\n    if (!machineName || machineName.length === 0)\r\n      return \"\";\r\n\r\n    if (machineName === \"::1\" || machineName === \"127.0.0.1\")\r\n      return \"localhost\";\r\n\r\n    return machineName.toLowerCase();\r\n  }\r\n\r\n  /* private static prepareUserName(userName: string, machineName: string): string {\r\n    if (!userName || userName.length === 0)\r\n      return \"\";\r\n\r\n    let preparedUserName: string = userName;\r\n\r\n    const backslashPos: number = userName.indexOf(\"\\\\\");\r\n    if (backslashPos >= 0)\r\n      preparedUserName = userName.substr(backslashPos + 1);\r\n    else {\r\n      const slashPos: number = userName.indexOf(\"/\");\r\n      if (slashPos >= 0)\r\n        preparedUserName = userName.substr(slashPos + 1);\r\n    }\r\n\r\n    preparedUserName = preparedUserName.toLowerCase();\r\n    if (!!machineName && machineName.length > 0 && (preparedUserName.includes(\"administrator\") || preparedUserName.includes(\"system\")))\r\n      preparedUserName = `${machineName.toLowerCase()}\\\\${preparedUserName}`;\r\n\r\n    return preparedUserName;\r\n  } */\r\n\r\n  private static usageTypeToString(val: UsageType): string {\r\n    switch (val) {\r\n      case UsageType.Beta:\r\n        return \"Beta\";\r\n      case UsageType.HomeUse:\r\n        return \"HomeUse\";\r\n      case UsageType.PreActivation:\r\n        return \"PreActivation\";\r\n      case UsageType.Production:\r\n        return \"Production\";\r\n      case UsageType.Trial:\r\n        return \"Trial\";\r\n      default:\r\n        throw new Error(\"Unhandled UsageType enum value\");\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { BentleyStatus, ClientRequestContext, Guid, GuidString, Logger, LogLevel } from \"@bentley/bentleyjs-core\";\r\nimport { AuthorizedClientRequestContext } from \"../AuthorizedClientRequestContext\";\r\nimport { Client } from \"../Client\";\r\nimport { Config } from \"../Config\";\r\nimport { ImsDelegationSecureTokenClient } from \"../ImsClients\";\r\nimport { ClientsLoggerCategory } from \"../ClientsLoggerCategory\";\r\nimport { request, RequestOptions, Response } from \"../Request\";\r\nimport { AccessToken, AuthorizationToken, IncludePrefix } from \"../Token\";\r\nimport { FeatureLogEntryJson, LogEntryConverter, UsageLogEntryJson } from \"./LogEntryConverter\";\r\n\r\nconst loggerCategory: string = ClientsLoggerCategory.UlasClient;\r\n\r\n/** Represents one of the potential usage types.\r\n * See also\r\n *  - [[UsageLogEntry]], [[FeatureLogEntry]]\r\n *  - *UsageType* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n *  site (section *Models*)\r\n * @internal\r\n */\r\nexport enum UsageType {\r\n  Production, Trial, Beta, HomeUse, PreActivation,\r\n}\r\n\r\n/** Represents the version of the product logging usage or features.\r\n * See also [[UsageLogEntry]], [[FeatureLogEntry]].\r\n * @internal\r\n */\r\nexport interface ProductVersion {\r\n  major: number;\r\n  minor: number;\r\n  sub1?: number;\r\n  sub2?: number;\r\n}\r\n\r\n/**\r\n * Usage log entry data that is submitted to the ULAS Posting Service.\r\n * See also\r\n *  - [[UlasClient]]\r\n *  - *UsageLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n *  site (section *Models*)\r\n * @internal\r\n */\r\nexport class UsageLogEntry {\r\n  /** The GUID of the context that the usage should be associated with. */\r\n  public contextId?: GuidString;\r\n\r\n  /** Name of the client machine from which usage is logged */\r\n  public readonly hostName: string;\r\n\r\n  /** The type of usage that occurred on the client. It is acting as a filter to eliminate records from log processing that\r\n   * should not count towards a customer’s peak processing.\r\n   */\r\n  public readonly usageType: UsageType;\r\n\r\n  /** Timestamp against which the usage is logged.\r\n   * It is set at construction time of this object.\r\n   */\r\n  public readonly timestamp: string;\r\n\r\n  /** Creates a new UsageLogEntry object.\r\n   *  This also sets the timestamp against which the usage will be logged.\r\n   *  @param hostName Name of the client machine from which usage is logged.\r\n   *  @param usageType Usage type (see [[UsageType]])\r\n   *  @param contextId The GUID of the context that the usage should be associated with.\r\n   */\r\n  public constructor(hostName: string, usageType: UsageType, contextId?: GuidString) {\r\n    this.hostName = hostName;\r\n    this.usageType = usageType;\r\n    this.contextId = contextId;\r\n    this.timestamp = new Date().toISOString();\r\n  }\r\n}\r\n\r\n/**\r\n * Represents arbitrary metadata that can be attached to a\r\n * [[FeatureLogEntry]] when collecting information about feature usage.\r\n * @internal\r\n */\r\nexport interface FeatureLogEntryAttribute {\r\n  name: string;\r\n  value: any;\r\n}\r\n\r\n/**\r\n * Feature log entry data that is submitted to the ULAS Posting Service.\r\n * See also\r\n *  - [[UlasClient]]\r\n *  - *FeatureLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n *  site (section *Models*)\r\n * @internal\r\n */\r\nexport class FeatureLogEntry {\r\n  /** The GUID of the context that the usage should be associated with. */\r\n  public contextId?: GuidString;\r\n\r\n  /** ID of the feature to log (from the Global Feature Registry). */\r\n  public readonly featureId: GuidString;\r\n\r\n  /** Additional user-defined metadata for the feature usage. */\r\n  public usageData: FeatureLogEntryAttribute[];\r\n\r\n  /** Name of the client machine from which usage is logged. */\r\n  public readonly hostName: string;\r\n\r\n  /** The type of usage that occurred on the client. It is acting as a filter to eliminate records from log processing that\r\n   * should not count towards a customer’s peak processing.\r\n   */\r\n  public readonly usageType: UsageType;\r\n\r\n  /** Timestamp against which the feature is logged.\r\n   * It is set at construction time of this object.\r\n   */\r\n  public readonly timestamp: string;\r\n\r\n  /** Creates a new FeatureLogEntry object.\r\n   *  This also sets the timestamp against which the feature will be logged.\r\n   *  @param featureId Feature ID from the Global Feature Registry which is being logged.\r\n   *  @param hostName Name of the client machine from which the feature is being logged.\r\n   *  @param usageType Usage type (see [[UsageType]])\r\n   *  @param contextId The GUID of the context that the usage should be associated with.\r\n   */\r\n  public constructor(featureId: GuidString, hostName: string, usageType: UsageType, contextId?: GuidString) {\r\n    this.featureId = featureId;\r\n    this.hostName = hostName;\r\n    this.usageType = usageType;\r\n    this.contextId = contextId;\r\n    this.usageData = [];\r\n    this.timestamp = new Date().toISOString();\r\n  }\r\n}\r\n\r\n/**\r\n * Start point of a duration Feature log entry that is submitted to the ULAS Posting Service.\r\n * See also\r\n *  - [[UlasClient]]\r\n *  - [[FeatureLogEntry]]\r\n *  - *FeatureLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n *  site (section *Models*)\r\n * @internal\r\n */\r\nexport class FeatureStartedLogEntry extends FeatureLogEntry {\r\n  /** ID of this entry which must be passed to the respective [[FeatureEndedLogEntry]] to\r\n   * correlate start and end entry.\r\n   */\r\n  public readonly entryId: GuidString;\r\n\r\n  /** Creates a new FeatureStartedLogEntry object.\r\n   *  @param featureId Feature ID from the Global Feature Registry which is being logged.\r\n   *  @param hostName Name of the client machine from which the feature is being logged.\r\n   *  @param usageType Usage type (see [[UsageType]])\r\n   *  @param contextId The GUID of the context that the usage should be associated with.\r\n   */\r\n  public constructor(featureId: GuidString, hostName: string, usageType: UsageType, contextId?: GuidString) {\r\n    super(featureId, hostName, usageType, contextId);\r\n    this.entryId = Guid.createValue();\r\n  }\r\n}\r\n\r\n/**\r\n * End point of a duration Feature log entry that is submitted to the ULAS Posting Service.\r\n * See also\r\n *  - [[UlasClient]]\r\n *  - [[FeatureStartedLogEntry]]\r\n *  - *FeatureLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n *  site (section *Models*)\r\n * @internal\r\n */\r\nexport class FeatureEndedLogEntry extends FeatureLogEntry {\r\n  /* ID of the corresponding [[FeatureStartedLogEntry]].\r\n   * See [[FeatureStartedLogEntry.entryId]]\r\n   */\r\n  public readonly startEntryId: GuidString;\r\n\r\n  /** Creates a new FeatureEndedLogEntry object.\r\n   *  @param featureId Feature ID from the Global Feature Registry which is being logged.\r\n   *  @param startEntryId ID of the corresponding [[FeatureStartedLogEntry]]\r\n   *  @param hostName Name of the client machine from which the feature is being logged.\r\n   *  @param usageType Usage type (see [[UsageType]])\r\n   *  @param contextId The GUID of the context that the usage should be associated with.\r\n   */\r\n  public constructor(featureId: GuidString, startEntryId: GuidString, hostName: string, usageType: UsageType, contextId?: GuidString) {\r\n    super(featureId, hostName, usageType, contextId);\r\n    this.startEntryId = startEntryId;\r\n  }\r\n\r\n  /** Creates a new FeatureEndedLogEntry from the specified FeatureStartedLogEntry.\r\n   *  @param startEntry Corresponding [[FeatureStartedLogEntry]]\r\n   *  @return Corresponding FeatureEndedLogEntry.\r\n   */\r\n  public static fromStartEntry(startEntry: FeatureStartedLogEntry): FeatureEndedLogEntry {\r\n    const endEntry = new FeatureEndedLogEntry(startEntry.featureId, startEntry.entryId,\r\n      startEntry.hostName, startEntry.usageType, startEntry.contextId);\r\n\r\n    endEntry.usageData = startEntry.usageData;\r\n\r\n    return endEntry;\r\n  }\r\n}\r\n\r\n/**\r\n * Response from posting a [[UsageLogEntry]] or [[FeatureLogEntry]] with the [[UlasClient]].\r\n * See also *LogPostingResponse* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n * site (section *Models*)\r\n * @internal\r\n */\r\nexport interface LogPostingResponse {\r\n  /* The overall status of the request. */\r\n  status: BentleyStatus;\r\n  /* The message localized in client's language. */\r\n  message: string;\r\n  /* The time in milliseconds it took to complete the request submitted by the client. */\r\n  time: number;\r\n  /* The unique ID of the request assigned by the server when handling the client's request. */\r\n  requestId: GuidString;\r\n}\r\n\r\n/**\r\n * Client for the Bentley Usage Logging & Analysis Services (ULAS).\r\n * See also the two `POST` requests on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)\r\n * @internal\r\n */\r\nexport class UlasClient extends Client {\r\n  private static readonly _buddiSearchKey: string = \"UsageLoggingServices.RealtimeLogging.Url\";\r\n  private static readonly _configRelyingPartyUri = \"imjs_ulas_relying_party_uri\";\r\n  private static readonly _configDefaultRelyingPartyUri = \"imjs_default_relying_party_uri\";\r\n\r\n  /** Creates an instance of UlasClient. */\r\n  constructor() { super(); }\r\n\r\n  /**\r\n   * Gets name/key to query the service URLs from the URL Discovery Service (\"Buddi\")\r\n   * @returns Search key for the URL.\r\n   */\r\n  protected getUrlSearchKey(): string { return UlasClient._buddiSearchKey; }\r\n\r\n  protected async setupOptionDefaults(options: RequestOptions): Promise<void> {\r\n    await super.setupOptionDefaults(options);\r\n    options.useCorsProxy = true;\r\n  }\r\n\r\n  /**\r\n   * Gets theRelyingPartyUrl for the service.\r\n   * @returns RelyingPartyUrl for the service.\r\n   */\r\n  private getRelyingPartyUrl(): string {\r\n    if (Config.App.has(UlasClient._configRelyingPartyUri))\r\n      return Config.App.get(UlasClient._configRelyingPartyUri) + \"/\";\r\n    else\r\n      return Config.App.get(UlasClient._configDefaultRelyingPartyUri) + \"/\";\r\n  }\r\n\r\n  /**\r\n   * Gets the (delegation) access token to access the service\r\n   * @param requestContext The client request context.\r\n   * @param authTokenInfo Access token.\r\n   * @returns Resolves to the (delegation) access token.\r\n   * @internal\r\n   */\r\n  public async getAccessToken(requestContext: ClientRequestContext, authorizationToken: AuthorizationToken): Promise<AccessToken> {\r\n    const imsClient = new ImsDelegationSecureTokenClient();\r\n    return imsClient.getToken(requestContext, authorizationToken, this.getRelyingPartyUrl());\r\n  }\r\n\r\n  /**\r\n   * Logs usage via the ULAS service\r\n   * @param requestContext The client request context.\r\n   * @param hostName The client host name.\r\n   * @param usageType The client usage type\r\n   * @returns Response from the service.\r\n   */\r\n  public async logUsage(requestContext: AuthorizedClientRequestContext, entry: UsageLogEntry): Promise<LogPostingResponse> {\r\n    requestContext.enter();\r\n    const entryJson: UsageLogEntryJson = LogEntryConverter.toUsageLogJson(requestContext, entry);\r\n    return this.logEntry(requestContext, entryJson, false);\r\n  }\r\n\r\n  /**\r\n   * Logs one ore more feature entries via the ULAS service\r\n   * @param requestContext The client request context.\r\n   * @param entries One or more feature log entries.\r\n   * @returns Response from the service.\r\n   */\r\n  public async logFeature(requestContext: AuthorizedClientRequestContext, ...entries: FeatureLogEntry[]): Promise<LogPostingResponse> {\r\n    requestContext.enter();\r\n    if (entries.length === 0)\r\n      throw new Error(\"At least one FeatureLogEntry must be passed to UlasClient.logFeatures.\");\r\n\r\n    const entriesJson: FeatureLogEntryJson[] = LogEntryConverter.toFeatureLogJson(requestContext, entries);\r\n    return this.logEntry(requestContext, entriesJson, true);\r\n  }\r\n\r\n  private async logEntry(requestContext: AuthorizedClientRequestContext, entryJson: UsageLogEntryJson | FeatureLogEntryJson[], isFeatureEntry: boolean): Promise<LogPostingResponse> {\r\n    requestContext.enter();\r\n    let postUrl: string = (await this.getUrl(requestContext));\r\n    requestContext.enter();\r\n    if (isFeatureEntry)\r\n      postUrl += \"/featureLog\";\r\n\r\n    const token = requestContext.accessToken;\r\n    const authString: string = !token.getSamlAssertion() ? token.toTokenString() : \"SAML \" + token.toTokenString(IncludePrefix.No);\r\n    const options: RequestOptions = {\r\n      method: \"POST\",\r\n      headers: { authorization: authString },\r\n      body: entryJson,\r\n    };\r\n\r\n    await this.setupOptionDefaults(options);\r\n    requestContext.enter();\r\n    if (Logger.isEnabled(loggerCategory, LogLevel.Trace))\r\n      Logger.logTrace(loggerCategory, `Sending ${isFeatureEntry ? \"Feature\" : \"Usage\"} Log REST request...`, () => ({ url: postUrl, body: entryJson }));\r\n\r\n    const resp: Response = await request(requestContext, postUrl, options);\r\n    requestContext.enter();\r\n    const requestDetails = { url: postUrl, body: entryJson, response: resp };\r\n    if (Logger.isEnabled(loggerCategory, LogLevel.Trace))\r\n      Logger.logTrace(loggerCategory, `Sent ${isFeatureEntry ? \"Feature\" : \"Usage\"} Log REST request.`, () => requestDetails);\r\n\r\n    const respBody: any = resp.body;\r\n    if (!respBody || !respBody.status || respBody.status.toLowerCase() !== \"success\")\r\n      throw new Error(`Post ${isFeatureEntry ? \"Feature\" : \"Usage\"} Log REST request failed ${!!respBody.msg ? \": \" + respBody.msg : \"\"}. Details: ${JSON.stringify(requestDetails)}`);\r\n\r\n    return { status: BentleyStatus.SUCCESS, message: !!respBody.msg ? respBody.msg : \"\", time: !!respBody.time ? respBody.time : -1, requestId: respBody.reqID };\r\n  }\r\n}\r\n","/* (ignored) */","/* (ignored) */","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5vDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9KA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC/bA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1OA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAEA;AACA;AACA;AACA;AACA;AAAA;AACA,UAaA;AACA;AACA;;;;;;;;;;;;;;ACphBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AClIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9qBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACzEA;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC7DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC/NA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACvSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACv5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3tBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC1PA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3tCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACxnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3pJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AClBA;;;AAGA;AACA;;AAGA;AASA;;;;;;AAMA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;;;;;;;;;;;;;;;ACvBA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;AACA;;;AAGA;AACA;AAIA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhEA;AAkEA;;;AAGA;AACA;AACA;AADA;AAGA;;;AAGA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AApDA;AACA;AAFA;;;;;;;;;;;;;;AC3HA;;;AAGA;AACA;;AAEA;;;;AAIA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;AC/BA;;;AAGA;AACA;;AAIA;;AAEA;AACA;AAIA;AAFA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjMA;;;;;;;;;;;;;;;;;;;;;;ACXA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AAqBA;AAnBA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AApBA;AADA;AACA;AAAA;AAuBA;;AAEA;AACA;AAwBA;AAtBA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;;AAEA;AAEA;AASA;AAPA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AARA;AADA;AACA;AAAA;AAWA;;AAEA;AAEA;AAGA;AADA;AADA;AACA;AAFA;AADA;AACA;AAAA;AAKA;;AAEA;AAEA;AAEA;AAFA;AADA;AACA;AAAA;AAIA;;AAEA;AAEA;AAEA;AAFA;AADA;AACA;AAAA;AAIA;;AAEA;AAEA;AAYA;AAVA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAXA;AADA;AACA;AAAA;AA8BA;;AAEA;AACA;AAIA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;;AA/FA;AACA;AAFA;;;;;;;;;;;;;;AC1JA;;;AAGA;AACA;;;;;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqJA;AACA;AAEA;AACA;AAKA;AACA;AAYA;AACA;AAAA;AAAA;AACA;AACA;AAIA;AAKA;AACA;AAAA;AALA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAKA;AACA;AAJA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;;AA/TA;AADA;AAmUA;;AAEA;AACA;AAKA;AAHA;AADA;AACA;AAFA;AAUA;;AAEA;AACA;AAWA;AARA;AAFA;AACA;AACA;AAIA;AAFA;AACA;AACA;AAGA;AADA;AACA;AAVA;;;;;;;;;;;;;;;AClkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;;;AAGA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AA3HA;;;;;;;;;;;;;;ACxBA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAYA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA1BA;AADA;AA8BA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAvDA;AADA;AA2DA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAnEA;AADA;AAuEA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;;;;;;;;;;;;;;;;;;;;;AC5MA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;AAUA;AAEA;AAuHA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AA7OA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAIA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAKA;AADA;AACA;AAxGA;AADA;AACA;AAAA;AAiPA;;;AAGA;AAEA;AAYA;AAVA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAXA;AADA;AACA;AAAA;AAcA;;;AAGA;AAEA;AAkBA;AAbA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAjBA;AADA;AACA;AAAA;AAoBA;;;;;;;AAOA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AAaA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAvOA;AACA;AAFA;;;;;;;;;;;;;;;AC/TA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AA+GA;AACA;;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;;AAEA;AACA;AAIA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAhGA;AAkGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/JA;AAiKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;;;;;;;;;;;;;;ACxbA;;;AAGA;AACA;;AAIA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AATA;AAWA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AATA;;;;;;;;;;;;;;;AClDA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;;;;AAIA;AACA;AAEA;;;AAGA;AACA;AAAA;AAAA;AAAA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AA3OA;AADA;;;;;;;;;;;;;;AClBA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAhHA;AAkHA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAtBA;AAwBA;;AAEA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAnIA;AACA;AACA;AAHA;;;;;;;;;;;;;;;ACpKA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAZA;AAGA;AAGA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;;;;;;;;;;;;;;;ACVA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AArJA;AAuJA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAqBA;;;AAGA;AACA;AAMA;;;AAGA;AACA;AACA;AADA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AASA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA3UA;AACA;AAFA;;;;;;;;;;;;;;;AClMA;AACA;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAPA;;;;;;;;;;;;;;;ACbA;;;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA1FA;;;;;;;;;;;;;;;ACzBA;;;AAGA;AACA;AACA;AACA;AAGA;;;AAGA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;;;;;;;;;;;;;;;ACPA;AAGA;AAEA;AAEA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AASA;;;AAGA;AACA;AACA;AAPA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;;AAlLA;AACA;AAJA;;;;;;;;;;;;;;AChCA;;;AAGA;AACA;;;;;;;;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAGA;AAuDA;AApDA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAKA;AAFA;AACA;AACA;AAKA;AAFA;AACA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAKA;AAFA;AACA;AACA;AAIA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAtDA;AAFA;AACA;AACA;AAAA;AAyDA;;;AAGA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAxCA;AA0CA;;;;AAIA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAvHA;;;;;;;;;;;;;;AChJA;;;AAGA;AACA;;;;;;;;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AA2DA;AAxDA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAvDA;AADA;AACA;AAAA;AA6DA;;;AAGA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;;AA3IA;;;AAGA;AACA;AALA;AA+IA;AACA;AAAA;AACA;AACA;AAgCA;AA9BA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAtJA;;;;;;;;;;;;;;AC3RA;;;AAGA;AACA;;;;;;;;AAEA;AAGA;AAEA;AAEA;AACA;AAGA;AAEA;;;;;AAKA;AAEA;AAgCA;AA7BA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AA/BA;AADA;AACA;AAAA;AAkCA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAlCA;AAoCA;;;;AAIA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAxEA;;;;;;;;;;;;;;ACzGA;;;AAGA;AACA;;AAGA;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAxBA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;;;;;;;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAEA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAwBA;AArBA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAvBA;AA0BA;;;AAGA;AAEA;AAIA;AADA;AADA;AACA;AAHA;AADA;AACA;AAAA;AAMA;;;AAGA;AAEA;AAGA;AADA;AADA;AACA;AAFA;AADA;AACA;AAAA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAiBA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;;;AAGA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;AA2CA;;;AAGA;AACA;AASA;AACA;AACA;AAVA;AAWA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlGA;;;AAGA;AACA;AAPA;AAwGA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AA4BA;AAzBA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AA3BA;AADA;AACA;AAAA;AA8BA;;;AAGA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAtCA;AAwCA;;;AAGA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAvNA;;;;;;;;;;;;;;AC3YA;;;AAGA;AACA;;AAEA;;;AAGA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AArBA;;;;;;;;;;;;;;ACVA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;;AA9IA;AAHA;AAoJA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAxEA;AA0EA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAlDA;AAoDA;;AAEA;AACA;AAAA;;AACA;AACA;AACA;AAAA;AAHA;;;;;;;;;;;;;;;;;;;;;AC5SA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAmCA;;AAEA;AACA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;;AAEA;AACA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;;AAEA;AACA;AAUA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AAMA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AAAA;;AAOA;AACA;AAaA;AAXA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AAQA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AAEA;AAIA;AADA;AADA;AACA;AAHA;AADA;AACA;AAAA;AAMA;;AAEA;AAEA;AACA;AADA;AADA;AACA;AAAA;AAGA;;AAEA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAnFA;AAqFA;;AAEA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAnHA;;;;;;;;;;;;;;ACpWA;;;AAGA;AACA;;;;;;;;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAQA;AALA;AADA;AACA;AAIA;AADA;AACA;AAPA;AAUA;;AAEA;AACA;AAcA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAnDA;AAqDA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAlBA;AAoBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AA9CA;AAgDA;AACA;AAMA;AANA;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApEA;;;;;;;;;;;;;;;;;;;;;ACtLA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAuBA;;AAEA;AACA;AAUA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAgCA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AACA;AADA;AAGA;;AAEA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;;AAEA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;;AAEA;AAEA;AAMA;AAJA;AADA;AACA;AAGA;AADA;AACA;AALA;AADA;AACA;AAAA;AAQA;;AAEA;AAEA;AACA;AADA;AADA;AACA;AAAA;AAGA;;;AAGA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA/EA;AAiFA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA/GA;;;;;;;;;;;;;;ACrRA;;;AAGA;AACA;;;;;;;;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAiBA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;;;AAGA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxCA;AA0CA;;;AAGA;AACA;AAwBA;AArBA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAvBA;AA0BA;;;AAGA;AAEA;AAIA;AADA;AADA;AACA;AAHA;AADA;AACA;AAAA;AAMA;;;AAGA;AAEA;AAGA;AADA;AADA;AACA;AAFA;AADA;AACA;AAAA;AAKA;;;AAGA;AACA;AASA;AACA;AACA;AAVA;AAWA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAnIA;;;AAGA;AACA;AAPA;AAyIA;;;;AAIA;AACA;AAIA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA1NA;;;;;;;;;;;;;;ACxVA;;;AAGA;AACA;;AAGA;AAGA;;AAEA;AACA;AAAA;AACA;AAqGA;AApGA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAtGA;AAwGA;;AAEA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;;AAEA;AACA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAxBA;AA0BA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AALA;;;;;;;;;;;;;;ACxLA;;;AAGA;AACA;;;;;;;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAOA;;AAEA;AACA;AAGA;AADA;AADA;AACA;AAFA;AAKA;;AAEA;AAEA;AAAA;AAAA;AADA;AACA;AAAA;AAEA;;AAEA;AAEA;AAAA;AAAA;AADA;AACA;AAAA;AAYA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;;;AAGA;AACA;AAGA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA1IA;;;;;;;;;;;;;;AC1EA;;;AAGA;AACA;;;;;;;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;;AAEA;AAEA;AAgBA;AAbA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAfA;AADA;AACA;AAAA;AAkBA;;AAEA;AAEA;AAgBA;AAbA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAfA;AADA;AACA;AAAA;AAkBA;;;AAGA;AACA;AAMA;;;AAGA;AACA;AACA;AAPA;AACA;AAOA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AA1FA;AA4FA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAlDA;AAoDA;;AAEA;AACA;AAAA;;AACA;AAiDA;AA7CA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAlDA;AAoDA;;AAEA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;;;;;;;;;;;;;;AC9QA;;;AAGA;AACA;;;;;;;;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;;;AAGA;AAEA;AA+BA;AA7BA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AA9BA;AADA;AACA;AAAA;AAiCA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA1CA;AA4CA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA5FA;;;;;;;;;;;;;;AC3GA;;;AAGA;AACA;;;;;;;;AAEA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AAEA;AA8BA;AA3BA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAIA;AADA;AACA;AAMA;AADA;AACA;AA7BA;AADA;AACA;AAAA;AAgCA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;AA2CA;AAxCA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AA1CA;AADA;AACA;AAAA;AA6CA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAZA;AAcA;;;;AAIA;AACA;AAKA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAvRA;AAyRA;;;;AAIA;AACA;AAGA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AA3HA;;;;;;;;;;;;;;;;;;ACjhBA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;;;;;;;;;;;;;;;ACtGA;;;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;;AAZA;AADA;;;;;;;;;;;;;;;ACPA;;;AAGA;AACA;AACA;AAEA;AAEA;AAsEA;AACA;AAUA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;AAoBA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;;;;;;;;;;;;;;;AChFA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;;AAMA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAaA;;;;;;;AAOA;AACA;AAiBA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7BA;AAyCA;;;;;;;AAOA;AACA;AAuBA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;;;;;;;;AAQA;AACA;AAMA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;;;;;;;;AAQA;AACA;AAMA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAGA;AAEA;AACA;AACA;AA9BA;AAiDA;;;;AAIA;AACA;AAKA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AApGA;AACA;AACA;AAHA;;;;;;;;;;;;ACjOA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;A","sourceRoot":""}