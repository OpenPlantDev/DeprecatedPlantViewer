{"version":3,"file":"presentation-frontend.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\PersistenceHelper.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\Presentation.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\PresentationManager.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\RulesetManager.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\RulesetVariablesManager.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\presentation-frontend.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\selection\\SelectionChangeEvent.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\selection\\SelectionHandler.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\selection\\SelectionManager.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\selection\\SelectionScopesManager.ts","file:///external \"bentleyjs_core\"","file:///external \"imodeljs_frontend\"","file:///external \"presentation_common\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bentleyjs_core\"), require(\"imodeljs_frontend\"), require(\"presentation_common\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"presentation_frontend\", [\"bentleyjs_core\", \"imodeljs_frontend\", \"presentation_common\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"presentation_frontend\"] = factory(require(\"bentleyjs_core\"), require(\"imodeljs_frontend\"), require(\"presentation_common\"));\n\telse\n\t\troot[\"presentation_frontend\"] = factory(root[\"bentleyjs_core\"], root[\"imodeljs_frontend\"], root[\"presentation_common\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_frontend__, __WEBPACK_EXTERNAL_MODULE__bentley_presentation_common__) {\nreturn ","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { PersistentKeysContainer, KeySet } from \"@bentley/presentation-common\";\nimport { Id64String } from \"@bentley/bentleyjs-core\";\n\n/**\n * Static class which can be used to convert between\n * [KeySet]($presentation-common) and\n * [PersistentKeysContainer]($presentation-common).\n *\n * @beta\n */\nexport class PersistenceHelper {\n\n  /* istanbul ignore next */\n  private constructor() { }\n\n  /**\n   * Create a [PersistentKeysContainer]($presentation-common)\n   * @param imodel iModel whose keys are contained in the `keyset`\n   * @param keyset The keys to put into the persistent container\n   */\n  public static async createPersistentKeysContainer(imodel: IModelConnection, keyset: KeySet): Promise<PersistentKeysContainer> {\n    const instanceClassNames = Array.from(keyset.instanceKeys.keys());\n    const instanceClassNameBindings = instanceClassNames.map(() => \"?\").join(\",\");\n    const modelClassNameObjs = [];\n    for await (const modelClassNameObj of imodel.query(`\n      SELECT s.Alias || '.' || c.Name AS fullClassName\n        FROM [meta].[ECSchemaDef] s\n        JOIN [meta].[ECClassDef] c ON c.SchemaId = s.ECInstanceId\n        JOIN [meta].[ClassHasAllBaseClasses] b ON b.SourceECInstanceId = c.ECInstanceId\n        JOIN [meta].[ECClassDef] mc ON mc.ECInstanceId = b.TargetECInstanceId\n        JOIN [meta].[ECSchemaDef] ms ON ms.ECInstanceId = mc.SchemaId\n       WHERE ms.Alias || '.' || mc.Name = 'bis.Model'\n             AND s.Alias || '.' || c.Name IN (${instanceClassNameBindings})\n    `, instanceClassNames)) {\n      modelClassNameObjs.push(modelClassNameObj);\n    }\n    const modelClassNames = new Set(modelClassNameObjs.map((o: any) => (o.fullClassName as string)));\n    let modelIds = new Array<Id64String>();\n    let elementIds = new Array<Id64String>();\n    for (const entry of keyset.instanceKeys.entries()) {\n      const className = entry[0];\n      const ids = entry[1];\n      if (modelClassNames.has(className))\n        modelIds = modelIds.concat(Array.from(ids));\n      else\n        elementIds = elementIds.concat(Array.from(ids));\n    }\n    return {\n      models: modelIds,\n      elements: elementIds,\n      nodes: Array.from(keyset.nodeKeys),\n    };\n  }\n\n  /**\n   * Create a [KeySet]($presentation-common)\n   * @param imodel iModel whose keys are contained in the `container`\n   * @param container Container of keys to put into the KeySet\n   */\n  public static async createKeySet(imodel: IModelConnection, container: PersistentKeysContainer): Promise<KeySet> {\n    const keyset = new KeySet();\n    keyset.add(container.nodes);\n    keyset.add(await imodel.models.getProps(container.models));\n    keyset.add(await imodel.elements.getProps(container.elements));\n    return keyset;\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { I18N } from \"@bentley/imodeljs-i18n\";\nimport { IModelApp } from \"@bentley/imodeljs-frontend\";\nimport { PresentationError, PresentationStatus } from \"@bentley/presentation-common\";\nimport { PresentationManager, PresentationManagerProps } from \"./PresentationManager\";\nimport { SelectionManager } from \"./selection/SelectionManager\";\nimport { SelectionScopesManager } from \"./selection/SelectionScopesManager\";\n\nlet presentationManager: PresentationManager | undefined;\nlet selectionManager: SelectionManager | undefined;\nlet i18n: I18N | undefined;\n\n/**\n * Static class used to statically set up Presentation library for the frontend.\n * Basically what it does is:\n * - Create a singleton [[PresentationManager]] instance\n * - Create a singleton [[SelectionManager]] instance\n *\n * @public\n */\nexport class Presentation {\n\n  /* istanbul ignore next */\n  private constructor() { }\n\n  /**\n   * Initializes Presentation library for the frontend.\n   *\n   * Example:\n   * ``` ts\n   * [[include:Presentation.Frontend.Initialization]]\n   * ```\n   *\n   * The method should be called after a call\n   * to [IModelApp.startup]($imodeljs-frontend)\n   *\n   * @param props Optional properties to use when creating [[PresentationManager]]. If not provided\n   * or provided with `activeLocale` not set, `Presentation.i18n.languageList()[0]` is used as active locale.\n   */\n  public static initialize(props?: PresentationManagerProps): void {\n    if (!IModelApp.initialized) {\n      throw new PresentationError(PresentationStatus.NotInitialized,\n        \"IModelApp.startup must be called before calling Presentation.initialize\");\n    }\n    if (!i18n) {\n      i18n = IModelApp.i18n;\n    }\n    if (!presentationManager) {\n      if (!props)\n        props = {};\n      if (!props.activeLocale) {\n        const languages = Presentation.i18n.languageList();\n        props.activeLocale = (languages.length ? languages[0] : undefined);\n      }\n      presentationManager = PresentationManager.create(props);\n    }\n    if (!selectionManager) {\n      const scopesManager = new SelectionScopesManager({\n        rpcRequestsHandler: presentationManager.rpcRequestsHandler,\n        localeProvider: () => this.presentation.activeLocale,\n      });\n      selectionManager = new SelectionManager({\n        scopes: scopesManager,\n      });\n    }\n  }\n\n  /**\n   * Terminates Presentation library frontend. This method should be called\n   * before a call to [IModelApp.shutdown]($imodeljs-frontend)\n   */\n  public static terminate(): void {\n    if (presentationManager)\n      presentationManager.dispose();\n    presentationManager = undefined;\n    selectionManager = undefined;\n    i18n = undefined;\n  }\n\n  /**\n   * Get the singleton [[PresentationManager]]\n   */\n  public static get presentation(): PresentationManager {\n    if (!presentationManager)\n      throw new Error(\"Presentation must be first initialized by calling Presentation.initialize\");\n    return presentationManager;\n  }\n\n  /** @internal */\n  public static set presentation(value: PresentationManager) {\n    if (presentationManager)\n      presentationManager.dispose();\n    presentationManager = value;\n  }\n\n  /**\n   * Get the singleton [[SelectionManager]]\n   */\n  public static get selection(): SelectionManager {\n    if (!selectionManager)\n      throw new Error(\"Presentation must be first initialized by calling Presentation.initialize\");\n    return selectionManager;\n  }\n\n  /** @internal */\n  public static set selection(value: SelectionManager) {\n    selectionManager = value;\n  }\n\n  /**\n   * Get localization manager used by Presentation frontend.\n   * Returns the result of `IModelApp.i18n`.\n   */\n  public static get i18n(): I18N {\n    if (!i18n)\n      throw new Error(\"Presentation must be first initialized by calling Presentation.initialize\");\n    return i18n;\n  }\n\n  /** @internal */\n  public static set i18n(value: I18N) {\n    i18n = value;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { IDisposable } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport {\n  RpcRequestsHandler, DescriptorOverrides,\n  HierarchyRequestOptions, Node, NodeKey, NodePathElement,\n  ContentRequestOptions, Content, Descriptor, SelectionInfo,\n  Paged, KeySet, InstanceKey, LabelRequestOptions,\n} from \"@bentley/presentation-common\";\nimport { RulesetVariablesManager, RulesetVariablesManagerImpl } from \"./RulesetVariablesManager\";\nimport { RulesetManager, RulesetManagerImpl } from \"./RulesetManager\";\n\n/**\n * Properties used to configure [[PresentationManager]]\n * @public\n */\nexport interface PresentationManagerProps {\n  /**\n   * Sets the active locale to use when localizing presentation-related\n   * strings. It can later be changed through [[PresentationManager]].\n   */\n  activeLocale?: string;\n\n  /**\n   * ID used to identify client that requests data. Generally, clients should\n   * store this ID in their local storage so the ID can be reused across\n   * sessions - this allows reusing some caches.\n   *\n   * Defaults to a unique GUID as a client id.\n   */\n  clientId?: string;\n\n  /** @internal */\n  rpcRequestsHandler?: RpcRequestsHandler;\n}\n\n/**\n * Frontend Presentation manager which basically just forwards all calls to\n * the backend implementation.\n *\n * @public\n */\nexport class PresentationManager implements IDisposable {\n\n  private _requestsHandler: RpcRequestsHandler;\n  private _rulesets: RulesetManager;\n  private _rulesetVars: Map<string, RulesetVariablesManager>;\n\n  /**\n   * Get / set active locale used for localizing presentation data\n   */\n  public activeLocale: string | undefined;\n\n  private constructor(props?: PresentationManagerProps) {\n    if (props)\n      this.activeLocale = props.activeLocale;\n\n    this._requestsHandler = (props && props.rpcRequestsHandler)\n      ? props.rpcRequestsHandler\n      : new RpcRequestsHandler(props ? { clientId: props.clientId } : undefined);\n\n    this._rulesetVars = new Map<string, RulesetVariablesManager>();\n\n    const rulesets = new RulesetManagerImpl();\n    this._rulesets = rulesets;\n    this._requestsHandler.registerClientStateHolder(rulesets);\n  }\n\n  public dispose() {\n    this._requestsHandler.dispose();\n  }\n\n  /**\n   * Create a new PresentationManager instance\n   * @param props Optional properties used to configure the manager\n   */\n  public static create(props?: PresentationManagerProps) {\n    return new PresentationManager(props);\n  }\n\n  /** @internal */\n  public get rpcRequestsHandler() { return this._requestsHandler; }\n\n  /**\n   * Get rulesets manager\n   */\n  public rulesets() { return this._rulesets; }\n\n  /**\n   * Get ruleset variables manager for specific ruleset\n   * @param rulesetId Id of the ruleset to get the vars manager for\n   */\n  public vars(rulesetId: string) {\n    if (!this._rulesetVars.has(rulesetId)) {\n      const varsManager = new RulesetVariablesManagerImpl(rulesetId);\n      this._rulesetVars.set(rulesetId, varsManager);\n      this._requestsHandler.registerClientStateHolder(varsManager);\n    }\n    return this._rulesetVars.get(rulesetId)!;\n  }\n\n  private toIModelTokenOptions<TOptions extends { imodel: IModelConnection, locale?: string }>(options: TOptions) {\n    // 1. put default `locale`\n    // 2. put all `options` members (if `locale` is set, it'll override the default put at #1)\n    // 3. put `imodel` of type `IModelToken` which overwrites the `imodel` from `options` put at #2\n    return Object.assign({}, { locale: this.activeLocale }, options, {\n      imodel: options.imodel.iModelToken,\n    });\n  }\n\n  /**\n   * Retrieves nodes.\n   * @param requestOptions options for the request\n   * @param parentKey    Key of the parent node.\n   * @return A promise object that returns either a nodes response object with nodes and nodes count on success or an error string on error.\n   */\n  public async getNodesAndCount(requestOptions: Paged<HierarchyRequestOptions<IModelConnection>>, parentKey?: NodeKey) {\n    const parentKeyJson = parentKey ? NodeKey.toJSON(parentKey) : undefined;\n    const result = await this._requestsHandler.getNodesAndCount(this.toIModelTokenOptions(requestOptions), parentKeyJson);\n    return { ...result, nodes: result.nodes.map(Node.fromJSON) };\n  }\n\n  /**\n   * Retrieves nodes\n   * @param requestOptions options for the request\n   * @param parentKey    Key of the parent node if requesting for child nodes\n   * @return A promise object that returns either an array of nodes on success or an error string on error.\n   */\n  public async getNodes(requestOptions: Paged<HierarchyRequestOptions<IModelConnection>>, parentKey?: NodeKey): Promise<Node[]> {\n    const parentKeyJson = parentKey ? NodeKey.toJSON(parentKey) : undefined;\n    const result = await this._requestsHandler.getNodes(this.toIModelTokenOptions(requestOptions), parentKeyJson);\n    return result.map(Node.fromJSON);\n  }\n\n  /**\n   * Retrieves nodes count.\n   * @param requestOptions options for the request\n   * @param parentKey Key of the parent node if requesting for child nodes count.\n   * @return A promise object that returns the number of nodes.\n   */\n  public async getNodesCount(requestOptions: HierarchyRequestOptions<IModelConnection>, parentKey?: NodeKey): Promise<number> {\n    const parentKeyJson = parentKey ? NodeKey.toJSON(parentKey) : undefined;\n    return this._requestsHandler.getNodesCount(this.toIModelTokenOptions(requestOptions), parentKeyJson);\n  }\n\n  /**\n   * Retrieves paths from root nodes to children nodes according to specified keys. Intersecting paths will be merged.\n   * @param requestOptions options for the request\n   * @param paths Paths from root node to some child node.\n   * @param markedIndex Index of the path in `paths` that will be marked.\n   * @return A promise object that returns either an array of paths on success or an error string on error.\n   */\n  public async getNodePaths(requestOptions: HierarchyRequestOptions<IModelConnection>, paths: InstanceKey[][], markedIndex: number): Promise<NodePathElement[]> {\n    const pathsJson = paths.map((p) => p.map(InstanceKey.toJSON));\n    const result = await this._requestsHandler.getNodePaths(this.toIModelTokenOptions(requestOptions), pathsJson, markedIndex);\n    return result.map(NodePathElement.fromJSON);\n  }\n\n  /**\n   * Retrieves paths from root nodes to nodes containing filter text in their label.\n   * @param requestOptions options for the request\n   * @param filterText Text to filter nodes against.\n   * @return A promise object that returns either an array of paths on success or an error string on error.\n   */\n  public async getFilteredNodePaths(requestOptions: HierarchyRequestOptions<IModelConnection>, filterText: string): Promise<NodePathElement[]> {\n    const result = await this._requestsHandler.getFilteredNodePaths(this.toIModelTokenOptions(requestOptions), filterText);\n    return result.map(NodePathElement.fromJSON);\n  }\n\n  /**\n   * Retrieves the content descriptor which can be used to get content.\n   * @param requestOptions options for the request\n   * @param displayType  The preferred display type of the return content.\n   * @param keys         Keys of ECInstances to get the content for.\n   * @param selection    Optional selection info in case the content is being requested due to selection change.\n   * @return A promise object that returns either a descriptor on success or an error string on error.\n   */\n  public async getContentDescriptor(requestOptions: ContentRequestOptions<IModelConnection>, displayType: string, keys: KeySet, selection: SelectionInfo | undefined): Promise<Descriptor | undefined> {\n    const result = await this._requestsHandler.getContentDescriptor(this.toIModelTokenOptions(requestOptions), displayType, keys.toJSON(), selection);\n    return Descriptor.fromJSON(result);\n  }\n\n  /**\n   * Retrieves the content set size based on the supplied content descriptor override.\n   * @param requestOptions          options for the request\n   * @param descriptorOrOverrides   Content descriptor or its overrides specifying how the content should be customized\n   * @param keys                    Keys of ECInstances to get the content for.\n   * @return A promise object that returns either a number on success or an error string on error.\n   * Even if concrete implementation returns content in pages, this function returns the total\n   * number of records in the content set.\n   */\n  public async getContentSetSize(requestOptions: ContentRequestOptions<IModelConnection>, descriptorOrOverrides: Descriptor | DescriptorOverrides, keys: KeySet): Promise<number> {\n    return this._requestsHandler.getContentSetSize(this.toIModelTokenOptions(requestOptions), this.createDescriptorParam(descriptorOrOverrides), keys.toJSON());\n  }\n\n  /**\n   * Retrieves the content based on the supplied content descriptor override.\n   * @param requestOptions          options for the request\n   * @param descriptorOrOverrides   Content descriptor or its overrides specifying how the content should be customized\n   * @param keys                    Keys of ECInstances to get the content for.\n   * @return A promise object that returns either content on success or an error string on error.\n   */\n  public async getContent(requestOptions: Paged<ContentRequestOptions<IModelConnection>>, descriptorOrOverrides: Descriptor | DescriptorOverrides, keys: KeySet): Promise<Content | undefined> {\n    const result = await this._requestsHandler.getContent(this.toIModelTokenOptions(requestOptions), this.createDescriptorParam(descriptorOrOverrides), keys.toJSON());\n    return Content.fromJSON(result);\n  }\n\n  /**\n   * Retrieves the content and content set size based on the supplied content descriptor override.\n   * @param requestOptions          Options for the request.\n   * @param descriptorOrOverrides   Content descriptor or its overrides specifying how the content should be customized\n   * @param keys                    Keys of ECInstances to get the content for.\n   * @returns A promise object that returns either content and content set size on success or an error string on error.\n   */\n  public async getContentAndSize(requestOptions: Paged<ContentRequestOptions<IModelConnection>>, descriptorOrOverrides: Descriptor | DescriptorOverrides, keys: KeySet) {\n    const result = await this._requestsHandler.getContentAndSize(this.toIModelTokenOptions(requestOptions), this.createDescriptorParam(descriptorOrOverrides), keys.toJSON());\n    return { ...result, content: Content.fromJSON(result.content) };\n  }\n\n  private createDescriptorParam(descriptorOrOverrides: Descriptor | DescriptorOverrides) {\n    if (descriptorOrOverrides instanceof Descriptor)\n      return descriptorOrOverrides.createStrippedDescriptor().toJSON();\n    return descriptorOrOverrides;\n  }\n\n  /**\n   * Retrieves distinct values of specific field from the content based on the supplied content descriptor override.\n   * @param requestOptions options for the request\n   * @param descriptor           Content descriptor which specifies how the content should be returned.\n   * @param keys                 Keys of ECInstances to get the content for.\n   * @param fieldName            Name of the field from which to take values.\n   * @param maximumValueCount    Maximum numbers of values that can be returned. Unlimited if 0.\n   * @return A promise object that returns either distinct values on success or an error string on error.\n   */\n  public async getDistinctValues(requestOptions: ContentRequestOptions<IModelConnection>, descriptor: Descriptor, keys: KeySet, fieldName: string, maximumValueCount: number = 0): Promise<string[]> {\n    return this._requestsHandler.getDistinctValues(this.toIModelTokenOptions(requestOptions),\n      descriptor.createStrippedDescriptor().toJSON(), keys.toJSON(), fieldName, maximumValueCount);\n  }\n\n  /**\n   * Retrieves display label of specific item\n   * @param requestOptions options for the request\n   * @param key Key of instance to get label for\n   */\n  public async getDisplayLabel(requestOptions: LabelRequestOptions<IModelConnection>, key: InstanceKey): Promise<string> {\n    return this._requestsHandler.getDisplayLabel(this.toIModelTokenOptions(requestOptions), InstanceKey.toJSON(key));\n  }\n  /**\n   * Retrieves display label of specific items\n   * @param requestOptions options for the request\n   * @param keys Keys of instances to get labels for\n   */\n  public async getDisplayLabels(requestOptions: LabelRequestOptions<IModelConnection>, keys: InstanceKey[]): Promise<string[]> {\n    return this._requestsHandler.getDisplayLabels(this.toIModelTokenOptions(requestOptions), keys.map(InstanceKey.toJSON));\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { BeEvent, Guid } from \"@bentley/bentleyjs-core\";\nimport { RulesetManagerState, Ruleset, RegisteredRuleset, IClientStateHolder } from \"@bentley/presentation-common\";\n\n/**\n * Presentation ruleset registry.\n * @public\n */\nexport interface RulesetManager {\n  /**\n   * Get a ruleset with the specified id.\n   */\n  get(id: string): Promise<RegisteredRuleset | undefined>;\n\n  /**\n   * Register the supplied ruleset\n   */\n  add(ruleset: Ruleset): Promise<RegisteredRuleset>;\n\n  /**\n   * Unregister the supplied ruleset\n   */\n  remove(ruleset: RegisteredRuleset | [string, string]): Promise<boolean>;\n\n  /**\n   * Remove all rulesets registered in this session.\n   */\n  clear(): Promise<void>;\n}\n\n/** @internal */\nexport class RulesetManagerImpl implements RulesetManager, IClientStateHolder<RulesetManagerState> {\n\n  private _clientRulesets = new Map<string, RegisteredRuleset[]>();\n  public key = RulesetManagerState.STATE_ID;\n  public onStateChanged = new BeEvent<() => void>();\n\n  public get state(): RulesetManagerState {\n    const rulesets: RulesetManagerState = [];\n    this._clientRulesets.forEach((m) => {\n      m.forEach((r) => rulesets.push(r.toJSON()));\n    });\n    return rulesets;\n  }\n\n  /**\n   * Get a ruleset with the specified id.\n   */\n  public async get(id: string): Promise<RegisteredRuleset | undefined> {\n    const m = this._clientRulesets.get(id);\n    if (!m)\n      return undefined;\n    return m[0];\n  }\n\n  /**\n   * Register the supplied ruleset\n   */\n  public async add(ruleset: Ruleset): Promise<RegisteredRuleset> {\n    const registered = new RegisteredRuleset(ruleset, Guid.createValue(), (r: RegisteredRuleset) => this.remove(r));\n    if (!this._clientRulesets.has(ruleset.id))\n      this._clientRulesets.set(ruleset.id, []);\n    this._clientRulesets.get(ruleset.id)!.push(registered);\n    this.onStateChanged.raiseEvent();\n    return registered;\n  }\n\n  /**\n   * Unregister the supplied ruleset\n   */\n  public async remove(ruleset: RegisteredRuleset | [string, string]): Promise<boolean> {\n    let rulesetId, uniqueIdentifier: string;\n    if (Array.isArray(ruleset)) {\n      rulesetId = ruleset[0];\n      uniqueIdentifier = ruleset[1];\n    } else {\n      rulesetId = ruleset.id;\n      uniqueIdentifier = ruleset.uniqueIdentifier;\n    }\n\n    const m = this._clientRulesets.get(rulesetId);\n    if (!m)\n      return false;\n\n    let didRemove = false;\n    for (let i = 0; i < m.length; ++i) {\n      if (m[i].uniqueIdentifier === uniqueIdentifier) {\n        m.splice(i, 1);\n        didRemove = true;\n        break;\n      }\n    }\n\n    if (didRemove)\n      this.onStateChanged.raiseEvent();\n\n    return didRemove;\n  }\n\n  /**\n   * Remove all rulesets registered in this session.\n   */\n  public async clear(): Promise<void> {\n    if (0 === this._clientRulesets.size)\n      return;\n\n    this._clientRulesets.clear();\n    this.onStateChanged.raiseEvent();\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { Id64, Id64String, BeEvent } from \"@bentley/bentleyjs-core\";\nimport { RulesetVariablesState, VariableValueTypes, VariableValue, IClientStateHolder } from \"@bentley/presentation-common\";\n\n/**\n * Presentation ruleset variables' registry.\n * @public\n */\nexport interface RulesetVariablesManager {\n\n  /**\n   * Retrieves `string` variable value.\n   * Returns empty string if variable does not exist or does not convert to string.\n   */\n  getString(variableId: string): Promise<string>;\n  /**\n   * Sets `string` variable value\n   */\n  setString(variableId: string, value: string): Promise<void>;\n\n  /**\n   * Retrieves `boolean` variable value.\n   * Returns `false` if variable does not exist or does not convert to boolean.\n   */\n  getBool(variableId: string): Promise<boolean>;\n  /**\n   * Sets `boolean` variable value\n   */\n  setBool(variableId: string, value: boolean): Promise<void>;\n\n  /**\n   * Retrieves `number` variable value.\n   * Returns `0` if variable does not exist or does not convert to integer.\n   */\n  getInt(variableId: string): Promise<number>;\n  /**\n   * Sets `number` variable value\n   */\n  setInt(variableId: string, value: number): Promise<void>;\n\n  /**\n   * Retrieves `number[]` variable value.\n   * Returns empty array if variable does not exist or does not convert to integer array.\n   */\n  getInts(variableId: string): Promise<number[]>;\n  /**\n   * Sets `number[]` variable value\n   */\n  setInts(variableId: string, value: number[]): Promise<void>;\n\n  /**\n   * Retrieves `Id64String` variable value.\n   * Returns invalid Id64String if variable does not exist or does not convert to Id64String.\n   */\n  getId64(variableId: string): Promise<Id64String>;\n  /**\n   * Sets `Id64String` variable value\n   */\n  setId64(variableId: string, value: Id64String): Promise<void>;\n\n  /**\n   * Retrieves `Id64String[]` variable value.\n   * Returns empty array if variable does not exist or does not convert to Id64String array.\n   */\n  getId64s(variableId: string): Promise<Id64String[]>;\n  /**\n   * Sets `Id64String[]` variable value\n   */\n  setId64s(variableId: string, value: Id64String[]): Promise<void>;\n}\n\n/** @internal */\nexport class RulesetVariablesManagerImpl implements RulesetVariablesManager, IClientStateHolder<RulesetVariablesState> {\n\n  private _rulesetId: string;\n  private _clientValues = new Map<string, [VariableValueTypes, VariableValue]>();\n  public key = RulesetVariablesState.STATE_ID;\n  public onStateChanged = new BeEvent<() => void>();\n\n  public constructor(rulesetId: string) {\n    this._rulesetId = rulesetId;\n  }\n\n  public get state(): RulesetVariablesState {\n    const state: RulesetVariablesState = {};\n    const values: Array<[string, VariableValueTypes, VariableValue]> = [];\n    for (const entry of this._clientValues)\n      values.push([entry[0], entry[1][0], entry[1][1]]);\n    state[this._rulesetId] = values;\n    return state;\n  }\n\n  private changeValueType(actualValue: VariableValue, fromType: VariableValueTypes, toType: VariableValueTypes): VariableValue | undefined {\n    switch (toType) {\n      case VariableValueTypes.Bool:\n        switch (fromType) {\n          case VariableValueTypes.Int: return (0 !== actualValue);\n          case VariableValueTypes.Id64: return Id64.isValidId64(actualValue as string);\n          default: return undefined;\n        }\n      case VariableValueTypes.Int:\n        switch (fromType) {\n          case VariableValueTypes.Bool: return actualValue ? 1 : 0;\n          case VariableValueTypes.Id64: return Id64.getUpperUint32(actualValue as string);\n          default: return undefined;\n        }\n      case VariableValueTypes.IntArray:\n        switch (fromType) {\n          case VariableValueTypes.Id64Array: return (actualValue as string[]).map((id) => Id64.getUpperUint32(id));\n          default: return undefined;\n        }\n      case VariableValueTypes.Id64:\n        switch (fromType) {\n          case VariableValueTypes.Bool: return Id64.fromLocalAndBriefcaseIds(actualValue ? 1 : 0, 0);\n          case VariableValueTypes.Int: return Id64.fromLocalAndBriefcaseIds(actualValue as number, 0);\n          default: return undefined;\n        }\n      case VariableValueTypes.Id64Array:\n        switch (fromType) {\n          case VariableValueTypes.IntArray: return (actualValue as number[]).map((int) => Id64.fromLocalAndBriefcaseIds(int, 0));\n          default: return undefined;\n        }\n    }\n    return undefined;\n  }\n\n  private async getValue(id: string, type: VariableValueTypes): Promise<VariableValue | undefined> {\n    const value = this._clientValues.get(id);\n    if (!value)\n      return undefined;\n\n    if (value[0] !== type)\n      return this.changeValueType(value[1], value[0], type);\n\n    return value[1];\n  }\n  private async setValue(id: string, type: VariableValueTypes, value: VariableValue): Promise<void> {\n    this._clientValues.set(id, [type, value]);\n    this.onStateChanged.raiseEvent();\n  }\n\n  /**\n   * Retrieves `string` variable value.\n   * Returns empty string if variable does not exist or does not convert to string.\n   */\n  public async getString(variableId: string): Promise<string> {\n    return (await this.getValue(variableId, VariableValueTypes.String) as string) || \"\";\n  }\n\n  /**\n   * Sets `string` variable value\n   */\n  public async setString(variableId: string, value: string): Promise<void> {\n    await this.setValue(variableId, VariableValueTypes.String, value);\n  }\n\n  /**\n   * Retrieves `boolean` variable value.\n   * Returns `false` if variable does not exist or does not convert to boolean.\n   */\n  public async getBool(variableId: string): Promise<boolean> {\n    return (await this.getValue(variableId, VariableValueTypes.Bool) as boolean) || false;\n  }\n\n  /**\n   * Sets `boolean` variable value\n   */\n  public async setBool(variableId: string, value: boolean): Promise<void> {\n    await this.setValue(variableId, VariableValueTypes.Bool, value);\n  }\n\n  /**\n   * Retrieves `number` variable value.\n   * Returns `0` if variable does not exist or does not convert to integer.\n   */\n  public async getInt(variableId: string): Promise<number> {\n    return (await this.getValue(variableId, VariableValueTypes.Int) as number) || 0;\n  }\n\n  /**\n   * Sets `number` variable value\n   */\n  public async setInt(variableId: string, value: number): Promise<void> {\n    await this.setValue(variableId, VariableValueTypes.Int, value);\n  }\n\n  /**\n   * Retrieves `number[]` variable value.\n   * Returns empty array if variable does not exist or does not convert to integer array.\n   */\n  public async getInts(variableId: string): Promise<number[]> {\n    return (await this.getValue(variableId, VariableValueTypes.IntArray) as number[]) || [];\n  }\n\n  /**\n   * Sets `number[]` variable value\n   */\n  public async setInts(variableId: string, value: number[]): Promise<void> {\n    await this.setValue(variableId, VariableValueTypes.IntArray, value);\n  }\n\n  /**\n   * Retrieves `Id64String` variable value.\n   * Returns invalid Id64String if variable does not exist or does not convert to Id64String.\n   */\n  public async getId64(variableId: string): Promise<Id64String> {\n    return (await this.getValue(variableId, VariableValueTypes.Id64) as Id64String) || Id64.invalid;\n  }\n\n  /**\n   * Sets `Id64String` variable value\n   */\n  public async setId64(variableId: string, value: Id64String): Promise<void> {\n    await this.setValue(variableId, VariableValueTypes.Id64, value);\n  }\n\n  /**\n   * Retrieves `Id64String[]` variable value.\n   * Returns empty array if variable does not exist or does not convert to Id64String array.\n   */\n  public async getId64s(variableId: string): Promise<Id64String[]> {\n    return (await this.getValue(variableId, VariableValueTypes.Id64Array) as Id64String[]) || [];\n  }\n\n  /**\n   * Sets `Id64String[]` variable value\n   */\n  public async setId64s(variableId: string, value: Id64String[]): Promise<void> {\n    await this.setValue(variableId, VariableValueTypes.Id64Array, value);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nexport { PersistenceHelper } from \"./PersistenceHelper\";\nexport { Presentation } from \"./Presentation\";\nexport { PresentationManager, PresentationManagerProps } from \"./PresentationManager\";\nexport { RulesetManager } from \"./RulesetManager\";\nexport { RulesetVariablesManager } from \"./RulesetVariablesManager\";\n\n/** @module UnifiedSelection */\nexport { SelectionChangeEvent, SelectionChangeEventArgs, SelectionChangeType, SelectionChangesListener } from \"./selection/SelectionChangeEvent\";\nexport { ISelectionProvider } from \"./selection/ISelectionProvider\";\nexport { SelectionManager, SelectionManagerProps } from \"./selection/SelectionManager\";\nexport { SelectionScopesManager, SelectionScopesManagerProps } from \"./selection/SelectionScopesManager\";\nexport { SelectionHandler } from \"./selection/SelectionHandler\";\n\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\ndeclare var BUILD_SEMVER: string;\n/* istanbul ignore next */\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\n  if (!(window as any).iModelJsVersions)\n    (window as any).iModelJsVersions = new Map<string, string>();\n  (window as any).iModelJsVersions.set(\"presentation-frontend\", BUILD_SEMVER);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport { BeEvent } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { KeySet } from \"@bentley/presentation-common\";\nimport { ISelectionProvider } from \"./ISelectionProvider\";\n\n/**\n * An interface for selection change listeners.\n * @public\n */\nexport declare type SelectionChangesListener = (args: SelectionChangeEventArgs, provider: ISelectionProvider) => void;\n\n/**\n * An event broadcasted on selection changes\n * @public\n */\nexport class SelectionChangeEvent extends BeEvent<SelectionChangesListener> { }\n\n/**\n * The type of selection change\n * @public\n */\nexport enum SelectionChangeType {\n  /** Added to selection. */\n  Add,\n\n  /** Removed from selection. */\n  Remove,\n\n  /** Selection was replaced. */\n  Replace,\n\n  /** Selection was cleared. */\n  Clear,\n}\n\n/**\n * The event object that's sent when the selection changes.\n * @public\n */\nexport interface SelectionChangeEventArgs {\n  /** The name of the selection source which caused the selection change. */\n  source: string;\n\n  /** Level of the selection. */\n  level: number;\n\n  /** The selection change type. */\n  changeType: SelectionChangeType;\n\n  /** Set of keys affected by this selection change event. */\n  keys: Readonly<KeySet>;\n\n  /** iModel connection with which the selection is associated with. */\n  imodel: IModelConnection;\n\n  /** The timestamp of when the selection change happened */\n  timestamp: Date;\n\n  /** Ruleset Id. */\n  rulesetId?: string;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport { IDisposable, DisposableList } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { Keys, KeySet } from \"@bentley/presentation-common\";\nimport { SelectionChangeEventArgs, SelectionChangesListener } from \"./SelectionChangeEvent\";\nimport { SelectionManager } from \"./SelectionManager\";\nimport { ISelectionProvider } from \"./ISelectionProvider\";\n\n/**\n * A class that handles selection changes and helps to change\n * internal the selection state.\n *\n * @public\n */\nexport class SelectionHandler implements IDisposable {\n  private _inSelect: boolean;\n  private _disposables: DisposableList;\n\n  /** Selection manager used by this handler to manage selection */\n  public readonly manager: SelectionManager;\n  /** Name that's used as `SelectionChangeEventArgs.source` when making selection changes */\n  public name: string;\n  /** iModel whose selection is being handled */\n  public imodel: IModelConnection;\n  /**\n   * ID of presentation ruleset used by the component using this handler. The ID is set as\n   * `SelectionChangeEventArgs.rulesetId` when making selection changes and event\n   * listeners can use or ignore this information.\n   */\n  public rulesetId?: string;\n  /** Callback function called when selection changes */\n  public onSelect?: SelectionChangesListener;\n\n  /**\n   * Constructor.\n   * @param manager SelectionManager used to store overall selection.\n   * @param name The name of the selection handler.\n   * @param rulesetId Id of a ruleset selection changes will be associated.\n   * @param imodel iModel connection with which the selection changes will be associated with.\n   * @param onSelect Callback function called when selection changes.\n   */\n  constructor(manager: SelectionManager, name: string, imodel: IModelConnection, rulesetId?: string, onSelect?: SelectionChangesListener) {\n    this._inSelect = false;\n    this.manager = manager;\n    this._disposables = new DisposableList();\n    this.name = name;\n    this.rulesetId = rulesetId;\n    this.imodel = imodel;\n    this.onSelect = onSelect;\n    this._disposables.add(this.manager.selectionChange.addListener(this.onSelectionChanged));\n  }\n\n  /**\n   * Destructor. Must be called before disposing this object to make sure it cleans\n   * up correctly.\n   */\n  public dispose(): void {\n    this._disposables.dispose();\n  }\n\n  /**\n   * Called when the selection changes. Handles this callback by first checking whether\n   * the event should be handled at all (using the `shouldHandle` method) and then calling `onSelect`\n   */\n  protected onSelectionChanged = (evt: SelectionChangeEventArgs, provider: ISelectionProvider): void => {\n    if (!this.onSelect || !this.shouldHandle(evt))\n      return;\n\n    this._inSelect = true;\n    this.onSelect(evt, provider);\n    this._inSelect = false;\n  }\n\n  /** Called to check whether the event should be handled by this handler */\n  protected shouldHandle(evt: SelectionChangeEventArgs): boolean {\n    if (this.name === evt.source)\n      return false;\n    return true;\n  }\n\n  /** Get selection levels for the imodel managed by this handler */\n  public getSelectionLevels(): number[] {\n    return this.manager.getSelectionLevels(this.imodel);\n  }\n\n  /**\n   * Get selection for the imodel managed by this handler.\n   * @param level Level of the selection to get. Defaults to 0.\n   */\n  public getSelection(level?: number): Readonly<KeySet> {\n    return this.manager.getSelection(this.imodel, level);\n  }\n\n  /**\n   * Add to selection.\n   * @param keys The keys to add to selection.\n   * @param level Level of the selection.\n   */\n  public addToSelection(keys: Keys, level: number = 0): void {\n    if (this._inSelect)\n      return;\n\n    return this.manager.addToSelection(this.name, this.imodel, keys, level, this.rulesetId);\n  }\n\n  /**\n   * Remove from selection.\n   * @param keys The keys to remove from selection.\n   * @param level Level of the selection.\n   */\n  public removeFromSelection(keys: Keys, level: number = 0): void {\n    if (this._inSelect)\n      return;\n\n    return this.manager.removeFromSelection(this.name, this.imodel, keys, level, this.rulesetId);\n  }\n\n  /**\n   * Change selection.\n   * @param keys The keys indicating the new selection.\n   * @param level Level of the selection.\n   */\n  public replaceSelection(keys: Keys, level: number = 0): void {\n    if (this._inSelect)\n      return;\n\n    return this.manager.replaceSelection(this.name, this.imodel, keys, level, this.rulesetId);\n  }\n\n  /**\n   * Clear selection.\n   * @param level Level of the selection.\n   */\n  public clearSelection(level: number = 0): void {\n    if (this._inSelect)\n      return;\n\n    return this.manager.clearSelection(this.name, this.imodel, level, this.rulesetId);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport { IDisposable, GuidString, Guid, Id64Arg, Id64, Id64Array } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection, SelectionSetEvent, SelectionSetEventType, ElementLocateManager, IModelApp } from \"@bentley/imodeljs-frontend\";\nimport { KeySet, Keys, SelectionScope } from \"@bentley/presentation-common\";\nimport { ISelectionProvider } from \"./ISelectionProvider\";\nimport { SelectionChangeEvent, SelectionChangeEventArgs, SelectionChangeType } from \"./SelectionChangeEvent\";\nimport { SelectionScopesManager } from \"./SelectionScopesManager\";\n\n/**\n * Properties for creating [[SelectionManager]].\n * @public\n */\nexport interface SelectionManagerProps {\n  /** A manager for [selection scopes]($docs/learning/unified-selection/Terminology#selection-scope) */\n  scopes: SelectionScopesManager;\n}\n\n/**\n * The selection manager which stores the overall selection.\n * @public\n */\nexport class SelectionManager implements ISelectionProvider {\n  private _selectionContainerMap = new Map<IModelConnection, SelectionContainer>();\n  private _imodelToolSelectionSyncHandlers = new Map<IModelConnection, { requestorsCount: number, handler: ToolSelectionSyncHandler }>();\n\n  /** An event which gets broadcasted on selection changes */\n  public readonly selectionChange: SelectionChangeEvent;\n\n  /** Manager for [selection scopes]($docs/learning/unified-selection/Terminology#selection-scope) */\n  public readonly scopes: SelectionScopesManager;\n\n  /**\n   * Creates an instance of SelectionManager.\n   */\n  constructor(props: SelectionManagerProps) {\n    this.selectionChange = new SelectionChangeEvent();\n    this.scopes = props.scopes;\n    IModelConnection.onClose.addListener((imodel: IModelConnection) => {\n      this.onConnectionClose(imodel);\n    });\n  }\n\n  private onConnectionClose(imodel: IModelConnection): void {\n    this.clearSelection(\"Connection Close Event\", imodel);\n    this._selectionContainerMap.delete(imodel);\n  }\n\n  private getContainer(imodel: IModelConnection): SelectionContainer {\n    let selectionContainer = this._selectionContainerMap.get(imodel);\n    if (!selectionContainer) {\n      selectionContainer = new SelectionContainer();\n      this._selectionContainerMap.set(imodel, selectionContainer);\n    }\n    return selectionContainer;\n  }\n\n  /**\n   * Request the manager to sync with imodel's tool selection (see `IModelConnection.selectionSet`).\n   */\n  public setSyncWithIModelToolSelection(imodel: IModelConnection, sync = true) {\n    const registration = this._imodelToolSelectionSyncHandlers.get(imodel);\n    if (sync) {\n      if (!registration || registration.requestorsCount === 0) {\n        this._imodelToolSelectionSyncHandlers.set(imodel, { requestorsCount: 1, handler: new ToolSelectionSyncHandler(imodel, IModelApp.locateManager, this) });\n      } else {\n        this._imodelToolSelectionSyncHandlers.set(imodel, { ...registration, requestorsCount: registration.requestorsCount + 1 });\n      }\n    } else {\n      if (registration && registration.requestorsCount > 0) {\n        const requestorsCount = registration.requestorsCount - 1;\n        if (requestorsCount > 0) {\n          this._imodelToolSelectionSyncHandlers.set(imodel, { ...registration, requestorsCount });\n        } else {\n          this._imodelToolSelectionSyncHandlers.delete(imodel);\n          registration.handler.dispose();\n        }\n      }\n    }\n  }\n\n  /** Get the selection levels currently stored in this manager for the specified imodel */\n  public getSelectionLevels(imodel: IModelConnection): number[] {\n    return this.getContainer(imodel).getSelectionLevels();\n  }\n\n  /** Get the selection currently stored in this manager */\n  public getSelection(imodel: IModelConnection, level: number = 0): Readonly<KeySet> {\n    return this.getContainer(imodel).getSelection(level);\n  }\n\n  private handleEvent(evt: SelectionChangeEventArgs): void {\n    const container = this.getContainer(evt.imodel);\n    const selectedItemsSet = container.getSelection(evt.level);\n    const guidBefore = selectedItemsSet.guid;\n    switch (evt.changeType) {\n      case SelectionChangeType.Add:\n        selectedItemsSet.add(evt.keys);\n        break;\n      case SelectionChangeType.Remove:\n        selectedItemsSet.delete(evt.keys);\n        break;\n      case SelectionChangeType.Replace:\n        if (selectedItemsSet.size !== evt.keys.size || !selectedItemsSet.hasAll(evt.keys)) {\n          // note: the above check is only needed to avoid changing\n          // guid of the keyset if we're replacing keyset with the same keys\n          selectedItemsSet.clear().add(evt.keys);\n        }\n        break;\n      case SelectionChangeType.Clear:\n        selectedItemsSet.clear();\n        break;\n    }\n\n    if (selectedItemsSet.guid === guidBefore)\n      return;\n\n    container.clear(evt.level + 1);\n    this.selectionChange.raiseEvent(evt, this);\n  }\n\n  /**\n   * Add keys to the selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param keys Keys to add\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public addToSelection(source: string, imodel: IModelConnection, keys: Keys, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Add,\n      keys: new KeySet(keys),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Remove keys from current selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param keys Keys to remove\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public removeFromSelection(source: string, imodel: IModelConnection, keys: Keys, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Remove,\n      keys: new KeySet(keys),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Replace current selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param keys Keys to add\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public replaceSelection(source: string, imodel: IModelConnection, keys: Keys, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Replace,\n      keys: new KeySet(keys),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Clear current selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public clearSelection(source: string, imodel: IModelConnection, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Clear,\n      keys: new KeySet(),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Add keys to selection after applying [selection scope]($docs/learning/unified-selection/Terminology#selection-scope) on them.\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param ids Element IDs to add\n   * @param scope Selection scope to apply\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public async addToSelectionWithScope(source: string, imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string, level: number = 0, rulesetId?: string): Promise<void> {\n    const scopedKeys = await this.scopes.computeSelection(imodel, ids, scope);\n    this.addToSelection(source, imodel, scopedKeys, level, rulesetId);\n  }\n\n  /**\n   * Remove keys from current selection after applying [selection scope]($docs/learning/unified-selection/Terminology#selection-scope) on them.\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param ids Element IDs to remove\n   * @param scope Selection scope to apply\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public async removeFromSelectionWithScope(source: string, imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string, level: number = 0, rulesetId?: string): Promise<void> {\n    const scopedKeys = await this.scopes.computeSelection(imodel, ids, scope);\n    this.removeFromSelection(source, imodel, scopedKeys, level, rulesetId);\n  }\n\n  /**\n   * Replace current selection with keys after applying [selection scope]($docs/learning/unified-selection/Terminology#selection-scope) on them.\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param ids Element IDs to replace with\n   * @param scope Selection scope to apply\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public async replaceSelectionWithScope(source: string, imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string, level: number = 0, rulesetId?: string): Promise<void> {\n    const scopedKeys = await this.scopes.computeSelection(imodel, ids, scope);\n    this.replaceSelection(source, imodel, scopedKeys, level, rulesetId);\n  }\n}\n\n/** @internal */\nclass SelectionContainer {\n  private readonly _selectedItemsSetMap: Map<number, KeySet>;\n\n  constructor() {\n    this._selectedItemsSetMap = new Map<number, KeySet>();\n  }\n\n  public getSelection(level: number): KeySet {\n    let selectedItemsSet = this._selectedItemsSetMap.get(level);\n    if (!selectedItemsSet) {\n      selectedItemsSet = new KeySet();\n      this._selectedItemsSetMap.set(level, selectedItemsSet);\n    }\n    return selectedItemsSet;\n  }\n\n  public getSelectionLevels(): number[] {\n    const levels = new Array<number>();\n    for (const entry of this._selectedItemsSetMap.entries()) {\n      if (!entry[1].isEmpty)\n        levels.push(entry[0]);\n    }\n    return levels.sort();\n  }\n\n  public clear(level: number) {\n    const keys = this._selectedItemsSetMap.keys();\n    for (const key of keys) {\n      if (key >= level) {\n        const selectedItemsSet = this._selectedItemsSetMap.get(key)!;\n        selectedItemsSet.clear();\n      }\n    }\n  }\n}\n\n/** @internal */\nexport const TRANSIENT_ELEMENT_CLASSNAME = \"/TRANSIENT\";\n\n/** @internal */\nexport class ToolSelectionSyncHandler implements IDisposable {\n\n  private _selectionSourceName = \"Tool\";\n  private _logicalSelection: SelectionManager;\n  private _locateManager: ElementLocateManager;\n  private _imodel: IModelConnection;\n  private _imodelToolSelectionListenerDisposeFunc: () => void;\n  private _asyncsInProgress = new Set<GuidString>();\n\n  public constructor(imodel: IModelConnection, locateManager: ElementLocateManager, logicalSelection: SelectionManager) {\n    this._imodel = imodel;\n    this._locateManager = locateManager;\n    this._logicalSelection = logicalSelection;\n    this._imodelToolSelectionListenerDisposeFunc = imodel.selectionSet.onChanged.addListener(this.onToolSelectionChanged);\n  }\n\n  public dispose() {\n    this._imodelToolSelectionListenerDisposeFunc();\n  }\n\n  /** note: used only it tests */\n  public get pendingAsyncs() { return this._asyncsInProgress; }\n\n  // tslint:disable-next-line:naming-convention\n  private onToolSelectionChanged = async (ev: SelectionSetEvent): Promise<void> => {\n    // this component only cares about its own imodel\n    const imodel = ev.set.iModel;\n    if (imodel !== this._imodel)\n      return;\n\n    // determine the level of selection changes\n    // wip: may want to allow selecting at different levels?\n    const selectionLevel = 0;\n\n    let ids: Id64Arg;\n    switch (ev.type) {\n      case SelectionSetEventType.Add:\n        ids = ev.added;\n        break;\n      case SelectionSetEventType.Replace:\n        ids = ev.set.elements;\n        break;\n      default:\n        ids = ev.removed;\n        break;\n    }\n\n    // determine the scope id\n    // note: _always_ use \"element\" scope for fence selection\n    let scopeId = getScopeId(this._logicalSelection.scopes.activeScope);\n    const currHit = this._locateManager.currHit;\n    const isSingleSelectionFromPick = (undefined !== currHit && 1 === Id64.sizeOf(ids) && Id64.has(ids, currHit.sourceId));\n    if (!isSingleSelectionFromPick)\n      scopeId = \"element\";\n\n    // we're always using scoped selection changer even if the scope is set to \"element\" - that\n    // makes sure we're adding to selection keys with concrete classes and not \"BisCore:Element\", which\n    // we can't because otherwise our keys compare fails (presentation components load data with\n    // concrete classes)\n    const changer = new ScopedSelectionChanger(this._selectionSourceName, this._imodel, this._logicalSelection, scopeId);\n\n    // we know what to do immediately on `clear` events\n    if (SelectionSetEventType.Clear === ev.type) {\n      await changer.clear(selectionLevel);\n      return;\n    }\n\n    const parsedIds = parseIds(ids);\n    const asyncId = Guid.createValue();\n    this._asyncsInProgress.add(asyncId);\n    try {\n      switch (ev.type) {\n        case SelectionSetEventType.Add:\n          await changer.add(parsedIds.transient, parsedIds.persistent, selectionLevel);\n          break;\n        case SelectionSetEventType.Replace:\n          await changer.replace(parsedIds.transient, parsedIds.persistent, selectionLevel);\n          break;\n        case SelectionSetEventType.Remove:\n          await changer.remove(parsedIds.transient, parsedIds.persistent, selectionLevel);\n          break;\n      }\n    } finally {\n      this._asyncsInProgress.delete(asyncId);\n    }\n  }\n}\n\nconst getScopeId = (scope: SelectionScope | string | undefined): string => {\n  if (!scope)\n    return \"element\";\n  if (typeof scope === \"string\")\n    return scope;\n  return scope.id;\n};\n\nconst parseIds = (ids: Id64Arg): { persistent: Id64Arg, transient: Id64Arg } => {\n  let allPersistent = true;\n  let allTransient = true;\n  Id64.iterate(ids, (id) => {\n    if (Id64.isTransient(id))\n      allPersistent = false;\n    else\n      allTransient = false;\n    if (!allPersistent && !allTransient)\n      return false;\n    return true;\n  });\n\n  // avoid making a copy if ids are only persistent or only transient\n  if (allPersistent) {\n    return { persistent: ids, transient: [] };\n  } else if (allTransient) {\n    return { persistent: [], transient: ids };\n  }\n\n  // if `ids` contain mixed ids, we have to copy.. use Array instead of\n  // a Set for performance\n  const persistentElementIds: Id64Array = [];\n  const transientElementIds: Id64Array = [];\n  Id64.forEach(ids, (id) => {\n    if (Id64.isTransient(id))\n      transientElementIds.push(id);\n    else\n      persistentElementIds.push(id);\n  });\n  return { persistent: persistentElementIds, transient: transientElementIds };\n};\n\n/** @internal */\nclass ScopedSelectionChanger {\n  public readonly name: string;\n  public readonly imodel: IModelConnection;\n  public readonly manager: SelectionManager;\n  public readonly scope: SelectionScope | string;\n  public constructor(name: string, imodel: IModelConnection, manager: SelectionManager, scope: SelectionScope | string) {\n    this.name = name;\n    this.imodel = imodel;\n    this.manager = manager;\n    this.scope = scope;\n  }\n  public async clear(level: number): Promise<void> {\n    this.manager.clearSelection(this.name, this.imodel, level);\n  }\n  public async add(transientIds: Id64Arg, persistentIds: Id64Arg, level: number): Promise<void> {\n    const keys = await this.manager.scopes.computeSelection(this.imodel, persistentIds, this.scope);\n    Id64.forEach(transientIds, (id) => keys.add({ className: TRANSIENT_ELEMENT_CLASSNAME, id }));\n    this.manager.addToSelection(this.name, this.imodel, keys, level);\n  }\n  public async remove(transientIds: Id64Arg, persistentIds: Id64Arg, level: number): Promise<void> {\n    const keys = await this.manager.scopes.computeSelection(this.imodel, persistentIds, this.scope);\n    Id64.forEach(transientIds, (id) => keys.add({ className: TRANSIENT_ELEMENT_CLASSNAME, id }));\n    this.manager.removeFromSelection(this.name, this.imodel, keys, level);\n  }\n  public async replace(transientIds: Id64Arg, persistentIds: Id64Arg, level: number): Promise<void> {\n    const keys = await this.manager.scopes.computeSelection(this.imodel, persistentIds, this.scope);\n    Id64.forEach(transientIds, (id) => keys.add({ className: TRANSIENT_ELEMENT_CLASSNAME, id }));\n    this.manager.replaceSelection(this.name, this.imodel, keys, level);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module UnifiedSelection */\r\n\r\nimport { Id64Arg } from \"@bentley/bentleyjs-core\";\r\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\r\nimport { KeySet, SelectionScope, RpcRequestsHandler } from \"@bentley/presentation-common\";\r\n\r\n/**\r\n * Properties for creating [[SelectionScopesManager]].\r\n * @public\r\n */\r\nexport interface SelectionScopesManagerProps {\r\n  /** RPC handler to use for requesting selection scopes */\r\n  rpcRequestsHandler: RpcRequestsHandler;\r\n\r\n  /** Provider of active locale to use for localizing scopes */\r\n  localeProvider?: () => string | undefined;\r\n}\r\n\r\n/**\r\n * A manager that knows available [selection scopes]($docs/learning/unified-selection/Terminology#selection-scope)\r\n * and can compute logical selection based on element IDs and selection scope.\r\n *\r\n * @public\r\n */\r\nexport class SelectionScopesManager {\r\n\r\n  private _rpcRequestsHandler: RpcRequestsHandler;\r\n  private _getLocale: () => string | undefined;\r\n  private _activeScope: SelectionScope | string | undefined;\r\n\r\n  public constructor(props: SelectionScopesManagerProps) {\r\n    this._rpcRequestsHandler = props.rpcRequestsHandler;\r\n    this._getLocale = props.localeProvider ? props.localeProvider : (() => undefined);\r\n  }\r\n\r\n  /** Get active locale */\r\n  public get activeLocale() { return this._getLocale(); }\r\n\r\n  /** Get active selection scope or its id */\r\n  public get activeScope() { return this._activeScope; }\r\n  /** Set active selection scope or its id */\r\n  public set activeScope(scope: SelectionScope | string | undefined) { this._activeScope = scope; }\r\n\r\n  /**\r\n   * Get available selection scopes.\r\n   * @param imodel The iModel to get selection scopes for\r\n   * @param locale Optional locale to use when localizing scopes' label and description\r\n   */\r\n  public async getSelectionScopes(imodel: IModelConnection, locale?: string): Promise<SelectionScope[]> {\r\n    if (!locale)\r\n      locale = this._getLocale();\r\n    return this._rpcRequestsHandler.getSelectionScopes({ imodel: imodel.iModelToken, locale });\r\n  }\r\n\r\n  /**\r\n   * Computes keys that need to be added to logical selection based on provided selection scope.\r\n   * @param ids Element IDs to compute selection for\r\n   * @param scope Selection scope to apply\r\n   */\r\n  public async computeSelection(imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string): Promise<KeySet> {\r\n    // get scope id\r\n    const scopeId = (typeof scope === \"string\") ? scope : scope.id;\r\n\r\n    // convert ids input to array\r\n    if (typeof ids === \"string\")\r\n      ids = [ids];\r\n    else if (ids instanceof Set)\r\n      ids = [...ids];\r\n\r\n    // compute selection in batches to avoid HTTP 413\r\n    const keys = new KeySet();\r\n    const batchSize = 10000;\r\n    const batchesCount = Math.ceil(ids.length / batchSize);\r\n    const batchKeyPromises = [];\r\n    for (let batchIndex = 0; batchIndex < batchesCount; ++batchIndex) {\r\n      const batchStart = batchSize * batchIndex;\r\n      const batchEnd = (batchStart + batchSize > ids.length) ? ids.length : (batchStart + batchSize);\r\n      const batchIds = (0 === batchIndex && ids.length <= batchEnd) ? ids : ids.slice(batchStart, batchEnd);\r\n      batchKeyPromises.push(this._rpcRequestsHandler.computeSelection({ imodel: imodel.iModelToken }, batchIds, scopeId));\r\n    }\r\n    const batchKeys = (await Promise.all(batchKeyPromises)).map(KeySet.fromJSON);\r\n    batchKeys.forEach((bk) => keys.add(bk));\r\n    return keys;\r\n  }\r\n}\r\n","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_frontend__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_presentation_common__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;;;AAGA;AACA;;;;;;;;;AAGA;AAGA;;;;;;AAMA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;;AACA;AACA;AACA;;AACA;;;;;;;;AAQA;AACA;AATA;AAUA;AACA;;;;;;;;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAzDA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAvGA;;;;;;;;;;;;;;ACzBA;;;AAGA;AACA;;AAIA;AAMA;AACA;AA0BA;;;;;AAKA;AACA;AAWA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AAEA;AAtNA;;;;;;;;;;;;;;AC/CA;;;AAGA;AACA;;AAEA;AACA;AA4BA;AACA;AAAA;AAEA;AACA;AACA;AA2EA;AAzEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AA/EA;;;;;;;;;;;;;;ACpCA;;;AAGA;AACA;;AAEA;AACA;AAqEA;AACA;AAOA;AAJA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AA9JA;;;;;;;;;;;;;;AC7EA;;;AAGA;AACA;;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AAAA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC1BA;;;AAGA;AACA;;AAEA;AAWA;;;AAGA;AACA;AAAA;AAAA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;ACvCA;;;AAGA;AACA;;AAEA;AAOA;;;;;AAKA;AACA;AAmBA;;;;;;;AAOA;AACA;AAmBA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA7BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AA7HA;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAYA;;;AAGA;AACA;AAUA;;AAEA;AACA;AAZA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AA/NA;AAiOA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AASA;AAPA;AAKA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA3EA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAiEA;AAtFA;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACncA;;;AAGA;AACA;;AAIA;AAcA;;;;;AAKA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5DA;;;;;;;;;;;;AC5BA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;A","sourceRoot":""}