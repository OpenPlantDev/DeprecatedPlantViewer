{"version":3,"file":"imodeljs-quantity.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Constants.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Exception.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Formatter\\Format.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Formatter\\FormatEnums.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Formatter\\Formatter.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Parser.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Quantity.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\Unit.ts","file:///D:\\vsts_b\\5\\s\\core\\quantity\\src\\imodeljs-quantity.ts","file:///external \"bentleyjs_core\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bentleyjs_core\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"imodeljs_quantity\", [\"bentleyjs_core\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"imodeljs_quantity\"] = factory(require(\"bentleyjs_core\"));\n\telse\n\t\troot[\"imodeljs_quantity\"] = factory(root[\"bentleyjs_core\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__) {\nreturn ","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\n/** Constants used internally for both formatting and parsing.\n * @internal\n */\nexport class QuantityConstants {\n  public static readonly CHAR_COMMA = 44;\n  public static readonly CHAR_SPACE = 32;\n  public static readonly CHAR_NUMBER = 35;\n  public static readonly CHAR_PLUS = 43;\n  public static readonly CHAR_MINUS = 45;\n  public static readonly CHAR_PERIOD = 46;\n  public static readonly CHAR_SLASH = 47;\n  public static readonly CHAR_DIVISION_SLASH = 8725;\n  public static readonly CHAR_FRACTION_SLASH = 8260;\n  public static readonly CHAR_ONE_QUARTER = 188;\n  public static readonly CHAR_ONE_HALF = 189;\n  public static readonly CHAR_THREE_QUARTER = 190;\n  public static readonly CHAR_DIGIT_ZERO = 48;\n  public static readonly CHAR_DIGIT_NINE = 57;\n  public static readonly CHAR_UPPER_E = 69;\n  public static readonly CHAR_LOWER_E = 101;\n  private static _LOCALE_DECIMAL_SEPARATOR = \"\";\n  private static _LOCALE_THOUSAND_SEPARATOR = \"\";\n\n  /** Return the decimal separator for the current locale. */\n  public static get LocaleSpecificDecimalSeparator(): string {\n    if (QuantityConstants._LOCALE_DECIMAL_SEPARATOR.length > 0)\n      return QuantityConstants._LOCALE_DECIMAL_SEPARATOR;\n\n    QuantityConstants._LOCALE_DECIMAL_SEPARATOR = \".\";\n    const matches = (12345.6789).toLocaleString()!.match(/345(.*)67/);\n    if (matches && matches.length > 1)\n      QuantityConstants._LOCALE_DECIMAL_SEPARATOR = matches[1];\n\n    return QuantityConstants._LOCALE_DECIMAL_SEPARATOR;\n  }\n\n  /** Return the thousand separator for the current locale. */\n  public static get LocaleSpecificThousandSeparator(): string {\n    if (QuantityConstants._LOCALE_THOUSAND_SEPARATOR.length > 0)\n      return QuantityConstants._LOCALE_THOUSAND_SEPARATOR;\n\n    QuantityConstants._LOCALE_THOUSAND_SEPARATOR = \",\";\n    const matches = (12345.6789).toLocaleString()!.match(/12(.*)345/);\n    if (matches && matches.length > 0)\n      QuantityConstants._LOCALE_THOUSAND_SEPARATOR = matches[1];\n\n    return QuantityConstants._LOCALE_THOUSAND_SEPARATOR;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\nimport { BentleyError } from \"@bentley/bentleyjs-core\";\n\n/**\n * Status codes used during Quantity parsing and formatting processing.\n * @alpha\n */\nexport enum QuantityStatus {\n  QUANTITY_ERROR_BASE = 0x88DF,\n  Success = 0,\n  InvalidJson = QUANTITY_ERROR_BASE + 1,\n  InvalidCompositeFormat = QUANTITY_ERROR_BASE + 2,\n  UnableToGenerateParseTokens = QUANTITY_ERROR_BASE + 3,\n  NoValueOrUnitFoundInString = QUANTITY_ERROR_BASE + 4,\n  UnitLabelSuppliedButNotMatched = QUANTITY_ERROR_BASE + 5,\n  UnknownUnit = QUANTITY_ERROR_BASE + 6,\n  UnableToConvertParseTokensToQuantity = QUANTITY_ERROR_BASE + 7,\n}\n\n/** The error type thrown by this module. See [[QuantityStatus]] for `errorNumber` values.\n * @alpha\n */\nexport class QuantityError extends BentleyError {\n  public constructor(public readonly errorNumber: number, message?: string) {\n    super(errorNumber, message);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { FormatProps } from \"./Interfaces\";\nimport { UnitProps, UnitsProvider, UnitConversion, UnitConversionSpec } from \"../Interfaces\";\nimport { QuantityStatus, QuantityError } from \"../Exception\";\nimport { QuantityConstants } from \"../Constants\";\nimport {\n  FormatType, ScientificType, ShowSignOption, DecimalPrecision, FractionalPrecision, FormatTraits,\n} from \"./FormatEnums\";\n\n// cSpell:ignore ZERONORMALIZED, nosign, onlynegative, signalways, negativeparentheses\n// cSpell:ignore trailzeroes, keepsinglezero, zeroempty, keepdecimalpoint, applyrounding, fractiondash, showunitlabel, prependunitlabel, exponentonlynegative\n\n/** A class used to both define the specifications for formatting a quantity values and the methods to do the formatting.\n * @alpha\n */\nexport class Format implements FormatProps {\n  private _name = \"\";\n\n  protected _roundFactor: number = 0.0;\n  protected _type: FormatType = FormatType.Decimal; // required; options are decimal, fractional, scientific, station\n  protected _precision: number = DecimalPrecision.Six; // required\n  protected _minWidth?: number; // optional; positive int\n  protected _scientificType?: ScientificType; // required if type is scientific; options: normalized, zeroNormalized\n  protected _showSignOption: ShowSignOption = ShowSignOption.OnlyNegative; // options: noSign, onlyNegative, signAlways, negativeParentheses\n  protected _decimalSeparator: string = QuantityConstants.LocaleSpecificDecimalSeparator;\n  protected _thousandSeparator: string = QuantityConstants.LocaleSpecificThousandSeparator;\n  protected _uomSeparator = \" \"; // optional; default is \" \"; defined separator between magnitude and the unit\n  protected _stationSeparator = \"+\"; // optional; default is \"+\"\n  protected _stationOffsetSize?: number; // required when type is station; positive integer > 0\n  protected _formatTraits: FormatTraits = 0x0;\n  protected _spacer: string = \" \"; // optional; default is \" \"\n  protected _includeZero: boolean = true; // optional; default is true\n  protected _units?: Array<[UnitProps, string | undefined]>;\n\n  /** Constructor\n   *  @param name     The name of a format specification. TODO: make optional or remove\n   */\n  constructor(name: string) {\n    this._name = name;\n  }\n\n  get name(): string { return this._name; }\n  get roundFactor(): number { return this._roundFactor; }\n  get type(): FormatType { return this._type; }\n  get precision(): DecimalPrecision | FractionalPrecision { return this._precision; }\n  get minWidth(): number | undefined { return this._minWidth; }\n  get scientificType(): ScientificType | undefined { return this._scientificType; }\n  get showSignOption(): ShowSignOption { return this._showSignOption; }\n  get decimalSeparator(): string { return this._decimalSeparator; }\n  get thousandSeparator(): string { return this._thousandSeparator; }\n  get uomSeparator(): string { return this._uomSeparator; }\n  get stationSeparator(): string { return this._stationSeparator; }\n  get stationOffsetSize(): number | undefined { return this._stationOffsetSize; }\n  get formatTraits(): FormatTraits { return this._formatTraits; }\n  get spacer(): string | undefined { return this._spacer; }\n  get includeZero(): boolean | undefined { return this._includeZero; }\n  get units(): Array<[UnitProps, string | undefined]> | undefined { return this._units; }\n  get hasUnits(): boolean { return this._units !== undefined && this._units.length > 0; }\n\n  // parse and toString methods\n  public static scientificTypeToString(scientificType: ScientificType): string {\n    if (scientificType === ScientificType.Normalized)\n      return \"Normalized\";\n    else\n      return \"ZeroNormalized\";\n  }\n\n  /** This method parses input string that is typically extracted for persisted JSON data and validates that the string is a valid ScientificType. Throws exception if not valid. */\n  public static parseScientificType(scientificType: string, formatName: string): ScientificType {\n    switch (scientificType) {\n      case \"normalized\":\n        return ScientificType.Normalized;\n      case \"zeronormalized\":\n        return ScientificType.ZeroNormalized;\n      default:\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'SCIENTIFIC_TYPE' attribute.`);\n    }\n  }\n\n  /** Method used when generating a JSON object that represents this Format. */\n  public static showSignOptionToString(showSign: ShowSignOption): string {\n    switch (showSign) {\n      case ShowSignOption.NegativeParentheses:\n        return \"NegativeParentheses\";\n      case ShowSignOption.NoSign:\n        return \"NoSign\";\n      case ShowSignOption.OnlyNegative:\n        return \"OnlyNegative\";\n      case ShowSignOption.SignAlways:\n        return \"SignAlways\";\n    }\n  }\n\n  /** This method parses input string that is typically extracted for persisted JSON data and validates that the string is a valid ShowSignOption. Throws exception if not valid. */\n  public static parseShowSignOption(showSignOption: string, formatName: string): ShowSignOption {\n    switch (showSignOption.toLowerCase()) {\n      case \"nosign\":\n        return ShowSignOption.NoSign;\n      case \"onlynegative\":\n        return ShowSignOption.OnlyNegative;\n      case \"signalways\":\n        return ShowSignOption.SignAlways;\n      case \"negativeparentheses\":\n        return ShowSignOption.NegativeParentheses;\n      default:\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'showSignOption' attribute.`);\n    }\n  }\n\n  /** Method used when generating a JSON object that represents this Format. */\n  public static formatTraitsToArray(currentFormatTrait: FormatTraits): string[] {\n    const formatTraitsArr = Array<string>();\n    if ((currentFormatTrait & FormatTraits.TrailZeroes) === FormatTraits.TrailZeroes) formatTraitsArr.push(\"trailZeroes\");\n    if ((currentFormatTrait & FormatTraits.KeepSingleZero) === FormatTraits.KeepSingleZero) formatTraitsArr.push(\"keepSingleZero\");\n    if ((currentFormatTrait & FormatTraits.ZeroEmpty) === FormatTraits.ZeroEmpty) formatTraitsArr.push(\"zeroEmpty\");\n    if ((currentFormatTrait & FormatTraits.KeepDecimalPoint) === FormatTraits.KeepDecimalPoint) formatTraitsArr.push(\"keepDecimalPoint\");\n    if ((currentFormatTrait & FormatTraits.ApplyRounding) === FormatTraits.ApplyRounding) formatTraitsArr.push(\"applyRounding\");\n    if ((currentFormatTrait & FormatTraits.FractionDash) === FormatTraits.FractionDash) formatTraitsArr.push(\"fractionDash\");\n    if ((currentFormatTrait & FormatTraits.ShowUnitLabel) === FormatTraits.ShowUnitLabel) formatTraitsArr.push(\"showUnitLabel\");\n    if ((currentFormatTrait & FormatTraits.PrependUnitLabel) === FormatTraits.PrependUnitLabel) formatTraitsArr.push(\"prependUnitLabel\");\n    if ((currentFormatTrait & FormatTraits.Use1000Separator) === FormatTraits.Use1000Separator) formatTraitsArr.push(\"use1000Separator\");\n    if ((currentFormatTrait & FormatTraits.ExponentOnlyNegative) === FormatTraits.ExponentOnlyNegative) formatTraitsArr.push(\"exponentOnlyNegative\");\n\n    return formatTraitsArr;\n  }\n\n  /** This method parses input string that is typically extracted for persisted JSON data and validates that the string is a valid FormatTrait. Throws exception if not valid. */\n  public static parseFormatTrait(stringToCheck: string, currentFormatTrait: number): FormatTraits {\n    let formatTrait = currentFormatTrait;\n    switch (stringToCheck.toLowerCase()) {\n      case \"trailzeroes\":\n        formatTrait = currentFormatTrait | FormatTraits.TrailZeroes;\n        break;\n      case \"keepsinglezero\":\n        formatTrait = currentFormatTrait | FormatTraits.KeepSingleZero;\n        break;\n      case \"zeroempty\":\n        formatTrait = currentFormatTrait | FormatTraits.ZeroEmpty;\n        break;\n      case \"keepdecimalpoint\":\n        formatTrait = currentFormatTrait | FormatTraits.KeepDecimalPoint;\n        break;\n      case \"applyrounding\":\n        formatTrait = currentFormatTrait | FormatTraits.ApplyRounding;\n        break;\n      case \"fractiondash\":\n        formatTrait = currentFormatTrait | FormatTraits.FractionDash;\n        break;\n      case \"showunitlabel\":\n        formatTrait = currentFormatTrait | FormatTraits.ShowUnitLabel;\n        break;\n      case \"prependunitlabel\":\n        formatTrait = currentFormatTrait | FormatTraits.PrependUnitLabel;\n        break;\n      case \"use1000separator\":\n        formatTrait = currentFormatTrait | FormatTraits.Use1000Separator;\n        break;\n      case \"exponentonlynegative\":\n        formatTrait = currentFormatTrait | FormatTraits.ExponentOnlyNegative;\n        break;\n      default:\n        throw new QuantityError(QuantityStatus.InvalidJson, `Format has an invalid 'formatTraits' option.`);\n    }\n    return formatTrait;\n  }\n\n  /** Method used when generating a JSON object that represents this Format. */\n  public static formatTypeToString(type: FormatType): string {\n    switch (type) {\n      case FormatType.Decimal:\n        return \"Decimal\";\n      case FormatType.Scientific:\n        return \"Scientific\";\n      case FormatType.Station:\n        return \"Station\";\n      case FormatType.Fractional:\n        return \"Fractional\";\n    }\n  }\n\n  /** This method parses input string that is typically extracted for persisted JSON data and validates that the string is a valid FormatType. Throws exception if not valid. */\n  public static parseFormatType(jsonObjType: string, formatName: string): FormatType {\n    switch (jsonObjType.toLowerCase()) {\n      case \"decimal\":\n        return FormatType.Decimal;\n      case \"scientific\":\n        return FormatType.Scientific;\n      case \"station\":\n        return FormatType.Station;\n      case \"fractional\":\n        return FormatType.Fractional;\n      default:\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'type' attribute.`);\n    }\n  }\n\n  /** This method validates the input value, that is typically extracted for persisted JSON data, is a valid DecimalPrecision. Throws exception if not valid. */\n  public static parseDecimalPrecision(jsonObjPrecision: number): DecimalPrecision {\n    switch (jsonObjPrecision) {\n      case 0:\n        return DecimalPrecision.Zero;\n      case 1:\n        return DecimalPrecision.One;\n      case 2:\n        return DecimalPrecision.Two;\n      case 3:\n        return DecimalPrecision.Three;\n      case 4:\n        return DecimalPrecision.Four;\n      case 5:\n        return DecimalPrecision.Five;\n      case 6:\n        return DecimalPrecision.Six;\n      case 7:\n        return DecimalPrecision.Seven;\n      case 8:\n        return DecimalPrecision.Eight;\n      case 9:\n        return DecimalPrecision.Nine;\n      case 10:\n        return DecimalPrecision.Ten;\n      case 11:\n        return DecimalPrecision.Eleven;\n      case 12:\n        return DecimalPrecision.Twelve;\n      default:\n        throw new QuantityError(QuantityStatus.InvalidJson, `The 'precision' attribute must be an integer in the range 0-12.`);\n    }\n  }\n\n  /** This method validates the input value, that is typically extracted for persisted JSON data, is a valid FractionalPrecision. Throws exception if not valid. */\n  public static parseFractionalPrecision(jsonObjPrecision: number, formatName: string): FractionalPrecision {\n    switch (jsonObjPrecision) {\n      case 1:\n        return FractionalPrecision.One;\n      case 2:\n        return FractionalPrecision.Two;\n      case 4:\n        return FractionalPrecision.Four;\n      case 8:\n        return FractionalPrecision.Eight;\n      case 16:\n        return FractionalPrecision.Sixteen;\n      case 32:\n        return FractionalPrecision.ThirtyTwo;\n      case 64:\n        return FractionalPrecision.SixtyFour;\n      case 128:\n        return FractionalPrecision.OneHundredTwentyEight;\n      case 256:\n        return FractionalPrecision.TwoHundredFiftySix;\n      default:\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${formatName} has an invalid 'precision' attribute.`);\n    }\n  }\n\n  /** This method validates the input value, that is typically extracted for persisted JSON data, is a valid DecimalPrecision or FractionalPrecision. Throws exception if not valid. */\n  public static parsePrecision(precision: number, formatName: string, type: FormatType): DecimalPrecision | FractionalPrecision {\n    switch (type) { // type must be decimal, fractional, scientific, or station\n      case FormatType.Decimal:\n      case FormatType.Scientific:\n      case FormatType.Station:\n        return Format.parseDecimalPrecision(precision);\n      case FormatType.Fractional:\n        return Format.parseFractionalPrecision(precision, formatName);\n    }\n  }\n\n  private verifyFormatTraitsOptions(formatTraitsFromJson: string | string[]) {\n    const formatTraits = (Array.isArray(formatTraitsFromJson)) ? formatTraitsFromJson : formatTraitsFromJson.split(/,|;|\\|/);\n    formatTraits.forEach((formatTraitsString: string) => { // for each element in the string array\n      this._formatTraits = Format.parseFormatTrait(formatTraitsString, this.formatTraits);\n    });\n  }\n\n  /** This method returns true if the formatTrait is set in this Format object. */\n  public hasFormatTraitSet(formatTrait: FormatTraits): boolean {\n    return (this._formatTraits & formatTrait) === formatTrait;\n  }\n\n  private async createUnit(unitsProvider: UnitsProvider, name: string, label?: string): Promise<void> {\n    let newUnit: UnitProps | undefined;\n    if (name === undefined || typeof (name) !== \"string\" || (label !== undefined && typeof (label) !== \"string\")) // throws if name is undefined or name isn't a string or if label is defined and isn't a string\n      return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `This Composite has a unit with an invalid 'name' or 'label' attribute.`));\n    for (const unit of this.units!) {\n      const unitObj = unit[0].name;\n      if (unitObj.toLowerCase() === name.toLowerCase()) // duplicate names are not allowed\n        return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `The unit ${unitObj} has a duplicate name.`));\n    }\n    newUnit = await unitsProvider.findUnit(name);\n    if (!newUnit || !newUnit.isValid)\n      return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `Invalid unit name '${name}'.`));\n    this.units!.push([newUnit, label]);\n  }\n\n  private loadFormatProperties(jsonObj: any) {\n    if (undefined === jsonObj.type) // type is required\n      throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} does not have the required 'type' attribute.`);\n    if (typeof (jsonObj.type) !== \"string\")\n      throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'type' attribute. It should be of type 'string'.`);\n    this._type = Format.parseFormatType(jsonObj.type, this.name);\n\n    if (undefined === jsonObj.precision) // precision is required\n      throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} does not have the required 'precision' attribute.`);\n    else if (typeof (jsonObj.precision) !== \"number\") // must be a number\n      throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'precision' attribute. It should be of type 'number'.`);\n    else if (!Number.isInteger(jsonObj.precision)) // must be an integer\n      throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'precision' attribute. It should be an integer.`);\n    this._precision = Format.parsePrecision(jsonObj.precision, this.name, this._type as FormatType);\n\n    if (this.type === FormatType.Scientific) {\n      if (undefined === jsonObj.scientificType) // if format type is scientific and scientific type is undefined, throw\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has type 'Scientific' therefore attribute 'scientificType' is required.`);\n      if (typeof (jsonObj.scientificType) !== \"string\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'scientificType' attribute. It should be of type 'string'.`);\n      this._scientificType = Format.parseScientificType(jsonObj.scientificType.toLowerCase(), this.name);\n    }\n\n    if (this.type === FormatType.Station) {\n      if (undefined === jsonObj.stationOffsetSize)\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has type 'Station' therefore attribute 'stationOffsetSize' is required.`);\n      if (typeof (jsonObj.stationOffsetSize) !== \"number\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationOffsetSize' attribute. It should be of type 'number'.`);\n      if (!Number.isInteger(jsonObj.stationOffsetSize) || jsonObj.stationOffsetSize <= 0) // must be a positive int > 0\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationOffsetSize' attribute. It should be a positive integer.`);\n      this._stationOffsetSize = jsonObj.stationOffsetSize;\n    }\n\n    if (undefined !== jsonObj.roundFactor) { // optional; default is 0.0\n      if (typeof (jsonObj.roundFactor) !== \"number\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'roundFactor' attribute. It should be of type 'number'.`);\n      if (jsonObj.roundFactor !== this.roundFactor) // if roundFactor isn't default value of 0.0, reassign roundFactor variable\n        this._roundFactor = jsonObj.roundFactor;\n    }\n\n    if (undefined !== jsonObj.minWidth) { // optional\n      if (typeof (jsonObj.minWidth) !== \"number\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'minWidth' attribute. It should be of type 'number'.`);\n      if (!Number.isInteger(jsonObj.minWidth) || jsonObj.minWidth < 0) // must be a positive int\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'minWidth' attribute. It should be a positive integer.`);\n      this._minWidth = jsonObj.minWidth;\n    }\n\n    if (undefined !== jsonObj.showSignOption) { // optional; default is \"onlyNegative\"\n      if (typeof (jsonObj.showSignOption) !== \"string\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'showSignOption' attribute. It should be of type 'string'.`);\n      this._showSignOption = Format.parseShowSignOption(jsonObj.showSignOption, this.name);\n    }\n\n    if (undefined !== jsonObj.formatTraits && jsonObj.formatTraits.length !== 0) { // FormatTraits is optional\n      if (!Array.isArray(jsonObj.formatTraits) && typeof (jsonObj.formatTraits) !== \"string\") // must be either an array of strings or a string\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'formatTraits' attribute. It should be of type 'string' or 'string[]'.`);\n      this.verifyFormatTraitsOptions(jsonObj.formatTraits); // check that all of the options for formatTraits are valid. If now, throw\n    }\n\n    if (undefined !== jsonObj.decimalSeparator) { // optional\n      if (typeof (jsonObj.decimalSeparator) !== \"string\") // not a string or not a one character string\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'decimalSeparator' attribute. It should be of type 'string'.`);\n      if (jsonObj.decimalSeparator.length !== 1)\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'decimalSeparator' attribute. It must be a one character string.`);\n      this._decimalSeparator = jsonObj.decimalSeparator;\n    }\n\n    if (undefined !== jsonObj.thousandSeparator) { // optional\n      if (typeof (jsonObj.thousandSeparator) !== \"string\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'thousandSeparator' attribute. It should be of type 'string'.`);\n      if (jsonObj.thousandSeparator.length !== 1)\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'thousandSeparator' attribute. It must be a one character string.`);\n      this._thousandSeparator = jsonObj.thousandSeparator;\n    }\n\n    if (undefined !== jsonObj.uomSeparator) { // optional; default is \" \"\n      if (typeof (jsonObj.uomSeparator) !== \"string\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'uomSeparator' attribute. It should be of type 'string'.`);\n      if (jsonObj.uomSeparator.length < 0 || jsonObj.uomSeparator.length > 1)\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'uomSeparator' attribute. It must be empty or a string with a single character.`);\n      this._uomSeparator = jsonObj.uomSeparator;\n    }\n\n    if (undefined !== jsonObj.stationSeparator) { // optional; default is \"+\"\n      if (typeof (jsonObj.stationSeparator) !== \"string\")\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationSeparator' attribute. It should be of type 'string'.`);\n      if (jsonObj.stationSeparator.length !== 1)\n        throw new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has an invalid 'stationSeparator' attribute. It must be a one character string.`);\n      this._stationSeparator = jsonObj.stationSeparator;\n    }\n  }\n\n  /**\n   * Populates this Format with the values from the provided.\n   */\n  public async fromJson(unitsProvider: UnitsProvider, jsonObj: any): Promise<void> {\n    this.loadFormatProperties(jsonObj);\n\n    if (undefined !== jsonObj.composite) { // optional\n      this._units = new Array<[UnitProps, string | undefined]>();\n      if (jsonObj.composite.includeZero !== undefined) {\n        if (typeof (jsonObj.composite.includeZero) !== \"boolean\") // includeZero must be a boolean IF it is defined\n          return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'includeZero' attribute. It should be of type 'boolean'.`));\n        this._includeZero = jsonObj.composite.includeZero;\n      }\n      if (jsonObj.composite.spacer !== undefined) {  // spacer must be a string IF it is defined\n        if (typeof (jsonObj.composite.spacer) !== \"string\")\n          return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'spacer' attribute. It must be of type 'string'.`));\n        if (jsonObj.composite.spacer.length < 0 || jsonObj.composite.spacer.length > 1)\n          return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'spacer' attribute. It must be empty or a string with a single character.`));\n        this._spacer = jsonObj.composite.spacer;\n      }\n      if (jsonObj.composite.units !== undefined) { // if composite is defined, it must be an array with 1-4 units\n        if (!Array.isArray(jsonObj.composite.units)) { // must be an array\n          return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with an invalid 'units' attribute. It must be of type 'array'`));\n        }\n        if (jsonObj.composite.units.length > 0 && jsonObj.composite.units.length <= 4) { // Composite requires 1-4 units\n          try {\n            const createUnitPromises: Array<Promise<void>> = [];\n            for (const unit of jsonObj.composite.units) {\n              createUnitPromises.push(this.createUnit(unitsProvider, unit.name, unit.label));\n            }\n\n            await Promise.all(createUnitPromises);\n          } catch (e) {\n            return Promise.reject(e);\n          }\n        }\n      }\n      if (undefined === this.units || this.units.length === 0)\n        return Promise.reject(new QuantityError(QuantityStatus.InvalidJson, `The Format ${this.name} has a Composite with no valid 'units'`));\n    }\n  }\n\n  /**\n   * Returns a JSON object that contain the specification for this Format.\n   */\n  public toJson() {\n    const schemaJson: { [value: string]: any } = {};\n    schemaJson.type = Format.formatTypeToString(this.type!);\n    schemaJson.precision = this.precision;\n    schemaJson.roundFactor = this.roundFactor;\n    if (undefined !== this.minWidth) schemaJson.minWidth = this.minWidth;\n    schemaJson.showSignOption = Format.showSignOptionToString(this.showSignOption);\n    schemaJson.formatTraits = Format.formatTraitsToArray(this.formatTraits);\n    schemaJson.decimalSeparator = this.decimalSeparator;\n    schemaJson.thousandSeparator = this.thousandSeparator;\n    schemaJson.uomSeparator = this.uomSeparator;\n    if (undefined !== this.scientificType) schemaJson.scientificType = Format.scientificTypeToString(this.scientificType);\n    if (undefined !== this.stationOffsetSize) schemaJson.stationOffsetSize = this.stationOffsetSize;\n    schemaJson.stationSeparator = this.stationSeparator;\n    if (undefined !== this.units) {\n      const composite: { [value: string]: any } = {};\n      composite.spacer = this.spacer;\n      composite.includeZero = this.includeZero;\n      composite.units = [];\n      this.units.forEach((unit: any) => {\n        if (undefined !== unit[1])\n          composite.units.push({\n            name: unit[0].name,\n            label: unit[1],\n          });\n        else\n          composite.units.push({\n            name: unit[0].name,\n          });\n      });\n      schemaJson.composite = composite;\n    } else { }\n\n    return schemaJson;\n  }\n}\n\n/** A class that contains both formatting information and the conversion factors necessary to convert from an input unit to the units specified in the format.\n * @alpha\n */\nexport class FormatterSpec {\n  private _name = \"\";\n  private _conversions: UnitConversionSpec[] = [];  // max four entries\n  private _format: Format;\n\n  /** Constructor\n   *  @param name     The name of a format specification.\n   *  @param format   Defines the output format for the quantity value.\n   *  @param conversions An array of conversion factors necessary to convert from an input unit to the units specified in the format..\n   */\n  constructor(name: string, format: Format, conversions?: UnitConversionSpec[]) {\n    this._name = name;\n    this._format = format;\n    if (conversions) this._conversions = conversions;\n  }\n\n  get name(): string { return this._name; }\n  /** Returns an array of UnitConversionSpecs, one for each unit that is to be shown in the formatted quantity string. */\n  get unitConversions(): UnitConversionSpec[] { return this._conversions; }\n  get format(): Format { return this._format; }\n\n  /** Static async method to create a FormatSpec given the format and unit of the quantity that will be passed to the Formatter. The input unit will\n   * be used to generate conversion information for each unit specified in the Format. This method is async due to the fact that the units provider must make\n   * async calls to lookup unit definitions.\n   *  @param name     The name of a format specification.\n   *  @param unitsProvider The units provider is used to look up unit definitions and provide conversion information for converting between units.\n   *  @param inputUnit The unit the value to be formatted. This unit is often referred to as persistence unit.\n   */\n  public static async create(name: string, format: Format, unitsProvider: UnitsProvider, inputUnit?: UnitProps): Promise<FormatterSpec> {\n    const conversions: UnitConversionSpec[] = [];\n\n    if (format.units) {\n      let convertFromUnit = inputUnit;\n      for (const unit of format.units) {\n        let unitConversion: UnitConversion;\n        if (convertFromUnit) {\n          unitConversion = await unitsProvider.getConversion(convertFromUnit, unit[0]);\n        } else {\n          unitConversion = ({ factor: 1.0, offset: 0.0 }) as UnitConversion;\n        }\n        const unitLabel = (unit[1] && unit[1]!.length > 0) ? unit[1]! : unit[0].label;\n        const spec = ({ name: unit[0].name, label: unitLabel, conversion: unitConversion }) as UnitConversionSpec;\n\n        conversions.push(spec);\n        convertFromUnit = unit[0];\n      }\n    } else {\n      // if format is only numeric and a input unit is defined set spec to use the input unit as the format unit\n      if (inputUnit) {\n        const spec: UnitConversionSpec = { name: inputUnit.name, label: inputUnit.label, conversion: { factor: 1.0, offset: 0.0 } };\n        conversions.push(spec);\n      }\n    }\n\n    return Promise.resolve(new FormatterSpec(name, format, conversions));\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @alpha */\nexport enum FormatTraits {\n  TrailZeroes = 0x1,\n  KeepSingleZero = 0x2,\n  ZeroEmpty = 0x4,\n  KeepDecimalPoint = 0x8,\n  ApplyRounding = 0x10,\n  FractionDash = 0x20,\n  ShowUnitLabel = 0x40,\n  PrependUnitLabel = 0x80,\n  Use1000Separator = 0x100,\n  ExponentOnlyNegative = 0x200,\n}\n\n/** @alpha */\nexport enum FractionalPrecision {\n  One = 1,\n  Two = 2,\n  Four = 4,\n  Eight = 8,\n  Sixteen = 16,\n  ThirtyTwo = 32,\n  SixtyFour = 64,\n  OneHundredTwentyEight = 128,\n  TwoHundredFiftySix = 256,\n}\n\n/** @alpha */\nexport enum DecimalPrecision {\n  Zero = 0,\n  One = 1,\n  Two = 2,\n  Three = 3,\n  Four = 4,\n  Five = 5,\n  Six = 6,\n  Seven = 7,\n  Eight = 8,\n  Nine = 9,\n  Ten = 10,\n  Eleven = 11,\n  Twelve = 12,\n}\n\n/** @alpha */\nexport enum FormatType {\n  Decimal,\n  Fractional,\n  Scientific,\n  Station,\n}\n\n/** @alpha */\nexport enum ScientificType {\n  Normalized,\n  ZeroNormalized,\n}\n\n/** @alpha */\nexport enum ShowSignOption {\n  NoSign,\n  OnlyNegative,\n  SignAlways,\n  NegativeParentheses,\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { QuantityConstants } from \"../Constants\";\nimport { QuantityStatus, QuantityError } from \"../Exception\";\nimport { FormatterSpec } from \"./Format\";\nimport { FormatType, ScientificType, ShowSignOption, DecimalPrecision, FractionalPrecision, FormatTraits } from \"./FormatEnums\";\n\n/**  rounding additive\n * @internal\n */\nconst FPV_ROUNDFACTOR = 0.50000000001;\n\n/** A private helper class used to format fraction part of value into a numerator and denominator.\n * @internal\n */\nclass FractionalNumeric {\n  private _integral: number = 0;\n  private _numerator: number = 0;\n  private _denominator: number = 1;\n  private _greatestCommonFactor: number = 1;\n  private _textParts: string[] = [];\n\n  constructor(value: number, precision: FractionalPrecision, reduce: boolean) {\n    this.calculate(value, precision as number);\n    this.formTextParts(reduce);\n  }\n\n  private calculate(value: number, denominator: number) {\n    const positiveValue = Math.abs(value);\n    this._denominator = denominator;\n    this._integral = Math.floor(positiveValue);\n    const fractionPart = positiveValue - this._integral;\n    this._numerator = Math.floor(fractionPart * this._denominator + FPV_ROUNDFACTOR);\n\n    if (0 !== denominator && (this._numerator / this._denominator) === 1) {\n      this._numerator = 0;\n      this._integral += 1;\n    } else {\n      this._greatestCommonFactor = this.getGreatestCommonFactor(this._numerator, this._denominator);\n    }\n  }\n\n  /** Determine the GCD given two values. This value can be used to reduce a fraction.\n   * See algorithm description http://en.wikipedia.org/wiki/Euclidean_algorithm\n   */\n  private getGreatestCommonFactor(numerator: number, denominator: number): number {\n    let r;\n    while (denominator !== 0) {\n      r = numerator % denominator;\n      numerator = denominator;\n      denominator = r;\n    }\n    return (numerator < 0) ? -numerator : numerator;\n  }\n\n  public get greatestCommonFactor(): number { return this._greatestCommonFactor; }\n  public get hasFractionPart(): boolean { return this._textParts.length > 0; }\n  public get isZero(): boolean { return 0 === this._numerator; }\n\n  public getIntegralString(): string {\n    if (this._textParts.length > 0) return this._textParts[0];\n    return \"\";\n  }\n\n  public getNumeratorString(): string {\n    if (this._textParts.length >= 3) return this._textParts[1];\n    return \"\";\n  }\n\n  public getDenominatorString(): string {\n    if (this._textParts.length >= 3) return this._textParts[2];\n    return \"\";\n  }\n\n  private formTextParts(reduce: boolean): void {\n    let numerator = this._numerator;\n    let denominator = this._denominator;\n\n    if (reduce && this._greatestCommonFactor > 1) {\n      numerator /= this.greatestCommonFactor;\n      denominator /= this.greatestCommonFactor;\n    }\n\n    this._textParts.push(this._integral.toFixed(0));\n    if (numerator > 0) {\n      this._textParts.push(numerator.toFixed(0));\n      this._textParts.push(denominator.toFixed(0));\n    }\n  }\n}\n\n/** A helper class that contains methods used to format quantity values based on a format that are defined via the Format class.\n * @alpha\n */\nexport class Formatter {\n  // tslint:disable-next-line:naming-convention\n  private static FPV_MINTHRESHOLD = 1.0e-14;\n\n  private static isNegligible(value: number): boolean { return (Math.abs(value) < Formatter.FPV_MINTHRESHOLD); }\n\n  /** Return floating point value rounded by specific rounding factor.\n   *  @param value    Value to be rounded.\n   *  @param roundTo  Rounding factor.\n   */\n  private static roundDouble(value: number, roundTo: number): number {\n    if (Formatter.isNegligible(roundTo))\n      return value;\n\n    roundTo = Math.abs(roundTo);\n    let rnd = FPV_ROUNDFACTOR + (value / roundTo);\n    const iVal = Math.floor(rnd);\n    rnd = iVal * roundTo;\n    return (value < 0.0) ? -rnd : rnd;\n  }\n\n  /** Generate a formatted text string integer value insert 1000 separators if appropriate.\n   *  @param wholePart    Integer value to be formatted.\n   */\n  private static integerPartToText(wholePart: number, spec: FormatterSpec): string {\n    // build invariant string represent wholePart\n    let formattedValue = wholePart.toFixed(0);\n\n    if ((formattedValue.length > 3) && (spec.format.hasFormatTraitSet(FormatTraits.Use1000Separator) && (spec.format.thousandSeparator.length > 0))) {\n      let numSeparators = Math.floor(formattedValue.length / 3);\n      let groupLength = formattedValue.length % 3;\n\n      if (groupLength === 0) {\n        numSeparators = numSeparators - 1;\n        groupLength = groupLength + 3;\n      }\n\n      let outString = formattedValue.substr(0, groupLength);\n\n      for (let i = 1; i <= numSeparators; i += 1) {\n        outString = outString + spec.format.thousandSeparator + formattedValue.substr(groupLength, 3);\n        groupLength = groupLength + 3;\n      }\n\n      formattedValue = outString;\n    }\n\n    return formattedValue;\n  }\n\n  /** Trim trailing \"0\" from the text that represent the fractional part of a floating point value.\n   *  @param strVal   The value string.\n   */\n  private static trimTrailingZeroes(strVal: string): string {\n    let lastNonZeroCharIndex = -1;\n    for (let i = strVal.length - 1; i >= 0; i--) {\n      if (strVal.charCodeAt(i) !== QuantityConstants.CHAR_DIGIT_ZERO) {\n        lastNonZeroCharIndex = i;\n        break;\n      }\n    }\n    if (lastNonZeroCharIndex >= 0)\n      return strVal.substr(0, lastNonZeroCharIndex + 1);\n    return \"\";\n  }\n\n  /** Format a quantity value into a composite format such as ft-in or deg-min-sec.\n   *  @param compositeValue   The value for this part of the composite\n   *  @param isLastPart       If false the composite value should be a whole value, if true then the value should be formatted as a floating point value.\n   *  @param label            Label for this part of the composite. This will be either the default unit label or a custom label specified the format specification.\n   */\n  private static formatCompositePart(compositeValue: number, isLastPart: boolean, label: string, spec: FormatterSpec): string {\n    let componentText = \"\";\n    if (!isLastPart) {\n      componentText = Formatter.integerPartToText(compositeValue, spec);\n    } else {\n      componentText = Formatter.formatMagnitude(compositeValue, spec);\n    }\n\n    if (spec.format.hasFormatTraitSet(FormatTraits.ShowUnitLabel)) {\n      componentText = componentText + spec.format.uomSeparator + label;\n    } else {\n      if (!isLastPart) componentText = componentText + \":\";\n    }\n\n    return componentText;\n  }\n\n  /** Format a quantity value into a composite format such as ft-in or deg-min-sec.\n   *  @param magnitude   quantity value\n   *  @param fromUnit    quantity unit\n   */\n  private static formatComposite(magnitude: number, spec: FormatterSpec): string {\n    const compositeStrings: string[] = [];\n\n    // Caller will deal with appending +||-||() value sign as specified by formatting options so just format positive value\n    let posMagnitude = Math.abs(magnitude);\n\n    if ((Math.abs(posMagnitude) < 0.0001) && spec.format.hasFormatTraitSet(FormatTraits.ZeroEmpty)) return \"\";\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < spec.unitConversions.length; i++) {\n      const currentLabel = spec.unitConversions[i].label;\n      const unitConversion = spec.unitConversions[i].conversion;\n\n      if (unitConversion.factor < 1.0)\n        throw new QuantityError(QuantityStatus.InvalidCompositeFormat, `The Format ${spec.format.name} has a invalid unit specification..`);\n      if (i > 0 && unitConversion.offset !== 0)\n        throw new QuantityError(QuantityStatus.InvalidCompositeFormat, `The Format ${spec.format.name} has a invalid unit specification..`);\n\n      const unitValue = (posMagnitude * unitConversion.factor) + unitConversion.offset + Formatter.FPV_MINTHRESHOLD; // offset should only ever be defined for major unit\n      if (i < spec.format.units!.length - 1) {\n        const wholePart = Math.floor(unitValue);\n        const componentText = Formatter.formatCompositePart(wholePart, false, currentLabel, spec);\n        posMagnitude = unitValue - wholePart;\n        compositeStrings.push(componentText);\n      } else {\n        const componentText = Formatter.formatCompositePart(unitValue, true, currentLabel, spec);\n        compositeStrings.push(componentText);\n      }\n    }\n\n    return compositeStrings.join(spec.format.spacer ? spec.format.spacer : \"\");\n  }\n\n  /** Format a quantity value into a single text string. Imitate how formatting done by server method NumericFormatSpec::FormatDouble.\n   *  @param magnitude   quantity value\n   */\n  private static formatMagnitude(magnitude: number, spec: FormatterSpec): string {\n    let posMagnitude = Math.abs(magnitude);\n    if ((Math.abs(posMagnitude) < 0.0001) && spec.format.hasFormatTraitSet(FormatTraits.ZeroEmpty)) return \"\";\n\n    if (spec.format.hasFormatTraitSet(FormatTraits.ApplyRounding))\n      posMagnitude = Math.abs(Formatter.roundDouble(magnitude, spec.format.roundFactor));\n\n    const isSci = ((posMagnitude > 1.0e12) || spec.format.type === FormatType.Scientific);\n    const isDecimal = (isSci || spec.format.type === FormatType.Decimal);\n    const isFractional = (!isDecimal && spec.format.type === FormatType.Fractional);\n    /*const usesStops = spec.format.type === FormatType.Station;*/\n    const isPrecisionZero = spec.format.precision === DecimalPrecision.Zero;\n    const isKeepSingleZero = spec.format.hasFormatTraitSet(FormatTraits.KeepSingleZero);\n    const precisionScale = Math.pow(10.0, spec.format.precision);\n    const isKeepTrailingZeroes = spec.format.hasFormatTraitSet(FormatTraits.TrailZeroes);\n    let expInt = 0.0;\n\n    if (isSci && (posMagnitude !== 0.0)) {\n      let exp = Math.log10(posMagnitude);\n      let negativeExp = false;\n      if (exp < 0.0) {\n        exp = -exp;\n        negativeExp = true;\n      }\n\n      expInt = Math.floor(exp);\n      if (spec.format.type === FormatType.Scientific) {\n        if (spec.format.scientificType === ScientificType.ZeroNormalized && posMagnitude > 1.0) expInt += 1.0;\n        else if (spec.format.scientificType === ScientificType.Normalized && posMagnitude < 1.0) expInt += 1.0;\n        if (negativeExp) expInt = -expInt;\n      }\n      const factor = Math.pow(10.0, -expInt);\n      posMagnitude *= factor;\n    }\n\n    let formattedValue = \"\";\n    if (isDecimal) {\n      const actualVal = isPrecisionZero ? posMagnitude + FPV_ROUNDFACTOR : posMagnitude + Formatter.FPV_MINTHRESHOLD;\n      let wholePart = Math.floor(actualVal);\n      let fractionPart = actualVal - wholePart;\n      if (!isPrecisionZero) {\n        fractionPart = Math.abs(fractionPart) * precisionScale + FPV_ROUNDFACTOR;\n        if (fractionPart >= precisionScale) {\n          wholePart += 1;\n          fractionPart -= precisionScale;\n        }\n      }\n\n      formattedValue = Formatter.integerPartToText(wholePart, spec);\n      if (isPrecisionZero) {\n        if (isKeepSingleZero) {\n          formattedValue = formattedValue + spec.format.decimalSeparator + \"0\";\n        }\n      } else {\n        fractionPart = Math.floor(fractionPart) / precisionScale;\n        let fractionString = fractionPart.toFixed(spec.format.precision);\n        // remove leading \"0.\"\n        fractionString = fractionString.substr(2).padEnd(spec.format.precision, \"0\");\n        if (!isKeepTrailingZeroes) fractionString = Formatter.trimTrailingZeroes(fractionString);\n        if (fractionString.length > 0)\n          formattedValue = formattedValue + spec.format.decimalSeparator + fractionString;\n        else {\n          if (spec.format.hasFormatTraitSet(FormatTraits.KeepDecimalPoint))\n            formattedValue = formattedValue + spec.format.decimalSeparator;\n        }\n      }\n\n      if (isSci) {\n        const expString = \"e\" + expInt.toFixed(0);\n        formattedValue = formattedValue + expString;\n      }\n    } else if (isFractional) {\n      const fn = new FractionalNumeric(posMagnitude, spec.format.precision as FractionalPrecision, true);\n      formattedValue = fn.getIntegralString();\n\n      if (!fn.isZero && fn.hasFractionPart) {\n        const wholeFractionSeparator = spec.format.hasFormatTraitSet(FormatTraits.FractionDash) ? \"-\" : \" \";\n        const fractionString = fn.getNumeratorString() + \"/\" + fn.getDenominatorString();\n        formattedValue = formattedValue + wholeFractionSeparator + fractionString;\n      }\n    } else /* if (usesStops)*/ {\n      // we assume that stopping value is always positive\n      const denominator = (Math.pow(10, spec.format.stationOffsetSize!));\n      const tVal = Math.floor(posMagnitude); // this is the integer part only\n      const hiPart = Math.floor(tVal / denominator);\n      const lowPart = tVal - hiPart * denominator;\n      const fract = posMagnitude - tVal;\n      const fractionPart = Math.floor(0.5 + fract * precisionScale);\n      const stationString = hiPart.toFixed(0) + spec.format.stationSeparator + lowPart.toFixed(0).padStart(spec.format.stationOffsetSize!, \"0\");\n      let fractionString = \"\";\n      if (fractionPart > 0) {\n        fractionString = fractionPart.toFixed(0).padEnd(spec.format.precision, \"0\");\n        if (!isKeepTrailingZeroes) fractionString = Formatter.trimTrailingZeroes(fractionString);\n        formattedValue = stationString + spec.format.decimalSeparator + fractionString;\n      } else {\n        if (isKeepTrailingZeroes)\n          fractionString = spec.format.decimalSeparator + \"\".padEnd(spec.format.precision, \"0\");\n        else if (spec.format.hasFormatTraitSet(FormatTraits.KeepDecimalPoint))\n          fractionString = spec.format.decimalSeparator;\n        formattedValue = stationString + fractionString;\n      }\n    }\n    return formattedValue;\n  }\n\n  /** Format a quantity value into a single text string based on the current format specification of this class.\n   *  @param magnitude   defines the value to spec.format.\n   *  @param spec      A FormatterSpec object the defines specification for the magnitude and unit conversions for the formatter.\n   */\n  public static formatQuantity(magnitude: number, spec: FormatterSpec): string {\n    const valueIsNegative = magnitude < 0.0;\n    let prefix = \"\";\n    let suffix = \"\";\n    let formattedValue = \"\";\n    switch (spec.format.showSignOption) {\n      case ShowSignOption.NegativeParentheses:\n        if (valueIsNegative) {\n          prefix = \"(\";\n          suffix = \")\";\n        }\n        break;\n\n      case ShowSignOption.OnlyNegative:\n        if (valueIsNegative) prefix = \"-\";\n        break;\n\n      case ShowSignOption.SignAlways:\n        if (valueIsNegative) prefix = \"-\";\n        else prefix = \"+\";\n        break;\n\n      case ShowSignOption.NoSign:\n      default:\n        break;\n    }\n\n    let formattedMagnitude = \"\";\n\n    if (spec.format.hasUnits) {\n      formattedMagnitude = Formatter.formatComposite(magnitude, spec);\n    } else {\n      // unitless quantity\n      formattedMagnitude = Formatter.formatMagnitude(magnitude, spec);\n      if (formattedMagnitude.length > 0 && spec.unitConversions.length > 0 && spec.format.hasFormatTraitSet(FormatTraits.ShowUnitLabel)) {\n        if (spec.format.hasFormatTraitSet(FormatTraits.PrependUnitLabel))\n          formattedMagnitude = spec.unitConversions[0].label + spec.format.uomSeparator + formattedMagnitude;\n        else\n          formattedMagnitude = formattedMagnitude + spec.format.uomSeparator + spec.unitConversions[0].label;\n      }\n\n    }\n    // add Sign prefix and suffix as necessary\n    if ((prefix.length > 0 || suffix.length > 0) && formattedMagnitude.length > 0)\n      formattedValue = prefix + formattedMagnitude + suffix;\n    else\n      formattedValue = formattedMagnitude;\n\n    if (spec.format.minWidth && spec.format.minWidth < formattedValue.length)\n      formattedValue.padStart(spec.format.minWidth, \" \");\n\n    return formattedValue;\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { QuantityStatus } from \"./Exception\";\nimport { QuantityConstants } from \"./Constants\";\nimport { QuantityProps, UnitsProvider, UnitProps, UnitConversionSpec, UnitConversion, PotentialParseUnit } from \"./Interfaces\";\nimport { Quantity } from \"./Quantity\";\nimport { Format } from \"./Formatter/Format\";\nimport { FormatType, FormatTraits } from \"./Formatter/FormatEnums\";\n\n/**\n * Defines Results of parsing a string input by a user into its desired value type\n * @alpha\n */\nexport interface ParseResult {\n  value?: number | undefined;\n  status: QuantityStatus;\n}\n\n/** A ParserSpec holds information needed to parse a string into a quantity synchronously.\n * @alpha\n */\nexport class ParserSpec {\n  private _outUnit: UnitProps;\n  private _conversions: UnitConversionSpec[] = [];  // max four entries\n  private _format: Format;\n\n  /** Constructor\n   *  @param outUnit     The name of a format specification.\n   *  @param format   Defines the output format for the quantity value.\n   *  @param conversions An array of conversion factors necessary to convert from an input unit to the units specified in the format..\n   */\n  constructor(outUnit: UnitProps, format: Format, conversions: UnitConversionSpec[]) {\n    this._outUnit = outUnit;\n    this._format = format;\n    this._conversions = conversions;\n  }\n\n  /** Returns an array of UnitConversionSpecs for each unit label that may be used in the input string. */\n  get unitConversions(): UnitConversionSpec[] { return this._conversions; }\n  get format(): Format { return this._format; }\n  get outUnit(): UnitProps { return this._outUnit; }\n\n  /** Static async method to create a FormatSpec given the format and unit of the quantity that will be passed to the Formatter. The input unit will\n   * be used to generate conversion information for each unit specified in the Format. This method is async due to the fact that the units provider must make\n   * async calls to lookup unit definitions.\n   *  @param name     The name of a format specification.\n   *  @param unitsProvider The units provider is used to look up unit definitions and provide conversion information for converting between units.\n   *  @param inputUnit The unit the value to be formatted. This unit is often referred to as persistence unit.\n   */\n  public static async create(format: Format, unitsProvider: UnitsProvider, outUnit: UnitProps): Promise<ParserSpec> {\n    const conversions = await Parser.createUnitConversionSpecsForUnit(unitsProvider, outUnit);\n    return Promise.resolve(new ParserSpec(outUnit, format, conversions));\n  }\n}\n\n/** A ParseToken holds either a numeric or string token extracted from a string that represents a quantity value.\n * @alpha\n */\nclass ParseToken {\n  public value: number | string;\n\n  constructor(value: string | number) {\n    if (typeof value === \"string\") this.value = value.trim();\n    else this.value = value;\n  }\n\n  public get isString(): boolean { return typeof this.value === \"string\"; }\n  public get isNumber(): boolean { return typeof this.value === \"number\"; }\n}\n\n/** A ScientificToken holds an index and string representing the exponent.\n * @alpha\n */\nclass ScientificToken {\n  public index: number;\n  public exponent = \"\";\n\n  constructor(index: number, exponent?: string) {\n    this.index = index;\n    if (exponent) this.exponent = exponent;\n  }\n}\n\n/** A FractionToken holds an index and the fraction value of numerator / denominator.\n * @alpha\n */\nclass FractionToken {\n  public index: number;\n  public fraction = 0.0;\n  public exponent = \"\";\n\n  constructor(index: number, fraction?: number) {\n    this.index = index;\n    if (fraction) this.fraction = fraction;\n  }\n}\n\n/** A Parser class that is used to break a string that represents a quantity value into tokens.\n * @alpha\n */\nexport class Parser {\n  private static _log = false;\n  private static checkForScientificNotation(index: number, stringToParse: string, uomSeparatorToIgnore: number): ScientificToken {\n    let exponentString = \"\";\n    let i = index + 1;\n\n    for (; i < stringToParse.length; i++) {\n      const charCode = stringToParse.charCodeAt(i);\n      if (Parser.isDigit(charCode) || ((charCode === QuantityConstants.CHAR_MINUS || charCode === QuantityConstants.CHAR_PLUS) && (i === (index + 1)))) {\n        exponentString = exponentString.concat(stringToParse[i]);\n      } else {\n        i = uomSeparatorToIgnore === charCode ? i : i - 1;\n        break;\n      }\n    }\n\n    if (exponentString.length > 1 || ((exponentString.length === 1) && (exponentString.charCodeAt(0) !== QuantityConstants.CHAR_MINUS) && (exponentString.charCodeAt(0) !== QuantityConstants.CHAR_PLUS)))\n      return new ScientificToken(i, exponentString);\n\n    return new ScientificToken(index);\n  }\n\n  private static checkForFractions(index: number, stringToParse: string, uomSeparatorToIgnore: number, numeratorStr?: string): FractionToken {\n    let numeratorToken = \"\";\n    let denominatorToken = \"\";\n    let processingNumerator = true;\n    let i = index;\n    if (numeratorStr && numeratorStr.length > 0) {\n      numeratorToken = numeratorStr;\n      processingNumerator = false;\n    }\n\n    for (; i < stringToParse.length; i++) {\n      const charCode = stringToParse.charCodeAt(i);\n      if (Parser.isDigit(charCode)) {\n        if (processingNumerator) {\n          numeratorToken = numeratorToken.concat(stringToParse[i]);\n        } else {\n          denominatorToken = denominatorToken.concat(stringToParse[i]);\n        }\n      } else {\n        if (processingNumerator && (charCode === QuantityConstants.CHAR_SLASH || charCode === QuantityConstants.CHAR_DIVISION_SLASH || charCode === QuantityConstants.CHAR_DIVISION_SLASH)) {\n          processingNumerator = false;\n        } else {\n          if (uomSeparatorToIgnore !== charCode) i = i - 1; // skip over uom separator after fraction\n          break;\n        }\n      }\n    }\n\n    if (numeratorToken.length > 0 && denominatorToken.length > 0) {\n      const numerator = parseInt(numeratorToken, 10);\n      const denominator = parseInt(denominatorToken, 10);\n      if (denominator > 0)\n        return new FractionToken(i, numerator / denominator);\n      return new FractionToken(i);\n    }\n\n    return new FractionToken(index + 1);\n  }\n\n  private static isDigit(charCode: number): boolean {\n    return (charCode >= QuantityConstants.CHAR_DIGIT_ZERO) && (charCode <= QuantityConstants.CHAR_DIGIT_NINE);\n  }\n\n  private static isDigitOrDecimalSeparator(charCode: number, format: Format): boolean {\n    return (charCode === format.decimalSeparator.charCodeAt(0)) || Parser.isDigit(charCode);\n  }\n\n  /** Parse the quantity string and return and array of ParseTokens that represent the component invariant values and unit labels.\n   * @param quantitySpecification The quantity string to ba parsed.\n   */\n  public static parseQuantitySpecification(quantitySpecification: string, format: Format): ParseToken[] {\n    const tokens: ParseToken[] = [];\n    const str = quantitySpecification.trim();\n    let processingNumber = false;\n    let wipToken = \"\";\n    let signToken = \"\";\n    let uomSeparatorToIgnore = 0;\n    let fractionDashCode = 0;\n\n    const skipCodes: number[] = [format.thousandSeparator.charCodeAt(0)];\n\n    if (format.type === FormatType.Station && format.stationSeparator && format.stationSeparator.length === 1)\n      skipCodes.push(format.stationSeparator.charCodeAt(0));\n\n    if (format.type === FormatType.Fractional && format.hasFormatTraitSet(FormatTraits.FractionDash)) {\n      fractionDashCode = QuantityConstants.CHAR_MINUS;\n    }\n\n    if (format.uomSeparator && format.uomSeparator !== \" \" && format.uomSeparator.length === 1) {\n      uomSeparatorToIgnore = format.uomSeparator.charCodeAt(0);\n      skipCodes.push(uomSeparatorToIgnore);\n    }\n\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < str.length; i++) {\n      const charCode = str.charCodeAt(i);\n      if (Parser.isDigitOrDecimalSeparator(charCode, format)) {\n        if (!processingNumber) {\n          if (wipToken.length > 0) {\n            tokens.push(new ParseToken(wipToken));\n            wipToken = \"\";\n          }\n          processingNumber = true;\n        }\n        wipToken = wipToken.concat(str[i]);\n      } else {\n        if (processingNumber) {\n          if (charCode === QuantityConstants.CHAR_SLASH || charCode === QuantityConstants.CHAR_FRACTION_SLASH || charCode === QuantityConstants.CHAR_DIVISION_SLASH) {\n            const fractSymbol = Parser.checkForFractions(i + 1, str, uomSeparatorToIgnore, wipToken);\n            let fraction = fractSymbol.fraction;\n            i = fractSymbol.index;\n            if (fractSymbol.fraction !== 0.0) {\n              wipToken = \"\";\n              if (signToken.length > 0) {\n                if (signToken === \"-\") fraction = 0 - fraction;\n                signToken = \"\";\n              }\n\n              tokens.push(new ParseToken(fraction));\n              processingNumber = false;\n              continue;\n            }\n          } else {\n            // a space may signify end of number or start of decimal\n            if (charCode === QuantityConstants.CHAR_SPACE || charCode === fractionDashCode) {\n              const fractSymbol = Parser.checkForFractions(i + 1, str, uomSeparatorToIgnore);\n              let fraction = fractSymbol.fraction;\n              if (fractSymbol.fraction !== 0.0) {\n                i = fractSymbol.index;\n                if (signToken.length > 0) {\n                  wipToken = signToken + wipToken;\n                  if (signToken === \"-\") fraction = 0 - fraction;\n                  signToken = \"\";\n                }\n\n                const valueWithFraction = parseFloat(wipToken) + fraction;\n                tokens.push(new ParseToken(valueWithFraction));\n                processingNumber = false;\n                wipToken = \"\";\n              }\n              continue;\n            } else {\n              // an \"E\" or \"e\" may signify scientific notation\n              if (charCode === QuantityConstants.CHAR_UPPER_E || charCode === QuantityConstants.CHAR_LOWER_E) {\n                const exponentSymbol = Parser.checkForScientificNotation(i, str, uomSeparatorToIgnore);\n                i = exponentSymbol.index;\n\n                if (exponentSymbol.exponent && exponentSymbol.exponent.length > 0) {\n                  if (signToken.length > 0) {\n                    wipToken = signToken + wipToken;\n                    signToken = \"\";\n                  }\n\n                  wipToken = wipToken + \"e\" + exponentSymbol.exponent;\n                  const scientificValue = Number(wipToken);\n                  tokens.push(new ParseToken(scientificValue));\n                  processingNumber = false;\n                  wipToken = \"\";\n                  continue;\n                }\n              }\n            }\n          }\n\n          // ignore any codes in skipCodes\n          if (skipCodes.findIndex((ref) => ref === charCode) !== -1) continue;\n\n          if (signToken.length > 0) {\n            wipToken = signToken + wipToken;\n            signToken = \"\";\n          }\n\n          tokens.push(new ParseToken(parseFloat(wipToken)));\n\n          wipToken = (i < str.length) ? str[i] : \"\";\n          processingNumber = false;\n        } else {\n          // not processing a number\n          if (charCode === QuantityConstants.CHAR_PLUS || charCode === QuantityConstants.CHAR_MINUS) {\n            signToken = str[i];\n            continue;\n          }\n\n          wipToken = wipToken.concat(str[i]);\n        }\n      }\n    }\n\n    // handle case where end of input string is reached.\n    if (wipToken.length > 0) {\n      if (processingNumber) {\n        if (signToken.length > 0) {\n          wipToken = signToken + wipToken;\n          signToken = \"\";\n        }\n        tokens.push(new ParseToken(parseFloat(wipToken)));\n        processingNumber = false;\n      } else {\n        tokens.push(new ParseToken(wipToken));\n      }\n    }\n\n    return tokens;\n  }\n\n  private static async createQuantityFromParseTokens(tokens: ParseToken[], format: Format, unitsProvider: UnitsProvider): Promise<QuantityProps> {\n    const defaultUnit = format.units && format.units.length > 0 ? format.units[0][0] : undefined;\n\n    // common case where single value is supplied\n    if (tokens.length === 1) {\n      if (tokens[0].isNumber) {\n        return Promise.resolve(new Quantity(defaultUnit, tokens[0].value as number));\n      } else {\n        try {\n          const unit = await unitsProvider.findUnit(tokens[0].value as string, defaultUnit ? defaultUnit.unitFamily : undefined);\n          return Promise.resolve(new Quantity(unit));\n        } catch (err) { }\n      }\n    }\n\n    // common case where single value and single label are supplied\n    if (tokens.length === 2) {\n      if (tokens[0].isNumber && tokens[1].isString) {\n        const unit = await unitsProvider.findUnit(tokens[1].value as string, defaultUnit ? defaultUnit.unitFamily : undefined);\n        return Promise.resolve(new Quantity(unit, tokens[0].value as number));\n      } else {  // unit specification comes before value (like currency)\n        if (tokens[1].isNumber && tokens[0].isString) {\n          const unit = await unitsProvider.findUnit(tokens[0].value as string, defaultUnit ? defaultUnit.unitFamily : undefined);\n          return Promise.resolve(new Quantity(unit, tokens[1].value as number));\n        }\n      }\n    }\n\n    // common case where there are multiple value/label pairs\n    if (tokens.length % 2 === 0) {\n      let mag = 0.0;\n      let masterUnit = defaultUnit;\n      for (let i = 0; i < tokens.length; i = i + 2) {\n        if (tokens[i].isNumber && tokens[i + 1].isString) {\n          const value = tokens[i].value as number;\n          const unit = await unitsProvider.findUnit(tokens[i + 1].value as string, defaultUnit ? defaultUnit.unitFamily : undefined);\n          if (0 === i) {\n            masterUnit = unit;\n            mag = mag + value;\n          } else {\n            if (masterUnit) {\n              const conversion = await unitsProvider.getConversion(unit, masterUnit);\n              if (mag < 0.0)\n                mag = mag - ((value * conversion.factor)) + conversion.offset;\n              else\n                mag = mag + ((value * conversion.factor)) + conversion.offset;\n            }\n          }\n        }\n      }\n      return Promise.resolve(new Quantity(masterUnit, mag));\n    }\n\n    return Promise.resolve(new Quantity(defaultUnit));\n  }\n\n  /** Async method to generate a Quantity given a string that represents a quantity value and likely a unit label.\n   *  @param inString A string that contains text represent a quantity.\n   *  @param format   Defines the likely format of inString.\n   *  @param unitsProvider required to look up units that may be specified in inString\n   */\n  public static async parseIntoQuantity(inString: string, format: Format, unitsProvider: UnitsProvider): Promise<QuantityProps> {\n    const tokens: ParseToken[] = Parser.parseQuantitySpecification(inString, format);\n    if (tokens.length === 0)\n      return Promise.resolve(new Quantity());\n\n    return Parser.createQuantityFromParseTokens(tokens, format, unitsProvider);\n  }\n\n  /** method to get the Unit Conversion given a unit label */\n  private static tryFindUnitConversion(unitLabel: string, unitsConversions: UnitConversionSpec[]): UnitConversion | undefined {\n    if (unitsConversions.length > 0) {\n      const label = unitLabel.toLocaleLowerCase();\n      for (const conversion of unitsConversions) {\n        if (conversion.parseLabels) {\n          if (-1 !== conversion.parseLabels.findIndex((lbl) => lbl === label))\n            return conversion.conversion;\n        } else {\n          // tslint:disable-next-line:no-console\n          console.log(\"ERROR: Parser expects to find parseLabels array populate with all possible unit labels for the unit.\");\n        }\n      }\n    }\n\n    return undefined;\n  }\n\n  private static getQuantityValueFromParseTokens(tokens: ParseToken[], format: Format, unitsConversions: UnitConversionSpec[]): ParseResult {\n    const defaultUnit = format.units && format.units.length > 0 ? format.units[0][0] : undefined;\n    // common case where single value is supplied\n    if (tokens.length === 1) {\n      if (tokens[0].isNumber) {\n        if (defaultUnit) {\n          const conversion = Parser.tryFindUnitConversion(defaultUnit.label, unitsConversions);\n          if (conversion) {\n            const value = (tokens[0].value as number) * conversion.factor + conversion.offset;\n            return { value, status: QuantityStatus.Success };\n          }\n        }\n        // if no conversion or no defaultUnit, just return parsed number\n        return { value: tokens[0].value as number, status: QuantityStatus.UnknownUnit };\n      } else {\n        // only the unit label was specified so assume magnitude of 1\n        const conversion = Parser.tryFindUnitConversion(tokens[0].value as string, unitsConversions);\n        if (undefined !== conversion)\n          return { value: conversion.factor + conversion.offset, status: QuantityStatus.Success };\n        else\n          return { status: QuantityStatus.NoValueOrUnitFoundInString };\n      }\n    }\n\n    // common case where single value and single label are supplied\n    if (tokens.length === 2) {\n      if (tokens[0].isNumber && tokens[1].isString) {\n        const conversion = Parser.tryFindUnitConversion(tokens[1].value as string, unitsConversions);\n        if (conversion) {\n          const value = (tokens[0].value as number) * conversion.factor + conversion.offset;\n          return { value, status: QuantityStatus.Success };\n        }\n        // if no conversion, just return parsed number and ignore value in second token\n        return { value: tokens[0].value as number, status: QuantityStatus.UnitLabelSuppliedButNotMatched };\n      } else {  // unit specification comes before value (like currency)\n        if (tokens[1].isNumber && tokens[0].isString) {\n          const conversion = Parser.tryFindUnitConversion(tokens[0].value as string, unitsConversions);\n          if (conversion) {\n            const value = (tokens[1].value as number) * conversion.factor + conversion.offset;\n            return { value, status: QuantityStatus.Success };\n          }\n          // if no conversion, just return parsed number and ignore value in second token\n          return { value: tokens[1].value as number, status: QuantityStatus.UnitLabelSuppliedButNotMatched };\n        }\n      }\n    }\n\n    // common case where there are multiple value/label pairs\n    if (tokens.length % 2 === 0) {\n      let mag = 0.0;\n      for (let i = 0; i < tokens.length; i = i + 2) {\n        if (tokens[i].isNumber && tokens[i + 1].isString) {\n          const value = tokens[i].value as number;\n          const conversion = Parser.tryFindUnitConversion(tokens[i + 1].value as string, unitsConversions);\n          if (conversion) {\n            if (mag < 0.0)\n              mag = mag - ((value * conversion.factor)) + conversion.offset;\n            else\n              mag = mag + ((value * conversion.factor)) + conversion.offset;\n          }\n        }\n      }\n      return { value: mag, status: QuantityStatus.Success };\n    }\n\n    return { status: QuantityStatus.UnableToConvertParseTokensToQuantity };\n  }\n\n  /** Method to generate a Quantity given a string that represents a quantity value.\n   *  @param inString A string that contains text represent a quantity.\n   *  @param parserSpec unit label if not explicitly defined by user. Must have matching entry in supplied array of unitsConversions.\n   *  @param defaultValue default value to return if parsing is un successful\n   */\n  public static parseQuantityString(inString: string, parserSpec: ParserSpec): ParseResult {\n    return Parser.parseIntoQuantityValue(inString, parserSpec.format, parserSpec.unitConversions);\n  }\n\n  /** Method to generate a Quantity given a string that represents a quantity value and likely a unit label.\n   *  @param inString A string that contains text represent a quantity.\n   *  @param format   Defines the likely format of inString. Primary unit serves as a default unit if no unit label found in string.\n   *  @param unitsConversions dictionary of conversions used to convert from unit used in inString to output quantity\n   */\n  public static parseIntoQuantityValue(inString: string, format: Format, unitsConversions: UnitConversionSpec[]): ParseResult {\n    const tokens: ParseToken[] = Parser.parseQuantitySpecification(inString, format);\n    if (tokens.length === 0)\n      return { status: QuantityStatus.UnableToGenerateParseTokens };\n\n    if (Parser._log) {\n      // tslint:disable-next-line:no-console\n      console.log(`Parse tokens`);\n      let i = 0;\n      for (const token of tokens) {\n        // tslint:disable-next-line:no-console\n        console.log(`  [${i++}] isNumber=${token.isNumber} isString=${token.isString} token=${token.value}`);\n      }\n    }\n\n    return Parser.getQuantityValueFromParseTokens(tokens, format, unitsConversions);\n  }\n\n  /** Async Method used to create an array of UnitConversionSpec entries that can be used in synchronous calls to parse units. */\n  public static async createUnitConversionSpecsForUnit(unitsProvider: UnitsProvider, outUnit: UnitProps): Promise<UnitConversionSpec[]> {\n    const unitConversionSpecs: UnitConversionSpec[] = [];\n\n    const familyUnits = await unitsProvider.getUnitsByFamily(outUnit.unitFamily);\n    for (const unit of familyUnits) {\n      const conversion = await unitsProvider.getConversion(unit, outUnit);\n      const parseLabels: string[] = [unit.label.toLocaleLowerCase()];\n      // add any alternate labels that may be define by the UnitProp\n      if (unit.alternateLabels) {\n        unit.alternateLabels.forEach((label: string) => {\n          const potentialLabel = label.toLocaleLowerCase();\n          if (-1 === parseLabels.findIndex((lbl) => lbl === potentialLabel))\n            parseLabels.push(label.toLocaleLowerCase());\n        });\n      }\n\n      unitConversionSpecs.push({\n        name: unit.name,\n        label: unit.label,\n        conversion,\n        parseLabels,\n      });\n    }\n    return Promise.resolve(unitConversionSpecs);\n  }\n\n  /** Async Method used to create an array of UnitConversionSpec entries that can be used in synchronous calls to parse units. */\n  public static async createUnitConversionSpecs(unitsProvider: UnitsProvider, outUnitName: string, potentialParseUnits: PotentialParseUnit[]): Promise<UnitConversionSpec[]> {\n    const unitConversionSpecs: UnitConversionSpec[] = [];\n\n    const outUnit = await unitsProvider.findUnitByName(outUnitName);\n    if (!outUnit || !outUnit.name || 0 === outUnit.name.length) {\n      // tslint:disable-next-line:no-console\n      console.log(`[Parser.createUnitConversionSpecs] ERROR: Unable to locate out unit ${outUnitName}.`);\n      return Promise.resolve(unitConversionSpecs);\n    }\n\n    for (const potentialParseUnit of potentialParseUnits) {\n      const unit = await unitsProvider.findUnitByName(potentialParseUnit.unitName);\n      if (!unit || !unit.name || 0 === unit.name.length) {\n        // tslint:disable-next-line:no-console\n        console.log(`[Parser.createUnitConversionSpecs] ERROR: Unable to locate potential unit ${potentialParseUnit.unitName}.`);\n        continue;\n      }\n\n      const conversion = await unitsProvider.getConversion(unit, outUnit);\n      const parseLabels: string[] = [unit.label.toLocaleLowerCase()];\n      // add any alternate labels that may be define by the UnitProp\n      if (unit.alternateLabels) {\n        unit.alternateLabels.forEach((label: string) => {\n          const potentialLabel = label.toLocaleLowerCase();\n          if (-1 === parseLabels.findIndex((lbl) => lbl === potentialLabel))\n            parseLabels.push(label.toLocaleLowerCase());\n        });\n      }\n\n      if (potentialParseUnit.altLabels) {\n        potentialParseUnit.altLabels.forEach((label: string) => {\n          const potentialLabel = label.toLocaleLowerCase();\n          if (-1 === parseLabels.findIndex((lbl) => lbl === potentialLabel))\n            parseLabels.push(label.toLocaleLowerCase());\n        });\n      }\n      unitConversionSpecs.push({\n        name: unit.name,\n        label: unit.label,\n        conversion,\n        parseLabels,\n      });\n    }\n    return Promise.resolve(unitConversionSpecs);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\nimport { QuantityProps, UnitProps, UnitConversion } from \"./Interfaces\";\n\n/** The Quantity class is convenient container to specify both the magnitude and unit of a quantity. This class is commonly\n * returned as the result of parsing a string that represents a quantity.\n * @alpha\n */\nexport class Quantity implements QuantityProps {\n  protected _magnitude: number = 0.0;\n  protected _unit: UnitProps;\n  protected _isValid: boolean = false;\n\n  public get unit(): UnitProps { return this._unit; }\n  public get magnitude(): number { return this._magnitude; }\n  public get isValid(): boolean { return this._isValid; }\n\n  /** Constructor. The Quantity will only be set as valid if a unit is specified.\n   *  @param unit     Defines the quantity's unit.\n   *  @param magnitude   Defines the magnitude of the quantity.\n   */\n  public constructor(unit?: UnitProps, magnitude?: number) {\n    if (undefined !== unit) {\n      this._unit = unit;\n      this._isValid = true;\n    } else {\n      this._unit = { name: \"unknown\", label: \"unknown\", unitFamily: \"unknown\", isValid: false };\n    }\n\n    if (undefined !== magnitude)\n      this._magnitude = magnitude;\n  }\n\n  /** Convert a Quantity to the specified unit given the UnitConversion.\n   *  @param toUnit   The new unit for the quantity.\n   *  @param conversion  Defines the information needed to convert the Quantity's magnitude from the current unit to another unit. This conversion info is usually\n   *                     returned from the UnitsProvider.\n   */\n  public convertTo(toUnit: UnitProps, conversion: UnitConversion): Quantity | undefined {\n    const newMagnitude = (this.magnitude * conversion.factor) + conversion.offset;\n    return new Quantity(toUnit, newMagnitude);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { UnitProps } from \"./Interfaces\";\n\n/** This class provides basic implementation of UnitProps interface.\n * @alpha\n */\nexport class BasicUnit implements UnitProps {\n  public name = \"\";\n  public label = \"\";\n  public unitFamily = \"\";\n  public isValid = false;\n  public alternateLabels?: string[];\n\n  constructor(name: string, label: string, unitFamily: string, alternateLabels?: string[]) {\n    if (name && name.length > 0 && label && label.length > 0 && unitFamily && unitFamily.length > 0) {\n      this.name = name;\n      this.label = label;\n      this.unitFamily = unitFamily;\n      this.alternateLabels = alternateLabels;\n      this.isValid = true;\n    }\n  }\n}\n\n/** This class is a convenience class that can be returned when a valid Unit cannot be determined.\n * @alpha\n */\nexport class BadUnit implements UnitProps {\n  public name = \"\";\n  public label = \"\";\n  public unitFamily = \"\";\n  public isValid = false;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nexport * from \"./Constants\";\nexport * from \"./Exception\";\nexport * from \"./Interfaces\";\nexport * from \"./Parser\";\nexport * from \"./Quantity\";\nexport * from \"./Unit\";\n\nexport * from \"./Formatter/Format\";\nexport * from \"./Formatter/FormatEnums\";\nexport * from \"./Formatter/Formatter\";\nexport * from \"./Formatter/Interfaces\";\n\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\ndeclare var BUILD_SEMVER: string;\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\n  if (!(window as any).iModelJsVersions)\n    (window as any).iModelJsVersions = new Map<string, string>();\n  (window as any).iModelJsVersions.set(\"imodeljs-quantity\", BUILD_SEMVER);\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACVA;;;AAGA;;AAEA;;AAEA;AACA;AAoBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AA3CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;;;;;;;;;;;;;;ACRA;;;AAGA;;AAEA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AADA;AAEA;AACA;AAJA;;;;;;;;;;;;;;;ACpBA;AACA;AACA;AAIA;AACA;AAEA;;AAEA;AACA;AAmBA;;AAEA;AACA;AArBA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AArcA;AAucA;;AAEA;AACA;AAKA;;;;AAIA;AACA;AATA;AACA;AASA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAxDA;;;;;;;;;;;;;;;AC5dA;;;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpEA;;;AAGA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAOA;AANA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;;AAhSA;AACA;AAFA;;;;;;;;;;;;;;;AChGA;;;AAGA;AACA;AACA;AAEA;AAEA;AAWA;;AAEA;AACA;AAKA;;;;AAIA;AACA;AARA;AASA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAhCA;AAkCA;;AAEA;AACA;AAGA;AACA;AAAA;;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AAFA;AAGA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AAHA;AACA;AAGA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAjdA;AADA;;;;;;;;;;;;;;ACtGA;;;AAGA;;AAIA;;;AAGA;AACA;AASA;;;AAGA;AACA;AAZA;AAEA;AAWA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAlBA;AACA;AACA;AAkBA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAlCA;;;;;;;;;;;;;;;ACLA;;AAEA;AACA;AAOA;AANA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AALA;;;;;;;;;;;;;;;;;;AC9BA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACtBA;;;;;A","sourceRoot":""}