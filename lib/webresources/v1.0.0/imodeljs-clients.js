(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("bentleyjs_core"), require("geometry_core"));
	else if(typeof define === 'function' && define.amd)
		define("imodeljs_clients", ["bentleyjs_core", "geometry_core"], factory);
	else if(typeof exports === 'object')
		exports["imodeljs_clients"] = factory(require("bentleyjs_core"), require("geometry_core"));
	else
		root["imodeljs_clients"] = factory(root["bentleyjs_core"], root["geometry_core"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__, __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__) {
return (this["webpackJsonp"] = this["webpackJsonp"] || []).push([["imodeljs-clients"],{

/***/ "../../common/temp/node_modules/.registry.npmjs.org/base64-js/1.3.0/node_modules/base64-js/index.js":
/*!******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/base64-js/1.3.0/node_modules/base64-js/index.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  for (var i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js":
/*!************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(/*! base64-js */ "../../common/temp/node_modules/.registry.npmjs.org/base64-js/1.3.0/node_modules/base64-js/index.js")
var ieee754 = __webpack_require__(/*! ieee754 */ "../../common/temp/node_modules/.registry.npmjs.org/ieee754/1.1.13/node_modules/ieee754/index.js")
var isArray = __webpack_require__(/*! isarray */ "../../common/temp/node_modules/.registry.npmjs.org/isarray/1.0.0/node_modules/isarray/index.js")

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/builtin-status-codes/3.0.0/node_modules/builtin-status-codes/browser.js":
/*!******************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/builtin-status-codes/3.0.0/node_modules/builtin-status-codes/browser.js ***!
  \******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = {
  "100": "Continue",
  "101": "Switching Protocols",
  "102": "Processing",
  "200": "OK",
  "201": "Created",
  "202": "Accepted",
  "203": "Non-Authoritative Information",
  "204": "No Content",
  "205": "Reset Content",
  "206": "Partial Content",
  "207": "Multi-Status",
  "208": "Already Reported",
  "226": "IM Used",
  "300": "Multiple Choices",
  "301": "Moved Permanently",
  "302": "Found",
  "303": "See Other",
  "304": "Not Modified",
  "305": "Use Proxy",
  "307": "Temporary Redirect",
  "308": "Permanent Redirect",
  "400": "Bad Request",
  "401": "Unauthorized",
  "402": "Payment Required",
  "403": "Forbidden",
  "404": "Not Found",
  "405": "Method Not Allowed",
  "406": "Not Acceptable",
  "407": "Proxy Authentication Required",
  "408": "Request Timeout",
  "409": "Conflict",
  "410": "Gone",
  "411": "Length Required",
  "412": "Precondition Failed",
  "413": "Payload Too Large",
  "414": "URI Too Long",
  "415": "Unsupported Media Type",
  "416": "Range Not Satisfiable",
  "417": "Expectation Failed",
  "418": "I'm a teapot",
  "421": "Misdirected Request",
  "422": "Unprocessable Entity",
  "423": "Locked",
  "424": "Failed Dependency",
  "425": "Unordered Collection",
  "426": "Upgrade Required",
  "428": "Precondition Required",
  "429": "Too Many Requests",
  "431": "Request Header Fields Too Large",
  "451": "Unavailable For Legal Reasons",
  "500": "Internal Server Error",
  "501": "Not Implemented",
  "502": "Bad Gateway",
  "503": "Service Unavailable",
  "504": "Gateway Timeout",
  "505": "HTTP Version Not Supported",
  "506": "Variant Also Negotiates",
  "507": "Insufficient Storage",
  "508": "Loop Detected",
  "509": "Bandwidth Limit Exceeded",
  "510": "Not Extended",
  "511": "Network Authentication Required"
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/component-emitter/1.3.0/node_modules/component-emitter/index.js":
/*!**********************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/component-emitter/1.3.0/node_modules/component-emitter/index.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {


/**
 * Expose `Emitter`.
 */

if (true) {
  module.exports = Emitter;
}

/**
 * Initialize a new `Emitter`.
 *
 * @api public
 */

function Emitter(obj) {
  if (obj) return mixin(obj);
};

/**
 * Mixin the emitter properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}

/**
 * Listen on the given `event` with `fn`.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.on =
Emitter.prototype.addEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};
  (this._callbacks['$' + event] = this._callbacks['$' + event] || [])
    .push(fn);
  return this;
};

/**
 * Adds an `event` listener that will be invoked a single
 * time then automatically removed.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.once = function(event, fn){
  function on() {
    this.off(event, on);
    fn.apply(this, arguments);
  }

  on.fn = fn;
  this.on(event, on);
  return this;
};

/**
 * Remove the given callback for `event` or all
 * registered callbacks.
 *
 * @param {String} event
 * @param {Function} fn
 * @return {Emitter}
 * @api public
 */

Emitter.prototype.off =
Emitter.prototype.removeListener =
Emitter.prototype.removeAllListeners =
Emitter.prototype.removeEventListener = function(event, fn){
  this._callbacks = this._callbacks || {};

  // all
  if (0 == arguments.length) {
    this._callbacks = {};
    return this;
  }

  // specific event
  var callbacks = this._callbacks['$' + event];
  if (!callbacks) return this;

  // remove all handlers
  if (1 == arguments.length) {
    delete this._callbacks['$' + event];
    return this;
  }

  // remove specific handler
  var cb;
  for (var i = 0; i < callbacks.length; i++) {
    cb = callbacks[i];
    if (cb === fn || cb.fn === fn) {
      callbacks.splice(i, 1);
      break;
    }
  }

  // Remove event specific arrays for event types that no
  // one is subscribed for to avoid memory leak.
  if (callbacks.length === 0) {
    delete this._callbacks['$' + event];
  }

  return this;
};

/**
 * Emit `event` with the given args.
 *
 * @param {String} event
 * @param {Mixed} ...
 * @return {Emitter}
 */

Emitter.prototype.emit = function(event){
  this._callbacks = this._callbacks || {};

  var args = new Array(arguments.length - 1)
    , callbacks = this._callbacks['$' + event];

  for (var i = 1; i < arguments.length; i++) {
    args[i - 1] = arguments[i];
  }

  if (callbacks) {
    callbacks = callbacks.slice(0);
    for (var i = 0, len = callbacks.length; i < len; ++i) {
      callbacks[i].apply(this, args);
    }
  }

  return this;
};

/**
 * Return array of callbacks for `event`.
 *
 * @param {String} event
 * @return {Array}
 * @api public
 */

Emitter.prototype.listeners = function(event){
  this._callbacks = this._callbacks || {};
  return this._callbacks['$' + event] || [];
};

/**
 * Check if this emitter has `event` handlers.
 *
 * @param {String} event
 * @return {Boolean}
 * @api public
 */

Emitter.prototype.hasListeners = function(event){
  return !! this.listeners(event).length;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js":
/*!***************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../buffer/4.9.1/node_modules/buffer/index.js */ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js":
/*!**********************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var isObj = __webpack_require__(/*! is-obj */ "../../common/temp/node_modules/.registry.npmjs.org/is-obj/1.0.1/node_modules/is-obj/index.js");
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Sources cannot be null or undefined');
	}

	return Object(val);
}

function assignKey(to, from, key) {
	var val = from[key];

	if (val === undefined || val === null) {
		return;
	}

	if (hasOwnProperty.call(to, key)) {
		if (to[key] === undefined || to[key] === null) {
			throw new TypeError('Cannot convert undefined or null to object (' + key + ')');
		}
	}

	if (!hasOwnProperty.call(to, key) || !isObj(val)) {
		to[key] = val;
	} else {
		to[key] = assign(Object(to[key]), from[key]);
	}
}

function assign(to, from) {
	if (to === from) {
		return to;
	}

	from = Object(from);

	for (var key in from) {
		if (hasOwnProperty.call(from, key)) {
			assignKey(to, from, key);
		}
	}

	if (Object.getOwnPropertySymbols) {
		var symbols = Object.getOwnPropertySymbols(from);

		for (var i = 0; i < symbols.length; i++) {
			if (propIsEnumerable.call(from, symbols[i])) {
				assignKey(to, from, symbols[i]);
			}
		}
	}

	return to;
}

module.exports = function deepAssign(target) {
	target = toObject(target);

	for (var s = 1; s < arguments.length; s++) {
		assign(target, arguments[s]);
	}

	return target;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/events/3.0.0/node_modules/events/events.js":
/*!*************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/events/3.0.0/node_modules/events/events.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var R = typeof Reflect === 'object' ? Reflect : null
var ReflectApply = R && typeof R.apply === 'function'
  ? R.apply
  : function ReflectApply(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  }

var ReflectOwnKeys
if (R && typeof R.ownKeys === 'function') {
  ReflectOwnKeys = R.ownKeys
} else if (Object.getOwnPropertySymbols) {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target)
      .concat(Object.getOwnPropertySymbols(target));
  };
} else {
  ReflectOwnKeys = function ReflectOwnKeys(target) {
    return Object.getOwnPropertyNames(target);
  };
}

function ProcessEmitWarning(warning) {
  if (console && console.warn) console.warn(warning);
}

var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
  return value !== value;
}

function EventEmitter() {
  EventEmitter.init.call(this);
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._eventsCount = 0;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var defaultMaxListeners = 10;

Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
  enumerable: true,
  get: function() {
    return defaultMaxListeners;
  },
  set: function(arg) {
    if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
      throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
    }
    defaultMaxListeners = arg;
  }
});

EventEmitter.init = function() {

  if (this._events === undefined ||
      this._events === Object.getPrototypeOf(this)._events) {
    this._events = Object.create(null);
    this._eventsCount = 0;
  }

  this._maxListeners = this._maxListeners || undefined;
};

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
  if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
    throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
  }
  this._maxListeners = n;
  return this;
};

function $getMaxListeners(that) {
  if (that._maxListeners === undefined)
    return EventEmitter.defaultMaxListeners;
  return that._maxListeners;
}

EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
  return $getMaxListeners(this);
};

EventEmitter.prototype.emit = function emit(type) {
  var args = [];
  for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
  var doError = (type === 'error');

  var events = this._events;
  if (events !== undefined)
    doError = (doError && events.error === undefined);
  else if (!doError)
    return false;

  // If there is no 'error' event listener then throw.
  if (doError) {
    var er;
    if (args.length > 0)
      er = args[0];
    if (er instanceof Error) {
      // Note: The comments on the `throw` lines are intentional, they show
      // up in Node's output if this results in an unhandled exception.
      throw er; // Unhandled 'error' event
    }
    // At least give some kind of context to the user
    var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
    err.context = er;
    throw err; // Unhandled 'error' event
  }

  var handler = events[type];

  if (handler === undefined)
    return false;

  if (typeof handler === 'function') {
    ReflectApply(handler, this, args);
  } else {
    var len = handler.length;
    var listeners = arrayClone(handler, len);
    for (var i = 0; i < len; ++i)
      ReflectApply(listeners[i], this, args);
  }

  return true;
};

function _addListener(target, type, listener, prepend) {
  var m;
  var events;
  var existing;

  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }

  events = target._events;
  if (events === undefined) {
    events = target._events = Object.create(null);
    target._eventsCount = 0;
  } else {
    // To avoid recursion in the case that type === "newListener"! Before
    // adding it to the listeners, first emit "newListener".
    if (events.newListener !== undefined) {
      target.emit('newListener', type,
                  listener.listener ? listener.listener : listener);

      // Re-assign `events` because a newListener handler could have caused the
      // this._events to be assigned to a new object
      events = target._events;
    }
    existing = events[type];
  }

  if (existing === undefined) {
    // Optimize the case of one listener. Don't need the extra array object.
    existing = events[type] = listener;
    ++target._eventsCount;
  } else {
    if (typeof existing === 'function') {
      // Adding the second element, need to change to array.
      existing = events[type] =
        prepend ? [listener, existing] : [existing, listener];
      // If we've already got an array, just append.
    } else if (prepend) {
      existing.unshift(listener);
    } else {
      existing.push(listener);
    }

    // Check for listener leak
    m = $getMaxListeners(target);
    if (m > 0 && existing.length > m && !existing.warned) {
      existing.warned = true;
      // No error code for this since it is a Warning
      // eslint-disable-next-line no-restricted-syntax
      var w = new Error('Possible EventEmitter memory leak detected. ' +
                          existing.length + ' ' + String(type) + ' listeners ' +
                          'added. Use emitter.setMaxListeners() to ' +
                          'increase limit');
      w.name = 'MaxListenersExceededWarning';
      w.emitter = target;
      w.type = type;
      w.count = existing.length;
      ProcessEmitWarning(w);
    }
  }

  return target;
}

EventEmitter.prototype.addListener = function addListener(type, listener) {
  return _addListener(this, type, listener, false);
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.prependListener =
    function prependListener(type, listener) {
      return _addListener(this, type, listener, true);
    };

function onceWrapper() {
  var args = [];
  for (var i = 0; i < arguments.length; i++) args.push(arguments[i]);
  if (!this.fired) {
    this.target.removeListener(this.type, this.wrapFn);
    this.fired = true;
    ReflectApply(this.listener, this.target, args);
  }
}

function _onceWrap(target, type, listener) {
  var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
  var wrapped = onceWrapper.bind(state);
  wrapped.listener = listener;
  state.wrapFn = wrapped;
  return wrapped;
}

EventEmitter.prototype.once = function once(type, listener) {
  if (typeof listener !== 'function') {
    throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
  }
  this.on(type, _onceWrap(this, type, listener));
  return this;
};

EventEmitter.prototype.prependOnceListener =
    function prependOnceListener(type, listener) {
      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }
      this.prependListener(type, _onceWrap(this, type, listener));
      return this;
    };

// Emits a 'removeListener' event if and only if the listener was removed.
EventEmitter.prototype.removeListener =
    function removeListener(type, listener) {
      var list, events, position, i, originalListener;

      if (typeof listener !== 'function') {
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
      }

      events = this._events;
      if (events === undefined)
        return this;

      list = events[type];
      if (list === undefined)
        return this;

      if (list === listener || list.listener === listener) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else {
          delete events[type];
          if (events.removeListener)
            this.emit('removeListener', type, list.listener || listener);
        }
      } else if (typeof list !== 'function') {
        position = -1;

        for (i = list.length - 1; i >= 0; i--) {
          if (list[i] === listener || list[i].listener === listener) {
            originalListener = list[i].listener;
            position = i;
            break;
          }
        }

        if (position < 0)
          return this;

        if (position === 0)
          list.shift();
        else {
          spliceOne(list, position);
        }

        if (list.length === 1)
          events[type] = list[0];

        if (events.removeListener !== undefined)
          this.emit('removeListener', type, originalListener || listener);
      }

      return this;
    };

EventEmitter.prototype.off = EventEmitter.prototype.removeListener;

EventEmitter.prototype.removeAllListeners =
    function removeAllListeners(type) {
      var listeners, events, i;

      events = this._events;
      if (events === undefined)
        return this;

      // not listening for removeListener, no need to emit
      if (events.removeListener === undefined) {
        if (arguments.length === 0) {
          this._events = Object.create(null);
          this._eventsCount = 0;
        } else if (events[type] !== undefined) {
          if (--this._eventsCount === 0)
            this._events = Object.create(null);
          else
            delete events[type];
        }
        return this;
      }

      // emit removeListener for all listeners on all events
      if (arguments.length === 0) {
        var keys = Object.keys(events);
        var key;
        for (i = 0; i < keys.length; ++i) {
          key = keys[i];
          if (key === 'removeListener') continue;
          this.removeAllListeners(key);
        }
        this.removeAllListeners('removeListener');
        this._events = Object.create(null);
        this._eventsCount = 0;
        return this;
      }

      listeners = events[type];

      if (typeof listeners === 'function') {
        this.removeListener(type, listeners);
      } else if (listeners !== undefined) {
        // LIFO order
        for (i = listeners.length - 1; i >= 0; i--) {
          this.removeListener(type, listeners[i]);
        }
      }

      return this;
    };

function _listeners(target, type, unwrap) {
  var events = target._events;

  if (events === undefined)
    return [];

  var evlistener = events[type];
  if (evlistener === undefined)
    return [];

  if (typeof evlistener === 'function')
    return unwrap ? [evlistener.listener || evlistener] : [evlistener];

  return unwrap ?
    unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
}

EventEmitter.prototype.listeners = function listeners(type) {
  return _listeners(this, type, true);
};

EventEmitter.prototype.rawListeners = function rawListeners(type) {
  return _listeners(this, type, false);
};

EventEmitter.listenerCount = function(emitter, type) {
  if (typeof emitter.listenerCount === 'function') {
    return emitter.listenerCount(type);
  } else {
    return listenerCount.call(emitter, type);
  }
};

EventEmitter.prototype.listenerCount = listenerCount;
function listenerCount(type) {
  var events = this._events;

  if (events !== undefined) {
    var evlistener = events[type];

    if (typeof evlistener === 'function') {
      return 1;
    } else if (evlistener !== undefined) {
      return evlistener.length;
    }
  }

  return 0;
}

EventEmitter.prototype.eventNames = function eventNames() {
  return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
};

function arrayClone(arr, n) {
  var copy = new Array(n);
  for (var i = 0; i < n; ++i)
    copy[i] = arr[i];
  return copy;
}

function spliceOne(list, index) {
  for (; index + 1 < list.length; index++)
    list[index] = list[index + 1];
  list.pop();
}

function unwrapListeners(arr) {
  var ret = new Array(arr.length);
  for (var i = 0; i < ret.length; ++i) {
    ret[i] = arr[i].listener || arr[i];
  }
  return ret;
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/https-browserify/1.0.0/node_modules/https-browserify/index.js":
/*!********************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/https-browserify/1.0.0/node_modules/https-browserify/index.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var http = __webpack_require__(/*! http */ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/index.js")
var url = __webpack_require__(/*! url */ "../../common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/url.js")

var https = module.exports

for (var key in http) {
  if (http.hasOwnProperty(key)) https[key] = http[key]
}

https.request = function (params, cb) {
  params = validateParams(params)
  return http.request.call(this, params, cb)
}

https.get = function (params, cb) {
  params = validateParams(params)
  return http.get.call(this, params, cb)
}

function validateParams (params) {
  if (typeof params === 'string') {
    params = url.parse(params)
  }
  if (!params.protocol) {
    params.protocol = 'https:'
  }
  if (params.protocol !== 'https:') {
    throw new Error('Protocol "' + params.protocol + '" not supported. Expected "https:"')
  }
  return params
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/ieee754/1.1.13/node_modules/ieee754/index.js":
/*!***************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/ieee754/1.1.13/node_modules/ieee754/index.js ***!
  \***************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js":
/*!***************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js ***!
  \***************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/is-obj/1.0.1/node_modules/is-obj/index.js":
/*!************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/is-obj/1.0.1/node_modules/is-obj/index.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

module.exports = function (x) {
	var type = typeof x;
	return x !== null && (type === 'object' || type === 'function');
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/isarray/1.0.0/node_modules/isarray/index.js":
/*!**************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/isarray/1.0.0/node_modules/isarray/index.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/js-base64/2.5.1/node_modules/js-base64/base64.js":
/*!*******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/js-base64/2.5.1/node_modules/js-base64/base64.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
 *  base64.js
 *
 *  Licensed under the BSD 3-Clause License.
 *    http://opensource.org/licenses/BSD-3-Clause
 *
 *  References:
 *    http://en.wikipedia.org/wiki/Base64
 */
;(function (global, factory) {
     true
        ? module.exports = factory(global)
        : undefined
}((
    typeof self !== 'undefined' ? self
        : typeof window !== 'undefined' ? window
        : typeof global !== 'undefined' ? global
: this
), function(global) {
    'use strict';
    // existing version for noConflict()
    global = global || {};
    var _Base64 = global.Base64;
    var version = "2.5.1";
    // if node.js and NOT React Native, we use Buffer
    var buffer;
    if ( true && module.exports) {
        try {
            buffer = eval("require('buffer').Buffer");
        } catch (err) {
            buffer = undefined;
        }
    }
    // constants
    var b64chars
        = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    var b64tab = function(bin) {
        var t = {};
        for (var i = 0, l = bin.length; i < l; i++) t[bin.charAt(i)] = i;
        return t;
    }(b64chars);
    var fromCharCode = String.fromCharCode;
    // encoder stuff
    var cb_utob = function(c) {
        if (c.length < 2) {
            var cc = c.charCodeAt(0);
            return cc < 0x80 ? c
                : cc < 0x800 ? (fromCharCode(0xc0 | (cc >>> 6))
                                + fromCharCode(0x80 | (cc & 0x3f)))
                : (fromCharCode(0xe0 | ((cc >>> 12) & 0x0f))
                   + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                   + fromCharCode(0x80 | ( cc         & 0x3f)));
        } else {
            var cc = 0x10000
                + (c.charCodeAt(0) - 0xD800) * 0x400
                + (c.charCodeAt(1) - 0xDC00);
            return (fromCharCode(0xf0 | ((cc >>> 18) & 0x07))
                    + fromCharCode(0x80 | ((cc >>> 12) & 0x3f))
                    + fromCharCode(0x80 | ((cc >>>  6) & 0x3f))
                    + fromCharCode(0x80 | ( cc         & 0x3f)));
        }
    };
    var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
    var utob = function(u) {
        return u.replace(re_utob, cb_utob);
    };
    var cb_encode = function(ccc) {
        var padlen = [0, 2, 1][ccc.length % 3],
        ord = ccc.charCodeAt(0) << 16
            | ((ccc.length > 1 ? ccc.charCodeAt(1) : 0) << 8)
            | ((ccc.length > 2 ? ccc.charCodeAt(2) : 0)),
        chars = [
            b64chars.charAt( ord >>> 18),
            b64chars.charAt((ord >>> 12) & 63),
            padlen >= 2 ? '=' : b64chars.charAt((ord >>> 6) & 63),
            padlen >= 1 ? '=' : b64chars.charAt(ord & 63)
        ];
        return chars.join('');
    };
    var btoa = global.btoa ? function(b) {
        return global.btoa(b);
    } : function(b) {
        return b.replace(/[\s\S]{1,3}/g, cb_encode);
    };
    var _encode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function (u) {
            return (u.constructor === buffer.constructor ? u : buffer.from(u))
                .toString('base64')
        }
        :  function (u) {
            return (u.constructor === buffer.constructor ? u : new  buffer(u))
                .toString('base64')
        }
        : function (u) { return btoa(utob(u)) }
    ;
    var encode = function(u, urisafe) {
        return !urisafe
            ? _encode(String(u))
            : _encode(String(u)).replace(/[+\/]/g, function(m0) {
                return m0 == '+' ? '-' : '_';
            }).replace(/=/g, '');
    };
    var encodeURI = function(u) { return encode(u, true) };
    // decoder stuff
    var re_btou = new RegExp([
        '[\xC0-\xDF][\x80-\xBF]',
        '[\xE0-\xEF][\x80-\xBF]{2}',
        '[\xF0-\xF7][\x80-\xBF]{3}'
    ].join('|'), 'g');
    var cb_btou = function(cccc) {
        switch(cccc.length) {
        case 4:
            var cp = ((0x07 & cccc.charCodeAt(0)) << 18)
                |    ((0x3f & cccc.charCodeAt(1)) << 12)
                |    ((0x3f & cccc.charCodeAt(2)) <<  6)
                |     (0x3f & cccc.charCodeAt(3)),
            offset = cp - 0x10000;
            return (fromCharCode((offset  >>> 10) + 0xD800)
                    + fromCharCode((offset & 0x3FF) + 0xDC00));
        case 3:
            return fromCharCode(
                ((0x0f & cccc.charCodeAt(0)) << 12)
                    | ((0x3f & cccc.charCodeAt(1)) << 6)
                    |  (0x3f & cccc.charCodeAt(2))
            );
        default:
            return  fromCharCode(
                ((0x1f & cccc.charCodeAt(0)) << 6)
                    |  (0x3f & cccc.charCodeAt(1))
            );
        }
    };
    var btou = function(b) {
        return b.replace(re_btou, cb_btou);
    };
    var cb_decode = function(cccc) {
        var len = cccc.length,
        padlen = len % 4,
        n = (len > 0 ? b64tab[cccc.charAt(0)] << 18 : 0)
            | (len > 1 ? b64tab[cccc.charAt(1)] << 12 : 0)
            | (len > 2 ? b64tab[cccc.charAt(2)] <<  6 : 0)
            | (len > 3 ? b64tab[cccc.charAt(3)]       : 0),
        chars = [
            fromCharCode( n >>> 16),
            fromCharCode((n >>>  8) & 0xff),
            fromCharCode( n         & 0xff)
        ];
        chars.length -= [0, 0, 2, 1][padlen];
        return chars.join('');
    };
    var _atob = global.atob ? function(a) {
        return global.atob(a);
    } : function(a){
        return a.replace(/\S{1,4}/g, cb_decode);
    };
    var atob = function(a) {
        return _atob(String(a).replace(/[^A-Za-z0-9\+\/]/g, ''));
    };
    var _decode = buffer ?
        buffer.from && Uint8Array && buffer.from !== Uint8Array.from
        ? function(a) {
            return (a.constructor === buffer.constructor
                    ? a : buffer.from(a, 'base64')).toString();
        }
        : function(a) {
            return (a.constructor === buffer.constructor
                    ? a : new buffer(a, 'base64')).toString();
        }
        : function(a) { return btou(_atob(a)) };
    var decode = function(a){
        return _decode(
            String(a).replace(/[-_]/g, function(m0) { return m0 == '-' ? '+' : '/' })
                .replace(/[^A-Za-z0-9\+\/]/g, '')
        );
    };
    var noConflict = function() {
        var Base64 = global.Base64;
        global.Base64 = _Base64;
        return Base64;
    };
    // export Base64
    global.Base64 = {
        VERSION: version,
        atob: atob,
        btoa: btoa,
        fromBase64: decode,
        toBase64: encode,
        utob: utob,
        encode: encode,
        encodeURI: encodeURI,
        btou: btou,
        decode: decode,
        noConflict: noConflict,
        __buffer__: buffer
    };
    // if ES5 is available, make Base64.extendString() available
    if (typeof Object.defineProperty === 'function') {
        var noEnum = function(v){
            return {value:v,enumerable:false,writable:true,configurable:true};
        };
        global.Base64.extendString = function () {
            Object.defineProperty(
                String.prototype, 'fromBase64', noEnum(function () {
                    return decode(this)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64', noEnum(function (urisafe) {
                    return encode(this, urisafe)
                }));
            Object.defineProperty(
                String.prototype, 'toBase64URI', noEnum(function () {
                    return encode(this, true)
                }));
        };
    }
    //
    // export Base64 to the namespace
    //
    if (global['Meteor']) { // Meteor.js
        Base64 = global.Base64;
    }
    // module.exports and AMD are mutually exclusive.
    // module.exports has precedence.
    if ( true && module.exports) {
        module.exports.Base64 = global.Base64;
    }
    else if (true) {
        // AMD. Register as an anonymous module.
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function(){ return global.Base64 }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
    // that's it!
    return {Base64: global.Base64}
}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/process-nextick-args/2.0.0/node_modules/process-nextick-args/index.js":
/*!****************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/process-nextick-args/2.0.0/node_modules/process-nextick-args/index.js ***!
  \****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = { nextTick: nextTick };
} else {
  module.exports = process
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}


/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js":
/*!******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/punycode/1.4.1/node_modules/punycode/punycode.js":
/*!*******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/punycode/1.4.1/node_modules/punycode/punycode.js ***!
  \*******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports =  true && exports &&
		!exports.nodeType && exports;
	var freeModule =  true && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		true
	) {
		!(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
			return punycode;
		}).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}

}(this));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/module.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/module.js")(module), __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/formats.js":
/*!**********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/formats.js ***!
  \**********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var replace = String.prototype.replace;
var percentTwenties = /%20/g;

module.exports = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/index.js":
/*!********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/index.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var stringify = __webpack_require__(/*! ./stringify */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/stringify.js");
var parse = __webpack_require__(/*! ./parse */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/parse.js");
var formats = __webpack_require__(/*! ./formats */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/formats.js");

module.exports = {
    formats: formats,
    parse: parse,
    stringify: stringify
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/parse.js":
/*!********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/parse.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/utils.js");

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    charset: 'utf-8',
    charsetSentinel: false,
    comma: false,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    ignoreQueryPrefix: false,
    interpretNumericEntities: false,
    parameterLimit: 1000,
    parseArrays: true,
    plainObjects: false,
    strictNullHandling: false
};

var interpretNumericEntities = function (str) {
    return str.replace(/&#(\d+);/g, function ($0, numberStr) {
        return String.fromCharCode(parseInt(numberStr, 10));
    });
};

// This is what browsers will submit when the ✓ character occurs in an
// application/x-www-form-urlencoded body and the encoding of the page containing
// the form is iso-8859-1, or when the submitted form has an accept-charset
// attribute of iso-8859-1. Presumably also with other charsets that do not contain
// the ✓ character, such as us-ascii.
var isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')

// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.
var charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('✓')

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);
    var skipIndex = -1; // Keep track of where the utf8 sentinel was found
    var i;

    var charset = options.charset;
    if (options.charsetSentinel) {
        for (i = 0; i < parts.length; ++i) {
            if (parts[i].indexOf('utf8=') === 0) {
                if (parts[i] === charsetSentinel) {
                    charset = 'utf-8';
                } else if (parts[i] === isoSentinel) {
                    charset = 'iso-8859-1';
                }
                skipIndex = i;
                i = parts.length; // The eslint settings do not allow break;
            }
        }
    }

    for (i = 0; i < parts.length; ++i) {
        if (i === skipIndex) {
            continue;
        }
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder, charset);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder, charset);
            val = options.decoder(part.slice(pos + 1), defaults.decoder, charset);
        }

        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {
            val = interpretNumericEntities(val);
        }

        if (val && options.comma && val.indexOf(',') > -1) {
            val = val.split(',');
        }

        if (has.call(obj, key)) {
            obj[key] = utils.combine(obj[key], val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]' && options.parseArrays) {
            obj = [].concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (!options.parseArrays && cleanRoot === '') {
                obj = { 0: leaf };
            } else if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var normalizeParseOptions = function normalizeParseOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new Error('The charset option must be either utf-8, iso-8859-1, or undefined');
    }
    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;

    return {
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,
        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,
        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,
        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,
        depth: typeof opts.depth === 'number' ? opts.depth : defaults.depth,
        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,
        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,
        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,
        parseArrays: opts.parseArrays !== false,
        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (str, opts) {
    var options = normalizeParseOptions(opts);

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/stringify.js":
/*!************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/stringify.js ***!
  \************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/utils.js");
var formats = __webpack_require__(/*! ./formats */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/formats.js");
var has = Object.prototype.hasOwnProperty;

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    comma: 'comma',
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var isArray = Array.isArray;
var push = Array.prototype.push;
var pushToArray = function (arr, valueOrArray) {
    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);
};

var toISO = Date.prototype.toISOString;

var defaults = {
    addQueryPrefix: false,
    allowDots: false,
    charset: 'utf-8',
    charsetSentinel: false,
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    formatter: formats.formatters[formats['default']],
    // deprecated
    indices: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly,
    charset
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {
        obj = obj.join(',');
    }

    if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (isArray(obj)) {
            pushToArray(values, stringify(
                obj[key],
                typeof generateArrayPrefix === 'function' ? generateArrayPrefix(prefix, key) : prefix,
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        } else {
            pushToArray(values, stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly,
                charset
            ));
        }
    }

    return values;
};

var normalizeStringifyOptions = function normalizeStringifyOptions(opts) {
    if (!opts) {
        return defaults;
    }

    if (opts.encoder !== null && opts.encoder !== undefined && typeof opts.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var charset = opts.charset || defaults.charset;
    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {
        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');
    }

    var format = formats['default'];
    if (typeof opts.format !== 'undefined') {
        if (!has.call(formats.formatters, opts.format)) {
            throw new TypeError('Unknown format option provided.');
        }
        format = opts.format;
    }
    var formatter = formats.formatters[format];

    var filter = defaults.filter;
    if (typeof opts.filter === 'function' || isArray(opts.filter)) {
        filter = opts.filter;
    }

    return {
        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,
        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,
        charset: charset,
        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,
        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,
        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,
        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,
        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,
        filter: filter,
        formatter: formatter,
        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,
        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,
        sort: typeof opts.sort === 'function' ? opts.sort : null,
        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling
    };
};

module.exports = function (object, opts) {
    var obj = object;
    var options = normalizeStringifyOptions(opts);

    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (opts && opts.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = opts.arrayFormat;
    } else if (opts && 'indices' in opts) {
        arrayFormat = opts.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (options.sort) {
        objKeys.sort(options.sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (options.skipNulls && obj[key] === null) {
            continue;
        }
        pushToArray(keys, stringify(
            obj[key],
            key,
            generateArrayPrefix,
            options.strictNullHandling,
            options.skipNulls,
            options.encode ? options.encoder : null,
            options.filter,
            options.sort,
            options.allowDots,
            options.serializeDate,
            options.formatter,
            options.encodeValuesOnly,
            options.charset
        ));
    }

    var joined = keys.join(options.delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    if (options.charsetSentinel) {
        if (options.charset === 'iso-8859-1') {
            // encodeURIComponent('&#10003;'), the "numeric entity" representation of a checkmark
            prefix += 'utf8=%26%2310003%3B&';
        } else {
            // encodeURIComponent('✓')
            prefix += 'utf8=%E2%9C%93&';
        }
    }

    return joined.length > 0 ? prefix + joined : '';
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/utils.js":
/*!********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/utils.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var has = Object.prototype.hasOwnProperty;
var isArray = Array.isArray;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    while (queue.length > 1) {
        var item = queue.pop();
        var obj = item.obj[item.prop];

        if (isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (isArray(target)) {
            target.push(source);
        } else if (target && typeof target === 'object') {
            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (!target || typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (isArray(target) && !isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (isArray(target) && isArray(source)) {
        source.forEach(function (item, i) {
            if (has.call(target, i)) {
                var targetItem = target[i];
                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {
                    target[i] = merge(targetItem, item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str, decoder, charset) {
    var strWithoutPlus = str.replace(/\+/g, ' ');
    if (charset === 'iso-8859-1') {
        // unescape never throws, no try...catch needed:
        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);
    }
    // utf-8
    try {
        return decodeURIComponent(strWithoutPlus);
    } catch (e) {
        return strWithoutPlus;
    }
};

var encode = function encode(str, defaultEncoder, charset) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    if (charset === 'iso-8859-1') {
        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {
            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';
        });
    }

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    compactQueue(queue);

    return value;
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (!obj || typeof obj !== 'object') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var combine = function combine(a, b) {
    return [].concat(a, b);
};

module.exports = {
    arrayToObject: arrayToObject,
    assign: assign,
    combine: combine,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/decode.js":
/*!*******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/decode.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/encode.js":
/*!*******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/encode.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/index.js":
/*!******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/index.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.decode = exports.parse = __webpack_require__(/*! ./decode */ "../../common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/decode.js");
exports.encode = exports.stringify = __webpack_require__(/*! ./encode */ "../../common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/encode.js");


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js":
/*!*******************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js ***!
  \*******************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../common/temp/node_modules/.registry.npmjs.org/process-nextick-args/2.0.0/node_modules/process-nextick-args/index.js");
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "../../common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

var Readable = __webpack_require__(/*! ./_stream_readable */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_readable.js");
var Writable = __webpack_require__(/*! ./_stream_writable */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_writable.js");

util.inherits(Duplex, Readable);

{
  // avoid scope creep, the keys array can then be collected
  var keys = objectKeys(Writable.prototype);
  for (var v = 0; v < keys.length; v++) {
    var method = keys[v];
    if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
  }
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  pna.nextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  pna.nextTick(cb, err);
};

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_passthrough.js":
/*!************************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_passthrough.js ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.



module.exports = PassThrough;

var Transform = __webpack_require__(/*! ./_stream_transform */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_transform.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "../../common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_readable.js":
/*!*********************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_readable.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../common/temp/node_modules/.registry.npmjs.org/process-nextick-args/2.0.0/node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = __webpack_require__(/*! isarray */ "../../common/temp/node_modules/.registry.npmjs.org/isarray/1.0.0/node_modules/isarray/index.js");
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = __webpack_require__(/*! events */ "../../common/temp/node_modules/.registry.npmjs.org/events/3.0.0/node_modules/events/events.js").EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "../../common/temp/node_modules/.registry.npmjs.org/safe-buffer/5.1.2/node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "../../common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var debugUtil = __webpack_require__(/*! util */ 0);
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = __webpack_require__(/*! ./internal/streams/BufferList */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/BufferList.js");
var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/destroy.js");
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);

  // This is a hack to make sure that our error handler is attached before any
  // userland ones.  NEVER DO THIS. This is here only because this code needs
  // to continue to work with older versions of Node.js that do not include
  // the prependListener() method. The goal is to eventually remove this hack.
  if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
}

function ReadableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var readableHwm = options.readableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "../../common/temp/node_modules/.registry.npmjs.org/string_decoder/1.2.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js");

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = __webpack_require__(/*! string_decoder/ */ "../../common/temp/node_modules/.registry.npmjs.org/string_decoder/1.2.0/node_modules/string_decoder/lib/string_decoder.js").StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    pna.nextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        pna.nextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    pna.nextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var _this = this;

  var state = this._readableState;
  var paused = false;

  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) _this.push(chunk);
    }

    _this.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = _this.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  this._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return this;
};

Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._readableState.highWaterMark;
  }
});

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    pna.nextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_transform.js":
/*!**********************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_transform.js ***!
  \**********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.



module.exports = Transform;

var Duplex = __webpack_require__(/*! ./_stream_duplex */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js");

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "../../common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

util.inherits(Transform, Duplex);

function afterTransform(er, data) {
  var ts = this._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return this.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data != null) // single equals check for both `null` and `undefined`
    this.push(data);

  cb(er);

  var rs = this._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    this._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = {
    afterTransform: afterTransform.bind(this),
    needTransform: false,
    transforming: false,
    writecb: null,
    writechunk: null,
    writeencoding: null
  };

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.on('prefinish', prefinish);
}

function prefinish() {
  var _this = this;

  if (typeof this._flush === 'function') {
    this._flush(function (er, data) {
      done(_this, er, data);
    });
  } else {
    done(this, null, null);
  }
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this2 = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this2.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data != null) // single equals check for both `null` and `undefined`
    stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');

  if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_writable.js":
/*!*********************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_writable.js ***!
  \*********************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.



/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../common/temp/node_modules/.registry.npmjs.org/process-nextick-args/2.0.0/node_modules/process-nextick-args/index.js");
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = __webpack_require__(/*! core-util-is */ "../../common/temp/node_modules/.registry.npmjs.org/core-util-is/1.0.2/node_modules/core-util-is/lib/util.js");
util.inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js");
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: __webpack_require__(/*! util-deprecate */ "../../common/temp/node_modules/.registry.npmjs.org/util-deprecate/1.0.2/node_modules/util-deprecate/browser.js")
};
/*</replacement>*/

/*<replacement>*/
var Stream = __webpack_require__(/*! ./internal/streams/stream */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/stream-browser.js");
/*</replacement>*/

/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "../../common/temp/node_modules/.registry.npmjs.org/safe-buffer/5.1.2/node_modules/safe-buffer/index.js").Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}

/*</replacement>*/

var destroyImpl = __webpack_require__(/*! ./internal/streams/destroy */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/destroy.js");

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js");

  options = options || {};

  // Duplex streams are both readable and writable, but share
  // the same options object.
  // However, some cases require setting options to different
  // values for the readable and the writable sides of the duplex stream.
  // These options can be provided separately as readableXXX and writableXXX.
  var isDuplex = stream instanceof Duplex;

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var writableHwm = options.writableHighWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;

  if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;
      if (this !== Writable) return false;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || __webpack_require__(/*! ./_stream_duplex */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js");

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  pna.nextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    pna.nextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = !state.objectMode && _isUint8Array(chunk);

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
  // making it explicit this property is not enumerable
  // because otherwise some prototype manipulation in
  // userland will fail
  enumerable: false,
  get: function () {
    return this._writableState.highWaterMark;
  }
});

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    pna.nextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    pna.nextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
    state.bufferedRequestCount = 0;
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      state.bufferedRequestCount--;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      pna.nextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../timers-browserify/2.0.10/node_modules/timers-browserify/main.js */ "../../common/temp/node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js").setImmediate, __webpack_require__(/*! ./../../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/BufferList.js":
/*!********************************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/BufferList.js ***!
  \********************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = __webpack_require__(/*! safe-buffer */ "../../common/temp/node_modules/.registry.npmjs.org/safe-buffer/5.1.2/node_modules/safe-buffer/index.js").Buffer;
var util = __webpack_require__(/*! util */ 1);

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();

if (util && util.inspect && util.inspect.custom) {
  module.exports.prototype[util.inspect.custom] = function () {
    var obj = util.inspect({ length: this.length });
    return this.constructor.name + ' ' + obj;
  };
}

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/destroy.js":
/*!*****************************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/destroy.js ***!
  \*****************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*<replacement>*/

var pna = __webpack_require__(/*! process-nextick-args */ "../../common/temp/node_modules/.registry.npmjs.org/process-nextick-args/2.0.0/node_modules/process-nextick-args/index.js");
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      pna.nextTick(emitErrorNT, this, err);
    }
    return this;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      pna.nextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });

  return this;
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/stream-browser.js":
/*!************************************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/internal/streams/stream-browser.js ***!
  \************************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(/*! events */ "../../common/temp/node_modules/.registry.npmjs.org/events/3.0.0/node_modules/events/events.js").EventEmitter;


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/readable-browser.js":
/*!*****************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/readable-browser.js ***!
  \*****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ./lib/_stream_readable.js */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_readable.js");
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = __webpack_require__(/*! ./lib/_stream_writable.js */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_writable.js");
exports.Duplex = __webpack_require__(/*! ./lib/_stream_duplex.js */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_duplex.js");
exports.Transform = __webpack_require__(/*! ./lib/_stream_transform.js */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_transform.js");
exports.PassThrough = __webpack_require__(/*! ./lib/_stream_passthrough.js */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/lib/_stream_passthrough.js");


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/safe-buffer/5.1.2/node_modules/safe-buffer/index.js":
/*!**********************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/safe-buffer/5.1.2/node_modules/safe-buffer/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* eslint-disable node/no-deprecated-api */
var buffer = __webpack_require__(/*! buffer */ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js")
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js":
/*!*******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/index.js":
/*!**********************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/index.js ***!
  \**********************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var ClientRequest = __webpack_require__(/*! ./lib/request */ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/request.js")
var response = __webpack_require__(/*! ./lib/response */ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/response.js")
var extend = __webpack_require__(/*! xtend */ "../../common/temp/node_modules/.registry.npmjs.org/xtend/4.0.1/node_modules/xtend/immutable.js")
var statusCodes = __webpack_require__(/*! builtin-status-codes */ "../../common/temp/node_modules/.registry.npmjs.org/builtin-status-codes/3.0.0/node_modules/builtin-status-codes/browser.js")
var url = __webpack_require__(/*! url */ "../../common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/url.js")

var http = exports

http.request = function (opts, cb) {
	if (typeof opts === 'string')
		opts = url.parse(opts)
	else
		opts = extend(opts)

	// Normally, the page is loaded from http or https, so not specifying a protocol
	// will result in a (valid) protocol-relative url. However, this won't work if
	// the protocol is something else, like 'file:'
	var defaultProtocol = global.location.protocol.search(/^https?:$/) === -1 ? 'http:' : ''

	var protocol = opts.protocol || defaultProtocol
	var host = opts.hostname || opts.host
	var port = opts.port
	var path = opts.path || '/'

	// Necessary for IPv6 addresses
	if (host && host.indexOf(':') !== -1)
		host = '[' + host + ']'

	// This may be a relative url. The browser should always be able to interpret it correctly.
	opts.url = (host ? (protocol + '//' + host) : '') + (port ? ':' + port : '') + path
	opts.method = (opts.method || 'GET').toUpperCase()
	opts.headers = opts.headers || {}

	// Also valid opts.auth, opts.mode

	var req = new ClientRequest(opts)
	if (cb)
		req.on('response', cb)
	return req
}

http.get = function get (opts, cb) {
	var req = http.request(opts, cb)
	req.end()
	return req
}

http.ClientRequest = ClientRequest
http.IncomingMessage = response.IncomingMessage

http.Agent = function () {}
http.Agent.defaultMaxSockets = 4

http.globalAgent = new http.Agent()

http.STATUS_CODES = statusCodes

http.METHODS = [
	'CHECKOUT',
	'CONNECT',
	'COPY',
	'DELETE',
	'GET',
	'HEAD',
	'LOCK',
	'M-SEARCH',
	'MERGE',
	'MKACTIVITY',
	'MKCOL',
	'MOVE',
	'NOTIFY',
	'OPTIONS',
	'PATCH',
	'POST',
	'PROPFIND',
	'PROPPATCH',
	'PURGE',
	'PUT',
	'REPORT',
	'SEARCH',
	'SUBSCRIBE',
	'TRACE',
	'UNLOCK',
	'UNSUBSCRIBE'
]
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/capability.js":
/*!*******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/capability.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {exports.fetch = isFunction(global.fetch) && isFunction(global.ReadableStream)

exports.writableStream = isFunction(global.WritableStream)

exports.abortController = isFunction(global.AbortController)

exports.blobConstructor = false
try {
	new Blob([new ArrayBuffer(1)])
	exports.blobConstructor = true
} catch (e) {}

// The xhr request to example.com may violate some restrictive CSP configurations,
// so if we're running in a browser that supports `fetch`, avoid calling getXHR()
// and assume support for certain features below.
var xhr
function getXHR () {
	// Cache the xhr value
	if (xhr !== undefined) return xhr

	if (global.XMLHttpRequest) {
		xhr = new global.XMLHttpRequest()
		// If XDomainRequest is available (ie only, where xhr might not work
		// cross domain), use the page location. Otherwise use example.com
		// Note: this doesn't actually make an http request.
		try {
			xhr.open('GET', global.XDomainRequest ? '/' : 'https://example.com')
		} catch(e) {
			xhr = null
		}
	} else {
		// Service workers don't have XHR
		xhr = null
	}
	return xhr
}

function checkTypeSupport (type) {
	var xhr = getXHR()
	if (!xhr) return false
	try {
		xhr.responseType = type
		return xhr.responseType === type
	} catch (e) {}
	return false
}

// For some strange reason, Safari 7.0 reports typeof global.ArrayBuffer === 'object'.
// Safari 7.1 appears to have fixed this bug.
var haveArrayBuffer = typeof global.ArrayBuffer !== 'undefined'
var haveSlice = haveArrayBuffer && isFunction(global.ArrayBuffer.prototype.slice)

// If fetch is supported, then arraybuffer will be supported too. Skip calling
// checkTypeSupport(), since that calls getXHR().
exports.arraybuffer = exports.fetch || (haveArrayBuffer && checkTypeSupport('arraybuffer'))

// These next two tests unavoidably show warnings in Chrome. Since fetch will always
// be used if it's available, just return false for these to avoid the warnings.
exports.msstream = !exports.fetch && haveSlice && checkTypeSupport('ms-stream')
exports.mozchunkedarraybuffer = !exports.fetch && haveArrayBuffer &&
	checkTypeSupport('moz-chunked-arraybuffer')

// If fetch is supported, then overrideMimeType will be supported too. Skip calling
// getXHR().
exports.overrideMimeType = exports.fetch || (getXHR() ? isFunction(getXHR().overrideMimeType) : false)

exports.vbArray = isFunction(global.VBArray)

function isFunction (value) {
	return typeof value === 'function'
}

xhr = null // Help gc

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/request.js":
/*!****************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/request.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(Buffer, global, process) {var capability = __webpack_require__(/*! ./capability */ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/capability.js")
var inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js")
var response = __webpack_require__(/*! ./response */ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/response.js")
var stream = __webpack_require__(/*! readable-stream */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/readable-browser.js")
var toArrayBuffer = __webpack_require__(/*! to-arraybuffer */ "../../common/temp/node_modules/.registry.npmjs.org/to-arraybuffer/1.0.1/node_modules/to-arraybuffer/index.js")

var IncomingMessage = response.IncomingMessage
var rStates = response.readyStates

function decideMode (preferBinary, useFetch) {
	if (capability.fetch && useFetch) {
		return 'fetch'
	} else if (capability.mozchunkedarraybuffer) {
		return 'moz-chunked-arraybuffer'
	} else if (capability.msstream) {
		return 'ms-stream'
	} else if (capability.arraybuffer && preferBinary) {
		return 'arraybuffer'
	} else if (capability.vbArray && preferBinary) {
		return 'text:vbarray'
	} else {
		return 'text'
	}
}

var ClientRequest = module.exports = function (opts) {
	var self = this
	stream.Writable.call(self)

	self._opts = opts
	self._body = []
	self._headers = {}
	if (opts.auth)
		self.setHeader('Authorization', 'Basic ' + new Buffer(opts.auth).toString('base64'))
	Object.keys(opts.headers).forEach(function (name) {
		self.setHeader(name, opts.headers[name])
	})

	var preferBinary
	var useFetch = true
	if (opts.mode === 'disable-fetch' || ('requestTimeout' in opts && !capability.abortController)) {
		// If the use of XHR should be preferred. Not typically needed.
		useFetch = false
		preferBinary = true
	} else if (opts.mode === 'prefer-streaming') {
		// If streaming is a high priority but binary compatibility and
		// the accuracy of the 'content-type' header aren't
		preferBinary = false
	} else if (opts.mode === 'allow-wrong-content-type') {
		// If streaming is more important than preserving the 'content-type' header
		preferBinary = !capability.overrideMimeType
	} else if (!opts.mode || opts.mode === 'default' || opts.mode === 'prefer-fast') {
		// Use binary if text streaming may corrupt data or the content-type header, or for speed
		preferBinary = true
	} else {
		throw new Error('Invalid value for opts.mode')
	}
	self._mode = decideMode(preferBinary, useFetch)
	self._fetchTimer = null

	self.on('finish', function () {
		self._onFinish()
	})
}

inherits(ClientRequest, stream.Writable)

ClientRequest.prototype.setHeader = function (name, value) {
	var self = this
	var lowerName = name.toLowerCase()
	// This check is not necessary, but it prevents warnings from browsers about setting unsafe
	// headers. To be honest I'm not entirely sure hiding these warnings is a good thing, but
	// http-browserify did it, so I will too.
	if (unsafeHeaders.indexOf(lowerName) !== -1)
		return

	self._headers[lowerName] = {
		name: name,
		value: value
	}
}

ClientRequest.prototype.getHeader = function (name) {
	var header = this._headers[name.toLowerCase()]
	if (header)
		return header.value
	return null
}

ClientRequest.prototype.removeHeader = function (name) {
	var self = this
	delete self._headers[name.toLowerCase()]
}

ClientRequest.prototype._onFinish = function () {
	var self = this

	if (self._destroyed)
		return
	var opts = self._opts

	var headersObj = self._headers
	var body = null
	if (opts.method !== 'GET' && opts.method !== 'HEAD') {
		if (capability.arraybuffer) {
			body = toArrayBuffer(Buffer.concat(self._body))
		} else if (capability.blobConstructor) {
			body = new global.Blob(self._body.map(function (buffer) {
				return toArrayBuffer(buffer)
			}), {
				type: (headersObj['content-type'] || {}).value || ''
			})
		} else {
			// get utf8 string
			body = Buffer.concat(self._body).toString()
		}
	}

	// create flattened list of headers
	var headersList = []
	Object.keys(headersObj).forEach(function (keyName) {
		var name = headersObj[keyName].name
		var value = headersObj[keyName].value
		if (Array.isArray(value)) {
			value.forEach(function (v) {
				headersList.push([name, v])
			})
		} else {
			headersList.push([name, value])
		}
	})

	if (self._mode === 'fetch') {
		var signal = null
		var fetchTimer = null
		if (capability.abortController) {
			var controller = new AbortController()
			signal = controller.signal
			self._fetchAbortController = controller

			if ('requestTimeout' in opts && opts.requestTimeout !== 0) {
				self._fetchTimer = global.setTimeout(function () {
					self.emit('requestTimeout')
					if (self._fetchAbortController)
						self._fetchAbortController.abort()
				}, opts.requestTimeout)
			}
		}

		global.fetch(self._opts.url, {
			method: self._opts.method,
			headers: headersList,
			body: body || undefined,
			mode: 'cors',
			credentials: opts.withCredentials ? 'include' : 'same-origin',
			signal: signal
		}).then(function (response) {
			self._fetchResponse = response
			self._connect()
		}, function (reason) {
			global.clearTimeout(self._fetchTimer)
			if (!self._destroyed)
				self.emit('error', reason)
		})
	} else {
		var xhr = self._xhr = new global.XMLHttpRequest()
		try {
			xhr.open(self._opts.method, self._opts.url, true)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}

		// Can't set responseType on really old browsers
		if ('responseType' in xhr)
			xhr.responseType = self._mode.split(':')[0]

		if ('withCredentials' in xhr)
			xhr.withCredentials = !!opts.withCredentials

		if (self._mode === 'text' && 'overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain; charset=x-user-defined')

		if ('requestTimeout' in opts) {
			xhr.timeout = opts.requestTimeout
			xhr.ontimeout = function () {
				self.emit('requestTimeout')
			}
		}

		headersList.forEach(function (header) {
			xhr.setRequestHeader(header[0], header[1])
		})

		self._response = null
		xhr.onreadystatechange = function () {
			switch (xhr.readyState) {
				case rStates.LOADING:
				case rStates.DONE:
					self._onXHRProgress()
					break
			}
		}
		// Necessary for streaming in Firefox, since xhr.response is ONLY defined
		// in onprogress, not in onreadystatechange with xhr.readyState = 3
		if (self._mode === 'moz-chunked-arraybuffer') {
			xhr.onprogress = function () {
				self._onXHRProgress()
			}
		}

		xhr.onerror = function () {
			if (self._destroyed)
				return
			self.emit('error', new Error('XHR error'))
		}

		try {
			xhr.send(body)
		} catch (err) {
			process.nextTick(function () {
				self.emit('error', err)
			})
			return
		}
	}
}

/**
 * Checks if xhr.status is readable and non-zero, indicating no error.
 * Even though the spec says it should be available in readyState 3,
 * accessing it throws an exception in IE8
 */
function statusValid (xhr) {
	try {
		var status = xhr.status
		return (status !== null && status !== 0)
	} catch (e) {
		return false
	}
}

ClientRequest.prototype._onXHRProgress = function () {
	var self = this

	if (!statusValid(self._xhr) || self._destroyed)
		return

	if (!self._response)
		self._connect()

	self._response._onXHRProgress()
}

ClientRequest.prototype._connect = function () {
	var self = this

	if (self._destroyed)
		return

	self._response = new IncomingMessage(self._xhr, self._fetchResponse, self._mode, self._fetchTimer)
	self._response.on('error', function(err) {
		self.emit('error', err)
	})

	self.emit('response', self._response)
}

ClientRequest.prototype._write = function (chunk, encoding, cb) {
	var self = this

	self._body.push(chunk)
	cb()
}

ClientRequest.prototype.abort = ClientRequest.prototype.destroy = function () {
	var self = this
	self._destroyed = true
	global.clearTimeout(self._fetchTimer)
	if (self._response)
		self._response._destroyed = true
	if (self._xhr)
		self._xhr.abort()
	else if (self._fetchAbortController)
		self._fetchAbortController.abort()
}

ClientRequest.prototype.end = function (data, encoding, cb) {
	var self = this
	if (typeof data === 'function') {
		cb = data
		data = undefined
	}

	stream.Writable.prototype.end.call(self, data, encoding, cb)
}

ClientRequest.prototype.flushHeaders = function () {}
ClientRequest.prototype.setTimeout = function () {}
ClientRequest.prototype.setNoDelay = function () {}
ClientRequest.prototype.setSocketKeepAlive = function () {}

// Taken from http://www.w3.org/TR/XMLHttpRequest/#the-setrequestheader%28%29-method
var unsafeHeaders = [
	'accept-charset',
	'accept-encoding',
	'access-control-request-headers',
	'access-control-request-method',
	'connection',
	'content-length',
	'cookie',
	'cookie2',
	'date',
	'dnt',
	'expect',
	'host',
	'keep-alive',
	'origin',
	'referer',
	'te',
	'trailer',
	'transfer-encoding',
	'upgrade',
	'via'
]

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../buffer/4.9.1/node_modules/buffer/index.js */ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/response.js":
/*!*****************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/response.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, Buffer, global) {var capability = __webpack_require__(/*! ./capability */ "../../common/temp/node_modules/.registry.npmjs.org/stream-http/2.8.3/node_modules/stream-http/lib/capability.js")
var inherits = __webpack_require__(/*! inherits */ "../../common/temp/node_modules/.registry.npmjs.org/inherits/2.0.3/node_modules/inherits/inherits_browser.js")
var stream = __webpack_require__(/*! readable-stream */ "../../common/temp/node_modules/.registry.npmjs.org/readable-stream/2.3.6/node_modules/readable-stream/readable-browser.js")

var rStates = exports.readyStates = {
	UNSENT: 0,
	OPENED: 1,
	HEADERS_RECEIVED: 2,
	LOADING: 3,
	DONE: 4
}

var IncomingMessage = exports.IncomingMessage = function (xhr, response, mode, fetchTimer) {
	var self = this
	stream.Readable.call(self)

	self._mode = mode
	self.headers = {}
	self.rawHeaders = []
	self.trailers = {}
	self.rawTrailers = []

	// Fake the 'close' event, but only once 'end' fires
	self.on('end', function () {
		// The nextTick is necessary to prevent the 'request' module from causing an infinite loop
		process.nextTick(function () {
			self.emit('close')
		})
	})

	if (mode === 'fetch') {
		self._fetchResponse = response

		self.url = response.url
		self.statusCode = response.status
		self.statusMessage = response.statusText
		
		response.headers.forEach(function (header, key){
			self.headers[key.toLowerCase()] = header
			self.rawHeaders.push(key, header)
		})

		if (capability.writableStream) {
			var writable = new WritableStream({
				write: function (chunk) {
					return new Promise(function (resolve, reject) {
						if (self._destroyed) {
							reject()
						} else if(self.push(new Buffer(chunk))) {
							resolve()
						} else {
							self._resumeFetch = resolve
						}
					})
				},
				close: function () {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.push(null)
				},
				abort: function (err) {
					if (!self._destroyed)
						self.emit('error', err)
				}
			})

			try {
				response.body.pipeTo(writable).catch(function (err) {
					global.clearTimeout(fetchTimer)
					if (!self._destroyed)
						self.emit('error', err)
				})
				return
			} catch (e) {} // pipeTo method isn't defined. Can't find a better way to feature test this
		}
		// fallback for when writableStream or pipeTo aren't available
		var reader = response.body.getReader()
		function read () {
			reader.read().then(function (result) {
				if (self._destroyed)
					return
				if (result.done) {
					global.clearTimeout(fetchTimer)
					self.push(null)
					return
				}
				self.push(new Buffer(result.value))
				read()
			}).catch(function (err) {
				global.clearTimeout(fetchTimer)
				if (!self._destroyed)
					self.emit('error', err)
			})
		}
		read()
	} else {
		self._xhr = xhr
		self._pos = 0

		self.url = xhr.responseURL
		self.statusCode = xhr.status
		self.statusMessage = xhr.statusText
		var headers = xhr.getAllResponseHeaders().split(/\r?\n/)
		headers.forEach(function (header) {
			var matches = header.match(/^([^:]+):\s*(.*)/)
			if (matches) {
				var key = matches[1].toLowerCase()
				if (key === 'set-cookie') {
					if (self.headers[key] === undefined) {
						self.headers[key] = []
					}
					self.headers[key].push(matches[2])
				} else if (self.headers[key] !== undefined) {
					self.headers[key] += ', ' + matches[2]
				} else {
					self.headers[key] = matches[2]
				}
				self.rawHeaders.push(matches[1], matches[2])
			}
		})

		self._charset = 'x-user-defined'
		if (!capability.overrideMimeType) {
			var mimeType = self.rawHeaders['mime-type']
			if (mimeType) {
				var charsetMatch = mimeType.match(/;\s*charset=([^;])(;|$)/)
				if (charsetMatch) {
					self._charset = charsetMatch[1].toLowerCase()
				}
			}
			if (!self._charset)
				self._charset = 'utf-8' // best guess
		}
	}
}

inherits(IncomingMessage, stream.Readable)

IncomingMessage.prototype._read = function () {
	var self = this

	var resolve = self._resumeFetch
	if (resolve) {
		self._resumeFetch = null
		resolve()
	}
}

IncomingMessage.prototype._onXHRProgress = function () {
	var self = this

	var xhr = self._xhr

	var response = null
	switch (self._mode) {
		case 'text:vbarray': // For IE9
			if (xhr.readyState !== rStates.DONE)
				break
			try {
				// This fails in IE8
				response = new global.VBArray(xhr.responseBody).toArray()
			} catch (e) {}
			if (response !== null) {
				self.push(new Buffer(response))
				break
			}
			// Falls through in IE8	
		case 'text':
			try { // This will fail when readyState = 3 in IE9. Switch mode and wait for readyState = 4
				response = xhr.responseText
			} catch (e) {
				self._mode = 'text:vbarray'
				break
			}
			if (response.length > self._pos) {
				var newData = response.substr(self._pos)
				if (self._charset === 'x-user-defined') {
					var buffer = new Buffer(newData.length)
					for (var i = 0; i < newData.length; i++)
						buffer[i] = newData.charCodeAt(i) & 0xff

					self.push(buffer)
				} else {
					self.push(newData, self._charset)
				}
				self._pos = response.length
			}
			break
		case 'arraybuffer':
			if (xhr.readyState !== rStates.DONE || !xhr.response)
				break
			response = xhr.response
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'moz-chunked-arraybuffer': // take whole
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING || !response)
				break
			self.push(new Buffer(new Uint8Array(response)))
			break
		case 'ms-stream':
			response = xhr.response
			if (xhr.readyState !== rStates.LOADING)
				break
			var reader = new global.MSStreamReader()
			reader.onprogress = function () {
				if (reader.result.byteLength > self._pos) {
					self.push(new Buffer(new Uint8Array(reader.result.slice(self._pos))))
					self._pos = reader.result.byteLength
				}
			}
			reader.onload = function () {
				self.push(null)
			}
			// reader.onerror = ??? // TODO: this
			reader.readAsArrayBuffer(response)
			break
	}

	// The ms-stream case handles end separately in reader.onload()
	if (self._xhr.readyState === rStates.DONE && self._mode !== 'ms-stream') {
		self.push(null)
	}
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../buffer/4.9.1/node_modules/buffer/index.js */ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js").Buffer, __webpack_require__(/*! ./../../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/string_decoder/1.2.0/node_modules/string_decoder/lib/string_decoder.js":
/*!*****************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/string_decoder/1.2.0/node_modules/string_decoder/lib/string_decoder.js ***!
  \*****************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



/*<replacement>*/

var Buffer = __webpack_require__(/*! safe-buffer */ "../../common/temp/node_modules/.registry.npmjs.org/safe-buffer/5.1.2/node_modules/safe-buffer/index.js").Buffer;
/*</replacement>*/

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte. If an invalid byte is detected, -2 is returned.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return byte >> 6 === 0x02 ? -1 : -2;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i || nb === -2) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd';
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd';
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd';
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character is added when ending on a partial
// character.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd';
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/agent-base.js":
/*!*****************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/agent-base.js ***!
  \*****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

function Agent() {
  this._defaults = [];
}

["use", "on", "once", "set", "query", "type", "accept", "auth", "withCredentials", "sortQuery", "retry", "ok", "redirects",
 "timeout", "buffer", "serialize", "parse", "ca", "key", "pfx", "cert"].forEach(function(fn) {
  /** Default setting for all requests from this agent */
  Agent.prototype[fn] = function(/*varargs*/) {
    this._defaults.push({fn:fn, arguments:arguments});
    return this;
  }
});

Agent.prototype._setDefaults = function(req) {
    this._defaults.forEach(function(def) {
      req[def.fn].apply(req, def.arguments);
    });
};

module.exports = Agent;


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/client.js":
/*!*************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/client.js ***!
  \*************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Root reference for iframes.
 */

var root;
if (typeof window !== 'undefined') { // Browser window
  root = window;
} else if (typeof self !== 'undefined') { // Web Worker
  root = self;
} else { // Other environments
  console.warn("Using browser-only version of superagent in non-browser environment");
  root = this;
}

var Emitter = __webpack_require__(/*! component-emitter */ "../../common/temp/node_modules/.registry.npmjs.org/component-emitter/1.3.0/node_modules/component-emitter/index.js");
var RequestBase = __webpack_require__(/*! ./request-base */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/request-base.js");
var isObject = __webpack_require__(/*! ./is-object */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/is-object.js");
var ResponseBase = __webpack_require__(/*! ./response-base */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/response-base.js");
var Agent = __webpack_require__(/*! ./agent-base */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/agent-base.js");

/**
 * Noop.
 */

function noop(){};

/**
 * Expose `request`.
 */

var request = exports = module.exports = function(method, url) {
  // callback
  if ('function' == typeof url) {
    return new exports.Request('GET', method).end(url);
  }

  // url first
  if (1 == arguments.length) {
    return new exports.Request('GET', method);
  }

  return new exports.Request(method, url);
}

exports.Request = Request;

/**
 * Determine XHR.
 */

request.getXHR = function () {
  if (root.XMLHttpRequest
      && (!root.location || 'file:' != root.location.protocol
          || !root.ActiveXObject)) {
    return new XMLHttpRequest;
  } else {
    try { return new ActiveXObject('Microsoft.XMLHTTP'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.6.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP.3.0'); } catch(e) {}
    try { return new ActiveXObject('Msxml2.XMLHTTP'); } catch(e) {}
  }
  throw Error("Browser-only version of superagent could not find XHR");
};

/**
 * Removes leading and trailing whitespace, added to support IE.
 *
 * @param {String} s
 * @return {String}
 * @api private
 */

var trim = ''.trim
  ? function(s) { return s.trim(); }
  : function(s) { return s.replace(/(^\s*|\s*$)/g, ''); };

/**
 * Serialize the given `obj`.
 *
 * @param {Object} obj
 * @return {String}
 * @api private
 */

function serialize(obj) {
  if (!isObject(obj)) return obj;
  var pairs = [];
  for (var key in obj) {
    pushEncodedKeyValuePair(pairs, key, obj[key]);
  }
  return pairs.join('&');
}

/**
 * Helps 'serialize' with serializing arrays.
 * Mutates the pairs array.
 *
 * @param {Array} pairs
 * @param {String} key
 * @param {Mixed} val
 */

function pushEncodedKeyValuePair(pairs, key, val) {
  if (val != null) {
    if (Array.isArray(val)) {
      val.forEach(function(v) {
        pushEncodedKeyValuePair(pairs, key, v);
      });
    } else if (isObject(val)) {
      for(var subkey in val) {
        pushEncodedKeyValuePair(pairs, key + '[' + subkey + ']', val[subkey]);
      }
    } else {
      pairs.push(encodeURIComponent(key)
        + '=' + encodeURIComponent(val));
    }
  } else if (val === null) {
    pairs.push(encodeURIComponent(key));
  }
}

/**
 * Expose serialization method.
 */

request.serializeObject = serialize;

/**
  * Parse the given x-www-form-urlencoded `str`.
  *
  * @param {String} str
  * @return {Object}
  * @api private
  */

function parseString(str) {
  var obj = {};
  var pairs = str.split('&');
  var pair;
  var pos;

  for (var i = 0, len = pairs.length; i < len; ++i) {
    pair = pairs[i];
    pos = pair.indexOf('=');
    if (pos == -1) {
      obj[decodeURIComponent(pair)] = '';
    } else {
      obj[decodeURIComponent(pair.slice(0, pos))] =
        decodeURIComponent(pair.slice(pos + 1));
    }
  }

  return obj;
}

/**
 * Expose parser.
 */

request.parseString = parseString;

/**
 * Default MIME type map.
 *
 *     superagent.types.xml = 'application/xml';
 *
 */

request.types = {
  html: 'text/html',
  json: 'application/json',
  xml: 'text/xml',
  urlencoded: 'application/x-www-form-urlencoded',
  'form': 'application/x-www-form-urlencoded',
  'form-data': 'application/x-www-form-urlencoded'
};

/**
 * Default serialization map.
 *
 *     superagent.serialize['application/xml'] = function(obj){
 *       return 'generated xml here';
 *     };
 *
 */

request.serialize = {
  'application/x-www-form-urlencoded': serialize,
  'application/json': JSON.stringify
};

/**
  * Default parsers.
  *
  *     superagent.parse['application/xml'] = function(str){
  *       return { object parsed from str };
  *     };
  *
  */

request.parse = {
  'application/x-www-form-urlencoded': parseString,
  'application/json': JSON.parse
};

/**
 * Parse the given header `str` into
 * an object containing the mapped fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

function parseHeader(str) {
  var lines = str.split(/\r?\n/);
  var fields = {};
  var index;
  var line;
  var field;
  var val;

  for (var i = 0, len = lines.length; i < len; ++i) {
    line = lines[i];
    index = line.indexOf(':');
    if (index === -1) { // could be empty line, just skip it
      continue;
    }
    field = line.slice(0, index).toLowerCase();
    val = trim(line.slice(index + 1));
    fields[field] = val;
  }

  return fields;
}

/**
 * Check if `mime` is json or has +json structured syntax suffix.
 *
 * @param {String} mime
 * @return {Boolean}
 * @api private
 */

function isJSON(mime) {
  // should match /json or +json
  // but not /json-seq
  return /[\/+]json($|[^-\w])/.test(mime);
}

/**
 * Initialize a new `Response` with the given `xhr`.
 *
 *  - set flags (.ok, .error, etc)
 *  - parse header
 *
 * Examples:
 *
 *  Aliasing `superagent` as `request` is nice:
 *
 *      request = superagent;
 *
 *  We can use the promise-like API, or pass callbacks:
 *
 *      request.get('/').end(function(res){});
 *      request.get('/', function(res){});
 *
 *  Sending data can be chained:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' })
 *        .end(function(res){});
 *
 *  Or passed to `.send()`:
 *
 *      request
 *        .post('/user')
 *        .send({ name: 'tj' }, function(res){});
 *
 *  Or passed to `.post()`:
 *
 *      request
 *        .post('/user', { name: 'tj' })
 *        .end(function(res){});
 *
 * Or further reduced to a single call for simple cases:
 *
 *      request
 *        .post('/user', { name: 'tj' }, function(res){});
 *
 * @param {XMLHTTPRequest} xhr
 * @param {Object} options
 * @api private
 */

function Response(req) {
  this.req = req;
  this.xhr = this.req.xhr;
  // responseText is accessible only if responseType is '' or 'text' and on older browsers
  this.text = ((this.req.method !='HEAD' && (this.xhr.responseType === '' || this.xhr.responseType === 'text')) || typeof this.xhr.responseType === 'undefined')
     ? this.xhr.responseText
     : null;
  this.statusText = this.req.xhr.statusText;
  var status = this.xhr.status;
  // handle IE9 bug: http://stackoverflow.com/questions/10046972/msie-returns-status-code-of-1223-for-ajax-request
  if (status === 1223) {
    status = 204;
  }
  this._setStatusProperties(status);
  this.header = this.headers = parseHeader(this.xhr.getAllResponseHeaders());
  // getAllResponseHeaders sometimes falsely returns "" for CORS requests, but
  // getResponseHeader still works. so we get content-type even if getting
  // other headers fails.
  this.header['content-type'] = this.xhr.getResponseHeader('content-type');
  this._setHeaderProperties(this.header);

  if (null === this.text && req._responseType) {
    this.body = this.xhr.response;
  } else {
    this.body = this.req.method != 'HEAD'
      ? this._parseBody(this.text ? this.text : this.xhr.response)
      : null;
  }
}

ResponseBase(Response.prototype);

/**
 * Parse the given body `str`.
 *
 * Used for auto-parsing of bodies. Parsers
 * are defined on the `superagent.parse` object.
 *
 * @param {String} str
 * @return {Mixed}
 * @api private
 */

Response.prototype._parseBody = function(str) {
  var parse = request.parse[this.type];
  if (this.req._parser) {
    return this.req._parser(this, str);
  }
  if (!parse && isJSON(this.type)) {
    parse = request.parse['application/json'];
  }
  return parse && str && (str.length || str instanceof Object)
    ? parse(str)
    : null;
};

/**
 * Return an `Error` representative of this response.
 *
 * @return {Error}
 * @api public
 */

Response.prototype.toError = function(){
  var req = this.req;
  var method = req.method;
  var url = req.url;

  var msg = 'cannot ' + method + ' ' + url + ' (' + this.status + ')';
  var err = new Error(msg);
  err.status = this.status;
  err.method = method;
  err.url = url;

  return err;
};

/**
 * Expose `Response`.
 */

request.Response = Response;

/**
 * Initialize a new `Request` with the given `method` and `url`.
 *
 * @param {String} method
 * @param {String} url
 * @api public
 */

function Request(method, url) {
  var self = this;
  this._query = this._query || [];
  this.method = method;
  this.url = url;
  this.header = {}; // preserves header name case
  this._header = {}; // coerces header names to lowercase
  this.on('end', function(){
    var err = null;
    var res = null;

    try {
      res = new Response(self);
    } catch(e) {
      err = new Error('Parser is unable to parse the response');
      err.parse = true;
      err.original = e;
      // issue #675: return the raw response if the response parsing fails
      if (self.xhr) {
        // ie9 doesn't have 'response' property
        err.rawResponse = typeof self.xhr.responseType == 'undefined' ? self.xhr.responseText : self.xhr.response;
        // issue #876: return the http status code if the response parsing fails
        err.status = self.xhr.status ? self.xhr.status : null;
        err.statusCode = err.status; // backwards-compat only
      } else {
        err.rawResponse = null;
        err.status = null;
      }

      return self.callback(err);
    }

    self.emit('response', res);

    var new_err;
    try {
      if (!self._isResponseOK(res)) {
        new_err = new Error(res.statusText || 'Unsuccessful HTTP response');
      }
    } catch(custom_err) {
      new_err = custom_err; // ok() callback can throw
    }

    // #1000 don't catch errors from the callback to avoid double calling it
    if (new_err) {
      new_err.original = err;
      new_err.response = res;
      new_err.status = res.status;
      self.callback(new_err, res);
    } else {
      self.callback(null, res);
    }
  });
}

/**
 * Mixin `Emitter` and `RequestBase`.
 */

Emitter(Request.prototype);
RequestBase(Request.prototype);

/**
 * Set Content-Type to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.xml = 'application/xml';
 *
 *      request.post('/')
 *        .type('xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 *      request.post('/')
 *        .type('application/xml')
 *        .send(xmlstring)
 *        .end(callback);
 *
 * @param {String} type
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.type = function(type){
  this.set('Content-Type', request.types[type] || type);
  return this;
};

/**
 * Set Accept to `type`, mapping values from `request.types`.
 *
 * Examples:
 *
 *      superagent.types.json = 'application/json';
 *
 *      request.get('/agent')
 *        .accept('json')
 *        .end(callback);
 *
 *      request.get('/agent')
 *        .accept('application/json')
 *        .end(callback);
 *
 * @param {String} accept
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.accept = function(type){
  this.set('Accept', request.types[type] || type);
  return this;
};

/**
 * Set Authorization field value with `user` and `pass`.
 *
 * @param {String} user
 * @param {String} [pass] optional in case of using 'bearer' as type
 * @param {Object} options with 'type' property 'auto', 'basic' or 'bearer' (default 'basic')
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.auth = function(user, pass, options){
  if (1 === arguments.length) pass = '';
  if (typeof pass === 'object' && pass !== null) { // pass is optional and can be replaced with options
    options = pass;
    pass = '';
  }
  if (!options) {
    options = {
      type: 'function' === typeof btoa ? 'basic' : 'auto',
    };
  }

  var encoder = function(string) {
    if ('function' === typeof btoa) {
      return btoa(string);
    }
    throw new Error('Cannot use basic auth, btoa is not a function');
  };

  return this._auth(user, pass, options, encoder);
};

/**
 * Add query-string `val`.
 *
 * Examples:
 *
 *   request.get('/shoes')
 *     .query('size=10')
 *     .query({ color: 'blue' })
 *
 * @param {Object|String} val
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.query = function(val){
  if ('string' != typeof val) val = serialize(val);
  if (val) this._query.push(val);
  return this;
};

/**
 * Queue the given `file` as an attachment to the specified `field`,
 * with optional `options` (or filename).
 *
 * ``` js
 * request.post('/upload')
 *   .attach('content', new Blob(['<a id="a"><b id="b">hey!</b></a>'], { type: "text/html"}))
 *   .end(callback);
 * ```
 *
 * @param {String} field
 * @param {Blob|File} file
 * @param {String|Object} options
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.attach = function(field, file, options){
  if (file) {
    if (this._data) {
      throw Error("superagent can't mix .send() and .attach()");
    }

    this._getFormData().append(field, file, options || file.name);
  }
  return this;
};

Request.prototype._getFormData = function(){
  if (!this._formData) {
    this._formData = new root.FormData();
  }
  return this._formData;
};

/**
 * Invoke the callback with `err` and `res`
 * and handle arity check.
 *
 * @param {Error} err
 * @param {Response} res
 * @api private
 */

Request.prototype.callback = function(err, res){
  if (this._shouldRetry(err, res)) {
    return this._retry();
  }

  var fn = this._callback;
  this.clearTimeout();

  if (err) {
    if (this._maxRetries) err.retries = this._retries - 1;
    this.emit('error', err);
  }

  fn(err, res);
};

/**
 * Invoke callback with x-domain error.
 *
 * @api private
 */

Request.prototype.crossDomainError = function(){
  var err = new Error('Request has been terminated\nPossible causes: the network is offline, Origin is not allowed by Access-Control-Allow-Origin, the page is being unloaded, etc.');
  err.crossDomain = true;

  err.status = this.status;
  err.method = this.method;
  err.url = this.url;

  this.callback(err);
};

// This only warns, because the request is still likely to work
Request.prototype.buffer = Request.prototype.ca = Request.prototype.agent = function(){
  console.warn("This is not supported in browser version of superagent");
  return this;
};

// This throws, because it can't send/receive data as expected
Request.prototype.pipe = Request.prototype.write = function(){
  throw Error("Streaming is not supported in browser version of superagent");
};

/**
 * Check if `obj` is a host object,
 * we don't want to serialize these :)
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */
Request.prototype._isHost = function _isHost(obj) {
  // Native objects stringify to [object File], [object Blob], [object FormData], etc.
  return obj && 'object' === typeof obj && !Array.isArray(obj) && Object.prototype.toString.call(obj) !== '[object Object]';
}

/**
 * Initiate request, invoking callback `fn(res)`
 * with an instanceof `Response`.
 *
 * @param {Function} fn
 * @return {Request} for chaining
 * @api public
 */

Request.prototype.end = function(fn){
  if (this._endCalled) {
    console.warn("Warning: .end() was called twice. This is not supported in superagent");
  }
  this._endCalled = true;

  // store callback
  this._callback = fn || noop;

  // querystring
  this._finalizeQueryString();

  return this._end();
};

Request.prototype._end = function() {
  var self = this;
  var xhr = (this.xhr = request.getXHR());
  var data = this._formData || this._data;

  this._setTimeouts();

  // state change
  xhr.onreadystatechange = function(){
    var readyState = xhr.readyState;
    if (readyState >= 2 && self._responseTimeoutTimer) {
      clearTimeout(self._responseTimeoutTimer);
    }
    if (4 != readyState) {
      return;
    }

    // In IE9, reads to any property (e.g. status) off of an aborted XHR will
    // result in the error "Could not complete the operation due to error c00c023f"
    var status;
    try { status = xhr.status } catch(e) { status = 0; }

    if (!status) {
      if (self.timedout || self._aborted) return;
      return self.crossDomainError();
    }
    self.emit('end');
  };

  // progress
  var handleProgress = function(direction, e) {
    if (e.total > 0) {
      e.percent = e.loaded / e.total * 100;
    }
    e.direction = direction;
    self.emit('progress', e);
  };
  if (this.hasListeners('progress')) {
    try {
      xhr.onprogress = handleProgress.bind(null, 'download');
      if (xhr.upload) {
        xhr.upload.onprogress = handleProgress.bind(null, 'upload');
      }
    } catch(e) {
      // Accessing xhr.upload fails in IE from a web worker, so just pretend it doesn't exist.
      // Reported here:
      // https://connect.microsoft.com/IE/feedback/details/837245/xmlhttprequest-upload-throws-invalid-argument-when-used-from-web-worker-context
    }
  }

  // initiate request
  try {
    if (this.username && this.password) {
      xhr.open(this.method, this.url, true, this.username, this.password);
    } else {
      xhr.open(this.method, this.url, true);
    }
  } catch (err) {
    // see #1149
    return this.callback(err);
  }

  // CORS
  if (this._withCredentials) xhr.withCredentials = true;

  // body
  if (!this._formData && 'GET' != this.method && 'HEAD' != this.method && 'string' != typeof data && !this._isHost(data)) {
    // serialize stuff
    var contentType = this._header['content-type'];
    var serialize = this._serializer || request.serialize[contentType ? contentType.split(';')[0] : ''];
    if (!serialize && isJSON(contentType)) {
      serialize = request.serialize['application/json'];
    }
    if (serialize) data = serialize(data);
  }

  // set header fields
  for (var field in this.header) {
    if (null == this.header[field]) continue;

    if (this.header.hasOwnProperty(field))
      xhr.setRequestHeader(field, this.header[field]);
  }

  if (this._responseType) {
    xhr.responseType = this._responseType;
  }

  // send stuff
  this.emit('request', this);

  // IE11 xhr.send(undefined) sends 'undefined' string as POST payload (instead of nothing)
  // We need null here if data is undefined
  xhr.send(typeof data !== 'undefined' ? data : null);
  return this;
};

request.agent = function() {
  return new Agent();
};

["GET", "POST", "OPTIONS", "PATCH", "PUT", "DELETE"].forEach(function(method) {
  Agent.prototype[method.toLowerCase()] = function(url, fn) {
    var req = new request.Request(method, url);
    this._setDefaults(req);
    if (fn) {
      req.end(fn);
    }
    return req;
  };
});

Agent.prototype.del = Agent.prototype['delete'];

/**
 * GET `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.get = function(url, data, fn) {
  var req = request('GET', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * HEAD `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.head = function(url, data, fn) {
  var req = request('HEAD', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.query(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * OPTIONS query to `url` with optional callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.options = function(url, data, fn) {
  var req = request('OPTIONS', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * DELETE `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

function del(url, data, fn) {
  var req = request('DELETE', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
}

request['del'] = del;
request['delete'] = del;

/**
 * PATCH `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.patch = function(url, data, fn) {
  var req = request('PATCH', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * POST `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed} [data]
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.post = function(url, data, fn) {
  var req = request('POST', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};

/**
 * PUT `url` with optional `data` and callback `fn(res)`.
 *
 * @param {String} url
 * @param {Mixed|Function} [data] or fn
 * @param {Function} [fn]
 * @return {Request}
 * @api public
 */

request.put = function(url, data, fn) {
  var req = request('PUT', url);
  if ('function' == typeof data) (fn = data), (data = null);
  if (data) req.send(data);
  if (fn) req.end(fn);
  return req;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/is-object.js":
/*!****************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/is-object.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if `obj` is an object.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isObject(obj) {
  return null !== obj && 'object' === typeof obj;
}

module.exports = isObject;


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/request-base.js":
/*!*******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/request-base.js ***!
  \*******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module of mixed-in functions shared between node and client code
 */
var isObject = __webpack_require__(/*! ./is-object */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/is-object.js");

/**
 * Expose `RequestBase`.
 */

module.exports = RequestBase;

/**
 * Initialize a new `RequestBase`.
 *
 * @api public
 */

function RequestBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in RequestBase.prototype) {
    obj[key] = RequestBase.prototype[key];
  }
  return obj;
}

/**
 * Clear previous timeout.
 *
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.clearTimeout = function _clearTimeout(){
  clearTimeout(this._timer);
  clearTimeout(this._responseTimeoutTimer);
  delete this._timer;
  delete this._responseTimeoutTimer;
  return this;
};

/**
 * Override default response body parser
 *
 * This function will be called to convert incoming data into request.body
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.parse = function parse(fn){
  this._parser = fn;
  return this;
};

/**
 * Set format of binary response body.
 * In browser valid formats are 'blob' and 'arraybuffer',
 * which return Blob and ArrayBuffer, respectively.
 *
 * In Node all values result in Buffer.
 *
 * Examples:
 *
 *      req.get('/')
 *        .responseType('blob')
 *        .end(callback);
 *
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.responseType = function(val){
  this._responseType = val;
  return this;
};

/**
 * Override default request body serializer
 *
 * This function will be called to convert data set via .send or .attach into payload to send
 *
 * @param {Function}
 * @api public
 */

RequestBase.prototype.serialize = function serialize(fn){
  this._serializer = fn;
  return this;
};

/**
 * Set timeouts.
 *
 * - response timeout is time between sending request and receiving the first byte of the response. Includes DNS and connection time.
 * - deadline is the time from start of the request to receiving response body in full. If the deadline is too short large files may not load at all on slow connections.
 *
 * Value of 0 or false means no timeout.
 *
 * @param {Number|Object} ms or {response, deadline}
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.timeout = function timeout(options){
  if (!options || 'object' !== typeof options) {
    this._timeout = options;
    this._responseTimeout = 0;
    return this;
  }

  for(var option in options) {
    switch(option) {
      case 'deadline':
        this._timeout = options.deadline;
        break;
      case 'response':
        this._responseTimeout = options.response;
        break;
      default:
        console.warn("Unknown timeout option", option);
    }
  }
  return this;
};

/**
 * Set number of retry attempts on error.
 *
 * Failed requests will be retried 'count' times if timeout or err.code >= 500.
 *
 * @param {Number} count
 * @param {Function} [fn]
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.retry = function retry(count, fn){
  // Default to 1 if no count passed or true
  if (arguments.length === 0 || count === true) count = 1;
  if (count <= 0) count = 0;
  this._maxRetries = count;
  this._retries = 0;
  this._retryCallback = fn;
  return this;
};

var ERROR_CODES = [
  'ECONNRESET',
  'ETIMEDOUT',
  'EADDRINFO',
  'ESOCKETTIMEDOUT'
];

/**
 * Determine if a request should be retried.
 * (Borrowed from segmentio/superagent-retry)
 *
 * @param {Error} err
 * @param {Response} [res]
 * @returns {Boolean}
 */
RequestBase.prototype._shouldRetry = function(err, res) {
  if (!this._maxRetries || this._retries++ >= this._maxRetries) {
    return false;
  }
  if (this._retryCallback) {
    try {
      var override = this._retryCallback(err, res);
      if (override === true) return true;
      if (override === false) return false;
      // undefined falls back to defaults
    } catch(e) {
      console.error(e);
    }
  }
  if (res && res.status && res.status >= 500 && res.status != 501) return true;
  if (err) {
    if (err.code && ~ERROR_CODES.indexOf(err.code)) return true;
    // Superagent timeout
    if (err.timeout && err.code == 'ECONNABORTED') return true;
    if (err.crossDomain) return true;
  }
  return false;
};

/**
 * Retry request
 *
 * @return {Request} for chaining
 * @api private
 */

RequestBase.prototype._retry = function() {

  this.clearTimeout();

  // node
  if (this.req) {
    this.req = null;
    this.req = this.request();
  }

  this._aborted = false;
  this.timedout = false;

  return this._end();
};

/**
 * Promise support
 *
 * @param {Function} resolve
 * @param {Function} [reject]
 * @return {Request}
 */

RequestBase.prototype.then = function then(resolve, reject) {
  if (!this._fullfilledPromise) {
    var self = this;
    if (this._endCalled) {
      console.warn("Warning: superagent request was sent twice, because both .end() and .then() were called. Never call .end() if you use promises");
    }
    this._fullfilledPromise = new Promise(function(innerResolve, innerReject) {
      self.end(function(err, res) {
        if (err) innerReject(err);
        else innerResolve(res);
      });
    });
  }
  return this._fullfilledPromise.then(resolve, reject);
};

RequestBase.prototype['catch'] = function(cb) {
  return this.then(undefined, cb);
};

/**
 * Allow for extension
 */

RequestBase.prototype.use = function use(fn) {
  fn(this);
  return this;
};

RequestBase.prototype.ok = function(cb) {
  if ('function' !== typeof cb) throw Error("Callback required");
  this._okCallback = cb;
  return this;
};

RequestBase.prototype._isResponseOK = function(res) {
  if (!res) {
    return false;
  }

  if (this._okCallback) {
    return this._okCallback(res);
  }

  return res.status >= 200 && res.status < 300;
};

/**
 * Get request header `field`.
 * Case-insensitive.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

RequestBase.prototype.get = function(field){
  return this._header[field.toLowerCase()];
};

/**
 * Get case-insensitive header `field` value.
 * This is a deprecated internal API. Use `.get(field)` instead.
 *
 * (getHeader is no longer used internally by the superagent code base)
 *
 * @param {String} field
 * @return {String}
 * @api private
 * @deprecated
 */

RequestBase.prototype.getHeader = RequestBase.prototype.get;

/**
 * Set header `field` to `val`, or multiple fields with one object.
 * Case-insensitive.
 *
 * Examples:
 *
 *      req.get('/')
 *        .set('Accept', 'application/json')
 *        .set('X-API-Key', 'foobar')
 *        .end(callback);
 *
 *      req.get('/')
 *        .set({ Accept: 'application/json', 'X-API-Key': 'foobar' })
 *        .end(callback);
 *
 * @param {String|Object} field
 * @param {String} val
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.set = function(field, val){
  if (isObject(field)) {
    for (var key in field) {
      this.set(key, field[key]);
    }
    return this;
  }
  this._header[field.toLowerCase()] = val;
  this.header[field] = val;
  return this;
};

/**
 * Remove header `field`.
 * Case-insensitive.
 *
 * Example:
 *
 *      req.get('/')
 *        .unset('User-Agent')
 *        .end(callback);
 *
 * @param {String} field
 */
RequestBase.prototype.unset = function(field){
  delete this._header[field.toLowerCase()];
  delete this.header[field];
  return this;
};

/**
 * Write the field `name` and `val`, or multiple fields with one object
 * for "multipart/form-data" request bodies.
 *
 * ``` js
 * request.post('/upload')
 *   .field('foo', 'bar')
 *   .end(callback);
 *
 * request.post('/upload')
 *   .field({ foo: 'bar', baz: 'qux' })
 *   .end(callback);
 * ```
 *
 * @param {String|Object} name
 * @param {String|Blob|File|Buffer|fs.ReadStream} val
 * @return {Request} for chaining
 * @api public
 */
RequestBase.prototype.field = function(name, val) {
  // name should be either a string or an object.
  if (null === name || undefined === name) {
    throw new Error('.field(name, val) name can not be empty');
  }

  if (this._data) {
    console.error(".field() can't be used if .send() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObject(name)) {
    for (var key in name) {
      this.field(key, name[key]);
    }
    return this;
  }

  if (Array.isArray(val)) {
    for (var i in val) {
      this.field(name, val[i]);
    }
    return this;
  }

  // val should be defined now
  if (null === val || undefined === val) {
    throw new Error('.field(name, val) val can not be empty');
  }
  if ('boolean' === typeof val) {
    val = '' + val;
  }
  this._getFormData().append(name, val);
  return this;
};

/**
 * Abort the request, and clear potential timeout.
 *
 * @return {Request}
 * @api public
 */
RequestBase.prototype.abort = function(){
  if (this._aborted) {
    return this;
  }
  this._aborted = true;
  this.xhr && this.xhr.abort(); // browser
  this.req && this.req.abort(); // node
  this.clearTimeout();
  this.emit('abort');
  return this;
};

RequestBase.prototype._auth = function(user, pass, options, base64Encoder) {
  switch (options.type) {
    case 'basic':
      this.set('Authorization', 'Basic ' + base64Encoder(user + ':' + pass));
      break;

    case 'auto':
      this.username = user;
      this.password = pass;
      break;

    case 'bearer': // usage would be .auth(accessToken, { type: 'bearer' })
      this.set('Authorization', 'Bearer ' + user);
      break;
  }
  return this;
};

/**
 * Enable transmission of cookies with x-domain requests.
 *
 * Note that for this to work the origin must not be
 * using "Access-Control-Allow-Origin" with a wildcard,
 * and also must set "Access-Control-Allow-Credentials"
 * to "true".
 *
 * @api public
 */

RequestBase.prototype.withCredentials = function(on) {
  // This is browser-only functionality. Node side is no-op.
  if (on == undefined) on = true;
  this._withCredentials = on;
  return this;
};

/**
 * Set the max redirects to `n`. Does noting in browser XHR implementation.
 *
 * @param {Number} n
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.redirects = function(n){
  this._maxRedirects = n;
  return this;
};

/**
 * Maximum size of buffered response body, in bytes. Counts uncompressed size.
 * Default 200MB.
 *
 * @param {Number} n
 * @return {Request} for chaining
 */
RequestBase.prototype.maxResponseSize = function(n){
  if ('number' !== typeof n) {
    throw TypeError("Invalid argument");
  }
  this._maxResponseSize = n;
  return this;
};

/**
 * Convert to a plain javascript object (not JSON string) of scalar properties.
 * Note as this method is designed to return a useful non-this value,
 * it cannot be chained.
 *
 * @return {Object} describing method, url, and data of this request
 * @api public
 */

RequestBase.prototype.toJSON = function() {
  return {
    method: this.method,
    url: this.url,
    data: this._data,
    headers: this._header,
  };
};

/**
 * Send `data` as the request body, defaulting the `.type()` to "json" when
 * an object is given.
 *
 * Examples:
 *
 *       // manual json
 *       request.post('/user')
 *         .type('json')
 *         .send('{"name":"tj"}')
 *         .end(callback)
 *
 *       // auto json
 *       request.post('/user')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // manual x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send('name=tj')
 *         .end(callback)
 *
 *       // auto x-www-form-urlencoded
 *       request.post('/user')
 *         .type('form')
 *         .send({ name: 'tj' })
 *         .end(callback)
 *
 *       // defaults to x-www-form-urlencoded
 *      request.post('/user')
 *        .send('name=tobi')
 *        .send('species=ferret')
 *        .end(callback)
 *
 * @param {String|Object} data
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.send = function(data){
  var isObj = isObject(data);
  var type = this._header['content-type'];

  if (this._formData) {
    console.error(".send() can't be used if .attach() or .field() is used. Please use only .send() or only .field() & .attach()");
  }

  if (isObj && !this._data) {
    if (Array.isArray(data)) {
      this._data = [];
    } else if (!this._isHost(data)) {
      this._data = {};
    }
  } else if (data && this._data && this._isHost(this._data)) {
    throw Error("Can't merge these send calls");
  }

  // merge
  if (isObj && isObject(this._data)) {
    for (var key in data) {
      this._data[key] = data[key];
    }
  } else if ('string' == typeof data) {
    // default to x-www-form-urlencoded
    if (!type) this.type('form');
    type = this._header['content-type'];
    if ('application/x-www-form-urlencoded' == type) {
      this._data = this._data
        ? this._data + '&' + data
        : data;
    } else {
      this._data = (this._data || '') + data;
    }
  } else {
    this._data = data;
  }

  if (!isObj || this._isHost(data)) {
    return this;
  }

  // default to json
  if (!type) this.type('json');
  return this;
};

/**
 * Sort `querystring` by the sort function
 *
 *
 * Examples:
 *
 *       // default order
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery()
 *         .end(callback)
 *
 *       // customized sort function
 *       request.get('/user')
 *         .query('name=Nick')
 *         .query('search=Manny')
 *         .sortQuery(function(a, b){
 *           return a.length - b.length;
 *         })
 *         .end(callback)
 *
 *
 * @param {Function} sort
 * @return {Request} for chaining
 * @api public
 */

RequestBase.prototype.sortQuery = function(sort) {
  // _sort default to true but otherwise can be a function or boolean
  this._sort = typeof sort === 'undefined' ? true : sort;
  return this;
};

/**
 * Compose querystring to append to req.url
 *
 * @api private
 */
RequestBase.prototype._finalizeQueryString = function(){
  var query = this._query.join('&');
  if (query) {
    this.url += (this.url.indexOf('?') >= 0 ? '&' : '?') + query;
  }
  this._query.length = 0; // Makes the call idempotent

  if (this._sort) {
    var index = this.url.indexOf('?');
    if (index >= 0) {
      var queryArr = this.url.substring(index + 1).split('&');
      if ('function' === typeof this._sort) {
        queryArr.sort(this._sort);
      } else {
        queryArr.sort();
      }
      this.url = this.url.substring(0, index) + '?' + queryArr.join('&');
    }
  }
};

// For backwards compat only
RequestBase.prototype._appendQueryString = function() {console.trace("Unsupported");}

/**
 * Invoke callback with timeout error.
 *
 * @api private
 */

RequestBase.prototype._timeoutError = function(reason, timeout, errno){
  if (this._aborted) {
    return;
  }
  var err = new Error(reason + timeout + 'ms exceeded');
  err.timeout = timeout;
  err.code = 'ECONNABORTED';
  err.errno = errno;
  this.timedout = true;
  this.abort();
  this.callback(err);
};

RequestBase.prototype._setTimeouts = function() {
  var self = this;

  // deadline
  if (this._timeout && !this._timer) {
    this._timer = setTimeout(function(){
      self._timeoutError('Timeout of ', self._timeout, 'ETIME');
    }, this._timeout);
  }
  // response timeout
  if (this._responseTimeout && !this._responseTimeoutTimer) {
    this._responseTimeoutTimer = setTimeout(function(){
      self._timeoutError('Response timeout of ', self._responseTimeout, 'ETIMEDOUT');
    }, this._responseTimeout);
  }
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/response-base.js":
/*!********************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/response-base.js ***!
  \********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Module dependencies.
 */

var utils = __webpack_require__(/*! ./utils */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/utils.js");

/**
 * Expose `ResponseBase`.
 */

module.exports = ResponseBase;

/**
 * Initialize a new `ResponseBase`.
 *
 * @api public
 */

function ResponseBase(obj) {
  if (obj) return mixin(obj);
}

/**
 * Mixin the prototype properties.
 *
 * @param {Object} obj
 * @return {Object}
 * @api private
 */

function mixin(obj) {
  for (var key in ResponseBase.prototype) {
    obj[key] = ResponseBase.prototype[key];
  }
  return obj;
}

/**
 * Get case-insensitive `field` value.
 *
 * @param {String} field
 * @return {String}
 * @api public
 */

ResponseBase.prototype.get = function(field) {
  return this.header[field.toLowerCase()];
};

/**
 * Set header related properties:
 *
 *   - `.type` the content type without params
 *
 * A response of "Content-Type: text/plain; charset=utf-8"
 * will provide you with a `.type` of "text/plain".
 *
 * @param {Object} header
 * @api private
 */

ResponseBase.prototype._setHeaderProperties = function(header){
    // TODO: moar!
    // TODO: make this a util

    // content-type
    var ct = header['content-type'] || '';
    this.type = utils.type(ct);

    // params
    var params = utils.params(ct);
    for (var key in params) this[key] = params[key];

    this.links = {};

    // links
    try {
        if (header.link) {
            this.links = utils.parseLinks(header.link);
        }
    } catch (err) {
        // ignore
    }
};

/**
 * Set flags such as `.ok` based on `status`.
 *
 * For example a 2xx response will give you a `.ok` of __true__
 * whereas 5xx will be __false__ and `.error` will be __true__. The
 * `.clientError` and `.serverError` are also available to be more
 * specific, and `.statusType` is the class of error ranging from 1..5
 * sometimes useful for mapping respond colors etc.
 *
 * "sugar" properties are also defined for common cases. Currently providing:
 *
 *   - .noContent
 *   - .badRequest
 *   - .unauthorized
 *   - .notAcceptable
 *   - .notFound
 *
 * @param {Number} status
 * @api private
 */

ResponseBase.prototype._setStatusProperties = function(status){
    var type = status / 100 | 0;

    // status / class
    this.status = this.statusCode = status;
    this.statusType = type;

    // basics
    this.info = 1 == type;
    this.ok = 2 == type;
    this.redirect = 3 == type;
    this.clientError = 4 == type;
    this.serverError = 5 == type;
    this.error = (4 == type || 5 == type)
        ? this.toError()
        : false;

    // sugar
    this.created = 201 == status;
    this.accepted = 202 == status;
    this.noContent = 204 == status;
    this.badRequest = 400 == status;
    this.unauthorized = 401 == status;
    this.notAcceptable = 406 == status;
    this.forbidden = 403 == status;
    this.notFound = 404 == status;
    this.unprocessableEntity = 422 == status;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/utils.js":
/*!************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/utils.js ***!
  \************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Return the mime type for the given `str`.
 *
 * @param {String} str
 * @return {String}
 * @api private
 */

exports.type = function(str){
  return str.split(/ *; */).shift();
};

/**
 * Return header field parameters.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.params = function(str){
  return str.split(/ *; */).reduce(function(obj, str){
    var parts = str.split(/ *= */);
    var key = parts.shift();
    var val = parts.shift();

    if (key && val) obj[key] = val;
    return obj;
  }, {});
};

/**
 * Parse Link header fields.
 *
 * @param {String} str
 * @return {Object}
 * @api private
 */

exports.parseLinks = function(str){
  return str.split(/ *, */).reduce(function(obj, str){
    var parts = str.split(/ *; */);
    var url = parts[0].slice(1, -1);
    var rel = parts[1].split(/ *= */)[1].slice(1, -1);
    obj[rel] = url;
    return obj;
  }, {});
};

/**
 * Strip content related fields from `header`.
 *
 * @param {Object} header
 * @return {Object} header
 * @api private
 */

exports.cleanHeader = function(header, changesOrigin){
  delete header['content-type'];
  delete header['content-length'];
  delete header['transfer-encoding'];
  delete header['host'];
  // secuirty
  if (changesOrigin) {
    delete header['authorization'];
    delete header['cookie'];
  }
  return header;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js":
/*!**********************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/timers-browserify/2.0.10/node_modules/timers-browserify/main.js ***!
  \**********************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../../common/temp/node_modules/.registry.npmjs.org/setimmediate/1.0.5/node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/to-arraybuffer/1.0.1/node_modules/to-arraybuffer/index.js":
/*!****************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/to-arraybuffer/1.0.1/node_modules/to-arraybuffer/index.js ***!
  \****************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var Buffer = __webpack_require__(/*! buffer */ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js").Buffer

module.exports = function (buf) {
	// If the buffer is backed by a Uint8Array, a faster version will work
	if (buf instanceof Uint8Array) {
		// If the buffer isn't a subarray, return the underlying ArrayBuffer
		if (buf.byteOffset === 0 && buf.byteLength === buf.buffer.byteLength) {
			return buf.buffer
		} else if (typeof buf.buffer.slice === 'function') {
			// Otherwise we need to get a proper copy
			return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength)
		}
	}

	if (Buffer.isBuffer(buf)) {
		// This is the slow version that will work with any Buffer
		// implementation (even in old browsers)
		var arrayCopy = new Uint8Array(buf.length)
		var len = buf.length
		for (var i = 0; i < len; i++) {
			arrayCopy[i] = buf[i]
		}
		return arrayCopy.buffer
	} else {
		throw new Error('Argument must be a Buffer')
	}
}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/url.js":
/*!*****************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/url.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.



var punycode = __webpack_require__(/*! punycode */ "../../common/temp/node_modules/.registry.npmjs.org/punycode/1.4.1/node_modules/punycode/punycode.js");
var util = __webpack_require__(/*! ./util */ "../../common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/util.js");

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = __webpack_require__(/*! querystring */ "../../common/temp/node_modules/.registry.npmjs.org/querystring-es3/0.2.1/node_modules/querystring-es3/index.js");

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/util.js":
/*!******************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/util.js ***!
  \******************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/util-deprecate/1.0.2/node_modules/util-deprecate/browser.js":
/*!******************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/util-deprecate/1.0.2/node_modules/util-deprecate/browser.js ***!
  \******************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {
/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom-parser.js":
/*!******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom-parser.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

function DOMParser(options){
	this.options = options ||{locator:{}};
	
}
DOMParser.prototype.parseFromString = function(source,mimeType){
	var options = this.options;
	var sax =  new XMLReader();
	var domBuilder = options.domBuilder || new DOMHandler();//contentHandler and LexicalHandler
	var errorHandler = options.errorHandler;
	var locator = options.locator;
	var defaultNSMap = options.xmlns||{};
	var entityMap = {'lt':'<','gt':'>','amp':'&','quot':'"','apos':"'"}
	if(locator){
		domBuilder.setDocumentLocator(locator)
	}
	
	sax.errorHandler = buildErrorHandler(errorHandler,domBuilder,locator);
	sax.domBuilder = options.domBuilder || domBuilder;
	if(/\/x?html?$/.test(mimeType)){
		entityMap.nbsp = '\xa0';
		entityMap.copy = '\xa9';
		defaultNSMap['']= 'http://www.w3.org/1999/xhtml';
	}
	defaultNSMap.xml = defaultNSMap.xml || 'http://www.w3.org/XML/1998/namespace';
	if(source){
		sax.parse(source,defaultNSMap,entityMap);
	}else{
		sax.errorHandler.error("invalid doc source");
	}
	return domBuilder.doc;
}
function buildErrorHandler(errorImpl,domBuilder,locator){
	if(!errorImpl){
		if(domBuilder instanceof DOMHandler){
			return domBuilder;
		}
		errorImpl = domBuilder ;
	}
	var errorHandler = {}
	var isCallback = errorImpl instanceof Function;
	locator = locator||{}
	function build(key){
		var fn = errorImpl[key];
		if(!fn && isCallback){
			fn = errorImpl.length == 2?function(msg){errorImpl(key,msg)}:errorImpl;
		}
		errorHandler[key] = fn && function(msg){
			fn('[xmldom '+key+']\t'+msg+_locator(locator));
		}||function(){};
	}
	build('warning');
	build('error');
	build('fatalError');
	return errorHandler;
}

//console.log('#\n\n\n\n\n\n\n####')
/**
 * +ContentHandler+ErrorHandler
 * +LexicalHandler+EntityResolver2
 * -DeclHandler-DTDHandler 
 * 
 * DefaultHandler:EntityResolver, DTDHandler, ContentHandler, ErrorHandler
 * DefaultHandler2:DefaultHandler,LexicalHandler, DeclHandler, EntityResolver2
 * @link http://www.saxproject.org/apidoc/org/xml/sax/helpers/DefaultHandler.html
 */
function DOMHandler() {
    this.cdata = false;
}
function position(locator,node){
	node.lineNumber = locator.lineNumber;
	node.columnNumber = locator.columnNumber;
}
/**
 * @see org.xml.sax.ContentHandler#startDocument
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ContentHandler.html
 */ 
DOMHandler.prototype = {
	startDocument : function() {
    	this.doc = new DOMImplementation().createDocument(null, null, null);
    	if (this.locator) {
        	this.doc.documentURI = this.locator.systemId;
    	}
	},
	startElement:function(namespaceURI, localName, qName, attrs) {
		var doc = this.doc;
	    var el = doc.createElementNS(namespaceURI, qName||localName);
	    var len = attrs.length;
	    appendElement(this, el);
	    this.currentElement = el;
	    
		this.locator && position(this.locator,el)
	    for (var i = 0 ; i < len; i++) {
	        var namespaceURI = attrs.getURI(i);
	        var value = attrs.getValue(i);
	        var qName = attrs.getQName(i);
			var attr = doc.createAttributeNS(namespaceURI, qName);
			this.locator &&position(attrs.getLocator(i),attr);
			attr.value = attr.nodeValue = value;
			el.setAttributeNode(attr)
	    }
	},
	endElement:function(namespaceURI, localName, qName) {
		var current = this.currentElement
		var tagName = current.tagName;
		this.currentElement = current.parentNode;
	},
	startPrefixMapping:function(prefix, uri) {
	},
	endPrefixMapping:function(prefix) {
	},
	processingInstruction:function(target, data) {
	    var ins = this.doc.createProcessingInstruction(target, data);
	    this.locator && position(this.locator,ins)
	    appendElement(this, ins);
	},
	ignorableWhitespace:function(ch, start, length) {
	},
	characters:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
		//console.log(chars)
		if(chars){
			if (this.cdata) {
				var charNode = this.doc.createCDATASection(chars);
			} else {
				var charNode = this.doc.createTextNode(chars);
			}
			if(this.currentElement){
				this.currentElement.appendChild(charNode);
			}else if(/^\s*$/.test(chars)){
				this.doc.appendChild(charNode);
				//process xml
			}
			this.locator && position(this.locator,charNode)
		}
	},
	skippedEntity:function(name) {
	},
	endDocument:function() {
		this.doc.normalize();
	},
	setDocumentLocator:function (locator) {
	    if(this.locator = locator){// && !('lineNumber' in locator)){
	    	locator.lineNumber = 0;
	    }
	},
	//LexicalHandler
	comment:function(chars, start, length) {
		chars = _toString.apply(this,arguments)
	    var comm = this.doc.createComment(chars);
	    this.locator && position(this.locator,comm)
	    appendElement(this, comm);
	},
	
	startCDATA:function() {
	    //used in characters() methods
	    this.cdata = true;
	},
	endCDATA:function() {
	    this.cdata = false;
	},
	
	startDTD:function(name, publicId, systemId) {
		var impl = this.doc.implementation;
	    if (impl && impl.createDocumentType) {
	        var dt = impl.createDocumentType(name, publicId, systemId);
	        this.locator && position(this.locator,dt)
	        appendElement(this, dt);
	    }
	},
	/**
	 * @see org.xml.sax.ErrorHandler
	 * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
	 */
	warning:function(error) {
		console.warn('[xmldom warning]\t'+error,_locator(this.locator));
	},
	error:function(error) {
		console.error('[xmldom error]\t'+error,_locator(this.locator));
	},
	fatalError:function(error) {
		console.error('[xmldom fatalError]\t'+error,_locator(this.locator));
	    throw error;
	}
}
function _locator(l){
	if(l){
		return '\n@'+(l.systemId ||'')+'#[line:'+l.lineNumber+',col:'+l.columnNumber+']'
	}
}
function _toString(chars,start,length){
	if(typeof chars == 'string'){
		return chars.substr(start,length)
	}else{//java sax connect width xmldom on rhino(what about: "? && !(chars instanceof String)")
		if(chars.length >= start+length || start){
			return new java.lang.String(chars,start,length)+'';
		}
		return chars;
	}
}

/*
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/LexicalHandler.html
 * used method of org.xml.sax.ext.LexicalHandler:
 *  #comment(chars, start, length)
 *  #startCDATA()
 *  #endCDATA()
 *  #startDTD(name, publicId, systemId)
 *
 *
 * IGNORED method of org.xml.sax.ext.LexicalHandler:
 *  #endDTD()
 *  #startEntity(name)
 *  #endEntity(name)
 *
 *
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/DeclHandler.html
 * IGNORED method of org.xml.sax.ext.DeclHandler
 * 	#attributeDecl(eName, aName, type, mode, value)
 *  #elementDecl(name, model)
 *  #externalEntityDecl(name, publicId, systemId)
 *  #internalEntityDecl(name, value)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/ext/EntityResolver2.html
 * IGNORED method of org.xml.sax.EntityResolver2
 *  #resolveEntity(String name,String publicId,String baseURI,String systemId)
 *  #resolveEntity(publicId, systemId)
 *  #getExternalSubset(name, baseURI)
 * @link http://www.saxproject.org/apidoc/org/xml/sax/DTDHandler.html
 * IGNORED method of org.xml.sax.DTDHandler
 *  #notationDecl(name, publicId, systemId) {};
 *  #unparsedEntityDecl(name, publicId, systemId, notationName) {};
 */
"endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g,function(key){
	DOMHandler.prototype[key] = function(){return null}
})

/* Private static helpers treated below as private instance methods, so don't need to add these to the public API; we might use a Relator to also get rid of non-standard public properties */
function appendElement (hander,node) {
    if (!hander.currentElement) {
        hander.doc.appendChild(node);
    } else {
        hander.currentElement.appendChild(node);
    }
}//appendChild and setAttributeNS are preformance key

//if(typeof require == 'function'){
	var XMLReader = __webpack_require__(/*! ./sax */ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/sax.js").XMLReader;
	var DOMImplementation = exports.DOMImplementation = __webpack_require__(/*! ./dom */ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom.js").DOMImplementation;
	exports.XMLSerializer = __webpack_require__(/*! ./dom */ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom.js").XMLSerializer ;
	exports.DOMParser = DOMParser;
//}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom.js":
/*!***********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
 * DOM Level 2
 * Object DOMException
 * @see http://www.w3.org/TR/REC-DOM-Level-1/ecma-script-language-binding.html
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/ecma-script-binding.html
 */

function copy(src,dest){
	for(var p in src){
		dest[p] = src[p];
	}
}
/**
^\w+\.prototype\.([_\w]+)\s*=\s*((?:.*\{\s*?[\r\n][\s\S]*?^})|\S.*?(?=[;\r\n]));?
^\w+\.prototype\.([_\w]+)\s*=\s*(\S.*?(?=[;\r\n]));?
 */
function _extends(Class,Super){
	var pt = Class.prototype;
	if(Object.create){
		var ppt = Object.create(Super.prototype)
		pt.__proto__ = ppt;
	}
	if(!(pt instanceof Super)){
		function t(){};
		t.prototype = Super.prototype;
		t = new t();
		copy(pt,t);
		Class.prototype = pt = t;
	}
	if(pt.constructor != Class){
		if(typeof Class != 'function'){
			console.error("unknow Class:"+Class)
		}
		pt.constructor = Class
	}
}
var htmlns = 'http://www.w3.org/1999/xhtml' ;
// Node Types
var NodeType = {}
var ELEMENT_NODE                = NodeType.ELEMENT_NODE                = 1;
var ATTRIBUTE_NODE              = NodeType.ATTRIBUTE_NODE              = 2;
var TEXT_NODE                   = NodeType.TEXT_NODE                   = 3;
var CDATA_SECTION_NODE          = NodeType.CDATA_SECTION_NODE          = 4;
var ENTITY_REFERENCE_NODE       = NodeType.ENTITY_REFERENCE_NODE       = 5;
var ENTITY_NODE                 = NodeType.ENTITY_NODE                 = 6;
var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
var COMMENT_NODE                = NodeType.COMMENT_NODE                = 8;
var DOCUMENT_NODE               = NodeType.DOCUMENT_NODE               = 9;
var DOCUMENT_TYPE_NODE          = NodeType.DOCUMENT_TYPE_NODE          = 10;
var DOCUMENT_FRAGMENT_NODE      = NodeType.DOCUMENT_FRAGMENT_NODE      = 11;
var NOTATION_NODE               = NodeType.NOTATION_NODE               = 12;

// ExceptionCode
var ExceptionCode = {}
var ExceptionMessage = {};
var INDEX_SIZE_ERR              = ExceptionCode.INDEX_SIZE_ERR              = ((ExceptionMessage[1]="Index size error"),1);
var DOMSTRING_SIZE_ERR          = ExceptionCode.DOMSTRING_SIZE_ERR          = ((ExceptionMessage[2]="DOMString size error"),2);
var HIERARCHY_REQUEST_ERR       = ExceptionCode.HIERARCHY_REQUEST_ERR       = ((ExceptionMessage[3]="Hierarchy request error"),3);
var WRONG_DOCUMENT_ERR          = ExceptionCode.WRONG_DOCUMENT_ERR          = ((ExceptionMessage[4]="Wrong document"),4);
var INVALID_CHARACTER_ERR       = ExceptionCode.INVALID_CHARACTER_ERR       = ((ExceptionMessage[5]="Invalid character"),5);
var NO_DATA_ALLOWED_ERR         = ExceptionCode.NO_DATA_ALLOWED_ERR         = ((ExceptionMessage[6]="No data allowed"),6);
var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = ((ExceptionMessage[7]="No modification allowed"),7);
var NOT_FOUND_ERR               = ExceptionCode.NOT_FOUND_ERR               = ((ExceptionMessage[8]="Not found"),8);
var NOT_SUPPORTED_ERR           = ExceptionCode.NOT_SUPPORTED_ERR           = ((ExceptionMessage[9]="Not supported"),9);
var INUSE_ATTRIBUTE_ERR         = ExceptionCode.INUSE_ATTRIBUTE_ERR         = ((ExceptionMessage[10]="Attribute in use"),10);
//level2
var INVALID_STATE_ERR        	= ExceptionCode.INVALID_STATE_ERR        	= ((ExceptionMessage[11]="Invalid state"),11);
var SYNTAX_ERR               	= ExceptionCode.SYNTAX_ERR               	= ((ExceptionMessage[12]="Syntax error"),12);
var INVALID_MODIFICATION_ERR 	= ExceptionCode.INVALID_MODIFICATION_ERR 	= ((ExceptionMessage[13]="Invalid modification"),13);
var NAMESPACE_ERR            	= ExceptionCode.NAMESPACE_ERR           	= ((ExceptionMessage[14]="Invalid namespace"),14);
var INVALID_ACCESS_ERR       	= ExceptionCode.INVALID_ACCESS_ERR      	= ((ExceptionMessage[15]="Invalid access"),15);


function DOMException(code, message) {
	if(message instanceof Error){
		var error = message;
	}else{
		error = this;
		Error.call(this, ExceptionMessage[code]);
		this.message = ExceptionMessage[code];
		if(Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
	}
	error.code = code;
	if(message) this.message = this.message + ": " + message;
	return error;
};
DOMException.prototype = Error.prototype;
copy(ExceptionCode,DOMException)
/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-536297177
 * The NodeList interface provides the abstraction of an ordered collection of nodes, without defining or constraining how this collection is implemented. NodeList objects in the DOM are live.
 * The items in the NodeList are accessible via an integral index, starting from 0.
 */
function NodeList() {
};
NodeList.prototype = {
	/**
	 * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
	 * @standard level1
	 */
	length:0, 
	/**
	 * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
	 * @standard level1
	 * @param index  unsigned long 
	 *   Index into the collection.
	 * @return Node
	 * 	The node at the indexth position in the NodeList, or null if that is not a valid index. 
	 */
	item: function(index) {
		return this[index] || null;
	},
	toString:function(isHTML,nodeFilter){
		for(var buf = [], i = 0;i<this.length;i++){
			serializeToString(this[i],buf,isHTML,nodeFilter);
		}
		return buf.join('');
	}
};
function LiveNodeList(node,refresh){
	this._node = node;
	this._refresh = refresh
	_updateLiveList(this);
}
function _updateLiveList(list){
	var inc = list._node._inc || list._node.ownerDocument._inc;
	if(list._inc != inc){
		var ls = list._refresh(list._node);
		//console.log(ls.length)
		__set__(list,'length',ls.length);
		copy(ls,list);
		list._inc = inc;
	}
}
LiveNodeList.prototype.item = function(i){
	_updateLiveList(this);
	return this[i];
}

_extends(LiveNodeList,NodeList);
/**
 * 
 * Objects implementing the NamedNodeMap interface are used to represent collections of nodes that can be accessed by name. Note that NamedNodeMap does not inherit from NodeList; NamedNodeMaps are not maintained in any particular order. Objects contained in an object implementing NamedNodeMap may also be accessed by an ordinal index, but this is simply to allow convenient enumeration of the contents of a NamedNodeMap, and does not imply that the DOM specifies an order to these Nodes.
 * NamedNodeMap objects in the DOM are live.
 * used for attributes or DocumentType entities 
 */
function NamedNodeMap() {
};

function _findNodeIndex(list,node){
	var i = list.length;
	while(i--){
		if(list[i] === node){return i}
	}
}

function _addNamedNode(el,list,newAttr,oldAttr){
	if(oldAttr){
		list[_findNodeIndex(list,oldAttr)] = newAttr;
	}else{
		list[list.length++] = newAttr;
	}
	if(el){
		newAttr.ownerElement = el;
		var doc = el.ownerDocument;
		if(doc){
			oldAttr && _onRemoveAttribute(doc,el,oldAttr);
			_onAddAttribute(doc,el,newAttr);
		}
	}
}
function _removeNamedNode(el,list,attr){
	//console.log('remove attr:'+attr)
	var i = _findNodeIndex(list,attr);
	if(i>=0){
		var lastIndex = list.length-1
		while(i<lastIndex){
			list[i] = list[++i]
		}
		list.length = lastIndex;
		if(el){
			var doc = el.ownerDocument;
			if(doc){
				_onRemoveAttribute(doc,el,attr);
				attr.ownerElement = null;
			}
		}
	}else{
		throw DOMException(NOT_FOUND_ERR,new Error(el.tagName+'@'+attr))
	}
}
NamedNodeMap.prototype = {
	length:0,
	item:NodeList.prototype.item,
	getNamedItem: function(key) {
//		if(key.indexOf(':')>0 || key == 'xmlns'){
//			return null;
//		}
		//console.log()
		var i = this.length;
		while(i--){
			var attr = this[i];
			//console.log(attr.nodeName,key)
			if(attr.nodeName == key){
				return attr;
			}
		}
	},
	setNamedItem: function(attr) {
		var el = attr.ownerElement;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		var oldAttr = this.getNamedItem(attr.nodeName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},
	/* returns Node */
	setNamedItemNS: function(attr) {// raises: WRONG_DOCUMENT_ERR,NO_MODIFICATION_ALLOWED_ERR,INUSE_ATTRIBUTE_ERR
		var el = attr.ownerElement, oldAttr;
		if(el && el!=this._ownerElement){
			throw new DOMException(INUSE_ATTRIBUTE_ERR);
		}
		oldAttr = this.getNamedItemNS(attr.namespaceURI,attr.localName);
		_addNamedNode(this._ownerElement,this,attr,oldAttr);
		return oldAttr;
	},

	/* returns Node */
	removeNamedItem: function(key) {
		var attr = this.getNamedItem(key);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
		
		
	},// raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
	
	//for level2
	removeNamedItemNS:function(namespaceURI,localName){
		var attr = this.getNamedItemNS(namespaceURI,localName);
		_removeNamedNode(this._ownerElement,this,attr);
		return attr;
	},
	getNamedItemNS: function(namespaceURI, localName) {
		var i = this.length;
		while(i--){
			var node = this[i];
			if(node.localName == localName && node.namespaceURI == namespaceURI){
				return node;
			}
		}
		return null;
	}
};
/**
 * @see http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-102161490
 */
function DOMImplementation(/* Object */ features) {
	this._features = {};
	if (features) {
		for (var feature in features) {
			 this._features = features[feature];
		}
	}
};

DOMImplementation.prototype = {
	hasFeature: function(/* string */ feature, /* string */ version) {
		var versions = this._features[feature.toLowerCase()];
		if (versions && (!version || version in versions)) {
			return true;
		} else {
			return false;
		}
	},
	// Introduced in DOM Level 2:
	createDocument:function(namespaceURI,  qualifiedName, doctype){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR,WRONG_DOCUMENT_ERR
		var doc = new Document();
		doc.implementation = this;
		doc.childNodes = new NodeList();
		doc.doctype = doctype;
		if(doctype){
			doc.appendChild(doctype);
		}
		if(qualifiedName){
			var root = doc.createElementNS(namespaceURI,qualifiedName);
			doc.appendChild(root);
		}
		return doc;
	},
	// Introduced in DOM Level 2:
	createDocumentType:function(qualifiedName, publicId, systemId){// raises:INVALID_CHARACTER_ERR,NAMESPACE_ERR
		var node = new DocumentType();
		node.name = qualifiedName;
		node.nodeName = qualifiedName;
		node.publicId = publicId;
		node.systemId = systemId;
		// Introduced in DOM Level 2:
		//readonly attribute DOMString        internalSubset;
		
		//TODO:..
		//  readonly attribute NamedNodeMap     entities;
		//  readonly attribute NamedNodeMap     notations;
		return node;
	}
};


/**
 * @see http://www.w3.org/TR/2000/REC-DOM-Level-2-Core-20001113/core.html#ID-1950641247
 */

function Node() {
};

Node.prototype = {
	firstChild : null,
	lastChild : null,
	previousSibling : null,
	nextSibling : null,
	attributes : null,
	parentNode : null,
	childNodes : null,
	ownerDocument : null,
	nodeValue : null,
	namespaceURI : null,
	prefix : null,
	localName : null,
	// Modified in DOM Level 2:
	insertBefore:function(newChild, refChild){//raises 
		return _insertBefore(this,newChild,refChild);
	},
	replaceChild:function(newChild, oldChild){//raises 
		this.insertBefore(newChild,oldChild);
		if(oldChild){
			this.removeChild(oldChild);
		}
	},
	removeChild:function(oldChild){
		return _removeChild(this,oldChild);
	},
	appendChild:function(newChild){
		return this.insertBefore(newChild,null);
	},
	hasChildNodes:function(){
		return this.firstChild != null;
	},
	cloneNode:function(deep){
		return cloneNode(this.ownerDocument||this,this,deep);
	},
	// Modified in DOM Level 2:
	normalize:function(){
		var child = this.firstChild;
		while(child){
			var next = child.nextSibling;
			if(next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE){
				this.removeChild(next);
				child.appendData(next.data);
			}else{
				child.normalize();
				child = next;
			}
		}
	},
  	// Introduced in DOM Level 2:
	isSupported:function(feature, version){
		return this.ownerDocument.implementation.hasFeature(feature,version);
	},
    // Introduced in DOM Level 2:
    hasAttributes:function(){
    	return this.attributes.length>0;
    },
    lookupPrefix:function(namespaceURI){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			for(var n in map){
    				if(map[n] == namespaceURI){
    					return n;
    				}
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    lookupNamespaceURI:function(prefix){
    	var el = this;
    	while(el){
    		var map = el._nsMap;
    		//console.dir(map)
    		if(map){
    			if(prefix in map){
    				return map[prefix] ;
    			}
    		}
    		el = el.nodeType == ATTRIBUTE_NODE?el.ownerDocument : el.parentNode;
    	}
    	return null;
    },
    // Introduced in DOM Level 3:
    isDefaultNamespace:function(namespaceURI){
    	var prefix = this.lookupPrefix(namespaceURI);
    	return prefix == null;
    }
};


function _xmlEncoder(c){
	return c == '<' && '&lt;' ||
         c == '>' && '&gt;' ||
         c == '&' && '&amp;' ||
         c == '"' && '&quot;' ||
         '&#'+c.charCodeAt()+';'
}


copy(NodeType,Node);
copy(NodeType,Node.prototype);

/**
 * @param callback return true for continue,false for break
 * @return boolean true: break visit;
 */
function _visitNode(node,callback){
	if(callback(node)){
		return true;
	}
	if(node = node.firstChild){
		do{
			if(_visitNode(node,callback)){return true}
        }while(node=node.nextSibling)
    }
}



function Document(){
}
function _onAddAttribute(doc,el,newAttr){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		el._nsMap[newAttr.prefix?newAttr.localName:''] = newAttr.value
	}
}
function _onRemoveAttribute(doc,el,newAttr,remove){
	doc && doc._inc++;
	var ns = newAttr.namespaceURI ;
	if(ns == 'http://www.w3.org/2000/xmlns/'){
		//update namespace
		delete el._nsMap[newAttr.prefix?newAttr.localName:'']
	}
}
function _onUpdateChild(doc,el,newChild){
	if(doc && doc._inc){
		doc._inc++;
		//update childNodes
		var cs = el.childNodes;
		if(newChild){
			cs[cs.length++] = newChild;
		}else{
			//console.log(1)
			var child = el.firstChild;
			var i = 0;
			while(child){
				cs[i++] = child;
				child =child.nextSibling;
			}
			cs.length = i;
		}
	}
}

/**
 * attributes;
 * children;
 * 
 * writeable properties:
 * nodeValue,Attr:value,CharacterData:data
 * prefix
 */
function _removeChild(parentNode,child){
	var previous = child.previousSibling;
	var next = child.nextSibling;
	if(previous){
		previous.nextSibling = next;
	}else{
		parentNode.firstChild = next
	}
	if(next){
		next.previousSibling = previous;
	}else{
		parentNode.lastChild = previous;
	}
	_onUpdateChild(parentNode.ownerDocument,parentNode);
	return child;
}
/**
 * preformance key(refChild == null)
 */
function _insertBefore(parentNode,newChild,nextChild){
	var cp = newChild.parentNode;
	if(cp){
		cp.removeChild(newChild);//remove and update
	}
	if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
		var newFirst = newChild.firstChild;
		if (newFirst == null) {
			return newChild;
		}
		var newLast = newChild.lastChild;
	}else{
		newFirst = newLast = newChild;
	}
	var pre = nextChild ? nextChild.previousSibling : parentNode.lastChild;

	newFirst.previousSibling = pre;
	newLast.nextSibling = nextChild;
	
	
	if(pre){
		pre.nextSibling = newFirst;
	}else{
		parentNode.firstChild = newFirst;
	}
	if(nextChild == null){
		parentNode.lastChild = newLast;
	}else{
		nextChild.previousSibling = newLast;
	}
	do{
		newFirst.parentNode = parentNode;
	}while(newFirst !== newLast && (newFirst= newFirst.nextSibling))
	_onUpdateChild(parentNode.ownerDocument||parentNode,parentNode);
	//console.log(parentNode.lastChild.nextSibling == null)
	if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
		newChild.firstChild = newChild.lastChild = null;
	}
	return newChild;
}
function _appendSingleChild(parentNode,newChild){
	var cp = newChild.parentNode;
	if(cp){
		var pre = parentNode.lastChild;
		cp.removeChild(newChild);//remove and update
		var pre = parentNode.lastChild;
	}
	var pre = parentNode.lastChild;
	newChild.parentNode = parentNode;
	newChild.previousSibling = pre;
	newChild.nextSibling = null;
	if(pre){
		pre.nextSibling = newChild;
	}else{
		parentNode.firstChild = newChild;
	}
	parentNode.lastChild = newChild;
	_onUpdateChild(parentNode.ownerDocument,parentNode,newChild);
	return newChild;
	//console.log("__aa",parentNode.lastChild.nextSibling == null)
}
Document.prototype = {
	//implementation : null,
	nodeName :  '#document',
	nodeType :  DOCUMENT_NODE,
	doctype :  null,
	documentElement :  null,
	_inc : 1,
	
	insertBefore :  function(newChild, refChild){//raises 
		if(newChild.nodeType == DOCUMENT_FRAGMENT_NODE){
			var child = newChild.firstChild;
			while(child){
				var next = child.nextSibling;
				this.insertBefore(child,refChild);
				child = next;
			}
			return newChild;
		}
		if(this.documentElement == null && newChild.nodeType == ELEMENT_NODE){
			this.documentElement = newChild;
		}
		
		return _insertBefore(this,newChild,refChild),(newChild.ownerDocument = this),newChild;
	},
	removeChild :  function(oldChild){
		if(this.documentElement == oldChild){
			this.documentElement = null;
		}
		return _removeChild(this,oldChild);
	},
	// Introduced in DOM Level 2:
	importNode : function(importedNode,deep){
		return importNode(this,importedNode,deep);
	},
	// Introduced in DOM Level 2:
	getElementById :	function(id){
		var rtv = null;
		_visitNode(this.documentElement,function(node){
			if(node.nodeType == ELEMENT_NODE){
				if(node.getAttribute('id') == id){
					rtv = node;
					return true;
				}
			}
		})
		return rtv;
	},
	
	//document factory method:
	createElement :	function(tagName){
		var node = new Element();
		node.ownerDocument = this;
		node.nodeName = tagName;
		node.tagName = tagName;
		node.childNodes = new NodeList();
		var attrs	= node.attributes = new NamedNodeMap();
		attrs._ownerElement = node;
		return node;
	},
	createDocumentFragment :	function(){
		var node = new DocumentFragment();
		node.ownerDocument = this;
		node.childNodes = new NodeList();
		return node;
	},
	createTextNode :	function(data){
		var node = new Text();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createComment :	function(data){
		var node = new Comment();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createCDATASection :	function(data){
		var node = new CDATASection();
		node.ownerDocument = this;
		node.appendData(data)
		return node;
	},
	createProcessingInstruction :	function(target,data){
		var node = new ProcessingInstruction();
		node.ownerDocument = this;
		node.tagName = node.target = target;
		node.nodeValue= node.data = data;
		return node;
	},
	createAttribute :	function(name){
		var node = new Attr();
		node.ownerDocument	= this;
		node.name = name;
		node.nodeName	= name;
		node.localName = name;
		node.specified = true;
		return node;
	},
	createEntityReference :	function(name){
		var node = new EntityReference();
		node.ownerDocument	= this;
		node.nodeName	= name;
		return node;
	},
	// Introduced in DOM Level 2:
	createElementNS :	function(namespaceURI,qualifiedName){
		var node = new Element();
		var pl = qualifiedName.split(':');
		var attrs	= node.attributes = new NamedNodeMap();
		node.childNodes = new NodeList();
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.tagName = qualifiedName;
		node.namespaceURI = namespaceURI;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		attrs._ownerElement = node;
		return node;
	},
	// Introduced in DOM Level 2:
	createAttributeNS :	function(namespaceURI,qualifiedName){
		var node = new Attr();
		var pl = qualifiedName.split(':');
		node.ownerDocument = this;
		node.nodeName = qualifiedName;
		node.name = qualifiedName;
		node.namespaceURI = namespaceURI;
		node.specified = true;
		if(pl.length == 2){
			node.prefix = pl[0];
			node.localName = pl[1];
		}else{
			//el.prefix = null;
			node.localName = qualifiedName;
		}
		return node;
	}
};
_extends(Document,Node);


function Element() {
	this._nsMap = {};
};
Element.prototype = {
	nodeType : ELEMENT_NODE,
	hasAttribute : function(name){
		return this.getAttributeNode(name)!=null;
	},
	getAttribute : function(name){
		var attr = this.getAttributeNode(name);
		return attr && attr.value || '';
	},
	getAttributeNode : function(name){
		return this.attributes.getNamedItem(name);
	},
	setAttribute : function(name, value){
		var attr = this.ownerDocument.createAttribute(name);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	removeAttribute : function(name){
		var attr = this.getAttributeNode(name)
		attr && this.removeAttributeNode(attr);
	},
	
	//four real opeartion method
	appendChild:function(newChild){
		if(newChild.nodeType === DOCUMENT_FRAGMENT_NODE){
			return this.insertBefore(newChild,null);
		}else{
			return _appendSingleChild(this,newChild);
		}
	},
	setAttributeNode : function(newAttr){
		return this.attributes.setNamedItem(newAttr);
	},
	setAttributeNodeNS : function(newAttr){
		return this.attributes.setNamedItemNS(newAttr);
	},
	removeAttributeNode : function(oldAttr){
		//console.log(this == oldAttr.ownerElement)
		return this.attributes.removeNamedItem(oldAttr.nodeName);
	},
	//get real attribute name,and remove it by removeAttributeNode
	removeAttributeNS : function(namespaceURI, localName){
		var old = this.getAttributeNodeNS(namespaceURI, localName);
		old && this.removeAttributeNode(old);
	},
	
	hasAttributeNS : function(namespaceURI, localName){
		return this.getAttributeNodeNS(namespaceURI, localName)!=null;
	},
	getAttributeNS : function(namespaceURI, localName){
		var attr = this.getAttributeNodeNS(namespaceURI, localName);
		return attr && attr.value || '';
	},
	setAttributeNS : function(namespaceURI, qualifiedName, value){
		var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
		attr.value = attr.nodeValue = "" + value;
		this.setAttributeNode(attr)
	},
	getAttributeNodeNS : function(namespaceURI, localName){
		return this.attributes.getNamedItemNS(namespaceURI, localName);
	},
	
	getElementsByTagName : function(tagName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType == ELEMENT_NODE && (tagName === '*' || node.tagName == tagName)){
					ls.push(node);
				}
			});
			return ls;
		});
	},
	getElementsByTagNameNS : function(namespaceURI, localName){
		return new LiveNodeList(this,function(base){
			var ls = [];
			_visitNode(base,function(node){
				if(node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === '*' || node.namespaceURI === namespaceURI) && (localName === '*' || node.localName == localName)){
					ls.push(node);
				}
			});
			return ls;
			
		});
	}
};
Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;


_extends(Element,Node);
function Attr() {
};
Attr.prototype.nodeType = ATTRIBUTE_NODE;
_extends(Attr,Node);


function CharacterData() {
};
CharacterData.prototype = {
	data : '',
	substringData : function(offset, count) {
		return this.data.substring(offset, offset+count);
	},
	appendData: function(text) {
		text = this.data+text;
		this.nodeValue = this.data = text;
		this.length = text.length;
	},
	insertData: function(offset,text) {
		this.replaceData(offset,0,text);
	
	},
	appendChild:function(newChild){
		throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR])
	},
	deleteData: function(offset, count) {
		this.replaceData(offset,count,"");
	},
	replaceData: function(offset, count, text) {
		var start = this.data.substring(0,offset);
		var end = this.data.substring(offset+count);
		text = start + text + end;
		this.nodeValue = this.data = text;
		this.length = text.length;
	}
}
_extends(CharacterData,Node);
function Text() {
};
Text.prototype = {
	nodeName : "#text",
	nodeType : TEXT_NODE,
	splitText : function(offset) {
		var text = this.data;
		var newText = text.substring(offset);
		text = text.substring(0, offset);
		this.data = this.nodeValue = text;
		this.length = text.length;
		var newNode = this.ownerDocument.createTextNode(newText);
		if(this.parentNode){
			this.parentNode.insertBefore(newNode, this.nextSibling);
		}
		return newNode;
	}
}
_extends(Text,CharacterData);
function Comment() {
};
Comment.prototype = {
	nodeName : "#comment",
	nodeType : COMMENT_NODE
}
_extends(Comment,CharacterData);

function CDATASection() {
};
CDATASection.prototype = {
	nodeName : "#cdata-section",
	nodeType : CDATA_SECTION_NODE
}
_extends(CDATASection,CharacterData);


function DocumentType() {
};
DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
_extends(DocumentType,Node);

function Notation() {
};
Notation.prototype.nodeType = NOTATION_NODE;
_extends(Notation,Node);

function Entity() {
};
Entity.prototype.nodeType = ENTITY_NODE;
_extends(Entity,Node);

function EntityReference() {
};
EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
_extends(EntityReference,Node);

function DocumentFragment() {
};
DocumentFragment.prototype.nodeName =	"#document-fragment";
DocumentFragment.prototype.nodeType =	DOCUMENT_FRAGMENT_NODE;
_extends(DocumentFragment,Node);


function ProcessingInstruction() {
}
ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
_extends(ProcessingInstruction,Node);
function XMLSerializer(){}
XMLSerializer.prototype.serializeToString = function(node,isHtml,nodeFilter){
	return nodeSerializeToString.call(node,isHtml,nodeFilter);
}
Node.prototype.toString = nodeSerializeToString;
function nodeSerializeToString(isHtml,nodeFilter){
	var buf = [];
	var refNode = this.nodeType == 9?this.documentElement:this;
	var prefix = refNode.prefix;
	var uri = refNode.namespaceURI;
	
	if(uri && prefix == null){
		//console.log(prefix)
		var prefix = refNode.lookupPrefix(uri);
		if(prefix == null){
			//isHTML = true;
			var visibleNamespaces=[
			{namespace:uri,prefix:null}
			//{namespace:uri,prefix:''}
			]
		}
	}
	serializeToString(this,buf,isHtml,nodeFilter,visibleNamespaces);
	//console.log('###',this.nodeType,uri,prefix,buf.join(''))
	return buf.join('');
}
function needNamespaceDefine(node,isHTML, visibleNamespaces) {
	var prefix = node.prefix||'';
	var uri = node.namespaceURI;
	if (!prefix && !uri){
		return false;
	}
	if (prefix === "xml" && uri === "http://www.w3.org/XML/1998/namespace" 
		|| uri == 'http://www.w3.org/2000/xmlns/'){
		return false;
	}
	
	var i = visibleNamespaces.length 
	//console.log('@@@@',node.tagName,prefix,uri,visibleNamespaces)
	while (i--) {
		var ns = visibleNamespaces[i];
		// get namespace prefix
		//console.log(node.nodeType,node.tagName,ns.prefix,prefix)
		if (ns.prefix == prefix){
			return ns.namespace != uri;
		}
	}
	//console.log(isHTML,uri,prefix=='')
	//if(isHTML && prefix ==null && uri == 'http://www.w3.org/1999/xhtml'){
	//	return false;
	//}
	//node.flag = '11111'
	//console.error(3,true,node.flag,node.prefix,node.namespaceURI)
	return true;
}
function serializeToString(node,buf,isHTML,nodeFilter,visibleNamespaces){
	if(nodeFilter){
		node = nodeFilter(node);
		if(node){
			if(typeof node == 'string'){
				buf.push(node);
				return;
			}
		}else{
			return;
		}
		//buf.sort.apply(attrs, attributeSorter);
	}
	switch(node.nodeType){
	case ELEMENT_NODE:
		if (!visibleNamespaces) visibleNamespaces = [];
		var startVisibleNamespaces = visibleNamespaces.length;
		var attrs = node.attributes;
		var len = attrs.length;
		var child = node.firstChild;
		var nodeName = node.tagName;
		
		isHTML =  (htmlns === node.namespaceURI) ||isHTML 
		buf.push('<',nodeName);
		
		
		
		for(var i=0;i<len;i++){
			// add namespaces for attributes
			var attr = attrs.item(i);
			if (attr.prefix == 'xmlns') {
				visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
			}else if(attr.nodeName == 'xmlns'){
				visibleNamespaces.push({ prefix: '', namespace: attr.value });
			}
		}
		for(var i=0;i<len;i++){
			var attr = attrs.item(i);
			if (needNamespaceDefine(attr,isHTML, visibleNamespaces)) {
				var prefix = attr.prefix||'';
				var uri = attr.namespaceURI;
				var ns = prefix ? ' xmlns:' + prefix : " xmlns";
				buf.push(ns, '="' , uri , '"');
				visibleNamespaces.push({ prefix: prefix, namespace:uri });
			}
			serializeToString(attr,buf,isHTML,nodeFilter,visibleNamespaces);
		}
		// add namespace for current node		
		if (needNamespaceDefine(node,isHTML, visibleNamespaces)) {
			var prefix = node.prefix||'';
			var uri = node.namespaceURI;
			var ns = prefix ? ' xmlns:' + prefix : " xmlns";
			buf.push(ns, '="' , uri , '"');
			visibleNamespaces.push({ prefix: prefix, namespace:uri });
		}
		
		if(child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)){
			buf.push('>');
			//if is cdata child node
			if(isHTML && /^script$/i.test(nodeName)){
				while(child){
					if(child.data){
						buf.push(child.data);
					}else{
						serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					}
					child = child.nextSibling;
				}
			}else
			{
				while(child){
					serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
					child = child.nextSibling;
				}
			}
			buf.push('</',nodeName,'>');
		}else{
			buf.push('/>');
		}
		// remove added visible namespaces
		//visibleNamespaces.length = startVisibleNamespaces;
		return;
	case DOCUMENT_NODE:
	case DOCUMENT_FRAGMENT_NODE:
		var child = node.firstChild;
		while(child){
			serializeToString(child,buf,isHTML,nodeFilter,visibleNamespaces);
			child = child.nextSibling;
		}
		return;
	case ATTRIBUTE_NODE:
		return buf.push(' ',node.name,'="',node.value.replace(/[<&"]/g,_xmlEncoder),'"');
	case TEXT_NODE:
		return buf.push(node.data.replace(/[<&]/g,_xmlEncoder));
	case CDATA_SECTION_NODE:
		return buf.push( '<![CDATA[',node.data,']]>');
	case COMMENT_NODE:
		return buf.push( "<!--",node.data,"-->");
	case DOCUMENT_TYPE_NODE:
		var pubid = node.publicId;
		var sysid = node.systemId;
		buf.push('<!DOCTYPE ',node.name);
		if(pubid){
			buf.push(' PUBLIC "',pubid);
			if (sysid && sysid!='.') {
				buf.push( '" "',sysid);
			}
			buf.push('">');
		}else if(sysid && sysid!='.'){
			buf.push(' SYSTEM "',sysid,'">');
		}else{
			var sub = node.internalSubset;
			if(sub){
				buf.push(" [",sub,"]");
			}
			buf.push(">");
		}
		return;
	case PROCESSING_INSTRUCTION_NODE:
		return buf.push( "<?",node.target," ",node.data,"?>");
	case ENTITY_REFERENCE_NODE:
		return buf.push( '&',node.nodeName,';');
	//case ENTITY_NODE:
	//case NOTATION_NODE:
	default:
		buf.push('??',node.nodeName);
	}
}
function importNode(doc,node,deep){
	var node2;
	switch (node.nodeType) {
	case ELEMENT_NODE:
		node2 = node.cloneNode(false);
		node2.ownerDocument = doc;
		//var attrs = node2.attributes;
		//var len = attrs.length;
		//for(var i=0;i<len;i++){
			//node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
		//}
	case DOCUMENT_FRAGMENT_NODE:
		break;
	case ATTRIBUTE_NODE:
		deep = true;
		break;
	//case ENTITY_REFERENCE_NODE:
	//case PROCESSING_INSTRUCTION_NODE:
	////case TEXT_NODE:
	//case CDATA_SECTION_NODE:
	//case COMMENT_NODE:
	//	deep = false;
	//	break;
	//case DOCUMENT_NODE:
	//case DOCUMENT_TYPE_NODE:
	//cannot be imported.
	//case ENTITY_NODE:
	//case NOTATION_NODE：
	//can not hit in level3
	//default:throw e;
	}
	if(!node2){
		node2 = node.cloneNode(false);//false
	}
	node2.ownerDocument = doc;
	node2.parentNode = null;
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(importNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}
//
//var _relationMap = {firstChild:1,lastChild:1,previousSibling:1,nextSibling:1,
//					attributes:1,childNodes:1,parentNode:1,documentElement:1,doctype,};
function cloneNode(doc,node,deep){
	var node2 = new node.constructor();
	for(var n in node){
		var v = node[n];
		if(typeof v != 'object' ){
			if(v != node2[n]){
				node2[n] = v;
			}
		}
	}
	if(node.childNodes){
		node2.childNodes = new NodeList();
	}
	node2.ownerDocument = doc;
	switch (node2.nodeType) {
	case ELEMENT_NODE:
		var attrs	= node.attributes;
		var attrs2	= node2.attributes = new NamedNodeMap();
		var len = attrs.length
		attrs2._ownerElement = node2;
		for(var i=0;i<len;i++){
			node2.setAttributeNode(cloneNode(doc,attrs.item(i),true));
		}
		break;;
	case ATTRIBUTE_NODE:
		deep = true;
	}
	if(deep){
		var child = node.firstChild;
		while(child){
			node2.appendChild(cloneNode(doc,child,deep));
			child = child.nextSibling;
		}
	}
	return node2;
}

function __set__(object,key,value){
	object[key] = value
}
//do dynamic
try{
	if(Object.defineProperty){
		Object.defineProperty(LiveNodeList.prototype,'length',{
			get:function(){
				_updateLiveList(this);
				return this.$$length;
			}
		});
		Object.defineProperty(Node.prototype,'textContent',{
			get:function(){
				return getTextContent(this);
			},
			set:function(data){
				switch(this.nodeType){
				case ELEMENT_NODE:
				case DOCUMENT_FRAGMENT_NODE:
					while(this.firstChild){
						this.removeChild(this.firstChild);
					}
					if(data || String(data)){
						this.appendChild(this.ownerDocument.createTextNode(data));
					}
					break;
				default:
					//TODO:
					this.data = data;
					this.value = data;
					this.nodeValue = data;
				}
			}
		})
		
		function getTextContent(node){
			switch(node.nodeType){
			case ELEMENT_NODE:
			case DOCUMENT_FRAGMENT_NODE:
				var buf = [];
				node = node.firstChild;
				while(node){
					if(node.nodeType!==7 && node.nodeType !==8){
						buf.push(getTextContent(node));
					}
					node = node.nextSibling;
				}
				return buf.join('');
			default:
				return node.nodeValue;
			}
		}
		__set__ = function(object,key,value){
			//console.log(value)
			object['$$'+key] = value
		}
	}
}catch(e){//ie8
}

//if(typeof require == 'function'){
	exports.DOMImplementation = DOMImplementation;
	exports.XMLSerializer = XMLSerializer;
//}


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/sax.js":
/*!***********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/sax.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

//[4]   	NameStartChar	   ::=   	":" | [A-Z] | "_" | [a-z] | [#xC0-#xD6] | [#xD8-#xF6] | [#xF8-#x2FF] | [#x370-#x37D] | [#x37F-#x1FFF] | [#x200C-#x200D] | [#x2070-#x218F] | [#x2C00-#x2FEF] | [#x3001-#xD7FF] | [#xF900-#xFDCF] | [#xFDF0-#xFFFD] | [#x10000-#xEFFFF]
//[4a]   	NameChar	   ::=   	NameStartChar | "-" | "." | [0-9] | #xB7 | [#x0300-#x036F] | [#x203F-#x2040]
//[5]   	Name	   ::=   	NameStartChar (NameChar)*
var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]///\u10000-\uEFFFF
var nameChar = new RegExp("[\\-\\.0-9"+nameStartChar.source.slice(1,-1)+"\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
var tagNamePattern = new RegExp('^'+nameStartChar.source+nameChar.source+'*(?:\:'+nameStartChar.source+nameChar.source+'*)?$');
//var tagNamePattern = /^[a-zA-Z_][\w\-\.]*(?:\:[a-zA-Z_][\w\-\.]*)?$/
//var handlers = 'resolveEntity,getExternalSubset,characters,endDocument,endElement,endPrefixMapping,ignorableWhitespace,processingInstruction,setDocumentLocator,skippedEntity,startDocument,startElement,startPrefixMapping,notationDecl,unparsedEntityDecl,error,fatalError,warning,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,comment,endCDATA,endDTD,endEntity,startCDATA,startDTD,startEntity'.split(',')

//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
var S_TAG = 0;//tag name offerring
var S_ATTR = 1;//attr name offerring 
var S_ATTR_SPACE=2;//attr name end and space offer
var S_EQ = 3;//=space?
var S_ATTR_NOQUOT_VALUE = 4;//attr value(no quot value only)
var S_ATTR_END = 5;//attr value end and no space(quot end)
var S_TAG_SPACE = 6;//(attr value end || tag end ) && (space offer)
var S_TAG_CLOSE = 7;//closed el<el />

function XMLReader(){
	
}

XMLReader.prototype = {
	parse:function(source,defaultNSMap,entityMap){
		var domBuilder = this.domBuilder;
		domBuilder.startDocument();
		_copy(defaultNSMap ,defaultNSMap = {})
		parse(source,defaultNSMap,entityMap,
				domBuilder,this.errorHandler);
		domBuilder.endDocument();
	}
}
function parse(source,defaultNSMapCopy,entityMap,domBuilder,errorHandler){
	function fixedFromCharCode(code) {
		// String.prototype.fromCharCode does not supports
		// > 2 bytes unicode chars directly
		if (code > 0xffff) {
			code -= 0x10000;
			var surrogate1 = 0xd800 + (code >> 10)
				, surrogate2 = 0xdc00 + (code & 0x3ff);

			return String.fromCharCode(surrogate1, surrogate2);
		} else {
			return String.fromCharCode(code);
		}
	}
	function entityReplacer(a){
		var k = a.slice(1,-1);
		if(k in entityMap){
			return entityMap[k]; 
		}else if(k.charAt(0) === '#'){
			return fixedFromCharCode(parseInt(k.substr(1).replace('x','0x')))
		}else{
			errorHandler.error('entity not found:'+a);
			return a;
		}
	}
	function appendText(end){//has some bugs
		if(end>start){
			var xt = source.substring(start,end).replace(/&#?\w+;/g,entityReplacer);
			locator&&position(start);
			domBuilder.characters(xt,0,end-start);
			start = end
		}
	}
	function position(p,m){
		while(p>=lineEnd && (m = linePattern.exec(source))){
			lineStart = m.index;
			lineEnd = lineStart + m[0].length;
			locator.lineNumber++;
			//console.log('line++:',locator,startPos,endPos)
		}
		locator.columnNumber = p-lineStart+1;
	}
	var lineStart = 0;
	var lineEnd = 0;
	var linePattern = /.*(?:\r\n?|\n)|.*$/g
	var locator = domBuilder.locator;
	
	var parseStack = [{currentNSMap:defaultNSMapCopy}]
	var closeMap = {};
	var start = 0;
	while(true){
		try{
			var tagStart = source.indexOf('<',start);
			if(tagStart<0){
				if(!source.substr(start).match(/^\s*$/)){
					var doc = domBuilder.doc;
	    			var text = doc.createTextNode(source.substr(start));
	    			doc.appendChild(text);
	    			domBuilder.currentElement = text;
				}
				return;
			}
			if(tagStart>start){
				appendText(tagStart);
			}
			switch(source.charAt(tagStart+1)){
			case '/':
				var end = source.indexOf('>',tagStart+3);
				var tagName = source.substring(tagStart+2,end);
				var config = parseStack.pop();
				if(end<0){
					
	        		tagName = source.substring(tagStart+2).replace(/[\s<].*/,'');
	        		//console.error('#@@@@@@'+tagName)
	        		errorHandler.error("end tag name: "+tagName+' is not complete:'+config.tagName);
	        		end = tagStart+1+tagName.length;
	        	}else if(tagName.match(/\s</)){
	        		tagName = tagName.replace(/[\s<].*/,'');
	        		errorHandler.error("end tag name: "+tagName+' maybe not complete');
	        		end = tagStart+1+tagName.length;
				}
				//console.error(parseStack.length,parseStack)
				//console.error(config);
				var localNSMap = config.localNSMap;
				var endMatch = config.tagName == tagName;
				var endIgnoreCaseMach = endMatch || config.tagName&&config.tagName.toLowerCase() == tagName.toLowerCase()
		        if(endIgnoreCaseMach){
		        	domBuilder.endElement(config.uri,config.localName,tagName);
					if(localNSMap){
						for(var prefix in localNSMap){
							domBuilder.endPrefixMapping(prefix) ;
						}
					}
					if(!endMatch){
		            	errorHandler.fatalError("end tag name: "+tagName+' is not match the current start tagName:'+config.tagName );
					}
		        }else{
		        	parseStack.push(config)
		        }
				
				end++;
				break;
				// end elment
			case '?':// <?...?>
				locator&&position(tagStart);
				end = parseInstruction(source,tagStart,domBuilder);
				break;
			case '!':// <!doctype,<![CDATA,<!--
				locator&&position(tagStart);
				end = parseDCC(source,tagStart,domBuilder,errorHandler);
				break;
			default:
				locator&&position(tagStart);
				var el = new ElementAttributes();
				var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
				//elStartEnd
				var end = parseElementStartPart(source,tagStart,el,currentNSMap,entityReplacer,errorHandler);
				var len = el.length;
				
				
				if(!el.closed && fixSelfClosed(source,end,el.tagName,closeMap)){
					el.closed = true;
					if(!entityMap.nbsp){
						errorHandler.warning('unclosed xml attribute');
					}
				}
				if(locator && len){
					var locator2 = copyLocator(locator,{});
					//try{//attribute position fixed
					for(var i = 0;i<len;i++){
						var a = el[i];
						position(a.offset);
						a.locator = copyLocator(locator,{});
					}
					//}catch(e){console.error('@@@@@'+e)}
					domBuilder.locator = locator2
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
					domBuilder.locator = locator;
				}else{
					if(appendElement(el,domBuilder,currentNSMap)){
						parseStack.push(el)
					}
				}
				
				
				
				if(el.uri === 'http://www.w3.org/1999/xhtml' && !el.closed){
					end = parseHtmlSpecialContent(source,end,el.tagName,entityReplacer,domBuilder)
				}else{
					end++;
				}
			}
		}catch(e){
			errorHandler.error('element parse error: '+e)
			//errorHandler.error('element parse error: '+e);
			end = -1;
			//throw e;
		}
		if(end>start){
			start = end;
		}else{
			//TODO: 这里有可能sax回退，有位置错误风险
			appendText(Math.max(tagStart,start)+1);
		}
	}
}
function copyLocator(f,t){
	t.lineNumber = f.lineNumber;
	t.columnNumber = f.columnNumber;
	return t;
}

/**
 * @see #appendElement(source,elStartEnd,el,selfClosed,entityReplacer,domBuilder,parseStack);
 * @return end of the elementStartPart(end of elementEndPart for selfClosed el)
 */
function parseElementStartPart(source,start,el,currentNSMap,entityReplacer,errorHandler){
	var attrName;
	var value;
	var p = ++start;
	var s = S_TAG;//status
	while(true){
		var c = source.charAt(p);
		switch(c){
		case '=':
			if(s === S_ATTR){//attrName
				attrName = source.slice(start,p);
				s = S_EQ;
			}else if(s === S_ATTR_SPACE){
				s = S_EQ;
			}else{
				//fatalError: equal must after attrName or space after attrName
				throw new Error('attribute equal must after attrName');
			}
			break;
		case '\'':
		case '"':
			if(s === S_EQ || s === S_ATTR //|| s == S_ATTR_SPACE
				){//equal
				if(s === S_ATTR){
					errorHandler.warning('attribute value must after "="')
					attrName = source.slice(start,p)
				}
				start = p+1;
				p = source.indexOf(c,start)
				if(p>0){
					value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					el.add(attrName,value,start-1);
					s = S_ATTR_END;
				}else{
					//fatalError: no end quot match
					throw new Error('attribute value no end \''+c+'\' match');
				}
			}else if(s == S_ATTR_NOQUOT_VALUE){
				value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
				//console.log(attrName,value,start,p)
				el.add(attrName,value,start);
				//console.dir(el)
				errorHandler.warning('attribute "'+attrName+'" missed start quot('+c+')!!');
				start = p+1;
				s = S_ATTR_END
			}else{
				//fatalError: no equal before
				throw new Error('attribute value must after "="');
			}
			break;
		case '/':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				s =S_TAG_CLOSE;
				el.closed = true;
			case S_ATTR_NOQUOT_VALUE:
			case S_ATTR:
			case S_ATTR_SPACE:
				break;
			//case S_EQ:
			default:
				throw new Error("attribute invalid close char('/')")
			}
			break;
		case ''://end document
			//throw new Error('unexpected end of input')
			errorHandler.error('unexpected end of input');
			if(s == S_TAG){
				el.setTagName(source.slice(start,p));
			}
			return p;
		case '>':
			switch(s){
			case S_TAG:
				el.setTagName(source.slice(start,p));
			case S_ATTR_END:
			case S_TAG_SPACE:
			case S_TAG_CLOSE:
				break;//normal
			case S_ATTR_NOQUOT_VALUE://Compatible state
			case S_ATTR:
				value = source.slice(start,p);
				if(value.slice(-1) === '/'){
					el.closed  = true;
					value = value.slice(0,-1)
				}
			case S_ATTR_SPACE:
				if(s === S_ATTR_SPACE){
					value = attrName;
				}
				if(s == S_ATTR_NOQUOT_VALUE){
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value.replace(/&#?\w+;/g,entityReplacer),start)
				}else{
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !value.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+value+'" missed value!! "'+value+'" instead!!')
					}
					el.add(value,value,start)
				}
				break;
			case S_EQ:
				throw new Error('attribute value missed!!');
			}
//			console.log(tagName,tagNamePattern,tagNamePattern.test(tagName))
			return p;
		/*xml space '\x20' | #x9 | #xD | #xA; */
		case '\u0080':
			c = ' ';
		default:
			if(c<= ' '){//space
				switch(s){
				case S_TAG:
					el.setTagName(source.slice(start,p));//tagName
					s = S_TAG_SPACE;
					break;
				case S_ATTR:
					attrName = source.slice(start,p)
					s = S_ATTR_SPACE;
					break;
				case S_ATTR_NOQUOT_VALUE:
					var value = source.slice(start,p).replace(/&#?\w+;/g,entityReplacer);
					errorHandler.warning('attribute "'+value+'" missed quot(")!!');
					el.add(attrName,value,start)
				case S_ATTR_END:
					s = S_TAG_SPACE;
					break;
				//case S_TAG_SPACE:
				//case S_EQ:
				//case S_ATTR_SPACE:
				//	void();break;
				//case S_TAG_CLOSE:
					//ignore warning
				}
			}else{//not space
//S_TAG,	S_ATTR,	S_EQ,	S_ATTR_NOQUOT_VALUE
//S_ATTR_SPACE,	S_ATTR_END,	S_TAG_SPACE, S_TAG_CLOSE
				switch(s){
				//case S_TAG:void();break;
				//case S_ATTR:void();break;
				//case S_ATTR_NOQUOT_VALUE:void();break;
				case S_ATTR_SPACE:
					var tagName =  el.tagName;
					if(currentNSMap[''] !== 'http://www.w3.org/1999/xhtml' || !attrName.match(/^(?:disabled|checked|selected)$/i)){
						errorHandler.warning('attribute "'+attrName+'" missed value!! "'+attrName+'" instead2!!')
					}
					el.add(attrName,attrName,start);
					start = p;
					s = S_ATTR;
					break;
				case S_ATTR_END:
					errorHandler.warning('attribute space is required"'+attrName+'"!!')
				case S_TAG_SPACE:
					s = S_ATTR;
					start = p;
					break;
				case S_EQ:
					s = S_ATTR_NOQUOT_VALUE;
					start = p;
					break;
				case S_TAG_CLOSE:
					throw new Error("elements closed character '/' and '>' must be connected to");
				}
			}
		}//end outer switch
		//console.log('p++',p)
		p++;
	}
}
/**
 * @return true if has new namespace define
 */
function appendElement(el,domBuilder,currentNSMap){
	var tagName = el.tagName;
	var localNSMap = null;
	//var currentNSMap = parseStack[parseStack.length-1].currentNSMap;
	var i = el.length;
	while(i--){
		var a = el[i];
		var qName = a.qName;
		var value = a.value;
		var nsp = qName.indexOf(':');
		if(nsp>0){
			var prefix = a.prefix = qName.slice(0,nsp);
			var localName = qName.slice(nsp+1);
			var nsPrefix = prefix === 'xmlns' && localName
		}else{
			localName = qName;
			prefix = null
			nsPrefix = qName === 'xmlns' && ''
		}
		//can not set prefix,because prefix !== ''
		a.localName = localName ;
		//prefix == null for no ns prefix attribute 
		if(nsPrefix !== false){//hack!!
			if(localNSMap == null){
				localNSMap = {}
				//console.log(currentNSMap,0)
				_copy(currentNSMap,currentNSMap={})
				//console.log(currentNSMap,1)
			}
			currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
			a.uri = 'http://www.w3.org/2000/xmlns/'
			domBuilder.startPrefixMapping(nsPrefix, value) 
		}
	}
	var i = el.length;
	while(i--){
		a = el[i];
		var prefix = a.prefix;
		if(prefix){//no prefix attribute has no namespace
			if(prefix === 'xml'){
				a.uri = 'http://www.w3.org/XML/1998/namespace';
			}if(prefix !== 'xmlns'){
				a.uri = currentNSMap[prefix || '']
				
				//{console.log('###'+a.qName,domBuilder.locator.systemId+'',currentNSMap,a.uri)}
			}
		}
	}
	var nsp = tagName.indexOf(':');
	if(nsp>0){
		prefix = el.prefix = tagName.slice(0,nsp);
		localName = el.localName = tagName.slice(nsp+1);
	}else{
		prefix = null;//important!!
		localName = el.localName = tagName;
	}
	//no prefix element has default namespace
	var ns = el.uri = currentNSMap[prefix || ''];
	domBuilder.startElement(ns,localName,tagName,el);
	//endPrefixMapping and startPrefixMapping have not any help for dom builder
	//localNSMap = null
	if(el.closed){
		domBuilder.endElement(ns,localName,tagName);
		if(localNSMap){
			for(prefix in localNSMap){
				domBuilder.endPrefixMapping(prefix) 
			}
		}
	}else{
		el.currentNSMap = currentNSMap;
		el.localNSMap = localNSMap;
		//parseStack.push(el);
		return true;
	}
}
function parseHtmlSpecialContent(source,elStartEnd,tagName,entityReplacer,domBuilder){
	if(/^(?:script|textarea)$/i.test(tagName)){
		var elEndStart =  source.indexOf('</'+tagName+'>',elStartEnd);
		var text = source.substring(elStartEnd+1,elEndStart);
		if(/[&<]/.test(text)){
			if(/^script$/i.test(tagName)){
				//if(!/\]\]>/.test(text)){
					//lexHandler.startCDATA();
					domBuilder.characters(text,0,text.length);
					//lexHandler.endCDATA();
					return elEndStart;
				//}
			}//}else{//text area
				text = text.replace(/&#?\w+;/g,entityReplacer);
				domBuilder.characters(text,0,text.length);
				return elEndStart;
			//}
			
		}
	}
	return elStartEnd+1;
}
function fixSelfClosed(source,elStartEnd,tagName,closeMap){
	//if(tagName in closeMap){
	var pos = closeMap[tagName];
	if(pos == null){
		//console.log(tagName)
		pos =  source.lastIndexOf('</'+tagName+'>')
		if(pos<elStartEnd){//忘记闭合
			pos = source.lastIndexOf('</'+tagName)
		}
		closeMap[tagName] =pos
	}
	return pos<elStartEnd;
	//} 
}
function _copy(source,target){
	for(var n in source){target[n] = source[n]}
}
function parseDCC(source,start,domBuilder,errorHandler){//sure start with '<!'
	var next= source.charAt(start+2)
	switch(next){
	case '-':
		if(source.charAt(start + 3) === '-'){
			var end = source.indexOf('-->',start+4);
			//append comment source.substring(4,end)//<!--
			if(end>start){
				domBuilder.comment(source,start+4,end-start-4);
				return end+3;
			}else{
				errorHandler.error("Unclosed comment");
				return -1;
			}
		}else{
			//error
			return -1;
		}
	default:
		if(source.substr(start+3,6) == 'CDATA['){
			var end = source.indexOf(']]>',start+9);
			domBuilder.startCDATA();
			domBuilder.characters(source,start+9,end-start-9);
			domBuilder.endCDATA() 
			return end+3;
		}
		//<!DOCTYPE
		//startDTD(java.lang.String name, java.lang.String publicId, java.lang.String systemId) 
		var matchs = split(source,start);
		var len = matchs.length;
		if(len>1 && /!doctype/i.test(matchs[0][0])){
			var name = matchs[1][0];
			var pubid = len>3 && /^public$/i.test(matchs[2][0]) && matchs[3][0]
			var sysid = len>4 && matchs[4][0];
			var lastMatch = matchs[len-1]
			domBuilder.startDTD(name,pubid && pubid.replace(/^(['"])(.*?)\1$/,'$2'),
					sysid && sysid.replace(/^(['"])(.*?)\1$/,'$2'));
			domBuilder.endDTD();
			
			return lastMatch.index+lastMatch[0].length
		}
	}
	return -1;
}



function parseInstruction(source,start,domBuilder){
	var end = source.indexOf('?>',start);
	if(end){
		var match = source.substring(start,end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
		if(match){
			var len = match[0].length;
			domBuilder.processingInstruction(match[1], match[2]) ;
			return end+2;
		}else{//error
			return -1;
		}
	}
	return -1;
}

/**
 * @param source
 */
function ElementAttributes(source){
	
}
ElementAttributes.prototype = {
	setTagName:function(tagName){
		if(!tagNamePattern.test(tagName)){
			throw new Error('invalid tagName:'+tagName)
		}
		this.tagName = tagName
	},
	add:function(qName,value,offset){
		if(!tagNamePattern.test(qName)){
			throw new Error('invalid attribute:'+qName)
		}
		this[this.length++] = {qName:qName,value:value,offset:offset}
	},
	length:0,
	getLocalName:function(i){return this[i].localName},
	getLocator:function(i){return this[i].locator},
	getQName:function(i){return this[i].qName},
	getURI:function(i){return this[i].uri},
	getValue:function(i){return this[i].value}
//	,getIndex:function(uri, localName)){
//		if(localName){
//			
//		}else{
//			var qName = uri
//		}
//	},
//	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
//	getType:function(uri,localName){}
//	getType:function(i){},
}




function _set_proto_(thiz,parent){
	thiz.__proto__ = parent;
	return thiz;
}
if(!(_set_proto_({},_set_proto_.prototype) instanceof _set_proto_)){
	_set_proto_ = function(thiz,parent){
		function p(){};
		p.prototype = parent;
		p = new p();
		for(parent in thiz){
			p[parent] = thiz[parent];
		}
		return p;
	}
}

function split(source,start){
	var match;
	var buf = [];
	var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
	reg.lastIndex = start;
	reg.exec(source);//skip <
	while(match = reg.exec(source)){
		buf.push(match);
		if(match[1])return buf;
	}
}

exports.XMLReader = XMLReader;



/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/xpath/0.0.27/node_modules/xpath/xpath.js":
/*!***********************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/xpath/0.0.27/node_modules/xpath/xpath.js ***!
  \***********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
 * xpath.js
 *
 * An XPath 1.0 library for JavaScript.
 *
 * Cameron McCormack <cam (at) mcc.id.au>
 *
 * This work is licensed under the MIT License.
 *
 * Revision 20: April 26, 2011
 *   Fixed a typo resulting in FIRST_ORDERED_NODE_TYPE results being wrong,
 *   thanks to <shi_a009 (at) hotmail.com>.
 *
 * Revision 19: November 29, 2005
 *   Nodesets now store their nodes in a height balanced tree, increasing
 *   performance for the common case of selecting nodes in document order,
 *   thanks to S閎astien Cramatte <contact (at) zeninteractif.com>.
 *   AVL tree code adapted from Raimund Neumann <rnova (at) gmx.net>.
 *
 * Revision 18: October 27, 2005
 *   DOM 3 XPath support.  Caveats:
 *     - namespace prefixes aren't resolved in XPathEvaluator.createExpression,
 *       but in XPathExpression.evaluate.
 *     - XPathResult.invalidIteratorState is not implemented.
 *
 * Revision 17: October 25, 2005
 *   Some core XPath function fixes and a patch to avoid crashing certain
 *   versions of MSXML in PathExpr.prototype.getOwnerElement, thanks to
 *   S閎astien Cramatte <contact (at) zeninteractif.com>.
 *
 * Revision 16: September 22, 2005
 *   Workarounds for some IE 5.5 deficiencies.
 *   Fixed problem with prefix node tests on attribute nodes.
 *
 * Revision 15: May 21, 2005
 *   Fixed problem with QName node tests on elements with an xmlns="...".
 *
 * Revision 14: May 19, 2005
 *   Fixed QName node tests on attribute node regression.
 *
 * Revision 13: May 3, 2005
 *   Node tests are case insensitive now if working in an HTML DOM.
 *
 * Revision 12: April 26, 2005
 *   Updated licence.  Slight code changes to enable use of Dean
 *   Edwards' script compression, http://dean.edwards.name/packer/ .
 *
 * Revision 11: April 23, 2005
 *   Fixed bug with 'and' and 'or' operators, fix thanks to
 *   Sandy McArthur <sandy (at) mcarthur.org>.
 *
 * Revision 10: April 15, 2005
 *   Added support for a virtual root node, supposedly helpful for
 *   implementing XForms.  Fixed problem with QName node tests and
 *   the parent axis.
 *
 * Revision 9: March 17, 2005
 *   Namespace resolver tweaked so using the document node as the context
 *   for namespace lookups is equivalent to using the document element.
 *
 * Revision 8: February 13, 2005
 *   Handle implicit declaration of 'xmlns' namespace prefix.
 *   Fixed bug when comparing nodesets.
 *   Instance data can now be associated with a FunctionResolver, and
 *     workaround for MSXML not supporting 'localName' and 'getElementById',
 *     thanks to Grant Gongaware.
 *   Fix a few problems when the context node is the root node.
 *
 * Revision 7: February 11, 2005
 *   Default namespace resolver fix from Grant Gongaware
 *   <grant (at) gongaware.com>.
 *
 * Revision 6: February 10, 2005
 *   Fixed bug in 'number' function.
 *
 * Revision 5: February 9, 2005
 *   Fixed bug where text nodes not getting converted to string values.
 *
 * Revision 4: January 21, 2005
 *   Bug in 'name' function, fix thanks to Bill Edney.
 *   Fixed incorrect processing of namespace nodes.
 *   Fixed NamespaceResolver to resolve 'xml' namespace.
 *   Implemented union '|' operator.
 *
 * Revision 3: January 14, 2005
 *   Fixed bug with nodeset comparisons, bug lexing < and >.
 *
 * Revision 2: October 26, 2004
 *   QName node test namespace handling fixed.  Few other bug fixes.
 *
 * Revision 1: August 13, 2004
 *   Bug fixes from William J. Edney <bedney (at) technicalpursuit.com>.
 *   Added minimal licence.
 *
 * Initial version: June 14, 2004
 */

// non-node wrapper
var xpath = ( false) ? undefined : exports;

(function(exports) {
"use strict";

// functional helpers
function curry( func ) {
    var slice = Array.prototype.slice,
        totalargs = func.length,
        partial = function( args, fn ) {
            return function( ) {
                return fn.apply( this, args.concat( slice.call( arguments ) ) );
            }
        },
        fn = function( ) {
            var args = slice.call( arguments );
            return ( args.length < totalargs ) ?
                partial( args, fn ) :
                func.apply( this, slice.apply( arguments, [ 0, totalargs ] ) );
        };
    return fn;
}

var forEach = curry(function (f, xs) {
	for (var i = 0; i < xs.length; i += 1) {
		f(xs[i], i, xs);
	}
});

var reduce = curry(function (f, seed, xs) {
	var acc = seed;

	forEach(function (x, i) { acc = f(acc, x, i); }, xs);

	return acc;
});

var map = curry(function (f, xs) { 
	var mapped = new Array(xs.length);
	
	forEach(function (x, i) { mapped[i] = f(x); }, xs);

	return mapped;
});

var filter = curry(function (f, xs) {
	var filtered = [];
	
	forEach(function (x, i) { if(f(x, i)) { filtered.push(x); } }, xs);
	
	return filtered;
});

function compose() {
    if (arguments.length === 0) { throw new Error('compose requires at least one argument'); }

    var funcs = Array.prototype.slice.call(arguments).reverse();
	
    var f0 = funcs[0];
    var fRem = funcs.slice(1);

    return function () {
        return reduce(function (acc, next) {
            return next(acc);
        }, f0.apply(null, arguments), fRem);
    };
}

var includes = curry(function (values, value) {
	for (var i = 0; i < values.length; i += 1) {
		if (values[i] === value){
			return true;
		}
	}
	
	return false;
});

function always(value) { return function () { return value ;} }

var prop = curry(function (name, obj) { return obj[name]; });

function toString (x) { return x.toString(); }
var join = curry(function (s, xs) { return xs.join(s); });
var wrap = curry(function (pref, suf, str) { return pref + str + suf; });

function assign(target) { // .length of function is 2
    var to = Object(target);

    for (var index = 1; index < arguments.length; index++) {
        var nextSource = arguments[index];

        if (nextSource != null) { // Skip over if undefined or null
            for (var nextKey in nextSource) {
                // Avoid bugs when hasOwnProperty is shadowed
                if (Object.prototype.hasOwnProperty.call(nextSource, nextKey)) {
                    to[nextKey] = nextSource[nextKey];
                }
            }
        }
    }

    return to;
}

// XPathParser ///////////////////////////////////////////////////////////////

XPathParser.prototype = new Object();
XPathParser.prototype.constructor = XPathParser;
XPathParser.superclass = Object.prototype;

function XPathParser() {
	this.init();
}

XPathParser.prototype.init = function() {
	this.reduceActions = [];

	this.reduceActions[3] = function(rhs) {
		return new OrOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[5] = function(rhs) {
		return new AndOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[7] = function(rhs) {
		return new EqualsOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[8] = function(rhs) {
		return new NotEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[10] = function(rhs) {
		return new LessThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[11] = function(rhs) {
		return new GreaterThanOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[12] = function(rhs) {
		return new LessThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[13] = function(rhs) {
		return new GreaterThanOrEqualOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[15] = function(rhs) {
		return new PlusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[16] = function(rhs) {
		return new MinusOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[18] = function(rhs) {
		return new MultiplyOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[19] = function(rhs) {
		return new DivOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[20] = function(rhs) {
		return new ModOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[22] = function(rhs) {
		return new UnaryMinusOperation(rhs[1]);
	};
	this.reduceActions[24] = function(rhs) {
		return new BarOperation(rhs[0], rhs[2]);
	};
	this.reduceActions[25] = function(rhs) {
		return new PathExpr(undefined, undefined, rhs[0]);
	};
	this.reduceActions[27] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		return rhs[0];
	};
	this.reduceActions[28] = function(rhs) {
		rhs[0].locationPath = rhs[2];
		rhs[0].locationPath.steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
		return rhs[0];
	};
	this.reduceActions[29] = function(rhs) {
		return new PathExpr(rhs[0], [], undefined);
	};
	this.reduceActions[30] = function(rhs) {
		if (Utilities.instance_of(rhs[0], PathExpr)) {
			if (rhs[0].filterPredicates == undefined) {
				rhs[0].filterPredicates = [];
			}
			rhs[0].filterPredicates.push(rhs[1]);
			return rhs[0];
		} else {
			return new PathExpr(rhs[0], [rhs[1]], undefined);
		}
	};
	this.reduceActions[32] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[33] = function(rhs) {
		return new XString(rhs[0]);
	};
	this.reduceActions[34] = function(rhs) {
		return new XNumber(rhs[0]);
	};
	this.reduceActions[36] = function(rhs) {
		return new FunctionCall(rhs[0], []);
	};
	this.reduceActions[37] = function(rhs) {
		return new FunctionCall(rhs[0], rhs[2]);
	};
	this.reduceActions[38] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[39] = function(rhs) {
		rhs[2].unshift(rhs[0]);
		return rhs[2];
	};
	this.reduceActions[43] = function(rhs) {
		return new LocationPath(true, []);
	};
	this.reduceActions[44] = function(rhs) {
		rhs[1].absolute = true;
		return rhs[1];
	};
	this.reduceActions[46] = function(rhs) {
		return new LocationPath(false, [ rhs[0] ]);
	};
	this.reduceActions[47] = function(rhs) {
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[49] = function(rhs) {
		return new Step(rhs[0], rhs[1], []);
	};
	this.reduceActions[50] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], []);
	};
	this.reduceActions[51] = function(rhs) {
		return new Step(rhs[0], rhs[1], rhs[2]);
	};
	this.reduceActions[52] = function(rhs) {
		return new Step(Step.CHILD, rhs[0], rhs[1]);
	};
	this.reduceActions[54] = function(rhs) {
		return [ rhs[0] ];
	};
	this.reduceActions[55] = function(rhs) {
		rhs[1].unshift(rhs[0]);
		return rhs[1];
	};
	this.reduceActions[56] = function(rhs) {
		if (rhs[0] == "ancestor") {
			return Step.ANCESTOR;
		} else if (rhs[0] == "ancestor-or-self") {
			return Step.ANCESTORORSELF;
		} else if (rhs[0] == "attribute") {
			return Step.ATTRIBUTE;
		} else if (rhs[0] == "child") {
			return Step.CHILD;
		} else if (rhs[0] == "descendant") {
			return Step.DESCENDANT;
		} else if (rhs[0] == "descendant-or-self") {
			return Step.DESCENDANTORSELF;
		} else if (rhs[0] == "following") {
			return Step.FOLLOWING;
		} else if (rhs[0] == "following-sibling") {
			return Step.FOLLOWINGSIBLING;
		} else if (rhs[0] == "namespace") {
			return Step.NAMESPACE;
		} else if (rhs[0] == "parent") {
			return Step.PARENT;
		} else if (rhs[0] == "preceding") {
			return Step.PRECEDING;
		} else if (rhs[0] == "preceding-sibling") {
			return Step.PRECEDINGSIBLING;
		} else if (rhs[0] == "self") {
			return Step.SELF;
		}
		return -1;
	};
	this.reduceActions[57] = function(rhs) {
		return Step.ATTRIBUTE;
	};
	this.reduceActions[59] = function(rhs) {
		if (rhs[0] == "comment") {
			return NodeTest.commentTest;
		} else if (rhs[0] == "text") {
			return NodeTest.textTest;
		} else if (rhs[0] == "processing-instruction") {
			return NodeTest.anyPiTest;
		} else if (rhs[0] == "node") {
			return NodeTest.nodeTest;
		}
		return new NodeTest(-1, undefined);
	};
	this.reduceActions[60] = function(rhs) {
		return new NodeTest.PITest(rhs[2]);
	};
	this.reduceActions[61] = function(rhs) {
		return rhs[1];
	};
	this.reduceActions[63] = function(rhs) {
		rhs[1].absolute = true;
		rhs[1].steps.unshift(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
		return rhs[1];
	};
	this.reduceActions[64] = function(rhs) {
		rhs[0].steps.push(new Step(Step.DESCENDANTORSELF, NodeTest.nodeTest, []));
		rhs[0].steps.push(rhs[2]);
		return rhs[0];
	};
	this.reduceActions[65] = function(rhs) {
		return new Step(Step.SELF, NodeTest.nodeTest, []);
	};
	this.reduceActions[66] = function(rhs) {
		return new Step(Step.PARENT, NodeTest.nodeTest, []);
	};
	this.reduceActions[67] = function(rhs) {
		return new VariableReference(rhs[1]);
	};
	this.reduceActions[68] = function(rhs) {
		return NodeTest.nameTestAny;
	};
	this.reduceActions[69] = function(rhs) {
		return new NodeTest.NameTestPrefixAny(rhs[0].split(':')[0]);
	};
	this.reduceActions[70] = function(rhs) {
		return new NodeTest.NameTestQName(rhs[0]);
	};
};

XPathParser.actionTable = [
	" s s        sssssssss    s ss  s  ss",
	"                 s                  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                rrrrr               ",
	" s s        sssssssss    s ss  s  ss",
	"rs  rrrrrrrr s  sssssrrrrrr  rrs rs ",
	" s s        sssssssss    s ss  s  ss",
	"                            s       ",
	"                            s       ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"  s                                 ",
	"                            s       ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"a                                   ",
	"r       s                    rr  r  ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrs  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr sr  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"                sssss               ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"              s                     ",
	"                             s      ",
	"                rrrrr               ",
	" s s        sssssssss    s sss s  ss",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s s        sssssssss      ss  s  ss",
	" s s        sssssssss    s ss  s  ss",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s           s  sssss          s  s ",
	" s           s  sssss          s  s ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr sr  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             s      ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             rr     ",
	"                             s      ",
	"                             rs     ",
	"r      sr                    rr  r  ",
	"r   s  rr            s       rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rssrr            rss     rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrr            rrrss   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrsss         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrr   rr  r  ",
	"r   rrrrrrrr         rrrrrr  rr  r  ",
	"                                 r  ",
	"                                 s  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  srrrrrrrr         rrrrrrs rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr  r  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	" s s        sssssssss    s ss  s  ss",
	"r  rrrrrrrrr         rrrrrrr rr rr  ",
	"                             r      "
];

XPathParser.actionTableNumber = [
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                 J                  ",
	"a  aaaaaaaaa         aaaaaaa aa  a  ",
	"                YYYYY               ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"K1  KKKKKKKK .  +*)('KKKKKK  KK# K\" ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"                            N       ",
	"                            O       ",
	"e  eeeeeeeee         eeeeeee ee ee  ",
	"f  fffffffff         fffffff ff ff  ",
	"d  ddddddddd         ddddddd dd dd  ",
	"B  BBBBBBBBB         BBBBBBB BB BB  ",
	"A  AAAAAAAAA         AAAAAAA AA AA  ",
	"  P                                 ",
	"                            Q       ",
	" 1           .  +*)('          #  \" ",
	"b  bbbbbbbbb         bbbbbbb bb  b  ",
	"                                    ",
	"!       S                    !!  !  ",
	"\"      T\"                    \"\"  \"  ",
	"$   V  $$            U       $$  $  ",
	"&   &ZY&&            &XW     &&  &  ",
	")   )))))            )))\\[   ))  )  ",
	".   ....._^]         .....   ..  .  ",
	"1   11111111         11111   11  1  ",
	"5   55555555         55555`  55  5  ",
	"7   77777777         777777  77  7  ",
	"9   99999999         999999  99  9  ",
	":  c::::::::         ::::::b :: a:  ",
	"I  fIIIIIIII         IIIIIIe II  I  ",
	"=  =========         ======= == ==  ",
	"?  ?????????         ??????? ?? ??  ",
	"C  CCCCCCCCC         CCCCCCC CC CC  ",
	"J   JJJJJJJJ         JJJJJJ  JJ  J  ",
	"M   MMMMMMMM         MMMMMM  MM  M  ",
	"N  NNNNNNNNN         NNNNNNN NN  N  ",
	"P  PPPPPPPPP         PPPPPPP PP  P  ",
	"                +*)('               ",
	"R  RRRRRRRRR         RRRRRRR RR aR  ",
	"U  UUUUUUUUU         UUUUUUU UU  U  ",
	"Z  ZZZZZZZZZ         ZZZZZZZ ZZ ZZ  ",
	"c  ccccccccc         ccccccc cc cc  ",
	"                             j      ",
	"L  fLLLLLLLL         LLLLLLe LL  L  ",
	"6   66666666         66666   66  6  ",
	"              k                     ",
	"                             l      ",
	"                XXXXX               ",
	" 1 0        /.-,+*)('    & %$m #  \"!",
	"_  f________         ______e __  _  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1 0        /.-,+*)('      %$  #  \"!",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	">  >>>>>>>>>         >>>>>>> >> >>  ",
	" 1           .  +*)('          #  \" ",
	" 1           .  +*)('          #  \" ",
	"Q  QQQQQQQQQ         QQQQQQQ QQ aQ  ",
	"V  VVVVVVVVV         VVVVVVV VV aV  ",
	"T  TTTTTTTTT         TTTTTTT TT  T  ",
	"@  @@@@@@@@@         @@@@@@@ @@ @@  ",
	"                             \x87      ",
	"[  [[[[[[[[[         [[[[[[[ [[ [[  ",
	"D  DDDDDDDDD         DDDDDDD DD DD  ",
	"                             HH     ",
	"                             \x88      ",
	"                             F\x89     ",
	"#      T#                    ##  #  ",
	"%   V  %%            U       %%  %  ",
	"'   'ZY''            'XW     ''  '  ",
	"(   (ZY((            (XW     ((  (  ",
	"+   +++++            +++\\[   ++  +  ",
	"*   *****            ***\\[   **  *  ",
	"-   -----            ---\\[   --  -  ",
	",   ,,,,,            ,,,\\[   ,,  ,  ",
	"0   00000_^]         00000   00  0  ",
	"/   /////_^]         /////   //  /  ",
	"2   22222222         22222   22  2  ",
	"3   33333333         33333   33  3  ",
	"4   44444444         44444   44  4  ",
	"8   88888888         888888  88  8  ",
	"                                 ^  ",
	"                                 \x8a  ",
	";  f;;;;;;;;         ;;;;;;e ;;  ;  ",
	"<  f<<<<<<<<         <<<<<<e <<  <  ",
	"O  OOOOOOOOO         OOOOOOO OO  O  ",
	"`  `````````         ``````` ``  `  ",
	"S  SSSSSSSSS         SSSSSSS SS  S  ",
	"W  WWWWWWWWW         WWWWWWW WW  W  ",
	"\\  \\\\\\\\\\\\\\\\\\         \\\\\\\\\\\\\\ \\\\ \\\\  ",
	"E  EEEEEEEEE         EEEEEEE EE EE  ",
	" 1 0        /.-,+*)('    & %$  #  \"!",
	"]  ]]]]]]]]]         ]]]]]]] ]] ]]  ",
	"                             G      "
];

XPathParser.gotoTable = [
	"3456789:;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"L456789:;<=>?@ AB  CDEFGH IJ ",
	"            M        EFGH IJ ",
	"       N;<=>?@ AB  CDEFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"            S        EFGH IJ ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"              e              ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                        h  J ",
	"              i          j   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ ABpqCDEFGH IJ ",
	"                             ",
	"  r6789:;<=>?@ AB  CDEFGH IJ ",
	"   s789:;<=>?@ AB  CDEFGH IJ ",
	"    t89:;<=>?@ AB  CDEFGH IJ ",
	"    u89:;<=>?@ AB  CDEFGH IJ ",
	"     v9:;<=>?@ AB  CDEFGH IJ ",
	"     w9:;<=>?@ AB  CDEFGH IJ ",
	"     x9:;<=>?@ AB  CDEFGH IJ ",
	"     y9:;<=>?@ AB  CDEFGH IJ ",
	"      z:;<=>?@ AB  CDEFGH IJ ",
	"      {:;<=>?@ AB  CDEFGH IJ ",
	"       |;<=>?@ AB  CDEFGH IJ ",
	"       };<=>?@ AB  CDEFGH IJ ",
	"       ~;<=>?@ AB  CDEFGH IJ ",
	"         \x7f=>?@ AB  CDEFGH IJ ",
	"\x80456789:;<=>?@ AB  CDEFGH IJ\x81",
	"            \x82        EFGH IJ ",
	"            \x83        EFGH IJ ",
	"                             ",
	"                     \x84 GH IJ ",
	"                     \x85 GH IJ ",
	"              i          \x86   ",
	"              i          \x87   ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"                             ",
	"o456789:;<=>?@ AB\x8cqCDEFGH IJ ",
	"                             ",
	"                             "
];

XPathParser.productions = [
	[1, 1, 2],
	[2, 1, 3],
	[3, 1, 4],
	[3, 3, 3, -9, 4],
	[4, 1, 5],
	[4, 3, 4, -8, 5],
	[5, 1, 6],
	[5, 3, 5, -22, 6],
	[5, 3, 5, -5, 6],
	[6, 1, 7],
	[6, 3, 6, -23, 7],
	[6, 3, 6, -24, 7],
	[6, 3, 6, -6, 7],
	[6, 3, 6, -7, 7],
	[7, 1, 8],
	[7, 3, 7, -25, 8],
	[7, 3, 7, -26, 8],
	[8, 1, 9],
	[8, 3, 8, -12, 9],
	[8, 3, 8, -11, 9],
	[8, 3, 8, -10, 9],
	[9, 1, 10],
	[9, 2, -26, 9],
	[10, 1, 11],
	[10, 3, 10, -27, 11],
	[11, 1, 12],
	[11, 1, 13],
	[11, 3, 13, -28, 14],
	[11, 3, 13, -4, 14],
	[13, 1, 15],
	[13, 2, 13, 16],
	[15, 1, 17],
	[15, 3, -29, 2, -30],
	[15, 1, -15],
	[15, 1, -16],
	[15, 1, 18],
	[18, 3, -13, -29, -30],
	[18, 4, -13, -29, 19, -30],
	[19, 1, 20],
	[19, 3, 20, -31, 19],
	[20, 1, 2],
	[12, 1, 14],
	[12, 1, 21],
	[21, 1, -28],
	[21, 2, -28, 14],
	[21, 1, 22],
	[14, 1, 23],
	[14, 3, 14, -28, 23],
	[14, 1, 24],
	[23, 2, 25, 26],
	[23, 1, 26],
	[23, 3, 25, 26, 27],
	[23, 2, 26, 27],
	[23, 1, 28],
	[27, 1, 16],
	[27, 2, 16, 27],
	[25, 2, -14, -3],
	[25, 1, -32],
	[26, 1, 29],
	[26, 3, -20, -29, -30],
	[26, 4, -21, -29, -15, -30],
	[16, 3, -33, 30, -34],
	[30, 1, 2],
	[22, 2, -4, 14],
	[24, 3, 14, -4, 23],
	[28, 1, -35],
	[28, 1, -2],
	[17, 2, -36, -18],
	[29, 1, -17],
	[29, 1, -19],
	[29, 1, -18]
];

XPathParser.DOUBLEDOT = 2;
XPathParser.DOUBLECOLON = 3;
XPathParser.DOUBLESLASH = 4;
XPathParser.NOTEQUAL = 5;
XPathParser.LESSTHANOREQUAL = 6;
XPathParser.GREATERTHANOREQUAL = 7;
XPathParser.AND = 8;
XPathParser.OR = 9;
XPathParser.MOD = 10;
XPathParser.DIV = 11;
XPathParser.MULTIPLYOPERATOR = 12;
XPathParser.FUNCTIONNAME = 13;
XPathParser.AXISNAME = 14;
XPathParser.LITERAL = 15;
XPathParser.NUMBER = 16;
XPathParser.ASTERISKNAMETEST = 17;
XPathParser.QNAME = 18;
XPathParser.NCNAMECOLONASTERISK = 19;
XPathParser.NODETYPE = 20;
XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL = 21;
XPathParser.EQUALS = 22;
XPathParser.LESSTHAN = 23;
XPathParser.GREATERTHAN = 24;
XPathParser.PLUS = 25;
XPathParser.MINUS = 26;
XPathParser.BAR = 27;
XPathParser.SLASH = 28;
XPathParser.LEFTPARENTHESIS = 29;
XPathParser.RIGHTPARENTHESIS = 30;
XPathParser.COMMA = 31;
XPathParser.AT = 32;
XPathParser.LEFTBRACKET = 33;
XPathParser.RIGHTBRACKET = 34;
XPathParser.DOT = 35;
XPathParser.DOLLAR = 36;

XPathParser.prototype.tokenize = function(s1) {
	var types = [];
	var values = [];
	var s = s1 + '\0';

	var pos = 0;
	var c = s.charAt(pos++);
	while (1) {
		while (c == ' ' || c == '\t' || c == '\r' || c == '\n') {
			c = s.charAt(pos++);
		}
		if (c == '\0' || pos >= s.length) {
			break;
		}

		if (c == '(') {
			types.push(XPathParser.LEFTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ')') {
			types.push(XPathParser.RIGHTPARENTHESIS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '[') {
			types.push(XPathParser.LEFTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ']') {
			types.push(XPathParser.RIGHTBRACKET);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '@') {
			types.push(XPathParser.AT);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == ',') {
			types.push(XPathParser.COMMA);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '|') {
			types.push(XPathParser.BAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '+') {
			types.push(XPathParser.PLUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '-') {
			types.push(XPathParser.MINUS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '=') {
			types.push(XPathParser.EQUALS);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}
		if (c == '$') {
			types.push(XPathParser.DOLLAR);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == '.') {
			c = s.charAt(pos++);
			if (c == '.') {
				types.push(XPathParser.DOUBLEDOT);
				values.push("..");
				c = s.charAt(pos++);
				continue;
			}
			if (c >= '0' && c <= '9') {
				var number = "." + c;
				c = s.charAt(pos++);
				while (c >= '0' && c <= '9') {
					number += c;
					c = s.charAt(pos++);
				}
				types.push(XPathParser.NUMBER);
				values.push(number);
				continue;
			}
			types.push(XPathParser.DOT);
			values.push('.');
			continue;
		}

		if (c == '\'' || c == '"') {
			var delimiter = c;
			var literal = "";
			while (pos < s.length && (c = s.charAt(pos)) !== delimiter) {
				literal += c;
                pos += 1;
			}
            if (c !== delimiter) {
                throw XPathException.fromMessage("Unterminated string literal: " + delimiter + literal);
            }
            pos += 1;
			types.push(XPathParser.LITERAL);
			values.push(literal);
			c = s.charAt(pos++);
			continue;
		}

		if (c >= '0' && c <= '9') {
			var number = c;
			c = s.charAt(pos++);
			while (c >= '0' && c <= '9') {
				number += c;
				c = s.charAt(pos++);
			}
			if (c == '.') {
				if (s.charAt(pos) >= '0' && s.charAt(pos) <= '9') {
					number += c;
					number += s.charAt(pos++);
					c = s.charAt(pos++);
					while (c >= '0' && c <= '9') {
						number += c;
						c = s.charAt(pos++);
					}
				}
			}
			types.push(XPathParser.NUMBER);
			values.push(number);
			continue;
		}

		if (c == '*') {
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					types.push(XPathParser.MULTIPLYOPERATOR);
					values.push(c);
					c = s.charAt(pos++);
					continue;
				}
			}
			types.push(XPathParser.ASTERISKNAMETEST);
			values.push(c);
			c = s.charAt(pos++);
			continue;
		}

		if (c == ':') {
			if (s.charAt(pos) == ':') {
				types.push(XPathParser.DOUBLECOLON);
				values.push("::");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '/') {
			c = s.charAt(pos++);
			if (c == '/') {
				types.push(XPathParser.DOUBLESLASH);
				values.push("//");
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.SLASH);
			values.push('/');
			continue;
		}

		if (c == '!') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.NOTEQUAL);
				values.push("!=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
		}

		if (c == '<') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.LESSTHANOREQUAL);
				values.push("<=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.LESSTHAN);
			values.push('<');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '>') {
			if (s.charAt(pos) == '=') {
				types.push(XPathParser.GREATERTHANOREQUAL);
				values.push(">=");
				pos++;
				c = s.charAt(pos++);
				continue;
			}
			types.push(XPathParser.GREATERTHAN);
			values.push('>');
			c = s.charAt(pos++);
			continue;
		}

		if (c == '_' || Utilities.isLetter(c.charCodeAt(0))) {
			var name = c;
			c = s.charAt(pos++);
			while (Utilities.isNCNameChar(c.charCodeAt(0))) {
				name += c;
				c = s.charAt(pos++);
			}
			if (types.length > 0) {
				var last = types[types.length - 1];
				if (last != XPathParser.AT
						&& last != XPathParser.DOUBLECOLON
						&& last != XPathParser.LEFTPARENTHESIS
						&& last != XPathParser.LEFTBRACKET
						&& last != XPathParser.AND
						&& last != XPathParser.OR
						&& last != XPathParser.MOD
						&& last != XPathParser.DIV
						&& last != XPathParser.MULTIPLYOPERATOR
						&& last != XPathParser.SLASH
						&& last != XPathParser.DOUBLESLASH
						&& last != XPathParser.BAR
						&& last != XPathParser.PLUS
						&& last != XPathParser.MINUS
						&& last != XPathParser.EQUALS
						&& last != XPathParser.NOTEQUAL
						&& last != XPathParser.LESSTHAN
						&& last != XPathParser.LESSTHANOREQUAL
						&& last != XPathParser.GREATERTHAN
						&& last != XPathParser.GREATERTHANOREQUAL) {
					if (name == "and") {
						types.push(XPathParser.AND);
						values.push(name);
						continue;
					}
					if (name == "or") {
						types.push(XPathParser.OR);
						values.push(name);
						continue;
					}
					if (name == "mod") {
						types.push(XPathParser.MOD);
						values.push(name);
						continue;
					}
					if (name == "div") {
						types.push(XPathParser.DIV);
						values.push(name);
						continue;
					}
				}
			}
			if (c == ':') {
				if (s.charAt(pos) == '*') {
					types.push(XPathParser.NCNAMECOLONASTERISK);
					values.push(name + ":*");
					pos++;
					c = s.charAt(pos++);
					continue;
				}
				if (s.charAt(pos) == '_' || Utilities.isLetter(s.charCodeAt(pos))) {
					name += ':';
					c = s.charAt(pos++);
					while (Utilities.isNCNameChar(c.charCodeAt(0))) {
						name += c;
						c = s.charAt(pos++);
					}
					if (c == '(') {
						types.push(XPathParser.FUNCTIONNAME);
						values.push(name);
						continue;
					}
					types.push(XPathParser.QNAME);
					values.push(name);
					continue;
				}
				if (s.charAt(pos) == ':') {
					types.push(XPathParser.AXISNAME);
					values.push(name);
					continue;
				}
			}
			if (c == '(') {
				if (name == "comment" || name == "text" || name == "node") {
					types.push(XPathParser.NODETYPE);
					values.push(name);
					continue;
				}
				if (name == "processing-instruction") {
					if (s.charAt(pos) == ')') {
						types.push(XPathParser.NODETYPE);
					} else {
						types.push(XPathParser.PROCESSINGINSTRUCTIONWITHLITERAL);
					}
					values.push(name);
					continue;
				}
				types.push(XPathParser.FUNCTIONNAME);
				values.push(name);
				continue;
			}
			types.push(XPathParser.QNAME);
			values.push(name);
			continue;
		}

		throw new Error("Unexpected character " + c);
	}
	types.push(1);
	values.push("[EOF]");
	return [types, values];
};

XPathParser.SHIFT = 's';
XPathParser.REDUCE = 'r';
XPathParser.ACCEPT = 'a';

XPathParser.prototype.parse = function(s) {
	var types;
	var values;
	var res = this.tokenize(s);
	if (res == undefined) {
		return undefined;
	}
	types = res[0];
	values = res[1];
	var tokenPos = 0;
	var state = [];
	var tokenType = [];
	var tokenValue = [];
	var s;
	var a;
	var t;

	state.push(0);
	tokenType.push(1);
	tokenValue.push("_S");

	a = types[tokenPos];
	t = values[tokenPos++];
	while (1) {
		s = state[state.length - 1];
		switch (XPathParser.actionTable[s].charAt(a - 1)) {
			case XPathParser.SHIFT:
				tokenType.push(-a);
				tokenValue.push(t);
				state.push(XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32);
				a = types[tokenPos];
				t = values[tokenPos++];
				break;
			case XPathParser.REDUCE:
				var num = XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][1];
				var rhs = [];
				for (var i = 0; i < num; i++) {
					tokenType.pop();
					rhs.unshift(tokenValue.pop());
					state.pop();
				}
				var s_ = state[state.length - 1];
				tokenType.push(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0]);
				if (this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32] == undefined) {
					tokenValue.push(rhs[0]);
				} else {
					tokenValue.push(this.reduceActions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32](rhs));
				}
				state.push(XPathParser.gotoTable[s_].charCodeAt(XPathParser.productions[XPathParser.actionTableNumber[s].charCodeAt(a - 1) - 32][0] - 2) - 33);
				break;
			case XPathParser.ACCEPT:
				return new XPath(tokenValue.pop());
			default:
				throw new Error("XPath parse error");
		}
	}
};

// XPath /////////////////////////////////////////////////////////////////////

XPath.prototype = new Object();
XPath.prototype.constructor = XPath;
XPath.superclass = Object.prototype;

function XPath(e) {
	this.expression = e;
}

XPath.prototype.toString = function() {
	return this.expression.toString();
};

function setIfUnset(obj, prop, value) {
	if (!(prop in obj)) {
		obj[prop] = value;
	}
}

XPath.prototype.evaluate = function(c) {
	c.contextNode = c.expressionContextNode;
	c.contextSize = 1;
	c.contextPosition = 1;

	// [2017-11-25] Removed usage of .implementation.hasFeature() since it does
	//              not reliably detect HTML DOMs (always returns false in xmldom and true in browsers)
	if (c.isHtml) {
		setIfUnset(c, 'caseInsensitive', true);
		setIfUnset(c, 'allowAnyNamespaceForNoPrefix', true);
	}
	
    setIfUnset(c, 'caseInsensitive', false);

	return this.expression.evaluate(c);
};

XPath.XML_NAMESPACE_URI = "http://www.w3.org/XML/1998/namespace";
XPath.XMLNS_NAMESPACE_URI = "http://www.w3.org/2000/xmlns/";

// Expression ////////////////////////////////////////////////////////////////

Expression.prototype = new Object();
Expression.prototype.constructor = Expression;
Expression.superclass = Object.prototype;

function Expression() {
}

Expression.prototype.init = function() {
};

Expression.prototype.toString = function() {
	return "<Expression>";
};

Expression.prototype.evaluate = function(c) {
	throw new Error("Could not evaluate expression.");
};

// UnaryOperation ////////////////////////////////////////////////////////////

UnaryOperation.prototype = new Expression();
UnaryOperation.prototype.constructor = UnaryOperation;
UnaryOperation.superclass = Expression.prototype;

function UnaryOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryOperation.prototype.init = function(rhs) {
	this.rhs = rhs;
};

// UnaryMinusOperation ///////////////////////////////////////////////////////

UnaryMinusOperation.prototype = new UnaryOperation();
UnaryMinusOperation.prototype.constructor = UnaryMinusOperation;
UnaryMinusOperation.superclass = UnaryOperation.prototype;

function UnaryMinusOperation(rhs) {
	if (arguments.length > 0) {
		this.init(rhs);
	}
}

UnaryMinusOperation.prototype.init = function(rhs) {
	UnaryMinusOperation.superclass.init.call(this, rhs);
};

UnaryMinusOperation.prototype.evaluate = function(c) {
	return this.rhs.evaluate(c).number().negate();
};

UnaryMinusOperation.prototype.toString = function() {
	return "-" + this.rhs.toString();
};

// BinaryOperation ///////////////////////////////////////////////////////////

BinaryOperation.prototype = new Expression();
BinaryOperation.prototype.constructor = BinaryOperation;
BinaryOperation.superclass = Expression.prototype;

function BinaryOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BinaryOperation.prototype.init = function(lhs, rhs) {
	this.lhs = lhs;
	this.rhs = rhs;
};

// OrOperation ///////////////////////////////////////////////////////////////

OrOperation.prototype = new BinaryOperation();
OrOperation.prototype.constructor = OrOperation;
OrOperation.superclass = BinaryOperation.prototype;

function OrOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

OrOperation.prototype.init = function(lhs, rhs) {
	OrOperation.superclass.init.call(this, lhs, rhs);
};

OrOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " or " + this.rhs.toString() + ")";
};

OrOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// AndOperation //////////////////////////////////////////////////////////////

AndOperation.prototype = new BinaryOperation();
AndOperation.prototype.constructor = AndOperation;
AndOperation.superclass = BinaryOperation.prototype;

function AndOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

AndOperation.prototype.init = function(lhs, rhs) {
	AndOperation.superclass.init.call(this, lhs, rhs);
};

AndOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " and " + this.rhs.toString() + ")";
};

AndOperation.prototype.evaluate = function(c) {
	var b = this.lhs.evaluate(c).bool();
	if (!b.booleanValue()) {
		return b;
	}
	return this.rhs.evaluate(c).bool();
};

// EqualsOperation ///////////////////////////////////////////////////////////

EqualsOperation.prototype = new BinaryOperation();
EqualsOperation.prototype.constructor = EqualsOperation;
EqualsOperation.superclass = BinaryOperation.prototype;

function EqualsOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

EqualsOperation.prototype.init = function(lhs, rhs) {
	EqualsOperation.superclass.init.call(this, lhs, rhs);
};

EqualsOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " = " + this.rhs.toString() + ")";
};

EqualsOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).equals(this.rhs.evaluate(c));
};

// NotEqualOperation /////////////////////////////////////////////////////////

NotEqualOperation.prototype = new BinaryOperation();
NotEqualOperation.prototype.constructor = NotEqualOperation;
NotEqualOperation.superclass = BinaryOperation.prototype;

function NotEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

NotEqualOperation.prototype.init = function(lhs, rhs) {
	NotEqualOperation.superclass.init.call(this, lhs, rhs);
};

NotEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " != " + this.rhs.toString() + ")";
};

NotEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).notequal(this.rhs.evaluate(c));
};

// LessThanOperation /////////////////////////////////////////////////////////

LessThanOperation.prototype = new BinaryOperation();
LessThanOperation.prototype.constructor = LessThanOperation;
LessThanOperation.superclass = BinaryOperation.prototype;

function LessThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOperation.prototype.init = function(lhs, rhs) {
	LessThanOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthan(this.rhs.evaluate(c));
};

LessThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " < " + this.rhs.toString() + ")";
};

// GreaterThanOperation //////////////////////////////////////////////////////

GreaterThanOperation.prototype = new BinaryOperation();
GreaterThanOperation.prototype.constructor = GreaterThanOperation;
GreaterThanOperation.superclass = BinaryOperation.prototype;

function GreaterThanOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthan(this.rhs.evaluate(c));
};

GreaterThanOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " > " + this.rhs.toString() + ")";
};

// LessThanOrEqualOperation //////////////////////////////////////////////////

LessThanOrEqualOperation.prototype = new BinaryOperation();
LessThanOrEqualOperation.prototype.constructor = LessThanOrEqualOperation;
LessThanOrEqualOperation.superclass = BinaryOperation.prototype;

function LessThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

LessThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	LessThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

LessThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).lessthanorequal(this.rhs.evaluate(c));
};

LessThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " <= " + this.rhs.toString() + ")";
};

// GreaterThanOrEqualOperation ///////////////////////////////////////////////

GreaterThanOrEqualOperation.prototype = new BinaryOperation();
GreaterThanOrEqualOperation.prototype.constructor = GreaterThanOrEqualOperation;
GreaterThanOrEqualOperation.superclass = BinaryOperation.prototype;

function GreaterThanOrEqualOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

GreaterThanOrEqualOperation.prototype.init = function(lhs, rhs) {
	GreaterThanOrEqualOperation.superclass.init.call(this, lhs, rhs);
};

GreaterThanOrEqualOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).greaterthanorequal(this.rhs.evaluate(c));
};

GreaterThanOrEqualOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " >= " + this.rhs.toString() + ")";
};

// PlusOperation /////////////////////////////////////////////////////////////

PlusOperation.prototype = new BinaryOperation();
PlusOperation.prototype.constructor = PlusOperation;
PlusOperation.superclass = BinaryOperation.prototype;

function PlusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

PlusOperation.prototype.init = function(lhs, rhs) {
	PlusOperation.superclass.init.call(this, lhs, rhs);
};

PlusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().plus(this.rhs.evaluate(c).number());
};

PlusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " + " + this.rhs.toString() + ")";
};

// MinusOperation ////////////////////////////////////////////////////////////

MinusOperation.prototype = new BinaryOperation();
MinusOperation.prototype.constructor = MinusOperation;
MinusOperation.superclass = BinaryOperation.prototype;

function MinusOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MinusOperation.prototype.init = function(lhs, rhs) {
	MinusOperation.superclass.init.call(this, lhs, rhs);
};

MinusOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().minus(this.rhs.evaluate(c).number());
};

MinusOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " - " + this.rhs.toString() + ")";
};

// MultiplyOperation /////////////////////////////////////////////////////////

MultiplyOperation.prototype = new BinaryOperation();
MultiplyOperation.prototype.constructor = MultiplyOperation;
MultiplyOperation.superclass = BinaryOperation.prototype;

function MultiplyOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

MultiplyOperation.prototype.init = function(lhs, rhs) {
	MultiplyOperation.superclass.init.call(this, lhs, rhs);
};

MultiplyOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().multiply(this.rhs.evaluate(c).number());
};

MultiplyOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " * " + this.rhs.toString() + ")";
};

// DivOperation //////////////////////////////////////////////////////////////

DivOperation.prototype = new BinaryOperation();
DivOperation.prototype.constructor = DivOperation;
DivOperation.superclass = BinaryOperation.prototype;

function DivOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

DivOperation.prototype.init = function(lhs, rhs) {
	DivOperation.superclass.init.call(this, lhs, rhs);
};

DivOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().div(this.rhs.evaluate(c).number());
};

DivOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " div " + this.rhs.toString() + ")";
};

// ModOperation //////////////////////////////////////////////////////////////

ModOperation.prototype = new BinaryOperation();
ModOperation.prototype.constructor = ModOperation;
ModOperation.superclass = BinaryOperation.prototype;

function ModOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

ModOperation.prototype.init = function(lhs, rhs) {
	ModOperation.superclass.init.call(this, lhs, rhs);
};

ModOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).number().mod(this.rhs.evaluate(c).number());
};

ModOperation.prototype.toString = function() {
	return "(" + this.lhs.toString() + " mod " + this.rhs.toString() + ")";
};

// BarOperation //////////////////////////////////////////////////////////////

BarOperation.prototype = new BinaryOperation();
BarOperation.prototype.constructor = BarOperation;
BarOperation.superclass = BinaryOperation.prototype;

function BarOperation(lhs, rhs) {
	if (arguments.length > 0) {
		this.init(lhs, rhs);
	}
}

BarOperation.prototype.init = function(lhs, rhs) {
	BarOperation.superclass.init.call(this, lhs, rhs);
};

BarOperation.prototype.evaluate = function(c) {
	return this.lhs.evaluate(c).nodeset().union(this.rhs.evaluate(c).nodeset());
};

BarOperation.prototype.toString = function() {
	return map(toString, [this.lhs, this.rhs]).join(' | ');
};

// PathExpr //////////////////////////////////////////////////////////////////

PathExpr.prototype = new Expression();
PathExpr.prototype.constructor = PathExpr;
PathExpr.superclass = Expression.prototype;

function PathExpr(filter, filterPreds, locpath) {
	if (arguments.length > 0) {
		this.init(filter, filterPreds, locpath);
	}
}

PathExpr.prototype.init = function(filter, filterPreds, locpath) {
	PathExpr.superclass.init.call(this);
	this.filter = filter;
	this.filterPredicates = filterPreds;
	this.locationPath = locpath;
};

/**
 * Returns the topmost node of the tree containing node
 */
function findRoot(node) {
    while (node && node.parentNode) {
        node = node.parentNode;
    }

    return node;
}

PathExpr.applyPredicates = function (predicates, c, nodes) {
	return reduce(function (inNodes, pred) {
		var ctx = c.extend({ contextSize: inNodes.length });
		
		return filter(function (node, i) {
			return PathExpr.predicateMatches(pred, ctx.extend({ contextNode: node, contextPosition: i + 1 }));
		}, inNodes);
	}, nodes, predicates);
};

PathExpr.getRoot = function (xpc, nodes) {
	var firstNode = nodes[0];
	
    if (firstNode.nodeType === 9 /*Node.DOCUMENT_NODE*/) {
		return firstNode;
	}
	
    if (xpc.virtualRoot) {
    	return xpc.virtualRoot;
    }
		
	var ownerDoc = firstNode.ownerDocument;
	
	if (ownerDoc) {
		return ownerDoc;
	}
			
    // IE 5.5 doesn't have ownerDocument?
    var n = firstNode;
    while (n.parentNode != null) {
    	n = n.parentNode;
    }
    return n;
}

PathExpr.applyStep = function (step, xpc, node) {
	var self = this;
	var newNodes = [];
    xpc.contextNode = node;
    
    switch (step.axis) {
    	case Step.ANCESTOR:
    		// look at all the ancestor nodes
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		var m;
    		if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
    			m = PathExpr.getOwnerElement(xpc.contextNode);
    		} else {
    			m = xpc.contextNode.parentNode;
    		}
    		while (m != null) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    			if (m === xpc.virtualRoot) {
    				break;
    			}
    			m = m.parentNode;
    		}
    		break;
    
    	case Step.ANCESTORORSELF:
    		// look at all the ancestor nodes and the current node
    		for (var m = xpc.contextNode; m != null; m = m.nodeType == 2 /*Node.ATTRIBUTE_NODE*/ ? PathExpr.getOwnerElement(m) : m.parentNode) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    			if (m === xpc.virtualRoot) {
    				break;
    			}
    		}
    		break;
    
    	case Step.ATTRIBUTE:
    		// look at the attributes
    		var nnm = xpc.contextNode.attributes;
    		if (nnm != null) {
    			for (var k = 0; k < nnm.length; k++) {
    				var m = nnm.item(k);
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    			}
    		}
    		break;
    
    	case Step.CHILD:
    		// look at all child elements
    		for (var m = xpc.contextNode.firstChild; m != null; m = m.nextSibling) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    		}
    		break;
    
    	case Step.DESCENDANT:
    		// look at all descendant nodes
    		var st = [ xpc.contextNode.firstChild ];
    		while (st.length > 0) {
    			for (var m = st.pop(); m != null; ) {
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		}
    		break;
    
    	case Step.DESCENDANTORSELF:
    		// look at self
    		if (step.nodeTest.matches(xpc.contextNode, xpc)) {
    			newNodes.push(xpc.contextNode);
    		}
    		// look at all descendant nodes
    		var st = [ xpc.contextNode.firstChild ];
    		while (st.length > 0) {
    			for (var m = st.pop(); m != null; ) {
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		}
    		break;
    
    	case Step.FOLLOWING:
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		var st = [];
    		if (xpc.contextNode.firstChild != null) {
    			st.unshift(xpc.contextNode.firstChild);
    		} else {
    			st.unshift(xpc.contextNode.nextSibling);
    		}
    		for (var m = xpc.contextNode.parentNode; m != null && m.nodeType != 9 /*Node.DOCUMENT_NODE*/ && m !== xpc.virtualRoot; m = m.parentNode) {
    			st.unshift(m.nextSibling);
    		}
    		do {
    			for (var m = st.pop(); m != null; ) {
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.push(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		} while (st.length > 0);
    		break;
    
    	case Step.FOLLOWINGSIBLING:
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		for (var m = xpc.contextNode.nextSibling; m != null; m = m.nextSibling) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    		}
    		break;
    
    	case Step.NAMESPACE:
    		var n = {};
    		if (xpc.contextNode.nodeType == 1 /*Node.ELEMENT_NODE*/) {
    			n["xml"] = XPath.XML_NAMESPACE_URI;
    			n["xmlns"] = XPath.XMLNS_NAMESPACE_URI;
    			for (var m = xpc.contextNode; m != null && m.nodeType == 1 /*Node.ELEMENT_NODE*/; m = m.parentNode) {
    				for (var k = 0; k < m.attributes.length; k++) {
    					var attr = m.attributes.item(k);
    					var nm = String(attr.name);
    					if (nm == "xmlns") {
    						if (n[""] == undefined) {
    							n[""] = attr.value;
    						}
    					} else if (nm.length > 6 && nm.substring(0, 6) == "xmlns:") {
    						var pre = nm.substring(6, nm.length);
    						if (n[pre] == undefined) {
    							n[pre] = attr.value;
    						}
    					}
    				}
    			}
    			for (var pre in n) {
    				var nsn = new XPathNamespace(pre, n[pre], xpc.contextNode);
    				if (step.nodeTest.matches(nsn, xpc)) {
    					newNodes.push(nsn);
    				}
    			}
    		}
    		break;
    
    	case Step.PARENT:
    		m = null;
    		if (xpc.contextNode !== xpc.virtualRoot) {
    			if (xpc.contextNode.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
    				m = PathExpr.getOwnerElement(xpc.contextNode);
    			} else {
    				m = xpc.contextNode.parentNode;
    			}
    		}
    		if (m != null && step.nodeTest.matches(m, xpc)) {
    			newNodes.push(m);
    		}
    		break;
    
    	case Step.PRECEDING:
    		var st;
    		if (xpc.virtualRoot != null) {
    			st = [ xpc.virtualRoot ];
    		} else {
                // cannot rely on .ownerDocument because the node may be in a document fragment
                st = [findRoot(xpc.contextNode)];
    		}
    		outer: while (st.length > 0) {
    			for (var m = st.pop(); m != null; ) {
    				if (m == xpc.contextNode) {
    					break outer;
    				}
    				if (step.nodeTest.matches(m, xpc)) {
    					newNodes.unshift(m);
    				}
    				if (m.firstChild != null) {
    					st.push(m.nextSibling);
    					m = m.firstChild;
    				} else {
    					m = m.nextSibling;
    				}
    			}
    		}
    		break;
    
    	case Step.PRECEDINGSIBLING:
    		if (xpc.contextNode === xpc.virtualRoot) {
    			break;
    		}
    		for (var m = xpc.contextNode.previousSibling; m != null; m = m.previousSibling) {
    			if (step.nodeTest.matches(m, xpc)) {
    				newNodes.push(m);
    			}
    		}
    		break;
    
    	case Step.SELF:
    		if (step.nodeTest.matches(xpc.contextNode, xpc)) {
    			newNodes.push(xpc.contextNode);
    		}
    		break;
    
    	default:
    }
	
	return newNodes;
};

PathExpr.applySteps = function (steps, xpc, nodes) {
	return reduce(function (inNodes, step) {
		return [].concat.apply([], map(function (node) {
			return PathExpr.applyPredicates(step.predicates, xpc, PathExpr.applyStep(step, xpc, node));
		}, inNodes));
	}, nodes, steps);
}

PathExpr.prototype.applyFilter = function(c, xpc) {
	if (!this.filter) {
		return { nodes: [ c.contextNode ] };
	}
	
	var ns = this.filter.evaluate(c);

	if (!Utilities.instance_of(ns, XNodeSet)) {
        if (this.filterPredicates != null && this.filterPredicates.length > 0 || this.locationPath != null) {
		    throw new Error("Path expression filter must evaluate to a nodeset if predicates or location path are used");
		}

		return { nonNodes: ns };
	}
	
	return { 
	    nodes: PathExpr.applyPredicates(this.filterPredicates || [], xpc, ns.toUnsortedArray())
	};
};

PathExpr.applyLocationPath = function (locationPath, xpc, nodes) {
	if (!locationPath) {
		return nodes;
	}
	
	var startNodes = locationPath.absolute ? [ PathExpr.getRoot(xpc, nodes) ] : nodes;
		
    return PathExpr.applySteps(locationPath.steps, xpc, startNodes);
};

PathExpr.prototype.evaluate = function(c) {
	var xpc = assign(new XPathContext(), c);
	
    var filterResult = this.applyFilter(c, xpc);
	
	if ('nonNodes' in filterResult) {
		return filterResult.nonNodes;
	}	
	
	var ns = new XNodeSet();
	ns.addArray(PathExpr.applyLocationPath(this.locationPath, xpc, filterResult.nodes));
	return ns;
};

PathExpr.predicateMatches = function(pred, c) {
	var res = pred.evaluate(c);
	
	return Utilities.instance_of(res, XNumber)
		? c.contextPosition == res.numberValue()
		: res.booleanValue();
};

PathExpr.predicateString = compose(wrap('[', ']'), toString);
PathExpr.predicatesString = compose(join(''), map(PathExpr.predicateString));

PathExpr.prototype.toString = function() {
	if (this.filter != undefined) {
		var filterStr = toString(this.filter);

		if (Utilities.instance_of(this.filter, XString)) {
			return wrap("'", "'", filterStr);
		}
		if (this.filterPredicates != undefined && this.filterPredicates.length) {
			return wrap('(', ')', filterStr) + 
			    PathExpr.predicatesString(this.filterPredicates);
		}
		if (this.locationPath != undefined) {
			return filterStr + 
			    (this.locationPath.absolute ? '' : '/') +
				toString(this.locationPath);
		}

		return filterStr;
	}

	return toString(this.locationPath);
};

PathExpr.getOwnerElement = function(n) {
	// DOM 2 has ownerElement
	if (n.ownerElement) {
		return n.ownerElement;
	}
	// DOM 1 Internet Explorer can use selectSingleNode (ironically)
	try {
		if (n.selectSingleNode) {
			return n.selectSingleNode("..");
		}
	} catch (e) {
	}
	// Other DOM 1 implementations must use this egregious search
	var doc = n.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? n
			: n.ownerDocument;
	var elts = doc.getElementsByTagName("*");
	for (var i = 0; i < elts.length; i++) {
		var elt = elts.item(i);
		var nnm = elt.attributes;
		for (var j = 0; j < nnm.length; j++) {
			var an = nnm.item(j);
			if (an === n) {
				return elt;
			}
		}
	}
	return null;
};

// LocationPath //////////////////////////////////////////////////////////////

LocationPath.prototype = new Object();
LocationPath.prototype.constructor = LocationPath;
LocationPath.superclass = Object.prototype;

function LocationPath(abs, steps) {
	if (arguments.length > 0) {
		this.init(abs, steps);
	}
}

LocationPath.prototype.init = function(abs, steps) {
	this.absolute = abs;
	this.steps = steps;
};

LocationPath.prototype.toString = function() {
	return (
	    (this.absolute ? '/' : '') +
		map(toString, this.steps).join('/')
    );
};

// Step //////////////////////////////////////////////////////////////////////

Step.prototype = new Object();
Step.prototype.constructor = Step;
Step.superclass = Object.prototype;

function Step(axis, nodetest, preds) {
	if (arguments.length > 0) {
		this.init(axis, nodetest, preds);
	}
}

Step.prototype.init = function(axis, nodetest, preds) {
	this.axis = axis;
	this.nodeTest = nodetest;
	this.predicates = preds;
};

Step.prototype.toString = function() {
	return Step.STEPNAMES[this.axis] +
        "::" +
        this.nodeTest.toString() +
	    PathExpr.predicatesString(this.predicates);
};


Step.ANCESTOR = 0;
Step.ANCESTORORSELF = 1;
Step.ATTRIBUTE = 2;
Step.CHILD = 3;
Step.DESCENDANT = 4;
Step.DESCENDANTORSELF = 5;
Step.FOLLOWING = 6;
Step.FOLLOWINGSIBLING = 7;
Step.NAMESPACE = 8;
Step.PARENT = 9;
Step.PRECEDING = 10;
Step.PRECEDINGSIBLING = 11;
Step.SELF = 12;

Step.STEPNAMES = reduce(function (acc, x) { return acc[x[0]] = x[1], acc; }, {}, [
	[Step.ANCESTOR, 'ancestor'],
	[Step.ANCESTORORSELF, 'ancestor-or-self'],
	[Step.ATTRIBUTE, 'attribute'],
	[Step.CHILD, 'child'],
	[Step.DESCENDANT, 'descendant'],
	[Step.DESCENDANTORSELF, 'descendant-or-self'],
	[Step.FOLLOWING, 'following'],
	[Step.FOLLOWINGSIBLING, 'following-sibling'],
	[Step.NAMESPACE, 'namespace'],
	[Step.PARENT, 'parent'],
	[Step.PRECEDING, 'preceding'],
	[Step.PRECEDINGSIBLING, 'preceding-sibling'],
	[Step.SELF, 'self']
  ]);
  
// NodeTest //////////////////////////////////////////////////////////////////

NodeTest.prototype = new Object();
NodeTest.prototype.constructor = NodeTest;
NodeTest.superclass = Object.prototype;

function NodeTest(type, value) {
	if (arguments.length > 0) {
		this.init(type, value);
	}
}

NodeTest.prototype.init = function(type, value) {
	this.type = type;
	this.value = value;
};

NodeTest.prototype.toString = function() {
	return "<unknown nodetest type>";
};

NodeTest.prototype.matches = function (n, xpc) {
    console.warn('unknown node test type');
};

NodeTest.NAMETESTANY = 0;
NodeTest.NAMETESTPREFIXANY = 1;
NodeTest.NAMETESTQNAME = 2;
NodeTest.COMMENT = 3;
NodeTest.TEXT = 4;
NodeTest.PI = 5;
NodeTest.NODE = 6;

NodeTest.isNodeType = function (types){
	return compose(includes(types), prop('nodeType'));
};

NodeTest.makeNodeTestType = function (type, members, ctor) {
	var newType = ctor || function () {};
	
	newType.prototype = new NodeTest(members.type);
	newType.prototype.constructor = type;
	
	for (var key in members) {
		newType.prototype[key] = members[key];
	}
	
	return newType;
};
// create invariant node test for certain node types
NodeTest.makeNodeTypeTest = function (type, nodeTypes, stringVal) {
	return new (NodeTest.makeNodeTestType(type, {
		matches: NodeTest.isNodeType(nodeTypes),
		toString: always(stringVal)
	}))();
};

NodeTest.hasPrefix = function (node) {
	return node.prefix || (node.nodeName || node.tagName).indexOf(':') !== -1;
};

NodeTest.isElementOrAttribute = NodeTest.isNodeType([1, 2]);
NodeTest.nameSpaceMatches = function (prefix, xpc, n) {
	var nNamespace = (n.namespaceURI || '');
	
	if (!prefix) { 
	    return !nNamespace || (xpc.allowAnyNamespaceForNoPrefix && !NodeTest.hasPrefix(n)); 
	}
	
    var ns = xpc.namespaceResolver.getNamespace(prefix, xpc.expressionContextNode);

	if (ns == null) {
        throw new Error("Cannot resolve QName " + prefix);
    }

    return ns === nNamespace;
};
NodeTest.localNameMatches = function (localName, xpc, n) {
	var nLocalName = (n.localName || n.nodeName);
	
	return xpc.caseInsensitive
	    ? localName.toLowerCase() === nLocalName.toLowerCase()
		: localName === nLocalName;
};

NodeTest.NameTestPrefixAny = NodeTest.makeNodeTestType(NodeTest.NAMETESTPREFIXANY, {
	matches: function (n, xpc){
        return NodeTest.isElementOrAttribute(n) && 
		    NodeTest.nameSpaceMatches(this.prefix, xpc, n);
	},
	toString: function () {
		return this.prefix + ":*";
	}
}, function (prefix) { this.prefix = prefix; });

NodeTest.NameTestQName = NodeTest.makeNodeTestType(NodeTest.NAMETESTQNAME, {
	matches: function (n, xpc) {
		return NodeTest.isNodeType([1, 2, XPathNamespace.XPATH_NAMESPACE_NODE])(n) &&
		    NodeTest.nameSpaceMatches(this.prefix, xpc, n) &&
            NodeTest.localNameMatches(this.localName, xpc, n);
	},
	toString: function () {
        return this.name;
	}
}, function (name) { 
    var nameParts = name.split(':');
	
	this.name = name;
	this.prefix = nameParts.length > 1 ? nameParts[0] : null;
	this.localName = nameParts[nameParts.length > 1 ? 1 : 0];
});

NodeTest.PITest = NodeTest.makeNodeTestType(NodeTest.PI, {
	matches: function (n, xpc) {
		return NodeTest.isNodeType([7])(n) && (n.target || n.nodeName) === this.name;
	},
	toString: function () {
        return wrap('processing-instruction("', '")', this.name);
	}
}, function (name) { this.name = name; })

// singletons

// elements, attributes, namespaces
NodeTest.nameTestAny = NodeTest.makeNodeTypeTest(NodeTest.NAMETESTANY, [1, 2, XPathNamespace.XPATH_NAMESPACE_NODE], '*');
// text, cdata
NodeTest.textTest = NodeTest.makeNodeTypeTest(NodeTest.TEXT, [3, 4], 'text()');
NodeTest.commentTest = NodeTest.makeNodeTypeTest(NodeTest.COMMENT, [8], 'comment()');
// elements, attributes, text, cdata, PIs, comments, document nodes
NodeTest.nodeTest = NodeTest.makeNodeTypeTest(NodeTest.NODE, [1, 2, 3, 4, 7, 8, 9], 'node()');
NodeTest.anyPiTest = NodeTest.makeNodeTypeTest(NodeTest.PI, [7], 'processing-instruction()');

// VariableReference /////////////////////////////////////////////////////////

VariableReference.prototype = new Expression();
VariableReference.prototype.constructor = VariableReference;
VariableReference.superclass = Expression.prototype;

function VariableReference(v) {
	if (arguments.length > 0) {
		this.init(v);
	}
}

VariableReference.prototype.init = function(v) {
	this.variable = v;
};

VariableReference.prototype.toString = function() {
	return "$" + this.variable;
};

VariableReference.prototype.evaluate = function(c) {
    var parts = Utilities.resolveQName(this.variable, c.namespaceResolver, c.contextNode, false);

    if (parts[0] == null) {
        throw new Error("Cannot resolve QName " + fn);
    }
	var result = c.variableResolver.getVariable(parts[1], parts[0]);
    if (!result) {
        throw XPathException.fromMessage("Undeclared variable: " + this.toString());
    }
    return result;
};

// FunctionCall //////////////////////////////////////////////////////////////

FunctionCall.prototype = new Expression();
FunctionCall.prototype.constructor = FunctionCall;
FunctionCall.superclass = Expression.prototype;

function FunctionCall(fn, args) {
	if (arguments.length > 0) {
		this.init(fn, args);
	}
}

FunctionCall.prototype.init = function(fn, args) {
	this.functionName = fn;
	this.arguments = args;
};

FunctionCall.prototype.toString = function() {
	var s = this.functionName + "(";
	for (var i = 0; i < this.arguments.length; i++) {
		if (i > 0) {
			s += ", ";
		}
		s += this.arguments[i].toString();
	}
	return s + ")";
};

FunctionCall.prototype.evaluate = function(c) {
    var f = FunctionResolver.getFunctionFromContext(this.functionName, c);

    if (!f) {
		throw new Error("Unknown function " + this.functionName);
	}

    var a = [c].concat(this.arguments);
	return f.apply(c.functionResolver.thisArg, a);
};

// Operators /////////////////////////////////////////////////////////////////

var Operators = new Object();

Operators.equals = function(l, r) {
	return l.equals(r);
};

Operators.notequal = function(l, r) {
	return l.notequal(r);
};

Operators.lessthan = function(l, r) {
	return l.lessthan(r);
};

Operators.greaterthan = function(l, r) {
	return l.greaterthan(r);
};

Operators.lessthanorequal = function(l, r) {
	return l.lessthanorequal(r);
};

Operators.greaterthanorequal = function(l, r) {
	return l.greaterthanorequal(r);
};

// XString ///////////////////////////////////////////////////////////////////

XString.prototype = new Expression();
XString.prototype.constructor = XString;
XString.superclass = Expression.prototype;

function XString(s) {
	if (arguments.length > 0) {
		this.init(s);
	}
}

XString.prototype.init = function(s) {
	this.str = String(s);
};

XString.prototype.toString = function() {
	return this.str;
};

XString.prototype.evaluate = function(c) {
	return this;
};

XString.prototype.string = function() {
	return this;
};

XString.prototype.number = function() {
	return new XNumber(this.str);
};

XString.prototype.bool = function() {
	return new XBoolean(this.str);
};

XString.prototype.nodeset = function() {
	throw new Error("Cannot convert string to nodeset");
};

XString.prototype.stringValue = function() {
	return this.str;
};

XString.prototype.numberValue = function() {
	return this.number().numberValue();
};

XString.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XString.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().equals(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.equals);
	}
	return new XBoolean(this.str == r.str);
};

XString.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.number().notequal(r);
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithString(this, Operators.notequal);
	}
	return new XBoolean(this.str != r.str);
};

XString.prototype.lessthan = function(r) {
	return this.number().lessthan(r);
};

XString.prototype.greaterthan = function(r) {
	return this.number().greaterthan(r);
};

XString.prototype.lessthanorequal = function(r) {
	return this.number().lessthanorequal(r);
};

XString.prototype.greaterthanorequal = function(r) {
	return this.number().greaterthanorequal(r);
};

// XNumber ///////////////////////////////////////////////////////////////////

XNumber.prototype = new Expression();
XNumber.prototype.constructor = XNumber;
XNumber.superclass = Expression.prototype;

function XNumber(n) {
	if (arguments.length > 0) {
		this.init(n);
	}
}

XNumber.prototype.init = function(n) {
	this.num = typeof n === "string" ? this.parse(n) : Number(n);
};

XNumber.prototype.numberFormat = /^\s*-?[0-9]*\.?[0-9]+\s*$/;

XNumber.prototype.parse = function(s) {
    // XPath representation of numbers is more restrictive than what Number() or parseFloat() allow
    return this.numberFormat.test(s) ? parseFloat(s) : Number.NaN;
};

function padSmallNumber(numberStr) {
	var parts = numberStr.split('e-');
	var base = parts[0].replace('.', '');
	var exponent = Number(parts[1]);
	
	for (var i = 0; i < exponent - 1; i += 1) {
		base = '0' + base;
	}
	
	return '0.' + base;
}

function padLargeNumber(numberStr) {
	var parts = numberStr.split('e');
	var base = parts[0].replace('.', '');
	var exponent = Number(parts[1]);
	var zerosToAppend = exponent + 1 - base.length;
	
	for (var i = 0; i < zerosToAppend; i += 1){
		base += '0';
	}
	
	return base;
}

XNumber.prototype.toString = function() {
	var strValue = this.num.toString();

	if (strValue.indexOf('e-') !== -1) {
		return padSmallNumber(strValue);
	}
    
	if (strValue.indexOf('e') !== -1) {
		return padLargeNumber(strValue);
	}
	
	return strValue;
};

XNumber.prototype.evaluate = function(c) {
	return this;
};

XNumber.prototype.string = function() {
	
	
	return new XString(this.toString());
};

XNumber.prototype.number = function() {
	return this;
};

XNumber.prototype.bool = function() {
	return new XBoolean(this.num);
};

XNumber.prototype.nodeset = function() {
	throw new Error("Cannot convert number to nodeset");
};

XNumber.prototype.stringValue = function() {
	return this.string().stringValue();
};

XNumber.prototype.numberValue = function() {
	return this.num;
};

XNumber.prototype.booleanValue = function() {
	return this.bool().booleanValue();
};

XNumber.prototype.negate = function() {
	return new XNumber(-this.num);
};

XNumber.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().equals(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.equals(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.equals);
	}
	return new XBoolean(this.num == r.num);
};

XNumber.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XBoolean)) {
		return this.bool().notequal(r);
	}
	if (Utilities.instance_of(r, XString)) {
		return this.notequal(r.number());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.notequal);
	}
	return new XBoolean(this.num != r.num);
};

XNumber.prototype.lessthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthan(r.number());
	}
	return new XBoolean(this.num < r.num);
};

XNumber.prototype.greaterthan = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthan);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthan(r.number());
	}
	return new XBoolean(this.num > r.num);
};

XNumber.prototype.lessthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.greaterthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.lessthanorequal(r.number());
	}
	return new XBoolean(this.num <= r.num);
};

XNumber.prototype.greaterthanorequal = function(r) {
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithNumber(this, Operators.lessthanorequal);
	}
	if (Utilities.instance_of(r, XBoolean) || Utilities.instance_of(r, XString)) {
		return this.greaterthanorequal(r.number());
	}
	return new XBoolean(this.num >= r.num);
};

XNumber.prototype.plus = function(r) {
	return new XNumber(this.num + r.num);
};

XNumber.prototype.minus = function(r) {
	return new XNumber(this.num - r.num);
};

XNumber.prototype.multiply = function(r) {
	return new XNumber(this.num * r.num);
};

XNumber.prototype.div = function(r) {
	return new XNumber(this.num / r.num);
};

XNumber.prototype.mod = function(r) {
	return new XNumber(this.num % r.num);
};

// XBoolean //////////////////////////////////////////////////////////////////

XBoolean.prototype = new Expression();
XBoolean.prototype.constructor = XBoolean;
XBoolean.superclass = Expression.prototype;

function XBoolean(b) {
	if (arguments.length > 0) {
		this.init(b);
	}
}

XBoolean.prototype.init = function(b) {
	this.b = Boolean(b);
};

XBoolean.prototype.toString = function() {
	return this.b.toString();
};

XBoolean.prototype.evaluate = function(c) {
	return this;
};

XBoolean.prototype.string = function() {
	return new XString(this.b);
};

XBoolean.prototype.number = function() {
	return new XNumber(this.b);
};

XBoolean.prototype.bool = function() {
	return this;
};

XBoolean.prototype.nodeset = function() {
	throw new Error("Cannot convert boolean to nodeset");
};

XBoolean.prototype.stringValue = function() {
	return this.string().stringValue();
};

XBoolean.prototype.numberValue = function() {
	return this.number().numberValue();
};

XBoolean.prototype.booleanValue = function() {
	return this.b;
};

XBoolean.prototype.not = function() {
	return new XBoolean(!this.b);
};

XBoolean.prototype.equals = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.equals(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.equals);
	}
	return new XBoolean(this.b == r.b);
};

XBoolean.prototype.notequal = function(r) {
	if (Utilities.instance_of(r, XString) || Utilities.instance_of(r, XNumber)) {
		return this.notequal(r.bool());
	}
	if (Utilities.instance_of(r, XNodeSet)) {
		return r.compareWithBoolean(this, Operators.notequal);
	}
	return new XBoolean(this.b != r.b);
};

XBoolean.prototype.lessthan = function(r) {
	return this.number().lessthan(r);
};

XBoolean.prototype.greaterthan = function(r) {
	return this.number().greaterthan(r);
};

XBoolean.prototype.lessthanorequal = function(r) {
	return this.number().lessthanorequal(r);
};

XBoolean.prototype.greaterthanorequal = function(r) {
	return this.number().greaterthanorequal(r);
};

XBoolean.true_ = new XBoolean(true);
XBoolean.false_ = new XBoolean(false);

// AVLTree ///////////////////////////////////////////////////////////////////

AVLTree.prototype = new Object();
AVLTree.prototype.constructor = AVLTree;
AVLTree.superclass = Object.prototype;

function AVLTree(n) {
	this.init(n);
}

AVLTree.prototype.init = function(n) {
	this.left = null;
    this.right = null;
	this.node = n;
	this.depth = 1;
};

AVLTree.prototype.balance = function() {
    var ldepth = this.left  == null ? 0 : this.left.depth;
    var rdepth = this.right == null ? 0 : this.right.depth;

	if (ldepth > rdepth + 1) {
        // LR or LL rotation
        var lldepth = this.left.left  == null ? 0 : this.left.left.depth;
        var lrdepth = this.left.right == null ? 0 : this.left.right.depth;

        if (lldepth < lrdepth) {
            // LR rotation consists of a RR rotation of the left child
            this.left.rotateRR();
            // plus a LL rotation of this node, which happens anyway
        }
        this.rotateLL();
    } else if (ldepth + 1 < rdepth) {
        // RR or RL rorarion
		var rrdepth = this.right.right == null ? 0 : this.right.right.depth;
		var rldepth = this.right.left  == null ? 0 : this.right.left.depth;

        if (rldepth > rrdepth) {
            // RR rotation consists of a LL rotation of the right child
            this.right.rotateLL();
            // plus a RR rotation of this node, which happens anyway
        }
        this.rotateRR();
    }
};

AVLTree.prototype.rotateLL = function() {
    // the left side is too long => rotate from the left (_not_ leftwards)
    var nodeBefore = this.node;
    var rightBefore = this.right;
    this.node = this.left.node;
    this.right = this.left;
    this.left = this.left.left;
    this.right.left = this.right.right;
    this.right.right = rightBefore;
    this.right.node = nodeBefore;
    this.right.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.rotateRR = function() {
    // the right side is too long => rotate from the right (_not_ rightwards)
    var nodeBefore = this.node;
    var leftBefore = this.left;
    this.node = this.right.node;
    this.left = this.right;
    this.right = this.right.right;
    this.left.right = this.left.left;
    this.left.left = leftBefore;
    this.left.node = nodeBefore;
    this.left.updateInNewLocation();
    this.updateInNewLocation();
};

AVLTree.prototype.updateInNewLocation = function() {
    this.getDepthFromChildren();
};

AVLTree.prototype.getDepthFromChildren = function() {
    this.depth = this.node == null ? 0 : 1;
    if (this.left != null) {
        this.depth = this.left.depth + 1;
    }
    if (this.right != null && this.depth <= this.right.depth) {
        this.depth = this.right.depth + 1;
    }
};

function nodeOrder(n1, n2) {
	if (n1 === n2) {
		return 0;
	}

	if (n1.compareDocumentPosition) {
	    var cpos = n1.compareDocumentPosition(n2);

        if (cpos & 0x01) {
            // not in the same document; return an arbitrary result (is there a better way to do this)
            return 1;
        }
        if (cpos & 0x0A) {
            // n2 precedes or contains n1
            return 1;
        }
        if (cpos & 0x14) {
            // n2 follows or is contained by n1
            return -1;
        }

	    return 0;
	}

	var d1 = 0,
	    d2 = 0;
	for (var m1 = n1; m1 != null; m1 = m1.parentNode || m1.ownerElement) {
		d1++;
	}
	for (var m2 = n2; m2 != null; m2 = m2.parentNode || m2.ownerElement) {
		d2++;
	}

    // step up to same depth
	if (d1 > d2) {
		while (d1 > d2) {
			n1 = n1.parentNode || n1.ownerElement;
			d1--;
		}
		if (n1 === n2) {
			return 1;
		}
	} else if (d2 > d1) {
		while (d2 > d1) {
			n2 = n2.parentNode || n2.ownerElement;
			d2--;
		}
		if (n1 === n2) {
			return -1;
		}
	}

    var n1Par = n1.parentNode || n1.ownerElement,
        n2Par = n2.parentNode || n2.ownerElement;

    // find common parent
	while (n1Par !== n2Par) {
		n1 = n1Par;
		n2 = n2Par;
		n1Par = n1.parentNode || n1.ownerElement;
	    n2Par = n2.parentNode || n2.ownerElement;
	}
    
    var n1isAttr = Utilities.isAttribute(n1);
    var n2isAttr = Utilities.isAttribute(n2);
    
    if (n1isAttr && !n2isAttr) {
        return -1;
    }
    if (!n1isAttr && n2isAttr) {
        return 1;
    }
    
    if(n1Par) {
	    var cn = n1isAttr ? n1Par.attributes : n1Par.childNodes,
	        len = cn.length;
        for (var i = 0; i < len; i += 1) {
            var n = cn[i];
            if (n === n1) {
                return -1;
            }
            if (n === n2) {
                return 1;
            }
        }
    }        
    
    throw new Error('Unexpected: could not determine node order');
}

AVLTree.prototype.add = function(n)  {
	if (n === this.node) {
        return false;
    }

	var o = nodeOrder(n, this.node);

    var ret = false;
    if (o == -1) {
        if (this.left == null) {
            this.left = new AVLTree(n);
            ret = true;
        } else {
            ret = this.left.add(n);
            if (ret) {
                this.balance();
            }
        }
    } else if (o == 1) {
        if (this.right == null) {
            this.right = new AVLTree(n);
            ret = true;
        } else {
            ret = this.right.add(n);
            if (ret) {
                this.balance();
            }
        }
    }

    if (ret) {
        this.getDepthFromChildren();
    }
    return ret;
};

// XNodeSet //////////////////////////////////////////////////////////////////

XNodeSet.prototype = new Expression();
XNodeSet.prototype.constructor = XNodeSet;
XNodeSet.superclass = Expression.prototype;

function XNodeSet() {
	this.init();
}

XNodeSet.prototype.init = function() {
    this.tree = null;
	this.nodes = [];
	this.size = 0;
};

XNodeSet.prototype.toString = function() {
	var p = this.first();
	if (p == null) {
		return "";
	}
	return this.stringForNode(p);
};

XNodeSet.prototype.evaluate = function(c) {
	return this;
};

XNodeSet.prototype.string = function() {
	return new XString(this.toString());
};

XNodeSet.prototype.stringValue = function() {
	return this.toString();
};

XNodeSet.prototype.number = function() {
	return new XNumber(this.string());
};

XNodeSet.prototype.numberValue = function() {
	return Number(this.string());
};

XNodeSet.prototype.bool = function() {
	return new XBoolean(this.booleanValue());
};

XNodeSet.prototype.booleanValue = function() {
	return !!this.size;
};

XNodeSet.prototype.nodeset = function() {
	return this;
};

XNodeSet.prototype.stringForNode = function(n) {
	if (n.nodeType == 9   /*Node.DOCUMENT_NODE*/ || 
        n.nodeType == 1   /*Node.ELEMENT_NODE */ || 
        n.nodeType === 11 /*Node.DOCUMENT_FRAGMENT*/) {
		return this.stringForContainerNode(n);
	}
    if (n.nodeType === 2 /* Node.ATTRIBUTE_NODE */) {
        return n.value || n.nodeValue;
    }
	if (n.isNamespaceNode) {
		return n.namespace;
	}
	return n.nodeValue;
};

XNodeSet.prototype.stringForContainerNode = function(n) {
	var s = "";
	for (var n2 = n.firstChild; n2 != null; n2 = n2.nextSibling) {
        var nt = n2.nodeType;
        //  Element,    Text,       CDATA,      Document,   Document Fragment
        if (nt === 1 || nt === 3 || nt === 4 || nt === 9 || nt === 11) {
            s += this.stringForNode(n2);
        }
	}
	return s;
};

XNodeSet.prototype.buildTree = function () {
    if (!this.tree && this.nodes.length) {
        this.tree = new AVLTree(this.nodes[0]);
        for (var i = 1; i < this.nodes.length; i += 1) {
            this.tree.add(this.nodes[i]);
        }
    }

    return this.tree;
};

XNodeSet.prototype.first = function() {
	var p = this.buildTree();
	if (p == null) {
		return null;
	}
	while (p.left != null) {
		p = p.left;
	}
	return p.node;
};

XNodeSet.prototype.add = function(n) {
    for (var i = 0; i < this.nodes.length; i += 1) {
        if (n === this.nodes[i]) {
            return;
        }
    }

    this.tree = null;
    this.nodes.push(n);
    this.size += 1;
};

XNodeSet.prototype.addArray = function(ns) {
	var self = this;
	
	forEach(function (x) { self.add(x); }, ns);
};

/**
 * Returns an array of the node set's contents in document order
 */
XNodeSet.prototype.toArray = function() {
	var a = [];
	this.toArrayRec(this.buildTree(), a);
	return a;
};

XNodeSet.prototype.toArrayRec = function(t, a) {
	if (t != null) {
		this.toArrayRec(t.left, a);
		a.push(t.node);
		this.toArrayRec(t.right, a);
	}
};

/**
 * Returns an array of the node set's contents in arbitrary order
 */
XNodeSet.prototype.toUnsortedArray = function () {
    return this.nodes.slice();
};

XNodeSet.prototype.compareWithString = function(r, o) {
	var a = this.toUnsortedArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XString(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithNumber = function(r, o) {
	var a = this.toUnsortedArray();
	for (var i = 0; i < a.length; i++) {
		var n = a[i];
		var l = new XNumber(this.stringForNode(n));
		var res = o(l, r);
		if (res.booleanValue()) {
			return res;
		}
	}
	return new XBoolean(false);
};

XNodeSet.prototype.compareWithBoolean = function(r, o) {
	return o(this.bool(), r);
};

XNodeSet.prototype.compareWithNodeSet = function(r, o) {
	var arr = this.toUnsortedArray();
	var oInvert = function (lop, rop) { return o(rop, lop); };
	
	for (var i = 0; i < arr.length; i++) {
		var l = new XString(this.stringForNode(arr[i]));

		var res = r.compareWithString(l, oInvert);
		if (res.booleanValue()) {
			return res;
		}
	}
	
	return new XBoolean(false);
};

XNodeSet.compareWith = curry(function (o, r) {
	if (Utilities.instance_of(r, XString)) {
		return this.compareWithString(r, o);
	}
	if (Utilities.instance_of(r, XNumber)) {
		return this.compareWithNumber(r, o);
	}
	if (Utilities.instance_of(r, XBoolean)) {
		return this.compareWithBoolean(r, o);
	}
	return this.compareWithNodeSet(r, o);
});

XNodeSet.prototype.equals = XNodeSet.compareWith(Operators.equals);
XNodeSet.prototype.notequal = XNodeSet.compareWith(Operators.notequal);
XNodeSet.prototype.lessthan = XNodeSet.compareWith(Operators.lessthan);
XNodeSet.prototype.greaterthan = XNodeSet.compareWith(Operators.greaterthan);
XNodeSet.prototype.lessthanorequal = XNodeSet.compareWith(Operators.lessthanorequal);
XNodeSet.prototype.greaterthanorequal = XNodeSet.compareWith(Operators.greaterthanorequal);

XNodeSet.prototype.union = function(r) {
	var ns = new XNodeSet();
    ns.addArray(this.toUnsortedArray());
	ns.addArray(r.toUnsortedArray());
	return ns;
};

// XPathNamespace ////////////////////////////////////////////////////////////

XPathNamespace.prototype = new Object();
XPathNamespace.prototype.constructor = XPathNamespace;
XPathNamespace.superclass = Object.prototype;

function XPathNamespace(pre, ns, p) {
	this.isXPathNamespace = true;
	this.ownerDocument = p.ownerDocument;
	this.nodeName = "#namespace";
	this.prefix = pre;
	this.localName = pre;
	this.namespaceURI = ns;
	this.nodeValue = ns;
	this.ownerElement = p;
	this.nodeType = XPathNamespace.XPATH_NAMESPACE_NODE;
}

XPathNamespace.prototype.toString = function() {
	return "{ \"" + this.prefix + "\", \"" + this.namespaceURI + "\" }";
};

// XPathContext //////////////////////////////////////////////////////////////

XPathContext.prototype = new Object();
XPathContext.prototype.constructor = XPathContext;
XPathContext.superclass = Object.prototype;

function XPathContext(vr, nr, fr) {
	this.variableResolver = vr != null ? vr : new VariableResolver();
	this.namespaceResolver = nr != null ? nr : new NamespaceResolver();
	this.functionResolver = fr != null ? fr : new FunctionResolver();
}

XPathContext.prototype.extend = function (newProps) {
	return assign(new XPathContext(), this, newProps);
};

// VariableResolver //////////////////////////////////////////////////////////

VariableResolver.prototype = new Object();
VariableResolver.prototype.constructor = VariableResolver;
VariableResolver.superclass = Object.prototype;

function VariableResolver() {
}

VariableResolver.prototype.getVariable = function(ln, ns) {
	return null;
};

// FunctionResolver //////////////////////////////////////////////////////////

FunctionResolver.prototype = new Object();
FunctionResolver.prototype.constructor = FunctionResolver;
FunctionResolver.superclass = Object.prototype;

function FunctionResolver(thisArg) {
	this.thisArg = thisArg != null ? thisArg : Functions;
	this.functions = new Object();
	this.addStandardFunctions();
}

FunctionResolver.prototype.addStandardFunctions = function() {
	this.functions["{}last"] = Functions.last;
	this.functions["{}position"] = Functions.position;
	this.functions["{}count"] = Functions.count;
	this.functions["{}id"] = Functions.id;
	this.functions["{}local-name"] = Functions.localName;
	this.functions["{}namespace-uri"] = Functions.namespaceURI;
	this.functions["{}name"] = Functions.name;
	this.functions["{}string"] = Functions.string;
	this.functions["{}concat"] = Functions.concat;
	this.functions["{}starts-with"] = Functions.startsWith;
	this.functions["{}contains"] = Functions.contains;
	this.functions["{}substring-before"] = Functions.substringBefore;
	this.functions["{}substring-after"] = Functions.substringAfter;
	this.functions["{}substring"] = Functions.substring;
	this.functions["{}string-length"] = Functions.stringLength;
	this.functions["{}normalize-space"] = Functions.normalizeSpace;
	this.functions["{}translate"] = Functions.translate;
	this.functions["{}boolean"] = Functions.boolean_;
	this.functions["{}not"] = Functions.not;
	this.functions["{}true"] = Functions.true_;
	this.functions["{}false"] = Functions.false_;
	this.functions["{}lang"] = Functions.lang;
	this.functions["{}number"] = Functions.number;
	this.functions["{}sum"] = Functions.sum;
	this.functions["{}floor"] = Functions.floor;
	this.functions["{}ceiling"] = Functions.ceiling;
	this.functions["{}round"] = Functions.round;
};

FunctionResolver.prototype.addFunction = function(ns, ln, f) {
	this.functions["{" + ns + "}" + ln] = f;
};

FunctionResolver.getFunctionFromContext = function(qName, context) {
    var parts = Utilities.resolveQName(qName, context.namespaceResolver, context.contextNode, false);

    if (parts[0] === null) {
        throw new Error("Cannot resolve QName " + name);
    }

    return context.functionResolver.getFunction(parts[1], parts[0]);
};

FunctionResolver.prototype.getFunction = function(localName, namespace) {
	return this.functions["{" + namespace + "}" + localName];
};

// NamespaceResolver /////////////////////////////////////////////////////////

NamespaceResolver.prototype = new Object();
NamespaceResolver.prototype.constructor = NamespaceResolver;
NamespaceResolver.superclass = Object.prototype;

function NamespaceResolver() {
}

NamespaceResolver.prototype.getNamespace = function(prefix, n) {
	if (prefix == "xml") {
		return XPath.XML_NAMESPACE_URI;
	} else if (prefix == "xmlns") {
		return XPath.XMLNS_NAMESPACE_URI;
	}
	if (n.nodeType == 9 /*Node.DOCUMENT_NODE*/) {
		n = n.documentElement;
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		n = PathExpr.getOwnerElement(n);
	} else if (n.nodeType != 1 /*Node.ELEMENT_NODE*/) {
		n = n.parentNode;
	}
	while (n != null && n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		var nnm = n.attributes;
		for (var i = 0; i < nnm.length; i++) {
			var a = nnm.item(i);
			var aname = a.name || a.nodeName;
			if ((aname === "xmlns" && prefix === "")
					|| aname === "xmlns:" + prefix) {
				return String(a.value || a.nodeValue);
			}
		}
		n = n.parentNode;
	}
	return null;
};

// Functions /////////////////////////////////////////////////////////////////

var Functions = new Object();

Functions.last = function(c) {
	if (arguments.length != 1) {
		throw new Error("Function last expects ()");
	}

	return new XNumber(c.contextSize);
};

Functions.position = function(c) {
	if (arguments.length != 1) {
		throw new Error("Function position expects ()");
	}

	return new XNumber(c.contextPosition);
};

Functions.count = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of(ns = arguments[1].evaluate(c), XNodeSet)) {
		throw new Error("Function count expects (node-set)");
	}
	return new XNumber(ns.size);
};

Functions.id = function() {
	var c = arguments[0];
	var id;
	if (arguments.length != 2) {
		throw new Error("Function id expects (object)");
	}
	id = arguments[1].evaluate(c);
	if (Utilities.instance_of(id, XNodeSet)) {
		id = id.toArray().join(" ");
	} else {
		id = id.stringValue();
	}
	var ids = id.split(/[\x0d\x0a\x09\x20]+/);
	var count = 0;
	var ns = new XNodeSet();
	var doc = c.contextNode.nodeType == 9 /*Node.DOCUMENT_NODE*/
			? c.contextNode
			: c.contextNode.ownerDocument;
	for (var i = 0; i < ids.length; i++) {
		var n;
		if (doc.getElementById) {
			n = doc.getElementById(ids[i]);
		} else {
			n = Utilities.getElementById(doc, ids[i]);
		}
		if (n != null) {
			ns.add(n);
			count++;
		}
	}
	return ns;
};

Functions.localName = function(c, eNode) {
	var n;
	
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = eNode.evaluate(c).first();
	} else {
		throw new Error("Function local-name expects (node-set?)");
	}
	
	if (n == null) {
		return new XString("");
	}

	return new XString(n.localName ||     //  standard elements and attributes
	                   n.baseName  ||     //  IE
					   n.target    ||     //  processing instructions
                       n.nodeName  ||     //  DOM1 elements
					   "");               //  fallback
};

Functions.namespaceURI = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function namespace-uri expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	return new XString(n.namespaceURI);
};

Functions.name = function() {
	var c = arguments[0];
	var n;
	if (arguments.length == 1) {
		n = c.contextNode;
	} else if (arguments.length == 2) {
		n = arguments[1].evaluate(c).first();
	} else {
		throw new Error("Function name expects (node-set?)");
	}
	if (n == null) {
		return new XString("");
	}
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		return new XString(n.nodeName);
	} else if (n.nodeType == 2 /*Node.ATTRIBUTE_NODE*/) {
		return new XString(n.name || n.nodeName);
	} else if (n.nodeType === 7 /*Node.PROCESSING_INSTRUCTION_NODE*/) {
	    return new XString(n.target || n.nodeName);
	} else if (n.localName == null) {
		return new XString("");
	} else {
		return new XString(n.localName);
	}
};

Functions.string = function() {
	var c = arguments[0];
	if (arguments.length == 1) {
		return new XString(XNodeSet.prototype.stringForNode(c.contextNode));
	} else if (arguments.length == 2) {
		return arguments[1].evaluate(c).string();
	}
	throw new Error("Function string expects (object?)");
};

Functions.concat = function(c) {
	if (arguments.length < 3) {
		throw new Error("Function concat expects (string, string[, string]*)");
	}
	var s = "";
	for (var i = 1; i < arguments.length; i++) {
		s += arguments[i].evaluate(c).stringValue();
	}
	return new XString(s);
};

Functions.startsWith = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function startsWith expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.substring(0, s2.length) == s2);
};

Functions.contains = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function contains expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XBoolean(s1.indexOf(s2) !== -1);
};

Functions.substringBefore = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-before expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	return new XString(s1.substring(0, s1.indexOf(s2)));
};

Functions.substringAfter = function() {
	var c = arguments[0];
	if (arguments.length != 3) {
		throw new Error("Function substring-after expects (string, string)");
	}
	var s1 = arguments[1].evaluate(c).stringValue();
	var s2 = arguments[2].evaluate(c).stringValue();
	if (s2.length == 0) {
		return new XString(s1);
	}
	var i = s1.indexOf(s2);
	if (i == -1) {
		return new XString("");
	}
	return new XString(s1.substring(i + s2.length));
};

Functions.substring = function() {
	var c = arguments[0];
	if (!(arguments.length == 3 || arguments.length == 4)) {
		throw new Error("Function substring expects (string, number, number?)");
	}
	var s = arguments[1].evaluate(c).stringValue();
	var n1 = Math.round(arguments[2].evaluate(c).numberValue()) - 1;
	var n2 = arguments.length == 4 ? n1 + Math.round(arguments[3].evaluate(c).numberValue()) : undefined;
	return new XString(s.substring(n1, n2));
};

Functions.stringLength = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function string-length expects (string?)");
	}
	return new XNumber(s.length);
};

Functions.normalizeSpace = function() {
	var c = arguments[0];
	var s;
	if (arguments.length == 1) {
		s = XNodeSet.prototype.stringForNode(c.contextNode);
	} else if (arguments.length == 2) {
		s = arguments[1].evaluate(c).stringValue();
	} else {
		throw new Error("Function normalize-space expects (string?)");
	}
	var i = 0;
	var j = s.length - 1;
	while (Utilities.isSpace(s.charCodeAt(j))) {
		j--;
	}
	var t = "";
	while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
		i++;
	}
	while (i <= j) {
		if (Utilities.isSpace(s.charCodeAt(i))) {
			t += " ";
			while (i <= j && Utilities.isSpace(s.charCodeAt(i))) {
				i++;
			}
		} else {
			t += s.charAt(i);
			i++;
		}
	}
	return new XString(t);
};

Functions.translate = function(c, eValue, eFrom, eTo) {
	if (arguments.length != 4) {
		throw new Error("Function translate expects (string, string, string)");
	}

	var value = eValue.evaluate(c).stringValue();
	var from = eFrom.evaluate(c).stringValue();
	var to = eTo.evaluate(c).stringValue();
	
	var cMap = reduce(function (acc, ch, i) {
		if (!(ch in acc)) {
			acc[ch] = i > to.length ? '' : to[i];
		}
		return acc;
	}, {}, from);

    var t = join('', map(function (ch) {
        return ch in cMap ? cMap[ch] : ch;
    }, value));

	return new XString(t);
};

Functions.boolean_ = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function boolean expects (object)");
	}
	return arguments[1].evaluate(c).bool();
};

Functions.not = function(c, eValue) {
	if (arguments.length != 2) {
		throw new Error("Function not expects (object)");
	}
	return eValue.evaluate(c).bool().not();
};

Functions.true_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function true expects ()");
	}
	return XBoolean.true_;
};

Functions.false_ = function() {
	if (arguments.length != 1) {
		throw new Error("Function false expects ()");
	}
	return XBoolean.false_;
};

Functions.lang = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function lang expects (string)");
	}
	var lang;
	for (var n = c.contextNode; n != null && n.nodeType != 9 /*Node.DOCUMENT_NODE*/; n = n.parentNode) {
		var a = n.getAttributeNS(XPath.XML_NAMESPACE_URI, "lang");
		if (a != null) {
			lang = String(a);
			break;
		}
	}
	if (lang == null) {
		return XBoolean.false_;
	}
	var s = arguments[1].evaluate(c).stringValue();
	return new XBoolean(lang.substring(0, s.length) == s
				&& (lang.length == s.length || lang.charAt(s.length) == '-'));
};

Functions.number = function() {
	var c = arguments[0];
	if (!(arguments.length == 1 || arguments.length == 2)) {
		throw new Error("Function number expects (object?)");
	}
	if (arguments.length == 1) {
		return new XNumber(XNodeSet.prototype.stringForNode(c.contextNode));
	}
	return arguments[1].evaluate(c).number();
};

Functions.sum = function() {
	var c = arguments[0];
	var ns;
	if (arguments.length != 2 || !Utilities.instance_of((ns = arguments[1].evaluate(c)), XNodeSet)) {
		throw new Error("Function sum expects (node-set)");
	}
	ns = ns.toUnsortedArray();
	var n = 0;
	for (var i = 0; i < ns.length; i++) {
		n += new XNumber(XNodeSet.prototype.stringForNode(ns[i])).numberValue();
	}
	return new XNumber(n);
};

Functions.floor = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function floor expects (number)");
	}
	return new XNumber(Math.floor(arguments[1].evaluate(c).numberValue()));
};

Functions.ceiling = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function ceiling expects (number)");
	}
	return new XNumber(Math.ceil(arguments[1].evaluate(c).numberValue()));
};

Functions.round = function() {
	var c = arguments[0];
	if (arguments.length != 2) {
		throw new Error("Function round expects (number)");
	}
	return new XNumber(Math.round(arguments[1].evaluate(c).numberValue()));
};

// Utilities /////////////////////////////////////////////////////////////////

var Utilities = new Object();

Utilities.isAttribute = function (val) {
    return val && (val.nodeType === 2 || val.ownerElement);
}

Utilities.splitQName = function(qn) {
	var i = qn.indexOf(":");
	if (i == -1) {
		return [ null, qn ];
	}
	return [ qn.substring(0, i), qn.substring(i + 1) ];
};

Utilities.resolveQName = function(qn, nr, n, useDefault) {
	var parts = Utilities.splitQName(qn);
	if (parts[0] != null) {
		parts[0] = nr.getNamespace(parts[0], n);
	} else {
		if (useDefault) {
			parts[0] = nr.getNamespace("", n);
			if (parts[0] == null) {
				parts[0] = "";
			}
		} else {
			parts[0] = "";
		}
	}
	return parts;
};

Utilities.isSpace = function(c) {
	return c == 0x9 || c == 0xd || c == 0xa || c == 0x20;
};

Utilities.isLetter = function(c) {
	return c >= 0x0041 && c <= 0x005A ||
		c >= 0x0061 && c <= 0x007A ||
		c >= 0x00C0 && c <= 0x00D6 ||
		c >= 0x00D8 && c <= 0x00F6 ||
		c >= 0x00F8 && c <= 0x00FF ||
		c >= 0x0100 && c <= 0x0131 ||
		c >= 0x0134 && c <= 0x013E ||
		c >= 0x0141 && c <= 0x0148 ||
		c >= 0x014A && c <= 0x017E ||
		c >= 0x0180 && c <= 0x01C3 ||
		c >= 0x01CD && c <= 0x01F0 ||
		c >= 0x01F4 && c <= 0x01F5 ||
		c >= 0x01FA && c <= 0x0217 ||
		c >= 0x0250 && c <= 0x02A8 ||
		c >= 0x02BB && c <= 0x02C1 ||
		c == 0x0386 ||
		c >= 0x0388 && c <= 0x038A ||
		c == 0x038C ||
		c >= 0x038E && c <= 0x03A1 ||
		c >= 0x03A3 && c <= 0x03CE ||
		c >= 0x03D0 && c <= 0x03D6 ||
		c == 0x03DA ||
		c == 0x03DC ||
		c == 0x03DE ||
		c == 0x03E0 ||
		c >= 0x03E2 && c <= 0x03F3 ||
		c >= 0x0401 && c <= 0x040C ||
		c >= 0x040E && c <= 0x044F ||
		c >= 0x0451 && c <= 0x045C ||
		c >= 0x045E && c <= 0x0481 ||
		c >= 0x0490 && c <= 0x04C4 ||
		c >= 0x04C7 && c <= 0x04C8 ||
		c >= 0x04CB && c <= 0x04CC ||
		c >= 0x04D0 && c <= 0x04EB ||
		c >= 0x04EE && c <= 0x04F5 ||
		c >= 0x04F8 && c <= 0x04F9 ||
		c >= 0x0531 && c <= 0x0556 ||
		c == 0x0559 ||
		c >= 0x0561 && c <= 0x0586 ||
		c >= 0x05D0 && c <= 0x05EA ||
		c >= 0x05F0 && c <= 0x05F2 ||
		c >= 0x0621 && c <= 0x063A ||
		c >= 0x0641 && c <= 0x064A ||
		c >= 0x0671 && c <= 0x06B7 ||
		c >= 0x06BA && c <= 0x06BE ||
		c >= 0x06C0 && c <= 0x06CE ||
		c >= 0x06D0 && c <= 0x06D3 ||
		c == 0x06D5 ||
		c >= 0x06E5 && c <= 0x06E6 ||
		c >= 0x0905 && c <= 0x0939 ||
		c == 0x093D ||
		c >= 0x0958 && c <= 0x0961 ||
		c >= 0x0985 && c <= 0x098C ||
		c >= 0x098F && c <= 0x0990 ||
		c >= 0x0993 && c <= 0x09A8 ||
		c >= 0x09AA && c <= 0x09B0 ||
		c == 0x09B2 ||
		c >= 0x09B6 && c <= 0x09B9 ||
		c >= 0x09DC && c <= 0x09DD ||
		c >= 0x09DF && c <= 0x09E1 ||
		c >= 0x09F0 && c <= 0x09F1 ||
		c >= 0x0A05 && c <= 0x0A0A ||
		c >= 0x0A0F && c <= 0x0A10 ||
		c >= 0x0A13 && c <= 0x0A28 ||
		c >= 0x0A2A && c <= 0x0A30 ||
		c >= 0x0A32 && c <= 0x0A33 ||
		c >= 0x0A35 && c <= 0x0A36 ||
		c >= 0x0A38 && c <= 0x0A39 ||
		c >= 0x0A59 && c <= 0x0A5C ||
		c == 0x0A5E ||
		c >= 0x0A72 && c <= 0x0A74 ||
		c >= 0x0A85 && c <= 0x0A8B ||
		c == 0x0A8D ||
		c >= 0x0A8F && c <= 0x0A91 ||
		c >= 0x0A93 && c <= 0x0AA8 ||
		c >= 0x0AAA && c <= 0x0AB0 ||
		c >= 0x0AB2 && c <= 0x0AB3 ||
		c >= 0x0AB5 && c <= 0x0AB9 ||
		c == 0x0ABD ||
		c == 0x0AE0 ||
		c >= 0x0B05 && c <= 0x0B0C ||
		c >= 0x0B0F && c <= 0x0B10 ||
		c >= 0x0B13 && c <= 0x0B28 ||
		c >= 0x0B2A && c <= 0x0B30 ||
		c >= 0x0B32 && c <= 0x0B33 ||
		c >= 0x0B36 && c <= 0x0B39 ||
		c == 0x0B3D ||
		c >= 0x0B5C && c <= 0x0B5D ||
		c >= 0x0B5F && c <= 0x0B61 ||
		c >= 0x0B85 && c <= 0x0B8A ||
		c >= 0x0B8E && c <= 0x0B90 ||
		c >= 0x0B92 && c <= 0x0B95 ||
		c >= 0x0B99 && c <= 0x0B9A ||
		c == 0x0B9C ||
		c >= 0x0B9E && c <= 0x0B9F ||
		c >= 0x0BA3 && c <= 0x0BA4 ||
		c >= 0x0BA8 && c <= 0x0BAA ||
		c >= 0x0BAE && c <= 0x0BB5 ||
		c >= 0x0BB7 && c <= 0x0BB9 ||
		c >= 0x0C05 && c <= 0x0C0C ||
		c >= 0x0C0E && c <= 0x0C10 ||
		c >= 0x0C12 && c <= 0x0C28 ||
		c >= 0x0C2A && c <= 0x0C33 ||
		c >= 0x0C35 && c <= 0x0C39 ||
		c >= 0x0C60 && c <= 0x0C61 ||
		c >= 0x0C85 && c <= 0x0C8C ||
		c >= 0x0C8E && c <= 0x0C90 ||
		c >= 0x0C92 && c <= 0x0CA8 ||
		c >= 0x0CAA && c <= 0x0CB3 ||
		c >= 0x0CB5 && c <= 0x0CB9 ||
		c == 0x0CDE ||
		c >= 0x0CE0 && c <= 0x0CE1 ||
		c >= 0x0D05 && c <= 0x0D0C ||
		c >= 0x0D0E && c <= 0x0D10 ||
		c >= 0x0D12 && c <= 0x0D28 ||
		c >= 0x0D2A && c <= 0x0D39 ||
		c >= 0x0D60 && c <= 0x0D61 ||
		c >= 0x0E01 && c <= 0x0E2E ||
		c == 0x0E30 ||
		c >= 0x0E32 && c <= 0x0E33 ||
		c >= 0x0E40 && c <= 0x0E45 ||
		c >= 0x0E81 && c <= 0x0E82 ||
		c == 0x0E84 ||
		c >= 0x0E87 && c <= 0x0E88 ||
		c == 0x0E8A ||
		c == 0x0E8D ||
		c >= 0x0E94 && c <= 0x0E97 ||
		c >= 0x0E99 && c <= 0x0E9F ||
		c >= 0x0EA1 && c <= 0x0EA3 ||
		c == 0x0EA5 ||
		c == 0x0EA7 ||
		c >= 0x0EAA && c <= 0x0EAB ||
		c >= 0x0EAD && c <= 0x0EAE ||
		c == 0x0EB0 ||
		c >= 0x0EB2 && c <= 0x0EB3 ||
		c == 0x0EBD ||
		c >= 0x0EC0 && c <= 0x0EC4 ||
		c >= 0x0F40 && c <= 0x0F47 ||
		c >= 0x0F49 && c <= 0x0F69 ||
		c >= 0x10A0 && c <= 0x10C5 ||
		c >= 0x10D0 && c <= 0x10F6 ||
		c == 0x1100 ||
		c >= 0x1102 && c <= 0x1103 ||
		c >= 0x1105 && c <= 0x1107 ||
		c == 0x1109 ||
		c >= 0x110B && c <= 0x110C ||
		c >= 0x110E && c <= 0x1112 ||
		c == 0x113C ||
		c == 0x113E ||
		c == 0x1140 ||
		c == 0x114C ||
		c == 0x114E ||
		c == 0x1150 ||
		c >= 0x1154 && c <= 0x1155 ||
		c == 0x1159 ||
		c >= 0x115F && c <= 0x1161 ||
		c == 0x1163 ||
		c == 0x1165 ||
		c == 0x1167 ||
		c == 0x1169 ||
		c >= 0x116D && c <= 0x116E ||
		c >= 0x1172 && c <= 0x1173 ||
		c == 0x1175 ||
		c == 0x119E ||
		c == 0x11A8 ||
		c == 0x11AB ||
		c >= 0x11AE && c <= 0x11AF ||
		c >= 0x11B7 && c <= 0x11B8 ||
		c == 0x11BA ||
		c >= 0x11BC && c <= 0x11C2 ||
		c == 0x11EB ||
		c == 0x11F0 ||
		c == 0x11F9 ||
		c >= 0x1E00 && c <= 0x1E9B ||
		c >= 0x1EA0 && c <= 0x1EF9 ||
		c >= 0x1F00 && c <= 0x1F15 ||
		c >= 0x1F18 && c <= 0x1F1D ||
		c >= 0x1F20 && c <= 0x1F45 ||
		c >= 0x1F48 && c <= 0x1F4D ||
		c >= 0x1F50 && c <= 0x1F57 ||
		c == 0x1F59 ||
		c == 0x1F5B ||
		c == 0x1F5D ||
		c >= 0x1F5F && c <= 0x1F7D ||
		c >= 0x1F80 && c <= 0x1FB4 ||
		c >= 0x1FB6 && c <= 0x1FBC ||
		c == 0x1FBE ||
		c >= 0x1FC2 && c <= 0x1FC4 ||
		c >= 0x1FC6 && c <= 0x1FCC ||
		c >= 0x1FD0 && c <= 0x1FD3 ||
		c >= 0x1FD6 && c <= 0x1FDB ||
		c >= 0x1FE0 && c <= 0x1FEC ||
		c >= 0x1FF2 && c <= 0x1FF4 ||
		c >= 0x1FF6 && c <= 0x1FFC ||
		c == 0x2126 ||
		c >= 0x212A && c <= 0x212B ||
		c == 0x212E ||
		c >= 0x2180 && c <= 0x2182 ||
		c >= 0x3041 && c <= 0x3094 ||
		c >= 0x30A1 && c <= 0x30FA ||
		c >= 0x3105 && c <= 0x312C ||
		c >= 0xAC00 && c <= 0xD7A3 ||
		c >= 0x4E00 && c <= 0x9FA5 ||
		c == 0x3007 ||
		c >= 0x3021 && c <= 0x3029;
};

Utilities.isNCNameChar = function(c) {
	return c >= 0x0030 && c <= 0x0039
		|| c >= 0x0660 && c <= 0x0669
		|| c >= 0x06F0 && c <= 0x06F9
		|| c >= 0x0966 && c <= 0x096F
		|| c >= 0x09E6 && c <= 0x09EF
		|| c >= 0x0A66 && c <= 0x0A6F
		|| c >= 0x0AE6 && c <= 0x0AEF
		|| c >= 0x0B66 && c <= 0x0B6F
		|| c >= 0x0BE7 && c <= 0x0BEF
		|| c >= 0x0C66 && c <= 0x0C6F
		|| c >= 0x0CE6 && c <= 0x0CEF
		|| c >= 0x0D66 && c <= 0x0D6F
		|| c >= 0x0E50 && c <= 0x0E59
		|| c >= 0x0ED0 && c <= 0x0ED9
		|| c >= 0x0F20 && c <= 0x0F29
		|| c == 0x002E
		|| c == 0x002D
		|| c == 0x005F
		|| Utilities.isLetter(c)
		|| c >= 0x0300 && c <= 0x0345
		|| c >= 0x0360 && c <= 0x0361
		|| c >= 0x0483 && c <= 0x0486
		|| c >= 0x0591 && c <= 0x05A1
		|| c >= 0x05A3 && c <= 0x05B9
		|| c >= 0x05BB && c <= 0x05BD
		|| c == 0x05BF
		|| c >= 0x05C1 && c <= 0x05C2
		|| c == 0x05C4
		|| c >= 0x064B && c <= 0x0652
		|| c == 0x0670
		|| c >= 0x06D6 && c <= 0x06DC
		|| c >= 0x06DD && c <= 0x06DF
		|| c >= 0x06E0 && c <= 0x06E4
		|| c >= 0x06E7 && c <= 0x06E8
		|| c >= 0x06EA && c <= 0x06ED
		|| c >= 0x0901 && c <= 0x0903
		|| c == 0x093C
		|| c >= 0x093E && c <= 0x094C
		|| c == 0x094D
		|| c >= 0x0951 && c <= 0x0954
		|| c >= 0x0962 && c <= 0x0963
		|| c >= 0x0981 && c <= 0x0983
		|| c == 0x09BC
		|| c == 0x09BE
		|| c == 0x09BF
		|| c >= 0x09C0 && c <= 0x09C4
		|| c >= 0x09C7 && c <= 0x09C8
		|| c >= 0x09CB && c <= 0x09CD
		|| c == 0x09D7
		|| c >= 0x09E2 && c <= 0x09E3
		|| c == 0x0A02
		|| c == 0x0A3C
		|| c == 0x0A3E
		|| c == 0x0A3F
		|| c >= 0x0A40 && c <= 0x0A42
		|| c >= 0x0A47 && c <= 0x0A48
		|| c >= 0x0A4B && c <= 0x0A4D
		|| c >= 0x0A70 && c <= 0x0A71
		|| c >= 0x0A81 && c <= 0x0A83
		|| c == 0x0ABC
		|| c >= 0x0ABE && c <= 0x0AC5
		|| c >= 0x0AC7 && c <= 0x0AC9
		|| c >= 0x0ACB && c <= 0x0ACD
		|| c >= 0x0B01 && c <= 0x0B03
		|| c == 0x0B3C
		|| c >= 0x0B3E && c <= 0x0B43
		|| c >= 0x0B47 && c <= 0x0B48
		|| c >= 0x0B4B && c <= 0x0B4D
		|| c >= 0x0B56 && c <= 0x0B57
		|| c >= 0x0B82 && c <= 0x0B83
		|| c >= 0x0BBE && c <= 0x0BC2
		|| c >= 0x0BC6 && c <= 0x0BC8
		|| c >= 0x0BCA && c <= 0x0BCD
		|| c == 0x0BD7
		|| c >= 0x0C01 && c <= 0x0C03
		|| c >= 0x0C3E && c <= 0x0C44
		|| c >= 0x0C46 && c <= 0x0C48
		|| c >= 0x0C4A && c <= 0x0C4D
		|| c >= 0x0C55 && c <= 0x0C56
		|| c >= 0x0C82 && c <= 0x0C83
		|| c >= 0x0CBE && c <= 0x0CC4
		|| c >= 0x0CC6 && c <= 0x0CC8
		|| c >= 0x0CCA && c <= 0x0CCD
		|| c >= 0x0CD5 && c <= 0x0CD6
		|| c >= 0x0D02 && c <= 0x0D03
		|| c >= 0x0D3E && c <= 0x0D43
		|| c >= 0x0D46 && c <= 0x0D48
		|| c >= 0x0D4A && c <= 0x0D4D
		|| c == 0x0D57
		|| c == 0x0E31
		|| c >= 0x0E34 && c <= 0x0E3A
		|| c >= 0x0E47 && c <= 0x0E4E
		|| c == 0x0EB1
		|| c >= 0x0EB4 && c <= 0x0EB9
		|| c >= 0x0EBB && c <= 0x0EBC
		|| c >= 0x0EC8 && c <= 0x0ECD
		|| c >= 0x0F18 && c <= 0x0F19
		|| c == 0x0F35
		|| c == 0x0F37
		|| c == 0x0F39
		|| c == 0x0F3E
		|| c == 0x0F3F
		|| c >= 0x0F71 && c <= 0x0F84
		|| c >= 0x0F86 && c <= 0x0F8B
		|| c >= 0x0F90 && c <= 0x0F95
		|| c == 0x0F97
		|| c >= 0x0F99 && c <= 0x0FAD
		|| c >= 0x0FB1 && c <= 0x0FB7
		|| c == 0x0FB9
		|| c >= 0x20D0 && c <= 0x20DC
		|| c == 0x20E1
		|| c >= 0x302A && c <= 0x302F
		|| c == 0x3099
		|| c == 0x309A
		|| c == 0x00B7
		|| c == 0x02D0
		|| c == 0x02D1
		|| c == 0x0387
		|| c == 0x0640
		|| c == 0x0E46
		|| c == 0x0EC6
		|| c == 0x3005
		|| c >= 0x3031 && c <= 0x3035
		|| c >= 0x309D && c <= 0x309E
		|| c >= 0x30FC && c <= 0x30FE;
};

Utilities.coalesceText = function(n) {
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		if (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
			var s = m.nodeValue;
			var first = m;
			m = m.nextSibling;
			while (m != null && (m.nodeType == 3 /*Node.TEXT_NODE*/ || m.nodeType == 4 /*Node.CDATA_SECTION_NODE*/)) {
				s += m.nodeValue;
				var del = m;
				m = m.nextSibling;
				del.parentNode.removeChild(del);
			}
			if (first.nodeType == 4 /*Node.CDATA_SECTION_NODE*/) {
				var p = first.parentNode;
				if (first.nextSibling == null) {
					p.removeChild(first);
					p.appendChild(p.ownerDocument.createTextNode(s));
				} else {
					var next = first.nextSibling;
					p.removeChild(first);
					p.insertBefore(p.ownerDocument.createTextNode(s), next);
				}
			} else {
				first.nodeValue = s;
			}
			if (m == null) {
				break;
			}
		} else if (m.nodeType == 1 /*Node.ELEMENT_NODE*/) {
			Utilities.coalesceText(m);
		}
	}
};

Utilities.instance_of = function(o, c) {
	while (o != null) {
		if (o.constructor === c) {
			return true;
		}
		if (o === Object) {
			return false;
		}
		o = o.constructor.superclass;
	}
	return false;
};

Utilities.getElementById = function(n, id) {
	// Note that this does not check the DTD to check for actual
	// attributes of type ID, so this may be a bit wrong.
	if (n.nodeType == 1 /*Node.ELEMENT_NODE*/) {
		if (n.getAttribute("id") == id
				|| n.getAttributeNS(null, "id") == id) {
			return n;
		}
	}
	for (var m = n.firstChild; m != null; m = m.nextSibling) {
		var res = Utilities.getElementById(m, id);
		if (res != null) {
			return res;
		}
	}
	return null;
};

// XPathException ////////////////////////////////////////////////////////////

var XPathException = (function () {
    function getMessage(code, exception) {
        var msg = exception ? ": " + exception.toString() : "";
        switch (code) {
            case XPathException.INVALID_EXPRESSION_ERR:
                return "Invalid expression" + msg;
            case XPathException.TYPE_ERR:
                return "Type error" + msg;
        }
        return null;
    }

    function XPathException(code, error, message) {
        var err = Error.call(this, getMessage(code, error) || message);

        err.code = code;
        err.exception = error;

        return err;
    }

    XPathException.prototype = Object.create(Error.prototype);
    XPathException.prototype.constructor = XPathException;
    XPathException.superclass = Error;

    XPathException.prototype.toString = function() {
        return this.message;
    };

    XPathException.fromMessage = function(message, error) {
        return new XPathException(null, error, message);
    };

    XPathException.INVALID_EXPRESSION_ERR = 51;
    XPathException.TYPE_ERR = 52;

    return XPathException;
})();

// XPathExpression ///////////////////////////////////////////////////////////

XPathExpression.prototype = {};
XPathExpression.prototype.constructor = XPathExpression;
XPathExpression.superclass = Object.prototype;

function XPathExpression(e, r, p) {
	this.xpath = p.parse(e);
	this.context = new XPathContext();
	this.context.namespaceResolver = new XPathNSResolverWrapper(r);
}

XPathExpression.getOwnerDocument = function (n) {
	return n.nodeType === 9 /*Node.DOCUMENT_NODE*/ ? n : n.ownerDocument;
}

XPathExpression.detectHtmlDom = function (n) {
	if (!n) { return false; }
	
	var doc = XPathExpression.getOwnerDocument(n);
	
	try {
		return doc.implementation.hasFeature("HTML", "2.0");
	} catch (e) {
		return true;
	}
}

XPathExpression.prototype.evaluate = function(n, t, res) {
	this.context.expressionContextNode = n;
	// backward compatibility - no reliable way to detect whether the DOM is HTML, but
	// this library has been using this method up until now, so we will continue to use it
	// ONLY when using an XPathExpression
	this.context.caseInsensitive = XPathExpression.detectHtmlDom(n);
	
	var result = this.xpath.evaluate(this.context);
	return new XPathResult(result, t);
}

// XPathNSResolverWrapper ////////////////////////////////////////////////////

XPathNSResolverWrapper.prototype = {};
XPathNSResolverWrapper.prototype.constructor = XPathNSResolverWrapper;
XPathNSResolverWrapper.superclass = Object.prototype;

function XPathNSResolverWrapper(r) {
	this.xpathNSResolver = r;
}

XPathNSResolverWrapper.prototype.getNamespace = function(prefix, n) {
    if (this.xpathNSResolver == null) {
        return null;
    }
	return this.xpathNSResolver.lookupNamespaceURI(prefix);
};

// NodeXPathNSResolver ///////////////////////////////////////////////////////

NodeXPathNSResolver.prototype = {};
NodeXPathNSResolver.prototype.constructor = NodeXPathNSResolver;
NodeXPathNSResolver.superclass = Object.prototype;

function NodeXPathNSResolver(n) {
	this.node = n;
	this.namespaceResolver = new NamespaceResolver();
}

NodeXPathNSResolver.prototype.lookupNamespaceURI = function(prefix) {
	return this.namespaceResolver.getNamespace(prefix, this.node);
};

// XPathResult ///////////////////////////////////////////////////////////////

XPathResult.prototype = {};
XPathResult.prototype.constructor = XPathResult;
XPathResult.superclass = Object.prototype;

function XPathResult(v, t) {
	if (t == XPathResult.ANY_TYPE) {
		if (v.constructor === XString) {
			t = XPathResult.STRING_TYPE;
		} else if (v.constructor === XNumber) {
			t = XPathResult.NUMBER_TYPE;
		} else if (v.constructor === XBoolean) {
			t = XPathResult.BOOLEAN_TYPE;
		} else if (v.constructor === XNodeSet) {
			t = XPathResult.UNORDERED_NODE_ITERATOR_TYPE;
		}
	}
	this.resultType = t;
	switch (t) {
		case XPathResult.NUMBER_TYPE:
			this.numberValue = v.numberValue();
			return;
		case XPathResult.STRING_TYPE:
			this.stringValue = v.stringValue();
			return;
		case XPathResult.BOOLEAN_TYPE:
			this.booleanValue = v.booleanValue();
			return;
		case XPathResult.ANY_UNORDERED_NODE_TYPE:
		case XPathResult.FIRST_ORDERED_NODE_TYPE:
			if (v.constructor === XNodeSet) {
				this.singleNodeValue = v.first();
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_ITERATOR_TYPE:
		case XPathResult.ORDERED_NODE_ITERATOR_TYPE:
			if (v.constructor === XNodeSet) {
				this.invalidIteratorState = false;
				this.nodes = v.toArray();
				this.iteratorIndex = 0;
				return;
			}
			break;
		case XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE:
		case XPathResult.ORDERED_NODE_SNAPSHOT_TYPE:
			if (v.constructor === XNodeSet) {
				this.nodes = v.toArray();
				this.snapshotLength = this.nodes.length;
				return;
			}
			break;
	}
	throw new XPathException(XPathException.TYPE_ERR);
};

XPathResult.prototype.iterateNext = function() {
	if (this.resultType != XPathResult.UNORDERED_NODE_ITERATOR_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_ITERATOR_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[this.iteratorIndex++];
};

XPathResult.prototype.snapshotItem = function(i) {
	if (this.resultType != XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE
			&& this.resultType != XPathResult.ORDERED_NODE_SNAPSHOT_TYPE) {
		throw new XPathException(XPathException.TYPE_ERR);
	}
	return this.nodes[i];
};

XPathResult.ANY_TYPE = 0;
XPathResult.NUMBER_TYPE = 1;
XPathResult.STRING_TYPE = 2;
XPathResult.BOOLEAN_TYPE = 3;
XPathResult.UNORDERED_NODE_ITERATOR_TYPE = 4;
XPathResult.ORDERED_NODE_ITERATOR_TYPE = 5;
XPathResult.UNORDERED_NODE_SNAPSHOT_TYPE = 6;
XPathResult.ORDERED_NODE_SNAPSHOT_TYPE = 7;
XPathResult.ANY_UNORDERED_NODE_TYPE = 8;
XPathResult.FIRST_ORDERED_NODE_TYPE = 9;

// DOM 3 XPath support ///////////////////////////////////////////////////////

function installDOM3XPathSupport(doc, p) {
	doc.createExpression = function(e, r) {
		try {
			return new XPathExpression(e, r, p);
		} catch (e) {
			throw new XPathException(XPathException.INVALID_EXPRESSION_ERR, e);
		}
	};
	doc.createNSResolver = function(n) {
		return new NodeXPathNSResolver(n);
	};
	doc.evaluate = function(e, cn, r, t, res) {
		if (t < 0 || t > 9) {
			throw { code: 0, toString: function() { return "Request type not supported"; } };
		}
        return doc.createExpression(e, r, p).evaluate(cn, t, res);
	};
};

// ---------------------------------------------------------------------------

// Install DOM 3 XPath support for the current document.
try {
	var shouldInstall = true;
	try {
		if (document.implementation
				&& document.implementation.hasFeature
				&& document.implementation.hasFeature("XPath", null)) {
			shouldInstall = false;
		}
	} catch (e) {
	}
	if (shouldInstall) {
		installDOM3XPathSupport(document, new XPathParser());
	}
} catch (e) {
}

// ---------------------------------------------------------------------------
// exports for node.js

installDOM3XPathSupport(exports, new XPathParser());

(function() {
    var parser = new XPathParser();

    var defaultNSResolver = new NamespaceResolver();
    var defaultFunctionResolver = new FunctionResolver();
    var defaultVariableResolver = new VariableResolver();

    function makeNSResolverFromFunction(func) {
        return {
            getNamespace: function (prefix, node) {
                var ns = func(prefix, node);

                return ns || defaultNSResolver.getNamespace(prefix, node);
            }
        };
    }

    function makeNSResolverFromObject(obj) {
        return makeNSResolverFromFunction(obj.getNamespace.bind(obj));
    }

    function makeNSResolverFromMap(map) {
        return makeNSResolverFromFunction(function (prefix) {
            return map[prefix];
        });
    }

    function makeNSResolver(resolver) {
        if (resolver && typeof resolver.getNamespace === "function") {
            return makeNSResolverFromObject(resolver);
        }

        if (typeof resolver === "function") {
            return makeNSResolverFromFunction(resolver);
        }

        // assume prefix -> uri mapping
        if (typeof resolver === "object") {
            return makeNSResolverFromMap(resolver);
        }

        return defaultNSResolver;
    }

    /** Converts native JavaScript types to their XPath library equivalent */
    function convertValue(value) {
        if (value === null ||
            typeof value === "undefined" ||
            value instanceof XString ||
            value instanceof XBoolean ||
            value instanceof XNumber ||
            value instanceof XNodeSet) {
            return value;
        }

        switch (typeof value) {
            case "string": return new XString(value);
            case "boolean": return new XBoolean(value);
            case "number": return new XNumber(value);
        }

        // assume node(s)
        var ns = new XNodeSet();
        ns.addArray([].concat(value));
        return ns;
    }

    function makeEvaluator(func) {
        return function (context) {
            var args = Array.prototype.slice.call(arguments, 1).map(function (arg) {
                return arg.evaluate(context);
            });
            var result = func.apply(this, [].concat(context, args));
            return convertValue(result);
        };
    }

    function makeFunctionResolverFromFunction(func) {
        return {
            getFunction: function (name, namespace) {
                var found = func(name, namespace);
                if (found) {
                    return makeEvaluator(found);
                }
                return defaultFunctionResolver.getFunction(name, namespace);
            }
        };
    }

    function makeFunctionResolverFromObject(obj) {
        return makeFunctionResolverFromFunction(obj.getFunction.bind(obj));
    }

    function makeFunctionResolverFromMap(map) {
        return makeFunctionResolverFromFunction(function (name) {
            return map[name];
        });
    }

    function makeFunctionResolver(resolver) {
        if (resolver && typeof resolver.getFunction === "function") {
            return makeFunctionResolverFromObject(resolver);
        }

        if (typeof resolver === "function") {
            return makeFunctionResolverFromFunction(resolver);
        }

        // assume map
        if (typeof resolver === "object") {
            return makeFunctionResolverFromMap(resolver);
        }

        return defaultFunctionResolver;
    }

    function makeVariableResolverFromFunction(func) {
        return {
            getVariable: function (name, namespace) {
                var value = func(name, namespace);
                return convertValue(value);
            }
        };
    }

    function makeVariableResolver(resolver) {
        if (resolver) {
            if (typeof resolver.getVariable === "function") {
                return makeVariableResolverFromFunction(resolver.getVariable.bind(resolver));
            }

            if (typeof resolver === "function") {
                return makeVariableResolverFromFunction(resolver);
            }

            // assume map
            if (typeof resolver === "object") {
                return makeVariableResolverFromFunction(function (name) {
                    return resolver[name];
                });
            }
        }

        return defaultVariableResolver;
    }
	
	function copyIfPresent(prop, dest, source) {
		if (prop in source) { dest[prop] = source[prop]; }
	}

    function makeContext(options) {
        var context = new XPathContext();

        if (options) {
            context.namespaceResolver = makeNSResolver(options.namespaces);
            context.functionResolver = makeFunctionResolver(options.functions);
            context.variableResolver = makeVariableResolver(options.variables);
			context.expressionContextNode = options.node;
			copyIfPresent('allowAnyNamespaceForNoPrefix', context, options);
			copyIfPresent('isHtml', context, options);
        } else {
            context.namespaceResolver = defaultNSResolver;
        }

        return context;
    }

    function evaluate(parsedExpression, options) {
        var context = makeContext(options);

        return parsedExpression.evaluate(context);
    }

    var evaluatorPrototype = {
        evaluate: function (options) {
            return evaluate(this.expression, options);
        }

        ,evaluateNumber: function (options) {
            return this.evaluate(options).numberValue();
        }

        ,evaluateString: function (options) {
            return this.evaluate(options).stringValue();
        }

        ,evaluateBoolean: function (options) {
            return this.evaluate(options).booleanValue();
        }

        ,evaluateNodeSet: function (options) {
            return this.evaluate(options).nodeset();
        }

        ,select: function (options) {
            return this.evaluateNodeSet(options).toArray()
        }

        ,select1: function (options) {
            return this.select(options)[0];
        }
    };

    function parse(xpath) {
        var parsed = parser.parse(xpath);

        return Object.create(evaluatorPrototype, {
            expression: {
                value: parsed
            }
        });
    }

    exports.parse = parse;
})();

exports.XPath = XPath;
exports.XPathParser = XPathParser;
exports.XPathResult = XPathResult;

exports.Step = Step;
exports.NodeTest = NodeTest;
exports.BarOperation = BarOperation;

exports.NamespaceResolver = NamespaceResolver;
exports.FunctionResolver = FunctionResolver;
exports.VariableResolver = VariableResolver;

exports.Utilities = Utilities;

exports.XPathContext = XPathContext;
exports.XNodeSet = XNodeSet;
exports.XBoolean = XBoolean;
exports.XString = XString;
exports.XNumber = XNumber;

// helper
exports.select = function(e, doc, single) {
	return exports.selectWithResolver(e, doc, null, single);
};

exports.useNamespaces = function(mappings) {
	var resolver = {
		mappings: mappings || {},
		lookupNamespaceURI: function(prefix) {
			return this.mappings[prefix];
		}
	};

	return function(e, doc, single) {
		return exports.selectWithResolver(e, doc, resolver, single);
	};
};

exports.selectWithResolver = function(e, doc, resolver, single) {
	var expression = new XPathExpression(e, resolver, new XPathParser());
	var type = XPathResult.ANY_TYPE;

	var result = expression.evaluate(doc, type, null);

	if (result.resultType == XPathResult.STRING_TYPE) {
		result = result.stringValue;
	}
	else if (result.resultType == XPathResult.NUMBER_TYPE) {
		result = result.numberValue;
	}
	else if (result.resultType == XPathResult.BOOLEAN_TYPE) {
		result = result.booleanValue;
	}
	else {
		result = result.nodes;
		if (single) {
			result = result[0];
		}
	}

	return result;
};

exports.select1 = function(e, doc) {
	return exports.select(e, doc, true);
};

// end non-node wrapper
})(xpath);


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/xtend/4.0.1/node_modules/xtend/immutable.js":
/*!**************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/xtend/4.0.1/node_modules/xtend/immutable.js ***!
  \**************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = extend

var hasOwnProperty = Object.prototype.hasOwnProperty;

function extend() {
    var target = {}

    for (var i = 0; i < arguments.length; i++) {
        var source = arguments[i]

        for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
                target[key] = source[key]
            }
        }
    }

    return target
}


/***/ }),

/***/ "./lib/AuthorizedClientRequestContext.js":
/*!***********************************************!*\
  !*** ./lib/AuthorizedClientRequestContext.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** Provides generic context for a server application to get details of a particular request that originated at the client.
 * This context includes an [[AccessToken]] that carries authorization information. For services that do not require authorization
 * it's sufficient to pass an instance of the base class [[ClientRequestContext]].
 * @see [ClientRequestContext rules]($docs/learning/backend/managingclientrequestcontext.md).
 * @see [[ClientRequestContext]]
 * @public
 */
class AuthorizedClientRequestContext extends bentleyjs_core_1.ClientRequestContext {
    /** Constructor
     * @beta
     */
    constructor(accessToken, activityId = bentleyjs_core_1.Guid.createValue(), applicationId = "", applicationVersion = "", sessionId = bentleyjs_core_1.Guid.empty) {
        super(activityId, applicationId, applicationVersion, sessionId);
        this.accessToken = accessToken;
    }
    /**
     * @internal
     */
    toJSON() {
        const obj = super.toJSON();
        obj.accessToken = this.accessToken;
        return obj;
    }
}
exports.AuthorizedClientRequestContext = AuthorizedClientRequestContext;


/***/ }),

/***/ "./lib/Client.js":
/*!***********************!*\
  !*** ./lib/Client.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module BaseClients */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
const Config_1 = __webpack_require__(/*! ./Config */ "./lib/Config.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ./ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const Request_1 = __webpack_require__(/*! ./Request */ "./lib/Request.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.Clients;
/**
 * Provider for default RequestOptions, used by Client to set defaults.
 * @internal
 */
class DefaultRequestOptionsProvider {
    /** Creates an instance of DefaultRequestOptionsProvider and sets up the default options. */
    constructor() {
        this._defaultOptions = {
            method: "GET",
            useCorsProxy: false,
        };
    }
    /**
     * Augments options with the provider's default values.
     * @note The options passed in override any defaults where necessary.
     * @param options Options that should be augmented.
     */
    async assignOptions(options) {
        const clonedOptions = Object.assign({}, options);
        deepAssign(options, this._defaultOptions);
        deepAssign(options, clonedOptions); // ensure the supplied options override the defaults
        return Promise.resolve();
    }
}
exports.DefaultRequestOptionsProvider = DefaultRequestOptionsProvider;
// @todo Setup a logging framework.
/**
 * Base class for all Client implementations
 * @beta
 */
class Client {
    /**  Creates an instance of Client. */
    constructor() {
    }
    /**
     * Augments request options with defaults returned by the DefaultRequestOptionsProvider.
     * @note The options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!Client._defaultRequestOptionsProvider)
            Client._defaultRequestOptionsProvider = new DefaultRequestOptionsProvider();
        return Client._defaultRequestOptionsProvider.assignOptions(options);
    }
    /**
     * Gets the URL of the service. Attempts to discover and cache the URL from the URL Discovery Service. If not
     * found uses the default URL provided by client implementations. Note that for consistency
     * sake, the URL is stripped of any trailing "/"
     * @returns URL for the service
     */
    async getUrl(requestContext) {
        if (this._url) {
            return Promise.resolve(this._url);
        }
        const urlDiscoveryClient = new UrlDiscoveryClient();
        const searchKey = this.getUrlSearchKey();
        return urlDiscoveryClient.discoverUrl(requestContext, searchKey, undefined)
            .then(async (url) => {
            this._url = url;
            return Promise.resolve(this._url); // TODO: On the server this really needs a lifetime!!
        })
            .catch(async () => {
            return Promise.reject(`Failed to discover URL for service identified by "${searchKey}"`);
        });
    }
    /** used by clients to send delete requests */
    async delete(requestContext, relativeUrlPath) {
        requestContext.enter();
        const url = await this.getUrl(requestContext) + relativeUrlPath;
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Sending DELETE request", () => ({ url }));
        const options = {
            method: "DELETE",
            headers: { authorization: requestContext.accessToken.toTokenString() },
        };
        await this.setupOptionDefaults(options);
        await Request_1.request(requestContext, url, options);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Successful DELETE request", () => ({ url }));
    }
}
exports.Client = Client;
/**
 * Error for issues with authentication.
 * @beta
 */
class AuthenticationError extends Request_1.ResponseError {
}
exports.AuthenticationError = AuthenticationError;
/**
 * Client API to discover URLs from the URL Discovery service (a.k.a. Buddi service)
 * @internal
 */
class UrlDiscoveryClient extends Client {
    /**
     * Creates an instance of UrlDiscoveryClient.
     */
    constructor() {
        super();
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return "";
    }
    /**
     * Gets the URL for the discovery service
     * @returns URL of the discovery service.
     */
    async getUrl() {
        return Promise.resolve(Config_1.Config.App.getString(UrlDiscoveryClient.configURL, "https://buddi.bentley.com/WebService"));
    }
    /**
     * Discovers a URL given the search key.
     * @param searchKey Search key registered for the service.
     * @param regionId Override region to use for URL discovery.
     * @returns Registered URL for the service.
     */
    async discoverUrl(requestContext, searchKey, regionId) {
        requestContext.enter();
        const url = await this.getUrl() + "/GetUrl/";
        const resolvedRegion = typeof regionId !== "undefined" ? regionId : Config_1.Config.App.getNumber(UrlDiscoveryClient.configResolveUrlUsingRegion, 0);
        const options = {
            method: "GET",
            qs: {
                url: searchKey,
                region: resolvedRegion,
            },
        };
        await this.setupOptionDefaults(options);
        requestContext.enter();
        const response = await Request_1.request(requestContext, url, options);
        requestContext.enter();
        const discoveredUrl = response.body.result.url.replace(/\/$/, ""); // strip trailing "/" for consistency
        return Promise.resolve(discoveredUrl);
    }
}
UrlDiscoveryClient.configURL = "imjs_buddi_url";
UrlDiscoveryClient.configResolveUrlUsingRegion = "imjs_buddi_resolve_url_using_region";
exports.UrlDiscoveryClient = UrlDiscoveryClient;


/***/ }),

/***/ "./lib/ClientsLoggerCategory.js":
/*!**************************************!*\
  !*** ./lib/ClientsLoggerCategory.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Logging */
Object.defineProperty(exports, "__esModule", { value: true });
/** Logger categories used by this package
 * @note All logger categories in this package start with the `imodeljs-clients` prefix.
 * @see [Logger]($bentley)
 * @beta
 */
var ClientsLoggerCategory;
(function (ClientsLoggerCategory) {
    /** The logger category used by base clients */
    ClientsLoggerCategory["Clients"] = "imodeljs-clients.Clients";
    /** The logger category used when converting to/from ECJson. */
    ClientsLoggerCategory["ECJson"] = "ECJson";
    /** @internal */
    ClientsLoggerCategory["IModelBank"] = "imodeljs-clients.iModelBank";
    /** The logger category used for interactions with iModelHub. */
    ClientsLoggerCategory["IModelHub"] = "imodeljs-clients.imodelhub";
    /** @internal */
    ClientsLoggerCategory["ImsClients"] = "imodeljs-clients.ImsClients";
    ClientsLoggerCategory["Request"] = "imodeljs-clients.Request";
    /** @internal */
    ClientsLoggerCategory["UlasClient"] = "ulasclient";
})(ClientsLoggerCategory = exports.ClientsLoggerCategory || (exports.ClientsLoggerCategory = {}));


/***/ }),

/***/ "./lib/Config.js":
/*!***********************!*\
  !*** ./lib/Config.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Config */
Object.defineProperty(exports, "__esModule", { value: true });
/** Option to specify the version of the iModel to be acquired and used
 * @public
 */
class Config {
    constructor() {
        this._container = {};
        this._expanded = {};
    }
    /** append system vars */
    appendSystemVars() {
        this.set("imjs_env_is_browser", Boolean(typeof window !== undefined));
        try {
            const configRequest = new XMLHttpRequest();
            configRequest.open("GET", "config.json", false);
            configRequest.send();
            const configResponse = JSON.parse(configRequest.responseText);
            if (typeof configResponse !== "undefined") {
                this.merge(configResponse);
            }
        }
        catch (error) {
            // couldn't get config.
        }
        // Merge system environment variables that start with "imjs"
        const imjsPrefix = /^imjs/i;
        const systemEnv = Object.keys(process.env)
            .filter((key) => imjsPrefix.test(key))
            .reduce((env, key) => {
            env[key] = process.env[key];
            return env;
        }, {});
        this.merge(systemEnv);
    }
    /** Translate a external var name to a local one if it already exist */
    translateVar(name) {
        const foundVar = Object.keys(this._container).find((key) => {
            if (key.toLowerCase() === name.toLowerCase()) {
                return true;
            }
            else {
                return false;
            }
        });
        return foundVar ? foundVar : name;
    }
    /**
     * Expand var containing other vars as values.
     * This is strict function that will fail if recursion is detected or var name is not found.
     */
    expand(name, value) {
        if (typeof value !== "string")
            return value;
        const descriptor = Object.getOwnPropertyDescriptor(this._expanded, name);
        if (descriptor !== undefined) {
            return descriptor.value;
        }
        const vars = {};
        const matches = value.match(/\${[\w]+}/gi);
        if (matches === null)
            return value;
        matches.forEach((element) => {
            const varName = element.match(/\${([\w]+)}/i)[1];
            if (!vars.hasOwnProperty(varName))
                vars[varName] = element;
        });
        this._expanded[name] = null; // avoid recursive resolution by setting current entry to empty
        Object.getOwnPropertyNames(vars).forEach((element) => {
            const toReplace = vars[element];
            const subDescriptor = Object.getOwnPropertyDescriptor(this._expanded, element);
            if (subDescriptor !== undefined) {
                if (subDescriptor.value === null) {
                    throw new Error(`Found recursive definition of var ${element}`);
                }
                value = value.replace(toReplace, subDescriptor.value);
            }
            else if (this.has(element)) {
                value = value.replace(toReplace, this.get(element));
            }
            else {
                throw new Error(`Failed to expand var ${element}`);
            }
        });
        this._expanded[name] = value;
        return value;
    }
    /** Get a property value. Throws exception if property name is not found */
    get(varName, defaultVal) {
        const name = this.translateVar(varName);
        const descriptor = Object.getOwnPropertyDescriptor(this._container, name);
        if (descriptor === undefined) {
            if (defaultVal !== undefined)
                return defaultVal;
            throw new Error(`Property ${name} does not exists.`);
        }
        if (typeof descriptor.value === "string") {
            const strVal = descriptor.value;
            if (strVal.match(/\${\w+}/) !== null)
                return this.expand(name, strVal);
        }
        return descriptor.value;
    }
    /** Checks if a property exists or not */
    has(varName) {
        const name = this.translateVar(varName);
        return this._container.hasOwnProperty(name);
    }
    /** retrieves a property if it exists, otherwise returns undefined */
    query(varName) {
        return this.has(varName) ? this.get(varName) : undefined;
    }
    /** Get number type property */
    getNumber(name, defaultVal) {
        return Number(this.get(name, defaultVal));
    }
    /** Get boolean type property */
    getBoolean(name, defaultVal) {
        return Boolean(this.get(name, defaultVal));
    }
    /** Get string type property */
    getString(name, defaultVal) {
        return String(this.get(name, defaultVal));
    }
    /** Remove a property from config */
    remove(varName) {
        const name = this.translateVar(varName);
        if (!this.has(name)) {
            throw new Error(`Property ${name} does not exists.`);
        }
        this._expanded = {};
        delete this._container[name];
    }
    /** Set define a new property if it does not exist or update a writable property to new value */
    set(varName, value) {
        const name = this.translateVar(varName);
        this._container[name] = value;
        this._expanded = {};
    }
    /**
     *  Return list of property names present in config
     */
    getVars() {
        return Object.getOwnPropertyNames(this._container);
    }
    /**
     * Override or add new values from a given object into config. Immutable properties are skipped.
     */
    merge(source) {
        if (source === undefined || source === null || source !== Object(source)) {
            throw new Error("source should be an object");
        }
        this._copyProperties(this._container, source, true);
    }
    // copies the properties, recursing into object properties. Only do the translateVar at the top level.
    _copyProperties(destination, source, doTranslate) {
        Object.keys(source).forEach((varName) => {
            // if subkey is an object, recurse.
            if (typeof (source[varName]) === "object") {
                destination[varName] = {};
                this._copyProperties(destination[varName], source[varName], false);
            }
            else {
                const name = doTranslate ? this.translateVar(varName) : varName;
                const val = source[name];
                if (typeof val === "object" || typeof val === "undefined" || val === null)
                    return;
                const descriptor = Object.getOwnPropertyDescriptor(source, name);
                if (descriptor !== undefined) {
                    if (!descriptor.writable)
                        return;
                }
                destination[name] = val;
            }
        });
    }
    /**
     * Return clone of the internal property container object.
     */
    getContainer() {
        return JSON.parse(JSON.stringify(this._container));
    }
    /**
     * Provide singleton object for application
     */
    static get App() {
        if (!Config._appConfig) {
            Config._appConfig = new Config();
            Config._appConfig.appendSystemVars();
        }
        return Config._appConfig;
    }
}
exports.Config = Config;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "./lib/ConnectClients.js":
/*!*******************************!*\
  !*** ./lib/ConnectClients.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module ConnectServices */
const WsgClient_1 = __webpack_require__(/*! ./WsgClient */ "./lib/WsgClient.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Config_1 = __webpack_require__(/*! ./Config */ "./lib/Config.js");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
/** Connect context type
 * @beta
 */
var ContextType;
(function (ContextType) {
    ContextType[ContextType["Unknown"] = 0] = "Unknown";
    ContextType[ContextType["Asset"] = 2] = "Asset";
    ContextType[ContextType["Project"] = 3] = "Project";
})(ContextType = exports.ContextType || (exports.ContextType = {}));
/** Connect context. Currently supported contexts are [[Project]] and [[Asset]].
 * @beta
 */
let Context = class Context extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ContextTypeId")
], Context.prototype, "contextTypeId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], Context.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Number")
], Context.prototype, "number", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UltimateRefId")
], Context.prototype, "ultimateRefId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DataLocationId")
], Context.prototype, "dataLocationId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Status")
], Context.prototype, "status", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AllowExternalTeamMembers")
], Context.prototype, "allowExternalTeamMembers", void 0);
Context = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "CONNECTEDContext.Context", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Context);
exports.Context = Context;
/**
 * @beta
 */
class CommonContext extends Context {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Industry")
], CommonContext.prototype, "industry", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Location")
], CommonContext.prototype, "location", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Latitude")
], CommonContext.prototype, "latitude", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Longitude")
], CommonContext.prototype, "longitude", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CountryCode")
], CommonContext.prototype, "countryCode", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.TimeZoneLocation")
], CommonContext.prototype, "timeZoneLocation", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RegisteredDate")
], CommonContext.prototype, "registeredDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LastModifiedDate")
], CommonContext.prototype, "lastModifiedDate", void 0);
/** Connect project. Represents time-constrained work done on an [[Asset]].
 * @beta
 */
let Project = class Project extends CommonContext {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AssetId")
], Project.prototype, "assetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], Project.prototype, "type", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsRbacEnabled")
], Project.prototype, "isRbacEnabled", void 0);
Project = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "CONNECTEDContext.Project", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Project);
exports.Project = Project;
/** Connect asset. Assets represent a large scale item that is owned and/or operated by organization, such as buildings, highways and so on.
 * @beta
 */
let Asset = class Asset extends CommonContext {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AssetType")
], Asset.prototype, "assetType", void 0);
Asset = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "CONNECTEDContext.Asset", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Asset);
exports.Asset = Asset;
/** RBAC project
 * @internal
 */
let RbacProject = class RbacProject extends ECJsonTypeMap_1.WsgInstance {
};
RbacProject = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "RBAC.Project", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], RbacProject);
exports.RbacProject = RbacProject;
/** RBAC user
 * @internal
 */
let RbacUser = class RbacUser extends ECJsonTypeMap_1.WsgInstance {
};
RbacUser = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "RBAC.User", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], RbacUser);
exports.RbacUser = RbacUser;
/** RBAC permission
 * @internal
 */
let Permission = class Permission extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], Permission.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], Permission.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ServiceGPRId")
], Permission.prototype, "serviceGprId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CategoryId")
], Permission.prototype, "categoryId", void 0);
Permission = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "RBAC.Permission", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Permission);
exports.Permission = Permission;
/** Client API to access the connect services.
 * @beta
 */
class ConnectClient extends WsgClient_1.WsgClient {
    constructor() {
        super("sv1.0");
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ConnectClient.searchKey;
    }
    async setupOptionDefaults(options) {
        await super.setupOptionDefaults(options);
        deepAssign(options, { headers: { "content-type": "application/json" } });
    }
    /**
     * Gets theRelyingPartyUrl for the service.
     * @returns RelyingPartyUrl for the service.
     */
    getRelyingPartyUrl() {
        if (Config_1.Config.App.has(ConnectClient.configRelyingPartyUri))
            return Config_1.Config.App.get(ConnectClient.configRelyingPartyUri) + "/";
        if (Config_1.Config.App.getBoolean(WsgClient_1.WsgClient.configUseHostRelyingPartyUriAsFallback, true)) {
            if (Config_1.Config.App.has(WsgClient_1.WsgClient.configHostRelyingPartyUri))
                return Config_1.Config.App.get(WsgClient_1.WsgClient.configHostRelyingPartyUri) + "/";
        }
        throw new Error(`RelyingPartyUrl not set. Set it in Config.App using key ${ConnectClient.configRelyingPartyUri}`);
    }
    /**
     * Gets connect projects accessible to the authorized user.
     * @param requestContext The client request context
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to an array of projects.
     */
    async getProjects(requestContext, queryOptions) {
        return this.getInstances(requestContext, Project, "/Repositories/BentleyCONNECT--Main/ConnectedContext/Project", queryOptions);
    }
    /**
     * Gets a connect project.
     * @param requestContext The client request context
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to the found project. Rejects if no projects, or more than one project is found.
     */
    async getProject(requestContext, queryOptions) {
        const projects = await this.getProjects(requestContext, queryOptions);
        if (projects.length === 0)
            throw new Error("Could not find a project with the specified criteria that the user has access to");
        else if (projects.length > 1)
            throw new Error("More than one project found with the specified criteria");
        return projects[0];
    }
    /** Get the projects the user has been "invited" to.
     * @param token Delegation token of the authorized user.
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to an array of invited projects.
     */
    async getInvitedProjects(requestContext, queryOptions) {
        return this.getInstances(requestContext, Project, "/Repositories/BentleyCONNECT--Main/ConnectedContext/Project?rbaconly=true", queryOptions);
    }
    /**
     * Gets a connect asset.
     * @param requestContext The client request context
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to the found asset. Rejects if no assets, or more than one asset is found.
     */
    async getAsset(requestContext, queryOptions) {
        const assets = await this.getAssets(requestContext, queryOptions);
        if (assets.length === 0)
            throw new Error("Could not find an asset with the specified criteria that the user has access to");
        else if (assets.length > 1)
            throw new Error("More than one asset found with the specified criteria");
        return assets[0];
    }
    /**
     * Gets connect assets accessible to the authorized user.
     * @param requestContext The client request context
     * @param queryOptions Query options. Use the mapped EC property names in the query strings and not the TypeScript property names.
     * @returns Resolves to an array of assets.
     */
    async getAssets(requestContext, queryOptions) {
        return this.getInstances(requestContext, Asset, "/Repositories/BentleyCONNECT--Main/ConnectedContext/Asset", queryOptions);
    }
}
ConnectClient.searchKey = "CONNECTEDContextService.URL";
ConnectClient.configRelyingPartyUri = "imjs_connected_context_service_relying_party_uri";
exports.ConnectClient = ConnectClient;


/***/ }),

/***/ "./lib/ECJsonTypeMap.js":
/*!******************************!*\
  !*** ./lib/ECJsonTypeMap.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Utils */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Manages the mapping between TypeScript and EC Classes/Properties to transform back and forth
 * between TypeScript objects (strongly typed) and raw JSON instances. The raw JSON instances can
 * conform to one or more "application" ECSchemas.
 *
 * The mappings are setup on the TypeScript classes using class decorators: {@link ECJsonTypeMap.classToJson}
 * and TypeScript properties using property decorators: {@link ECJsonTypeMap.propertyToJson}.
 *
 * The following utility methods can then be used to convert between TypeScript and JSON:
 * {@link ECJsonTypeMap.fromJson<T>} is used to convert a JSON instance into an instance of type T.
 * {@link ECJsonTypeMap.toJson<T>} is used to convert an instance of some type T to JSON.
 * The caller passes the application as an argument to these methods to identify the schema of the
 * raw JSON that's being generated or consumed.
 *
 * #### example
 * The BriefcaseManager API requires that a briefcase be fetched from the server (based on the "wsg" ECSchema-s),
 * kept in memory as a strongly typed TypeScript object, and then saved locally in a ECDb cache (based on
 * the ECSchema in the ECDb). The JSON would need to be transformed between WSG, ECDb and in-memory TypeScript
 * objects. Listed below are:
 * 1. the EC-JSON required/sent by WSG
 * 2. the EC-JSON required/sent by ECDb
 * 3. the TypeScript instance
 * 4. the corresponding TypeScript class definition with the class and property decorators to make the required transformations.
 *
 * 1. the EC-JSON required/sent by WSG
 *     const wsgJsonForBriefcase: any = {
 *       instanceId: "5",
 *       schemaName: "iModelScope",
 *       className: "Briefcase",
 *       eTag: "87fgQrN6y3mHD6ciCsPxhCdxCxU=",
 *       properties: {
 *         FileName: "MyTestModel.bim",
 *         FileDescription: null,
 *         FileSize: "1232896",
 *         FileId: "0056da15-2009-4862-b82a-c031cb3902d8",
 *         BriefcaseId: 5,
 *         UserOwned: "efefac5b-9a57-488b-aed2-df27bffe6d78",
 *         AcquiredDate: "2017-07-04T18:08:15.77",
 *         IsReadOnly: false,
 *         },
 *       relationshipInstances: [{
 *         className: "FileAccessKey",
 *         relatedInstance: {
 *           className: "AccessKey",
 *           properties: {
 *           DownloadUrl: "https://imodelhubqasa01.blob.core.windows.net/imodelhub-5018f11f-...",
 *           },
 *         },
 *       },
 *       ],
 *     };
 *
 * 2. the EC-JSON required/sent by ECDb
 *     const ecdbJsonForBriefcase: any = {
 *       id: "1",
 *       className: "ServiceStore.LocalBriefcase",
 *       briefcaseId: 5,
 *       userId: "efefac5b-9a57-488b-aed2-df27bffe6d78",
 *       isReadOnly: false,
 *       accessMode: 0,
 *       localPathname: "d:/SomePathHere/MyTestModel.bim",
 *       lastAccessedAt: "2017-07-04T18:08:15.77",
 *     };
 *
 * 3. the TypeScript instance
 *     const briefcase: Briefcase = {
 *       id: "5",
 *       federationGuid: "5",
 *       eTag: "87fgQrN6y3mHD6ciCsPxhCdxCxU=",
 *       fileName: "MyTestModel.bim",
 *       fileDescription: null,
 *       fileSize: "1232896",
 *       fileId: "0056da15-2009-4862-b82a-c031cb3902d8",
 *       briefcaseId: 5,
 *       userId: "efefac5b-9a57-488b-aed2-df27bffe6d78",
 *       acquiredDate: "2017-07-04T18:08:15.77",
 *       isReadOnly: false,
 *       downloadUrl: "https://imodelhubqasa01.blob.core.windows.net/i...",
 *       accessMode: 0,
 *       localPathname: "%TEMP%iModeljs/imodelName/",
 *       lastAccessedAt: "2017-07-04T18:08:15.77",
 *     };
 *
 * 4. the corresponding TypeScript class definition with the class and property decorators
 *
 *     // Base class for all typed instances mapped to ECInstance-s in an ECDb
 *     export abstract class ECInstance
 *     {
 *       @ECJsonTypeMap.propertyToJson("ecdb", "id")
 *       public id: string;
 *
 *       [index: string]: any;
 *     }
 *
 *     // Base class for all typed instances mapped to ECInstance-s in both an ECDb, and the WSG repository
 *     export abstract class WsgInstance extends ECInstance
 *     {
 *       @ECJsonTypeMap.propertyToJson("wsg", "instanceId")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "instanceId")
 *       public federationGuid: GuidString;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "eTag")
 *       public eTag?: string;
 *     }
 *
 *     // Briefcase
 *     @ECJsonTypeMap.classToJson("wsg", "iModelScope.Briefcase", { schemaPropertyName: "schemaName", classPropertyName: "className" })
 *     @ECJsonTypeMap.classToJson("ecdb", "ServiceStore.LocalBriefcase", {classKeyPropertyName: "className"})
 *     export class Briefcase extends WsgInstance
 *     {
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
 *       public fileName: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
 *       public fileDescription: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
 *       public fileSize: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
 *       public fileId: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "briefcaseId")
 *       public briefcaseId: number;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.UserOwned")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "userId")
 *       public userOwned: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.AcquiredDate")
 *       public acquiredDate: string;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "properties.IsReadOnly")
 *       @ECJsonTypeMap.propertyToJson("ecdb", "isReadOnly")
 *       public isReadOnly: boolean;
 *
 *       @ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
 *       public downloadUrl?: string;
 *
 *       @ECJsonTypeMap.propertyToJson("ecdb", "accessMode")
 *       public accessMode: BriefcaseAccessMode;
 *
 *       @ECJsonTypeMap.propertyToJson("ecdb", "localPathname")
 *       public localPathname: string;
 *
 *       @ECJsonTypeMap.propertyToJson("ecdb", "lastAccessedAt")
 *       public lastAccessedAt: Date;
 *     }
 */
// @todo Update example with property type conversions once that's available.
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ./ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.ECJson;
const className = "className";
class PropertyEntry {
    constructor(typedPropertyName, propertyAccessString) {
        this.typedPropertyName = typedPropertyName;
        this.propertyAccessString = propertyAccessString;
    }
}
class ApplicationEntry {
    /** Constructor */
    constructor(applicationKey) {
        this.applicationKey = applicationKey;
        this.propertiesByAccessString = new Map();
    }
    getPropertyByAccessString(propertyAccessString) {
        return this.propertiesByAccessString.get(propertyAccessString);
    }
    /** Adds a new entry for a mapped property */
    addProperty(typedPropertyName, propertyAccessString) {
        let propertyEntry = this.getPropertyByAccessString(propertyAccessString);
        if (propertyEntry) {
            const err = `The ECProperty ${propertyAccessString} has already been mapped to another TypeScript property ${propertyEntry.typedPropertyName}`;
            throw new Error(err);
        }
        propertyEntry = new PropertyEntry(typedPropertyName, propertyAccessString);
        this.propertiesByAccessString.set(propertyAccessString, propertyEntry);
    }
}
/** Entry in the registry to capture the mapping between a single EC and TypeScript class */
class ClassEntry {
    /** Constructor */
    constructor(typedConstructor) {
        this.baseClassEntries = new Array();
        this.applicationsByKey = new Map();
        this.typedConstructor = typedConstructor;
    }
    /** Gets the application entry by the key  */
    getApplicationByKey(applicationKey) {
        return this.applicationsByKey.get(applicationKey);
    }
    /** Adds a new entry for a mapped application within a class  */
    addApplication(applicationKey) {
        let applicationEntry = this.getApplicationByKey(applicationKey);
        if (applicationEntry)
            throw new Error(`Internal error: Cannot add the same application twice`);
        applicationEntry = new ApplicationEntry(applicationKey);
        this.applicationsByKey.set(applicationKey, applicationEntry);
        return applicationEntry;
    }
}
/** Manages the mapping between TypeScript and EC Classes/Properties
 * @internal
 */
class ECJsonTypeMap {
    /** Gets an existing entry for a mapped class from the name of the TypeScript class */
    static getClassByType(typedConstructor) {
        return ECJsonTypeMap._classesByTypedName.get(typedConstructor);
    }
    /** Recursively gathers all class entries for base classes starting with the specified class */
    static gatherBaseClassEntries(baseClassEntries, classEntry) {
        const baseTypedConstructor = Object.getPrototypeOf(classEntry.typedConstructor.prototype).constructor;
        const baseClassEntry = ECJsonTypeMap.getClassByType(baseTypedConstructor);
        if (baseClassEntry) {
            baseClassEntries.push(baseClassEntry);
            this.gatherBaseClassEntries(baseClassEntries, baseClassEntry);
        }
    }
    static addClassPlaceholder(typedConstructor) {
        const classEntry = new ClassEntry(typedConstructor);
        ECJsonTypeMap._classesByTypedName.set(typedConstructor, classEntry);
        ECJsonTypeMap.gatherBaseClassEntries(classEntry.baseClassEntries, classEntry);
        return classEntry;
    }
    /** Adds a new entry for a mapped class */
    static addClass(typedConstructor, applicationKey, classKey, classKeyMapInfo) {
        if (!(classKeyMapInfo.classKeyPropertyName || (classKeyMapInfo.schemaPropertyName && classKeyMapInfo.classPropertyName)))
            throw new Error("Either classKeyPropertyName or schemaPropertyName+classPropertyName have to be supplied to identify how the class information is persisted in JSON");
        let classEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!classEntry) {
            classEntry = this.addClassPlaceholder(typedConstructor);
        }
        let applicationEntry = classEntry.getApplicationByKey(applicationKey);
        if (!applicationEntry) {
            applicationEntry = classEntry.addApplication(applicationKey);
            // will only happen if there are no properties that are mapped to the application - otherwise the property maps will cause the application entry to be added before
        }
        else if (applicationEntry.classKey === classKey) {
            const err = `Duplicate classKeys ${classKey} found on TypeScript class ${typedConstructor.name} for application ${applicationKey}`;
            throw new Error(err);
        }
        applicationEntry.classKey = classKey;
        applicationEntry.classKeyMapInfo = classKeyMapInfo;
        return classEntry;
    }
    /** Adds a new entry for a mapped property */
    static addProperty(typedPropertyName, typedConstructor, applicationKey, propertyAccessString) {
        let classEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!classEntry)
            classEntry = ECJsonTypeMap.addClassPlaceholder(typedConstructor);
        let applicationEntry = classEntry.getApplicationByKey(applicationKey);
        if (!applicationEntry)
            applicationEntry = classEntry.addApplication(applicationKey);
        applicationEntry.addProperty(typedPropertyName, propertyAccessString);
    }
    /** Create a typed instance from an untyped JSON ECInstance  */
    static fromJson(typedConstructor, applicationKey, ecJsonInstance) {
        const mappedClassEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!mappedClassEntry) {
            bentleyjs_core_1.Logger.logError(loggerCategory, `Type ${typedConstructor.name} is not mapped to an ECClass. Supply the appropriate class decorator`);
            return undefined;
        }
        const lowCaseApplicationKey = applicationKey.toLowerCase();
        const mappedApplicationEntry = mappedClassEntry.getApplicationByKey(lowCaseApplicationKey);
        if (!mappedApplicationEntry) {
            bentleyjs_core_1.Logger.logError(loggerCategory, `Type ${typedConstructor.name} is not mapped for the supplied application.`);
            return undefined;
        }
        let ecJsonClassKey;
        if (mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName)
            ecJsonClassKey = ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName];
        else if (mappedApplicationEntry.classKeyMapInfo.schemaPropertyName && mappedApplicationEntry.classKeyMapInfo.classPropertyName)
            ecJsonClassKey = ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.schemaPropertyName] + "." + ecJsonInstance[mappedApplicationEntry.classKeyMapInfo.classPropertyName];
        else {
            bentleyjs_core_1.assert(false, "Unexpected classKeyMapInfo");
            return undefined;
        }
        if (mappedApplicationEntry.classKey !== ecJsonClassKey) {
            bentleyjs_core_1.Logger.logError(loggerCategory, `The ClassKey ${mappedApplicationEntry.classKey} was specified to map with ${typedConstructor.name}, but does not match that specified in the JSON: ${ecJsonClassKey} `);
            return undefined;
        }
        let classEntries = Array(mappedClassEntry);
        classEntries = classEntries.concat(mappedClassEntry.baseClassEntries);
        const typedInstance = new typedConstructor();
        classEntries.forEach((classEntry) => {
            const applicationEntry = classEntry.getApplicationByKey(lowCaseApplicationKey);
            if (!applicationEntry)
                return;
            applicationEntry.propertiesByAccessString.forEach((propertyEntry, propertyAccessString) => {
                let ecValue = ecJsonInstance;
                const ecNameParts = propertyAccessString.split("."); // e.g., "relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId"
                for (let i = 0; i < ecNameParts.length; i++) {
                    const ecNameSubParts = ecNameParts[i].match(/[^\[\]]+/g);
                    if (!ecNameSubParts || ecNameSubParts.length === 0 || ecNameSubParts.length > 2)
                        return;
                    const subAccessString = ecNameSubParts[0];
                    ecValue = ecValue[subAccessString];
                    if (typeof ecValue === "undefined")
                        return;
                    if (ecNameSubParts.length === 2 && subAccessString === "relationshipInstances" && i < ecNameParts.length - 1) {
                        const nextEcNameSubParts = ecNameParts[i + 1].match(/[^\[\]]+/g);
                        if (!nextEcNameSubParts || nextEcNameSubParts.length !== 2)
                            return;
                        const expectedRelationshipInstanceClass = ecNameSubParts[1];
                        const relatedInstanceAccessString = nextEcNameSubParts[0];
                        const expectedRelatedInstanceClass = nextEcNameSubParts[1];
                        let arrayIndex = 0;
                        let arrayValue;
                        let actualRelatedInstanceClass;
                        while (expectedRelatedInstanceClass !== actualRelatedInstanceClass) {
                            arrayValue = ecValue[arrayIndex++];
                            if (typeof arrayValue === "undefined")
                                return;
                            if (expectedRelationshipInstanceClass === arrayValue[className]) {
                                const relatedInstance = arrayValue[relatedInstanceAccessString];
                                if (relatedInstance !== "undefined")
                                    actualRelatedInstanceClass = relatedInstance[className];
                            }
                        }
                        ecValue = arrayValue[relatedInstanceAccessString];
                        i++;
                    }
                }
                typedInstance[propertyEntry.typedPropertyName] = ecValue;
            });
        });
        return typedInstance;
    }
    /** Create an untyped instance from a typed instance */
    static toJson(applicationKey, typedInstance) {
        const lowCaseApplicationKey = applicationKey.toLowerCase(); // e.g., wsg
        const typedConstructor = Object.getPrototypeOf(typedInstance).constructor;
        const mappedClassEntry = ECJsonTypeMap.getClassByType(typedConstructor);
        if (!mappedClassEntry)
            return undefined;
        const mappedApplicationEntry = mappedClassEntry.getApplicationByKey(lowCaseApplicationKey);
        if (!mappedApplicationEntry)
            return undefined;
        const untypedInstance = {};
        if (mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName) {
            untypedInstance[mappedApplicationEntry.classKeyMapInfo.classKeyPropertyName] = mappedApplicationEntry.classKey;
        }
        else if (mappedApplicationEntry.classKeyMapInfo.schemaPropertyName && mappedApplicationEntry.classKeyMapInfo.classPropertyName) {
            const classKeyParts = mappedApplicationEntry.classKey.split(".", 2);
            untypedInstance[mappedApplicationEntry.classKeyMapInfo.schemaPropertyName] = classKeyParts[0];
            untypedInstance[mappedApplicationEntry.classKeyMapInfo.classPropertyName] = classKeyParts[1];
        }
        else {
            bentleyjs_core_1.assert(false, "Unexpected classKeyMapInfo");
            return undefined;
        }
        let classEntries = Array(mappedClassEntry);
        classEntries = classEntries.concat(mappedClassEntry.baseClassEntries);
        classEntries.forEach((classEntry) => {
            const applicationEntry = classEntry.getApplicationByKey(lowCaseApplicationKey);
            if (!applicationEntry)
                return;
            applicationEntry.propertiesByAccessString.forEach((propertyEntry, propertyAccessString) => {
                const typedValue = typedInstance[propertyEntry.typedPropertyName];
                if (typeof typedValue === "undefined")
                    return;
                const ecNameParts = propertyAccessString.split("."); // e.g., "relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId"
                let untypedInstanceCursor = untypedInstance;
                // iterate through each part of the propertyAccessString that was separated by dots
                ecNameParts.forEach((ecNamePart, index) => {
                    // if the name part has brackets, we want to extract the value inside the brackets and outside into a single array
                    // e.g., relationshipInstances[HasThumbnail] --> [relationshipInstances, HasThumbnail]
                    // e.g., property --> [property]
                    const ecNameSubParts = ecNamePart.match(/[^\[\]]+/g);
                    // we only want to continue if the ecNameSubParts array has 1 or 2 values
                    if (!ecNameSubParts || ecNameSubParts.length === 0 || ecNameSubParts.length > 2)
                        return;
                    // the access string is the current property of the class
                    const accessString = ecNameSubParts[0];
                    // only the last part of the propertyAccessString will be bound to the typedValue
                    const isLastPart = index >= ecNameParts.length - 1;
                    // if we have just 1 value in the ecNameSubParts array...
                    if (ecNameSubParts.length !== 2) {
                        // if the current cursor of the ec class object has no value for the access string
                        if (undefined === untypedInstanceCursor[accessString]) {
                            // we need to bind it the typedValue or initialize an empty object
                            let value = {};
                            if (isLastPart) {
                                value = typedValue;
                            }
                            untypedInstanceCursor[accessString] = value;
                        }
                        // advance the cursor to the newly defined value set by the accessString
                        untypedInstanceCursor = untypedInstanceCursor[accessString];
                        return;
                    }
                    // if we have 2 values in the ecNameSubParts array...
                    // the second value we can assume to be the expected class name of the ec object corresponding to the current position of the cursor
                    const expectedclassName = ecNameSubParts[1];
                    // if the accessString is relationshipInstances we know we have some like: "relationshipInstances[className]"
                    if (accessString === "relationshipInstances") {
                        // initially relationshipInstances will be undefined, but it will always be an array, so we need to initialize it as one
                        if (!untypedInstanceCursor[accessString])
                            untypedInstanceCursor[accessString] = [];
                        // determine if the relationshipInstance has an associated relatedInstance
                        const hasNextEcPart = /\[.*\]/.test(ecNameParts[index + 1]);
                        // split the related instance into an array with its class name
                        // e.g., relatedInstance[className] --> [relatedInstance, className]
                        // e.g., property --> [property]
                        const nextEcNameSubParts = ecNameParts[index + 1].match(/[^\[\]]+/g);
                        // we only want to continue if the nextEcNameSubParts array has 1 or 2 values
                        if (!nextEcNameSubParts || nextEcNameSubParts.length === 0 || nextEcNameSubParts.length > 2)
                            return;
                        // if there is a next ec part, then grab the first value, which ostensibly would always be "relatedInstance"
                        const relatedInstanceAccessString = hasNextEcPart ? nextEcNameSubParts[0] : undefined;
                        // if there is a next ec part, then grab the second value, which corresponds to the relatedInstance's expected class name
                        const expectedRelatedInstanceClass = hasNextEcPart ? nextEcNameSubParts[1] : undefined;
                        // determine the current index of the relationshipInstance that matches the expected class name
                        // given there may be multiple relationship instances, but we assume there is a unique combination
                        // between the class of the relationship instance and its relatedInstance (if the related instance is provided)
                        // e.g., given: relationshipInstances[classA].relatedInstance[classB] , classA and classB together are unique among all relationship instances
                        let relationshipCount = 0;
                        // while the index points to a defined relationship instance, check if classA and classB (from above example) match the expected classes
                        // the exception is if the relationship instance doesn't have a relatedInstance (possibly because the typedValue is the entire instance)
                        // in that case we only care about the matching the relationship instance class name
                        while (untypedInstanceCursor[accessString][relationshipCount]
                            && (untypedInstanceCursor[accessString][relationshipCount][className] !== expectedclassName
                                || (hasNextEcPart && untypedInstanceCursor[accessString][relationshipCount][relatedInstanceAccessString] && untypedInstanceCursor[accessString][relationshipCount][relatedInstanceAccessString][className] !== expectedRelatedInstanceClass))) {
                            relationshipCount++;
                        }
                        // if this is the first round, no relationship instances will be defined yet, so we need to initialize it
                        if (!untypedInstanceCursor[accessString][relationshipCount]) {
                            // Note: the only way this would be the last part is if the entire relationship instance is the typed value
                            let value = {};
                            if (isLastPart) {
                                value = typedValue;
                            }
                            untypedInstanceCursor[accessString][relationshipCount] = value;
                        }
                        // advance the cursor to the newly defined value set by the accessString
                        untypedInstanceCursor = untypedInstanceCursor[accessString][relationshipCount];
                    }
                    else {
                        if (accessString !== "relatedInstance" || !untypedInstanceCursor[accessString]
                            || (accessString === "relatedInstance" && untypedInstanceCursor[accessString][className] !== expectedclassName)) {
                            let value = {};
                            if (isLastPart) {
                                value = typedValue;
                            }
                            untypedInstanceCursor[accessString] = value;
                        }
                        untypedInstanceCursor = untypedInstanceCursor[accessString];
                    }
                    if (undefined === untypedInstanceCursor[className])
                        untypedInstanceCursor[className] = expectedclassName;
                });
            });
        });
        return untypedInstance;
    }
    /**
     * Decorator function for mapping TypeScript classes to JSON
     * @param applicationKey Identifies the application for which the mapping is specified. e.g., "ecdb", "wsg", etc.
     * @param classKey Identifies the ec class backing the JSON instance. (e.g., "ServiceStore.Briefcase" (ecdb) or "iModelScope.Briefcase" (wsg))
     * @param classKeyMapInfo Information on how the class key is persisted in the JSON instance (e.g., as two properties "schemaName" and "className")
     */
    static classToJson(applicationKey, classKey, classKeyMapInfo) {
        return (typedConstructor) => {
            ECJsonTypeMap.addClass(typedConstructor, applicationKey.toLowerCase(), classKey, classKeyMapInfo);
        };
    }
    /**
     * Decorator function for mapping typescript properties to JSON
     * @param applicationKey Identifies the application for which the mapping is specified. e.g., "ecdb", "wsg", etc.
     * @param propertyAccessString Access string for the ECProperty
     */
    static propertyToJson(applicationKey, propertyAccessString) {
        return (object, propertyKey) => {
            ECJsonTypeMap.addProperty(propertyKey, object.constructor, applicationKey.toLowerCase(), propertyAccessString);
        };
    }
}
ECJsonTypeMap._classesByTypedName = new Map();
exports.ECJsonTypeMap = ECJsonTypeMap;
/** Base class for all typed instances mapped to ECInstance-s in an ECDb
 * @beta
 */
class ECInstance {
}
__decorate([
    ECJsonTypeMap.propertyToJson("ecdb", "id")
], ECInstance.prototype, "ecId", void 0);
exports.ECInstance = ECInstance;
/** Base class for all typed instances mapped to ECInstance-s in both an ECDb, and the WSG repository
 * @beta
 */
class WsgInstance extends ECInstance {
}
__decorate([
    ECJsonTypeMap.propertyToJson("wsg", "instanceId"),
    ECJsonTypeMap.propertyToJson("ecdb", "wsgId")
], WsgInstance.prototype, "wsgId", void 0);
__decorate([
    ECJsonTypeMap.propertyToJson("wsg", "eTag"),
    ECJsonTypeMap.propertyToJson("ecdb", "eTag")
], WsgInstance.prototype, "eTag", void 0);
__decorate([
    ECJsonTypeMap.propertyToJson("wsg", "changeState")
], WsgInstance.prototype, "changeState", void 0);
exports.WsgInstance = WsgInstance;


/***/ }),

/***/ "./lib/IModelClient.js":
/*!*****************************!*\
  !*** ./lib/IModelClient.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const Briefcases_1 = __webpack_require__(/*! ./imodelhub/Briefcases */ "./lib/imodelhub/Briefcases.js");
const iModels_1 = __webpack_require__(/*! ./imodelhub/iModels */ "./lib/imodelhub/iModels.js");
const ChangeSets_1 = __webpack_require__(/*! ./imodelhub/ChangeSets */ "./lib/imodelhub/ChangeSets.js");
const Checkpoints_1 = __webpack_require__(/*! ./imodelhub/Checkpoints */ "./lib/imodelhub/Checkpoints.js");
const Locks_1 = __webpack_require__(/*! ./imodelhub/Locks */ "./lib/imodelhub/Locks.js");
const Codes_1 = __webpack_require__(/*! ./imodelhub/Codes */ "./lib/imodelhub/Codes.js");
const Users_1 = __webpack_require__(/*! ./imodelhub/Users */ "./lib/imodelhub/Users.js");
const Versions_1 = __webpack_require__(/*! ./imodelhub/Versions */ "./lib/imodelhub/Versions.js");
const Events_1 = __webpack_require__(/*! ./imodelhub/Events */ "./lib/imodelhub/Events.js");
const Thumbnails_1 = __webpack_require__(/*! ./imodelhub/Thumbnails */ "./lib/imodelhub/Thumbnails.js");
const GlobalEvents_1 = __webpack_require__(/*! ./imodelhub/GlobalEvents */ "./lib/imodelhub/GlobalEvents.js");
/**
 * Base class that allows access to different iModel related Class handlers. Handlers should be accessed through an instance of this class, rather than constructed directly.
 * @beta
 */
class IModelClient {
    /**
     * Creates an instance of [[IModelClient]].
     * @param fileHandler File handler to handle file upload/download and file system operations.
     */
    constructor(baseHandler, fileHandler) {
        this._handler = baseHandler;
        this._fileHandler = fileHandler || this._handler.getFileHandler();
        if (this._fileHandler)
            this._fileHandler.agent = this._handler.getAgent();
    }
    /**
     * Sets file handler for file upload/download.
     * @param fileHandler File handler to handle file upload/download and file system operations.
     */
    setFileHandler(fileHandler) {
        this._fileHandler = fileHandler;
        this._fileHandler.agent = this._handler.getAgent();
    }
    /**
     * Get the handler for [[HubIModel]] instances.
     * @note Use [[IModelHubClient.IModel]] for the preferred single iModel per [[Project]] workflow.
     */
    get iModels() {
        return new iModels_1.IModelsHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for [[HubIModel]].
     */
    get iModel() {
        return new iModels_1.IModelHandler(new iModels_1.IModelsHandler(this._handler, this._fileHandler));
    }
    /**
     * Get the handler for [[Briefcase]]s.
     * @internal
     */
    get briefcases() {
        return new Briefcases_1.BriefcaseHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for [[ChangeSet]]s.
     * @beta
     */
    get changeSets() {
        return new ChangeSets_1.ChangeSetHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for [[Checkpoint]]s.
     * @alpha
     */
    get checkpoints() {
        return new Checkpoints_1.CheckpointHandler(this._handler, this._fileHandler);
    }
    /**
     * Get the handler for [[Lock]]s.
     * @alpha
     */
    get locks() {
        return new Locks_1.LockHandler(this._handler);
    }
    /**
     * Get the handler for [Code]($common)s.
     * @alpha
     */
    get codes() {
        return new Codes_1.CodeHandler(this._handler);
    }
    /**
     * Get the handler for [[UserInfo]].
     * @alpha
     */
    get users() {
        return new Users_1.UserInfoHandler(this._handler);
    }
    /**
     * Get the handler for [[Version]]s.
     * @beta
     */
    get versions() {
        return new Versions_1.VersionHandler(this._handler);
    }
    /**
     * Get the handler for [[Thumbnail]]s.
     * @alpha
     */
    get thumbnails() {
        return new Thumbnails_1.ThumbnailHandler(this._handler);
    }
    /**
     * Get the handler for [[IModelHubEvent]]s.
     */
    get events() {
        return new Events_1.EventHandler(this._handler);
    }
    /**
     * Get the handler for [[IModelHubGlobalEvent]]s.
     */
    get globalEvents() {
        return new GlobalEvents_1.GlobalEventHandler(this._handler);
    }
    /**
     * Get the [CustomRequestOptions]($clients) object for controlling future request options.
     * @internal
     */
    get requestOptions() {
        return this._handler.getCustomRequestOptions();
    }
}
exports.IModelClient = IModelClient;


/***/ }),

/***/ "./lib/ImsClients.js":
/*!***************************!*\
  !*** ./lib/ImsClients.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Authentication */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const xmldom_1 = __webpack_require__(/*! xmldom */ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom-parser.js");
const xpath = __webpack_require__(/*! xpath */ "../../common/temp/node_modules/.registry.npmjs.org/xpath/0.0.27/node_modules/xpath/xpath.js");
const Client_1 = __webpack_require__(/*! ./Client */ "./lib/Client.js");
const Config_1 = __webpack_require__(/*! ./Config */ "./lib/Config.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ./ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const Request_1 = __webpack_require__(/*! ./Request */ "./lib/Request.js");
const Token_1 = __webpack_require__(/*! ./Token */ "./lib/Token.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.ImsClients;
/** Client API for the IMS Federated Authentication Service.
 * @internal
 * @deprecated
 */
class ImsFederatedAuthenticationClient extends Client_1.Client {
    /** Creates an instance of ImsFederatedAuthenticationClient. */
    constructor() {
        super();
    }
    /** Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ImsFederatedAuthenticationClient.searchKey;
    }
    /** Parses the response from the token request to obtain the token and the user profile.
     * @param authTokenResponse Response for the token request.
     */
    static parseTokenResponse(authTokenResponse) {
        const select = xpath.useNamespaces({
            trust: "http://docs.oasis-open.org/ws-sx/ws-trust/200512",
        });
        const dom = (new xmldom_1.DOMParser()).parseFromString(authTokenResponse);
        const samlAssertion = select("//saml:Assertion", dom).toString();
        if (!samlAssertion)
            return undefined;
        return Token_1.AuthorizationToken.fromSamlAssertion(samlAssertion);
    }
}
ImsFederatedAuthenticationClient.searchKey = "IMS.FederatedAuth.Url";
exports.ImsFederatedAuthenticationClient = ImsFederatedAuthenticationClient;
/** Client API for the IMS Active Secure Token Service.
 * @internal
 * @deprecated
 */
class ImsActiveSecureTokenClient extends Client_1.Client {
    /**
     * Creates an instance of ImsActiveSecureTokenClient.
     */
    constructor() {
        super();
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ImsActiveSecureTokenClient.searchKey;
    }
    async setupOptionDefaults(options) {
        await super.setupOptionDefaults(options);
        options.useCorsProxy = false;
    }
    /**
     * Gets the authorization token given the credentials.
     * Note that this can only be used in test environments - in an application passwords are never passed around, and the
     * application would/should not be aware of it.
     * @param userCredentials User credentials
     * @returns Resolves to the token and user profile.
     */
    async getToken(requestContext, userCredentials, appId) {
        const url = await this.getUrl(requestContext);
        const imjsAppId = appId ? `imodeljs ${appId}` : "imodeljs";
        const options = {
            method: "POST",
            auth: {
                user: userCredentials.email,
                password: userCredentials.password,
            },
            body: {
                AppliesTo: Config_1.Config.App.get("imjs_default_relying_party_uri"),
                DeviceId: (typeof window === "undefined") ? "backend" : "frontend",
                AppId: imjsAppId,
                Lifetime: 7 * 24 * 60,
            },
        };
        await this.setupOptionDefaults(options);
        return Request_1.request(requestContext, url, options)
            .then(async (res) => {
            if (!res.body.RequestedSecurityToken)
                return Promise.reject(new Error("Authorization token not in expected format " + JSON.stringify(res)));
            const token = Token_1.AuthorizationToken.fromSamlAssertion(res.body.RequestedSecurityToken);
            return Promise.resolve(token);
        });
    }
}
ImsActiveSecureTokenClient.searchKey = "Mobile.ImsStsAuth";
exports.ImsActiveSecureTokenClient = ImsActiveSecureTokenClient;
/** Client API for the IMS Delegation Secure Token Service.
 * @internal
 * @deprecated
 */
class ImsDelegationSecureTokenClient extends Client_1.Client {
    /**
     * Creates an instance of ImsDelegationSecureTokenClient.
     */
    constructor() {
        super();
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return ImsDelegationSecureTokenClient.searchKey;
    }
    /**
     * Gets the default URL for the service.
     * @returns Default URL for the service.
     */
    async setupOptionDefaults(options) {
        await super.setupOptionDefaults(options);
        options.useCorsProxy = false;
    }
    /**
     * Gets the (delegation) access token given the authorization token.
     * @param requestContext The client request context
     * @param authTokenInfo Access token.
     * @param relyingPartyUri Relying party URI required by the service - defaults to a value defined by the configuration.
     * @param appId Application id that's used for logging and tracing the authorization request
     * @returns Resolves to the (delegation) access token.
     */
    async getToken(requestContext, authorizationToken, relyingPartyUri, appId) {
        const url = await this.getUrl(requestContext) + "/json/IssueEx";
        if (!relyingPartyUri) {
            relyingPartyUri = Config_1.Config.App.get("imjs_default_relying_party_uri");
        }
        const imjsAppId = appId ? `imodeljs ${appId}` : "imodeljs";
        const options = {
            method: "POST",
            headers: {
                "authorization": authorizationToken.toTokenString(),
                "User-Agent": imjsAppId,
            },
            body: {
                ActAs: authorizationToken.getSamlAssertion(),
                AppliesTo: relyingPartyUri,
                AppliesToBootstrapToken: relyingPartyUri,
                DeviceId: (typeof window === "undefined") ? "backend" : "frontend",
                AppId: imjsAppId,
                Lifetime: 60,
            },
        };
        await this.setupOptionDefaults(options);
        return Request_1.request(requestContext, url, options)
            .then(async (res) => {
            if (!res.body.RequestedSecurityToken)
                return Promise.reject(new Error("Authorization token not in expected format " + JSON.stringify(res)));
            const accessToken = Token_1.AccessToken.fromSamlAssertion(res.body.RequestedSecurityToken);
            return Promise.resolve(accessToken);
        });
    }
}
ImsDelegationSecureTokenClient.searchKey = "ActiveSTSDelegationServiceUrl";
exports.ImsDelegationSecureTokenClient = ImsDelegationSecureTokenClient;
/** Implementation of IAuthorizationClient using IMS - this is only used in test environments
 * @internal
 * @deprecated
 */
class ImsTestAuthorizationClient {
    async signIn(requestContext, userCredentials, relyingPartyUri) {
        this._userCredentials = userCredentials;
        this._relyingPartyUri = relyingPartyUri;
        const authToken = await (new ImsActiveSecureTokenClient()).getToken(requestContext, userCredentials);
        this._accessToken = await (new ImsDelegationSecureTokenClient()).getToken(requestContext, authToken, relyingPartyUri);
        return this._accessToken;
    }
    /** Returns true if there's a current authorized user or client (in the case of agent applications).
     * Returns true if signed in and the access token has not expired, and false otherwise.
     */
    get isAuthorized() {
        return !!this._accessToken && !this.hasExpired;
    }
    /** Returns true if the user has signed in, but the token has expired and requires a refresh */
    get hasExpired() {
        if (!this._accessToken)
            return false;
        const expiresAt = this._accessToken.getExpiresAt();
        bentleyjs_core_1.assert(!!expiresAt);
        return ((expiresAt.getTime() - Date.now()) <= 0);
    }
    /** Returns true if the user has signed in, but the token has expired and requires a refresh */
    get hasSignedIn() {
        return !!this._accessToken;
    }
    /** Returns a promise that resolves to the AccessToken of the currently authorized user
     * or authorized client (in the case of agent applications).
     * The token is refreshed if necessary and possible.
     * @throws [[BentleyError]] If the client was not used to authorize, or there was an authorization error.
     */
    async getAccessToken(requestContext) {
        if (this.isAuthorized)
            return this._accessToken;
        if (!this._userCredentials)
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.AuthStatus.Error, "No use has signed in - call ImsTokenManager.signIn() before fetching access token", bentleyjs_core_1.Logger.logError, loggerCategory);
        return this.signIn(requestContext || new bentleyjs_core_1.ClientRequestContext(), this._userCredentials, this._relyingPartyUri);
    }
}
exports.ImsTestAuthorizationClient = ImsTestAuthorizationClient;


/***/ }),

/***/ "./lib/RealityDataServicesClient.js":
/*!******************************************!*\
  !*** ./lib/RealityDataServicesClient.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module OtherServices */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const WsgClient_1 = __webpack_require__(/*! ./WsgClient */ "./lib/WsgClient.js");
const url_1 = __webpack_require__(/*! url */ "../../common/temp/node_modules/.registry.npmjs.org/url/0.11.0/node_modules/url/url.js");
const Request_1 = __webpack_require__(/*! ./Request */ "./lib/Request.js");
const Config_1 = __webpack_require__(/*! ./Config */ "./lib/Config.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/** RealityData
 * This class implements a Reality Data stored in ProjectWise Context Share (Reality Data Service)
 * Data is accessed directly through methods of the reality data instance.
 * Access to the data required a properly entitled token though the access to the blob is controlled through
 * an Azure blob URL, the token may be required to obtain this Azure blob URL or refresh it.
 * The Azure blob URL is considered valid for an hour and is refreshed after 50 minutes.
 * In addition to the reality data properties, and Azure blob URL and internal states, a reality data also contains
 * the identification of the CONNECT project to identify the context(used for access permissions resolution) and
 * may contain a RealityDataClient to obtain the WSG client specialization to communicate with ProjectWise Context Share (to obtain the Azure blob URL).
 * @internal
 */
let RealityData = class RealityData extends ECJsonTypeMap_1.WsgInstance {
    /**
     * Gets string url to fetch blob data from. Access is read-only.
     * @param requestContext The client request context.
     * @param name name or path of tile
     * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.
     * @returns string url for blob data
     */
    async getBlobStringUrl(requestContext, name, nameRelativeToRootDocumentPath = false) {
        const url = await this.getBlobUrl(requestContext);
        let host = "";
        if (nameRelativeToRootDocumentPath && this._blobRooDocumentPath && this._blobRooDocumentPath !== "")
            host = url.origin + url.pathname + "/" + this._blobRooDocumentPath; // _blobRootDocumentPath is always '/' terminated if not empty
        else
            host = url.origin + url.pathname + "/";
        const query = url.search;
        return `${host}${name}${query}`;
    }
    /**
     * Gets a tileset's tile data
     * @param requestContext The client request context.
     * @param name name or path of tile
     * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.
     * @returns tile data json
     */
    async getModelData(requestContext, name, nameRelativeToRootDocumentPath = false) {
        return this.getTileJson(requestContext, name, nameRelativeToRootDocumentPath);
    }
    /**
     * Gets a tile access url URL object
     * @param requestContext The client request context.
     * @param writeAccess Optional boolean indicating if write access is requested. Default is false for read-only access.
     * @returns app URL object for blob url
     */
    async getBlobUrl(requestContext, writeAccess = false) {
        // Normally the client is set when the reality data is extracted for the client but it could be undefined
        // if the reality data instance is created manually.
        if (!this.client)
            this.client = new RealityDataServicesClient();
        if (!this.projectId)
            this.projectId = "Server";
        if (!this.id)
            return Promise.reject(new Error("id not set"));
        if (undefined === this._blobUrl || this._blobTimeStamp.valueOf() - Date.now() > 3000000) { // 3 million milliseconds or 50 minutes
            const fileAccess = await this.client.getFileAccessKey(requestContext, this.projectId, this.id, writeAccess);
            if (fileAccess.length !== 1)
                return Promise.reject(new Error("Could not obtain blob file access key for reality data: " + this.id));
            const urlString = fileAccess[0].url;
            this._blobUrl = (typeof window !== "undefined") ? new window.URL(urlString) : new url_1.URL(urlString);
            this._blobTimeStamp = new Date(Date.now());
            if (!this._blobRooDocumentPath && this.rootDocument) {
                const urlParts = this.rootDocument.split("/");
                urlParts.pop();
                if (urlParts.length === 0)
                    this._blobRooDocumentPath = "";
                else
                    this._blobRooDocumentPath = urlParts.join("/") + "/";
            }
        }
        return Promise.resolve(this._blobUrl);
    }
    /**
     * Gets a tileset's app data json
     * @param requestContext The client request context.
     * @param name name or path of tile
     * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.
     * @returns app data json object
     */
    async getTileJson(requestContext, name, nameRelativeToRootDocumentPath = false) {
        const stringUrl = await this.getBlobStringUrl(requestContext, name, nameRelativeToRootDocumentPath);
        const options = {
            method: "GET",
            responseType: "json",
        };
        const data = await Request_1.request(requestContext, stringUrl, options);
        return data.body;
    }
    /**
     * Gets tile content
     * @param requestContext The client request context.
     * @param name name or path of tile
     * @param nameRelativeToRootDocumentPath (optional default is false) Indicates if the given name is relative to the root document path.
     * @returns array buffer of tile content
     */
    async getTileContent(requestContext, name, nameRelativeToRootDocumentPath = false) {
        const stringUrl = await this.getBlobStringUrl(requestContext, name, nameRelativeToRootDocumentPath);
        const options = {
            method: "GET",
            responseType: "arraybuffer",
        };
        const data = await Request_1.request(requestContext, stringUrl, options);
        return data.body;
    }
    /**
     * Gets a reality data root document json
     * @param requestContext The client request context.
     * @returns tile data json
     */
    async getRootDocumentJson(requestContext) {
        requestContext.enter();
        if (!this.rootDocument)
            return Promise.reject(new Error("Root document not defined for reality data: " + this.id));
        const root = this.rootDocument;
        return this.getModelData(requestContext, root, false);
    }
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Id")
], RealityData.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.OrganizationId")
], RealityData.prototype, "organizationId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UltimateId")
], RealityData.prototype, "ultimateId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UltimateSite")
], RealityData.prototype, "ultimateSite", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ContainerName")
], RealityData.prototype, "containerName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.DataLocationGuid")
], RealityData.prototype, "dataLocationGuid", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], RealityData.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Dataset")
], RealityData.prototype, "dataSet", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Group")
], RealityData.prototype, "group", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], RealityData.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RootDocument")
], RealityData.prototype, "rootDocument", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Size")
], RealityData.prototype, "size", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SizeUpToDate")
], RealityData.prototype, "sizeUpToDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Classification")
], RealityData.prototype, "classification", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Streamed")
], RealityData.prototype, "streamed", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], RealityData.prototype, "type", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Footprint")
], RealityData.prototype, "footprint", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ApproximateFootprint")
], RealityData.prototype, "approximateFootprint", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ThumbnailDocument")
], RealityData.prototype, "thumbnailDocument", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MetadataUrl")
], RealityData.prototype, "metadataUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Copyright")
], RealityData.prototype, "copyright", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.TermsOfUse")
], RealityData.prototype, "termsOfUse", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AccuracyInMeters")
], RealityData.prototype, "accuracyInMeters", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ResolutionInMeters")
], RealityData.prototype, "resolutionInMeters", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Visibility")
], RealityData.prototype, "visibility", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Listable")
], RealityData.prototype, "listable", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ModifiedTimestamp")
], RealityData.prototype, "modifiedTimestamp", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LastAccessedTimeStamp")
], RealityData.prototype, "lastAccessedTimestamp", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedTimestamp")
], RealityData.prototype, "createdTimestamp", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.OwnedBy")
], RealityData.prototype, "ownedBy", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.OwnerId")
], RealityData.prototype, "ownerId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatorId")
], RealityData.prototype, "creatorId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Version")
], RealityData.prototype, "version", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Hidden")
], RealityData.prototype, "hidden", void 0);
RealityData = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "S3MX.RealityData", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], RealityData);
exports.RealityData = RealityData;
/** File Access Key
 * This class is used by the RealityDataServicesClient to extract an Azure blob URL
 * @internal
 */
let FileAccessKey = class FileAccessKey extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Url")
], FileAccessKey.prototype, "url", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], FileAccessKey.prototype, "type", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Permissions")
], FileAccessKey.prototype, "permissions", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RequiresConfirmation")
], FileAccessKey.prototype, "requiresConfirmation", void 0);
FileAccessKey = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "FileAccess.FileAccessKey", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], FileAccessKey);
exports.FileAccessKey = FileAccessKey;
/** RealityDataRelationship
 * This class is used to represent relationships with a Reality Data and CONNECT Context (CONNECT Project or CONNECT Asset)
 * @internal
 */
let RealityDataRelationship = class RealityDataRelationship extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RealityDataId")
], RealityDataRelationship.prototype, "realityDataId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RelationType")
], RealityDataRelationship.prototype, "relationType", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.RelatedId")
], RealityDataRelationship.prototype, "relatedId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ModifiedTimestamp")
], RealityDataRelationship.prototype, "modifiedTimestamp", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedTimestamp")
], RealityDataRelationship.prototype, "createdTimestamp", void 0);
RealityDataRelationship = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "S3MX.RealityDataRelationship", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], RealityDataRelationship);
exports.RealityDataRelationship = RealityDataRelationship;
/**
 * Client wrapper to Reality Data Service.
 * An instance of this class is used to extract reality data from the ProjectWise Context Share (Reality Data Service)
 * Most important methods enable to obtain a specific reality data, fetch all reality data associated to a project and
 * all reality data of a project within a provided spatial extent.
 * This class also implements extraction of the Azure blob address.
 * @internal
 */
class RealityDataServicesClient extends WsgClient_1.WsgClient {
    /**
     * Creates an instance of RealityDataServicesClient.
     */
    constructor() {
        super("v2.5");
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return RealityDataServicesClient.searchKey;
    }
    /**
     * Gets theRelyingPartyUrl for the service.
     * @returns RelyingPartyUrl for the service.
     */
    getRelyingPartyUrl() {
        if (Config_1.Config.App.has(RealityDataServicesClient.configRelyingPartyUri))
            return Config_1.Config.App.get(RealityDataServicesClient.configRelyingPartyUri) + "/";
        if (Config_1.Config.App.getBoolean(WsgClient_1.WsgClient.configUseHostRelyingPartyUriAsFallback, true)) {
            if (Config_1.Config.App.has(WsgClient_1.WsgClient.configHostRelyingPartyUri))
                return Config_1.Config.App.get(WsgClient_1.WsgClient.configHostRelyingPartyUri) + "/";
        }
        throw new Error(`RelyingPartyUrl not set. Set it in Config.App using key ${RealityDataServicesClient.configRelyingPartyUri}`);
    }
    /**
     * This method returns the URL to obtain the Reality Data details from PW Context Share.
     * Technically it should never be required as the RealityData object returned should have all the information to obtain the
     * data.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @returns string containing the URL to reality data for indicated tile.
     */
    async getRealityDataUrl(requestContext, projectId, tilesId) {
        const serverUrl = await this.getUrl(requestContext);
        return serverUrl + `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${tilesId}`;
    }
    /**
     * Gets reality data with all of its properties
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job
     * @returns The requested reality data.
     */
    async getRealityData(requestContext, projectId, tilesId) {
        const realityDatas = await this.getInstances(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${tilesId}`);
        if (realityDatas.length !== 1)
            return Promise.reject(new Error("Could not fetch reality data: " + tilesId));
        realityDatas[0].client = this;
        realityDatas[0].projectId = projectId;
        return realityDatas[0];
    }
    /**
     * Gets all reality data associated to the project. Consider using getRealityDataInProjectOverlapping() if spatial extent is known.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @returns an array of RealityData that are associated to the project.
     */
    async getRealityDataInProject(requestContext, projectId) {
        const realityDatas = await this.getInstances(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData?project=${projectId}&$filter=Type+eq+'RealityMesh3DTiles'`);
        realityDatas.forEach((realityData) => { realityData.client = this; realityData.projectId = projectId; });
        return realityDatas;
    }
    /**
     * Gets all reality data that has a footprint defined that overlaps the given area and that are associated with the project. Reality Data returned must be accessible by user
     * as public, enterprise data, private or accessible through context RBAC rights attributed to user.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param range The range to search for given as a range 2d where X represents the longitude in radians and Y the latitude in radians
     * longitude can be in the range -2P to 2PI but the minimum value must be smaller numerically to the maximum.
     * Note that the longitudes are usually by convention in the range of -PI to PI except
     * for ranges that overlap the -PI/+PI frontier in which case either representation is acceptable.
     * @returns an array of RealityData
     */
    async getRealityDataInProjectOverlapping(requestContext, projectId, range) {
        const minLongDeg = geometry_core_1.Angle.radiansToDegrees(range.low.x);
        const maxLongDeg = geometry_core_1.Angle.radiansToDegrees(range.high.x);
        const minLatDeg = geometry_core_1.Angle.radiansToDegrees(range.low.y);
        const maxLatDeg = geometry_core_1.Angle.radiansToDegrees(range.high.y);
        const polygonString = `{\"points\":[[${minLongDeg},${minLatDeg}],[${maxLongDeg},${minLatDeg}],[${maxLongDeg},${maxLatDeg}],[${minLongDeg},${maxLatDeg}],[${minLongDeg},${minLatDeg}]], \"coordinate_system\":\"4326\"}`;
        const realityDatas = await this.getInstances(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData?project=${projectId}&polygon=${polygonString}&$filter=Type+eq+'RealityMesh3DTiles'`);
        realityDatas.forEach((realityData) => { realityData.client = this; realityData.projectId = projectId; });
        return realityDatas;
    }
    /**
     * Creates a reality data with given properties
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param realityData The reality data to create. The Id of the reality data is usually left empty indicating for the service to assign
     * one. If set then the reality id must not exist on the server.
     * realityDataInstance id, called tilesId when returned from tile generator job
     * @returns The new reality data with all read-only properties set.
     */
    async createRealityData(requestContext, projectId, realityData) {
        const resultRealityData = await this.postInstance(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData`, realityData);
        if (!resultRealityData)
            return Promise.reject(new Error("Could not create new reality data: " + (realityData.id ? realityData.id : realityData.name)));
        resultRealityData.client = this;
        resultRealityData.projectId = projectId;
        return resultRealityData;
    }
    /**
     * Updates a reality data with given properties
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param realityData The reality data to update. The Id must contain the identifier of the reality data to update.
     * NOTE: As a probable known defect some specific read-only attributes must be undefined prior to passing the reality data.
     * These are: organizationId, sizeUpToDate, ownedBy, ownerId
     * @returns The newly modified reality data.
     */
    async updateRealityData(requestContext, projectId, realityData) {
        const resultRealityData = await this.postInstance(requestContext, RealityData, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${realityData.id}`, realityData);
        if (!resultRealityData)
            return Promise.reject(new Error("Could not update reality data: " + (realityData.id ? realityData.id : realityData.name)));
        resultRealityData.client = this;
        resultRealityData.projectId = projectId;
        return resultRealityData;
    }
    /**
     * Deletes a reality data.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param realityDataId The identifier of the reality data to delete.
     * @returns a void Promise.
     */
    async deleteRealityData(requestContext, projectId, realityDataId) {
        return this.deleteInstance(requestContext, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${realityDataId}`);
    }
    /**
     * Gets all reality data relationships associated to the given reality id, not only the relationship for given project.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project in which to make to call for permission reason
     * @param realityDataId realityDataInstance id to obtain the relationships for.
     * @returns All relationships associated to reality data. NThe requested reality data.
     */
    async getRealityDataRelationships(requestContext, projectId, realityDataId) {
        const relationships = await this.getInstances(requestContext, RealityDataRelationship, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityDataRelationship?$filter=RealityDataId+eq+'${realityDataId}'`);
        return relationships;
    }
    /**
     * Gets all reality data relationships associated to the given reality id, not only the relationship for given project.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project in which to make to call for permission reason
     * @param realityDataId realityDataInstance id to obtain the relationships for.
     * @returns All relationships associated to reality data. NThe requested reality data.
     */
    async createRealityDataRelationship(requestContext, projectId, relationship) {
        const resultRealityDataRelationship = await this.postInstance(requestContext, RealityDataRelationship, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityDataRelationship`, relationship);
        if (!resultRealityDataRelationship)
            return Promise.reject(new Error("Could not create new reality data relationship between reality data: " + (relationship.realityDataId ? relationship.realityDataId : "") + " and context: " + (relationship.relatedId ? relationship.relatedId : "")));
        return resultRealityDataRelationship;
    }
    /**
     * Gets all reality data relationships associated to the given reality id, not only the relationship for given project.
     * @param requestContext The client request context.
     * @param projectId id of associated connect project in which to make to call for permission reason
     * @param realityDataId realityDataInstance id to obtain the relationships for.
     * @returns All relationships associated to reality data. NThe requested reality data.
     */
    async deleteRealityDataRelationship(requestContext, projectId, relationshipId) {
        return this.deleteInstance(requestContext, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityDataRelationship/${relationshipId}`);
    }
    /**
     * Gets a tile file access key
     * @param requestContext The client request context.
     * @param projectId id of associated connect project
     * @param tilesId realityDataInstance id, called tilesId when returned from tile generator job.
     * @param writeAccess Optional boolean indicating if write access is requested. Default is false for read-only access.
     * @returns a FileAccessKey object containing the Azure blob address.
     */
    async getFileAccessKey(requestContext, projectId, tilesId, writeAccess = false) {
        const path = encodeURIComponent(tilesId);
        if (writeAccess)
            return this.getInstances(requestContext, FileAccessKey, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${path}/FileAccess.FileAccessKey?$filter=Permissions+eq+%27Write%27`);
        else
            return this.getInstances(requestContext, FileAccessKey, `/Repositories/S3MXECPlugin--${projectId}/S3MX/RealityData/${path}/FileAccess.FileAccessKey?$filter=Permissions+eq+%27Read%27`);
    }
    // ###TODO temporary means of extracting the tileId and projectId from the given url
    // This is the method that determines if the url refers to Reality Data stored on PW Context Share. If not then undefined is returned.
    /**
     * This is the method that determines if the url refers to Reality Data stored on PW Context Share. If not then undefined is returned.
     * @param url A fully formed URL to a reality data or a reality data folder or document of the form:
     *              https://{Host}/{version}/Repositories/S3MXECPlugin--{ProjectId}/S3MX/RealityData/{RealityDataId}
     *              https://{Host}/{version}/Repositories/S3MXECPlugin--{ProjectId}/S3MX/Folder/{RealityDataId}~2F{Folder}
     *              https://{Host}/{version}/Repositories/S3MXECPlugin--{ProjectId}/S3MX/Document/{RealityDataId}~2F{Full Document Path and name}'
     *            Where {Host} represents the Reality Data Service server (ex: connect-realitydataservices.bentley.com). This value is ignored since the
     *            actual host server name depends on the environment or can be changed in the future.
     *            Where {version} is the Bentley Web Service Gateway protocol version. This value is ignored but the version must be supported by Reality Data Service.
     *            Where {Folder} and {Document} are the full folder or document path relative to the Reality Data root.
     *            {RealityDataId} is extracted after validation of the URL and returned.
     *            {ProjectId} is ignored.
     * @returns A string containing the Reality Data Identifier (otherwise named tile id). If the URL is not a reality data service URL then undefined is returned.
     */
    getRealityDataIdFromUrl(url) {
        let realityDataId;
        const formattedUrl = url.replace(/~2F/g, "/");
        const urlParts = formattedUrl.split("/").map((entry) => entry.replace(/%2D/g, "-"));
        if ((urlParts[4] === "Repositories") && urlParts[5].match("S3MXECPlugin--*") && (urlParts[6] === "S3MX")) {
            // URL appears tpo be a correctly formed URL to Reality Data Service ... obtain the first GUID
            realityDataId = urlParts.find(bentleyjs_core_1.Guid.isGuid);
        }
        return realityDataId;
    }
}
RealityDataServicesClient.searchKey = "RealityDataServices";
RealityDataServicesClient.configRelyingPartyUri = "imjs_reality_data_service_relying_party_uri";
exports.RealityDataServicesClient = RealityDataServicesClient;


/***/ }),

/***/ "./lib/Request.js":
/*!************************!*\
  !*** ./lib/Request.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module BaseClients */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
const qs_1 = __webpack_require__(/*! qs */ "../../common/temp/node_modules/.registry.npmjs.org/qs/6.7.0/node_modules/qs/lib/index.js");
const sarequest = __webpack_require__(/*! superagent */ "../../common/temp/node_modules/.registry.npmjs.org/superagent/3.8.3/node_modules/superagent/lib/client.js");
const Config_1 = __webpack_require__(/*! ./Config */ "./lib/Config.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ./ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.Request;
/** @beta */
exports.requestIdHeaderName = "X-Correlation-Id";
/** @beta */
class RequestGlobalOptions {
}
RequestGlobalOptions.httpsProxy = undefined;
RequestGlobalOptions.timeout = {
    deadline: 25000,
    response: 10000,
};
exports.RequestGlobalOptions = RequestGlobalOptions;
/** Error object that's thrown/rejected if the Request fails due to a network error, or if the status is *not* in the range of 200-299 (inclusive)
 * @beta
 */
class ResponseError extends bentleyjs_core_1.BentleyError {
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, undefined, undefined, getMetaData);
    }
    /**
     * Parses error from server's response
     * @param response Http response from the server.
     * @returns Parsed error.
     * @internal
     */
    static parse(response, log = true) {
        const error = new ResponseError(ResponseError.parseHttpStatus(response.statusType));
        if (!response) {
            error.message = "Couldn't get response object.";
            return error;
        }
        if (response.response) {
            if (response.response.error) {
                error.name = response.response.error.name || error.name;
                error.description = response.response.error.message;
            }
            if (response.response.res) {
                error.message = response.response.res.statusMessage;
            }
            if (response.response.body && Object.keys(response.response.body).length > 0) {
                error._data = {};
                deepAssign(error._data, response.response.body);
            }
            else {
                error._data = response.response.text;
            }
        }
        error.status = response.status || response.statusCode;
        error.name = response.code || response.name || error.name;
        error.message = error.message || response.message || response.statusMessage;
        if (log)
            error.log();
        return error;
    }
    /**
     * Decides whether request should be retried or not
     * @param error Error returned by request
     * @param response Response returned by request
     * @internal
     */
    static shouldRetry(error, response) {
        if (error !== undefined && error !== null) {
            if ((error.status === undefined || error.status === null) && (error.res === undefined || error.res === null)) {
                return true;
            }
        }
        return (response !== undefined && response.statusType === bentleyjs_core_1.HttpStatus.ServerError);
    }
    /**
     * @internal
     */
    static parseHttpStatus(statusType) {
        switch (statusType) {
            case 1:
                return bentleyjs_core_1.HttpStatus.Info;
            case 2:
                return bentleyjs_core_1.HttpStatus.Success;
            case 3:
                return bentleyjs_core_1.HttpStatus.Redirection;
            case 4:
                return bentleyjs_core_1.HttpStatus.ClientError;
            case 5:
                return bentleyjs_core_1.HttpStatus.ServerError;
            default:
                return bentleyjs_core_1.HttpStatus.Success;
        }
    }
    /**
     * @internal
     */
    logMessage() {
        return `${this.status} ${this.name}: ${this.message}`;
    }
    /**
     * Logs this error
     * @internal
     */
    log() {
        bentleyjs_core_1.Logger.logError(loggerCategory, this.logMessage(), this.getMetaData());
    }
}
exports.ResponseError = ResponseError;
const logResponse = (req, startTime) => (res) => {
    const elapsed = new Date().getTime() - startTime;
    const elapsedTime = elapsed + "ms";
    bentleyjs_core_1.Logger.logTrace(loggerCategory, `${req.method.toUpperCase()} ${res.status} ${req.url} (${elapsedTime})`);
};
const logRequest = (req) => {
    const startTime = new Date().getTime();
    req.on("response", logResponse(req, startTime));
    return req;
};
// @todo The purpose of this wrapper is to allow us to easily replace this with another
// module that will rid us of NodeJs dependency.
/** Wrapper around HTTP request utility
 * @param requestContext The client request context
 * @param url Server URL to address the request
 * @param options Options to pass to the request
 * @returns Resolves to the response from the server
 * @throws ResponseError if the request fails due to network issues, or if the returned status is *outside* the range of 200-299 (inclusive)
 * @internal
 */
async function request(requestContext, url, options) {
    requestContext.enter();
    let proxyUrl = "";
    if (options.useCorsProxy === true) {
        proxyUrl = Config_1.Config.App.get("imjs_dev_cors_proxy_server", "");
        if (proxyUrl === "")
            proxyUrl = url;
        else
            proxyUrl = proxyUrl.replace(/\/$/, "") + "/" + url;
    }
    else {
        proxyUrl = url;
    }
    const retries = typeof options.retries === "undefined" ? 4 : options.retries;
    let sareq = sarequest(options.method, proxyUrl).retry(retries, options.retryCallback);
    if (bentleyjs_core_1.Logger.isEnabled(loggerCategory, bentleyjs_core_1.LogLevel.Trace))
        sareq = sareq.use(logRequest);
    if (options.headers)
        sareq = sareq.set(options.headers);
    if (requestContext.activityId !== "")
        sareq.set(exports.requestIdHeaderName, requestContext.activityId);
    let queryStr = "";
    let fullUrl = "";
    if (options.qs && Object.keys(options.qs).length > 0) {
        const stringifyOptions = { delimiter: "&", encode: false };
        queryStr = qs_1.stringify(options.qs, stringifyOptions);
        sareq = sareq.query(queryStr);
        fullUrl = url + "?" + queryStr;
    }
    else {
        fullUrl = url;
    }
    bentleyjs_core_1.Logger.logInfo(loggerCategory, fullUrl);
    if (options.auth)
        sareq = sareq.auth(options.auth.user, options.auth.password);
    if (options.accept)
        sareq = sareq.accept(options.accept);
    if (options.body)
        sareq = sareq.send(options.body);
    if (options.timeout)
        sareq = sareq.timeout(options.timeout);
    else
        sareq = sareq.timeout(RequestGlobalOptions.timeout);
    if (options.responseType)
        sareq = sareq.responseType(options.responseType);
    if (options.redirects)
        sareq = sareq.redirects(options.redirects);
    else
        sareq = sareq.redirects(0);
    if (options.buffer)
        sareq.buffer(options.buffer);
    if (options.parser)
        sareq.parse(options.parser);
    if (options.agent)
        sareq.agent(options.agent);
    else if (RequestGlobalOptions.httpsProxy)
        sareq.agent(RequestGlobalOptions.httpsProxy);
    if (options.progressCallback) {
        sareq.on("progress", (event) => {
            if (event) {
                options.progressCallback({
                    loaded: event.loaded,
                    total: event.total,
                    percent: event.percent,
                });
            }
        });
    }
    const errorCallback = options.errorCallback ? options.errorCallback : ResponseError.parse;
    if (options.readStream) {
        if (typeof window !== "undefined")
            throw new Error("This option is not supported on browsers");
        return new Promise((resolve, reject) => {
            sareq = sareq.type("blob");
            options
                .readStream
                .pipe(sareq)
                .on("error", (error) => {
                const parsedError = errorCallback(error);
                reject(parsedError);
            })
                .on("end", () => {
                const retResponse = {
                    status: 201,
                    header: undefined,
                    body: undefined,
                };
                resolve(retResponse);
            });
        });
    }
    if (options.stream) {
        if (typeof window !== "undefined")
            throw new Error("This option is not supported on browsers");
        return new Promise((resolve, reject) => {
            sareq
                .on("response", (res) => {
                if (res.statusCode !== 200) {
                    const parsedError = errorCallback(res);
                    reject(parsedError);
                    return;
                }
            })
                .pipe(options.stream)
                .on("error", (error) => {
                const parsedError = errorCallback(error);
                reject(parsedError);
            })
                .on("finish", () => {
                const retResponse = {
                    status: 200,
                    header: undefined,
                    body: undefined,
                };
                resolve(retResponse);
            });
        });
    }
    // console.log("%s %s %s", url, options.method, queryStr);
    /*
    * Note:
    * Javascript's fetch returns status.OK if error is between 200-299 inclusive, and doesn't reject in this case.
    * Fetch only rejects if there's some network issue (permissions issue or similar)
    * Superagent rejects network issues, and errors outside the range of 200-299. We are currently using
    * superagent, but may eventually switch to JavaScript's fetch library.
    */
    return sareq
        .then(async (response) => {
        const retResponse = {
            body: response.body,
            header: response.header,
            status: response.status,
        };
        return Promise.resolve(retResponse);
    })
        .catch(async (error) => {
        const parsedError = errorCallback(error);
        return Promise.reject(parsedError);
    });
}
exports.request = request;
/**
 * fetch array buffer from HTTP request
 * @param url server URL to address the request
 * @internal
 */
async function getArrayBuffer(requestContext, url) {
    const options = {
        method: "GET",
        responseType: "arraybuffer",
    };
    const data = await request(requestContext, url, options);
    return data.body;
}
exports.getArrayBuffer = getArrayBuffer;
/**
 * fetch json from HTTP request
 * @param url server URL to address the request
 * @internal
 */
async function getJson(requestContext, url) {
    const options = {
        method: "GET",
        responseType: "json",
    };
    const data = await request(requestContext, url, options);
    return data.body;
}
exports.getJson = getJson;


/***/ }),

/***/ "./lib/SettingsAdmin.js":
/*!******************************!*\
  !*** ./lib/SettingsAdmin.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Settings */
Object.defineProperty(exports, "__esModule", { value: true });
/** Possible values for SettingsResults.status
 * @alpha
 */
var SettingsStatus;
(function (SettingsStatus) {
    SettingsStatus[SettingsStatus["SETTINGS_ERROR_BASE"] = 110592] = "SETTINGS_ERROR_BASE";
    /** The specified setting was successfully saved, deleted, or retrieved. */
    SettingsStatus[SettingsStatus["Success"] = 0] = "Success";
    /** Access to the specified setting was blocked. */
    SettingsStatus[SettingsStatus["AuthorizationError"] = 110593] = "AuthorizationError";
    /** The Url for the setting is not properly formed. Check the characters in the setting name. */
    SettingsStatus[SettingsStatus["UrlError"] = 110594] = "UrlError";
    /** An invalid projectId was specified. */
    SettingsStatus[SettingsStatus["ProjectInvalid"] = 110595] = "ProjectInvalid";
    /** An invalid iModelId was specified. */
    SettingsStatus[SettingsStatus["IModelInvalid"] = 110596] = "IModelInvalid";
    /** The setting specified for deletion or retrieval does not exist. */
    SettingsStatus[SettingsStatus["SettingNotFound"] = 110597] = "SettingNotFound";
    /** The settings server malfunctioned.  */
    SettingsStatus[SettingsStatus["ServerError"] = 110598] = "ServerError";
    /** An unexpected error occurred.  */
    SettingsStatus[SettingsStatus["UnknownError"] = 110600] = "UnknownError";
})(SettingsStatus = exports.SettingsStatus || (exports.SettingsStatus = {}));
/** The result of the SettingsAdmin methods to save, retrieve, and delete settings.
 * These are constructed by the SettingsAdmin methods and examined by applications.
 * @alpha
 */
class SettingsResult {
    /** Construct a new SettingsResult. SettingsResult objects are created by the SettingsAdmin methods.
     * @internal
     * @param status The result of the settings method.
     * @param errorMessage An error message that is sometimes returned by the server.
     * @param setting The object returned by the "get" Settings methods.
     */
    constructor(status, errorMessage, setting) {
        this.status = status;
        this.errorMessage = errorMessage;
        this.setting = setting;
    }
}
exports.SettingsResult = SettingsResult;
/** The result of the SettingsAdmin methods to retrieve all settings by namespace.
 * These are constructed by the SettingsAdmin "getxxxByNamespace" methods and examined by applications.
 * @alpha
 */
class SettingsMapResult {
    /** Construct a new SettingsResult. SettingsResult objects are created by the SettingsAdmin methods.
     * @internal
     * @param status The result of the settings method.
     * @param errorMessage An error message that is sometimes returned by the server.
     * @param settingsMap A Map of name to property objects.
     */
    constructor(status, errorMessage, settingsMap) {
        this.status = status;
        this.errorMessage = errorMessage;
        this.settingsMap = settingsMap;
    }
}
exports.SettingsMapResult = SettingsMapResult;


/***/ }),

/***/ "./lib/SettingsClient.js":
/*!*******************************!*\
  !*** ./lib/SettingsClient.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Settings */
const Request_1 = __webpack_require__(/*! ./Request */ "./lib/Request.js");
const Client_1 = __webpack_require__(/*! ./Client */ "./lib/Client.js");
const SettingsAdmin_1 = __webpack_require__(/*! ./SettingsAdmin */ "./lib/SettingsAdmin.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ImsClients_1 = __webpack_require__(/*! ./ImsClients */ "./lib/ImsClients.js");
/**
 * Client API for the CONNECT ProductSettingsService - implements the SettingsAdmin interface when settings are stored by CONNECT.
 * This class is not accessed directly from applications, they should use IModelApp.SettingsAdmin.
 * @internal
 */
class ConnectSettingsClient extends Client_1.Client {
    /**
     * Creates an instance of ConnectSettingsClient.
     * @param deploymentEnv Deployment environment.
     */
    constructor(applicationId) {
        super();
        this.applicationId = applicationId;
    }
    /** Convenience method to get access token from a SAML authorization token.
     * @param requestContext The client request context.
     * @param authSamlToken Authorization SAML token (e.g. as obtained from ImsFederatedAuthenticationClient)
     * @returns SAML access token
     * @internal
     */
    async getAccessToken(requestContext, authSamlToken) {
        const baseUrl = await this.getUrl(requestContext);
        const imsClient = new ImsClients_1.ImsDelegationSecureTokenClient();
        return imsClient.getToken(requestContext, authSamlToken, baseUrl);
    }
    getUrlSearchKey() { return ConnectSettingsClient.searchKey; }
    // gets the portion of the Url that encapsulates the type of setting requested.
    getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId) {
        // The types of settings are:
        // Application, Project, iModel, and User specific.
        // Application, Project, and User Specific
        // Application and User Specific
        // Project, iModel, and User specific
        // Project and User Specific
        // Application Specific
        let urlTerminator;
        if (userSpecific) {
            urlTerminator = "/User/Setting";
        }
        else {
            if (shared)
                urlTerminator = "/SharedSetting";
            else
                urlTerminator = "/Setting";
        }
        // append the settingsNamespace and settingName if appropriate.
        if (settingNamespace)
            urlTerminator = urlTerminator.concat(`/${settingNamespace}`);
        if (settingName)
            urlTerminator = urlTerminator.concat(`/${settingName}`);
        let urlOptions;
        if (applicationSpecific) {
            if (projectId) {
                if (iModelId) {
                    urlOptions = `/v1.0/Application/${this.applicationId}/Context/${projectId}/iModel/${iModelId}${urlTerminator}`;
                }
                else {
                    urlOptions = `/v1.0/Application/${this.applicationId}/Context/${projectId}${urlTerminator}`;
                }
            }
            else {
                urlOptions = `/v1.0/Application/${this.applicationId}${urlTerminator}`;
            }
        }
        else {
            if (projectId) {
                if (iModelId) {
                    urlOptions = `/v1.0/Context/${projectId}/iModel/${iModelId}${urlTerminator}`;
                }
                else {
                    urlOptions = `/v1.0/Context/${projectId}${urlTerminator}`;
                }
            }
            else {
                // settings must depend on at least one of Application and Project
                throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Improperly specified setting");
            }
        }
        return urlOptions;
    }
    // Forms the response when there is an error.
    formErrorResponse(response) {
        if (400 === response.status) {
            return new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.ProjectInvalid, "Malformed URL or invalid Project " + JSON.stringify(response));
        }
        else if (401 === response.status) {
            return new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.AuthorizationError, "Authorization failure " + JSON.stringify(response));
        }
        else if (404 === response.status) {
            return new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.SettingNotFound);
        }
        else {
            return new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.ServerError, "Status indicates server error " + JSON.stringify(response));
        }
    }
    // Private function that can retrieve either user specific settings or non-user-specific settings
    async saveAnySetting(requestContext, userSpecific, settings, settingNamespace, settingName, applicationSpecific, shared, projectId, iModelId) {
        const baseUrl = await this.getUrl(requestContext);
        const accessTokenString = requestContext.accessToken.toTokenString();
        const options = {
            method: "PUT",
            headers: { authorization: accessTokenString },
            body: {
                properties: settings,
            },
        };
        await this.setupOptionDefaults(options);
        const urlOptions = this.getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId);
        const url = baseUrl.concat(urlOptions);
        return Request_1.request(requestContext, url, options).then(async (_response) => {
            return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.Success));
        }, async (response) => {
            if ((response.status < 200) || (response.status > 299))
                return Promise.resolve(this.formErrorResponse(response));
            return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.UnknownError, "Unexpected Status " + JSON.stringify(response)));
        });
    }
    // Retrieves previously saved user settings
    async getAnySetting(requestContext, userSpecific, settingNamespace, settingName, applicationSpecific, shared, projectId, iModelId) {
        const baseUrl = await this.getUrl(requestContext);
        const accessTokenString = requestContext.accessToken.toTokenString();
        const options = {
            method: "GET",
            headers: { authorization: accessTokenString },
        };
        await this.setupOptionDefaults(options);
        const urlOptions = this.getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId);
        const url = baseUrl.concat(urlOptions);
        return Request_1.request(requestContext, url, options).then(async (response) => {
            return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.Success, undefined, response.body.properties));
        }, async (response) => {
            if ((response.status < 200) || (response.status > 299))
                return Promise.resolve(this.formErrorResponse(response));
            return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.UnknownError, "Unexpected Status " + JSON.stringify(response)));
        });
    }
    // Retrieves all saved settings with the same namespace.
    async getAnySettingsByNamespace(requestContext, userSpecific, settingNamespace, applicationSpecific, shared, projectId, iModelId) {
        const baseUrl = await this.getUrl(requestContext);
        const accessTokenString = requestContext.accessToken.toTokenString();
        const options = {
            method: "GET",
            headers: { authorization: accessTokenString },
        };
        await this.setupOptionDefaults(options);
        const urlOptions = this.getUrlOptions(undefined, undefined, userSpecific, applicationSpecific, shared, projectId, iModelId);
        let url = baseUrl.concat(urlOptions);
        // now we want to append the query for the namespace.
        const queryString = `?$filter=namespace+eq+'${settingNamespace}'`;
        url = url.concat(queryString);
        return Request_1.request(requestContext, url, options).then(async (response) => {
            const settingsMap = new Map();
            for (const settingBody of response.body) {
                settingsMap.set(settingBody.name, settingBody.properties);
            }
            return Promise.resolve(new SettingsAdmin_1.SettingsMapResult(SettingsAdmin_1.SettingsStatus.Success, undefined, settingsMap));
        }, async (response) => {
            if ((response.status < 200) || (response.status > 299))
                return Promise.resolve(this.formErrorResponse(response));
            return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.UnknownError, "Unexpected Status " + JSON.stringify(response)));
        });
    }
    async deleteAnySetting(requestContext, userSpecific, settingNamespace, settingName, applicationSpecific, shared, projectId, iModelId) {
        const baseUrl = await this.getUrl(requestContext);
        const accessTokenString = requestContext.accessToken.toTokenString();
        const options = {
            method: "DELETE",
            headers: { authorization: accessTokenString },
        };
        await this.setupOptionDefaults(options);
        const urlOptions = this.getUrlOptions(settingNamespace, settingName, userSpecific, applicationSpecific, shared, projectId, iModelId);
        const url = baseUrl.concat(urlOptions);
        return Request_1.request(requestContext, url, options).then(async (_response) => {
            return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.Success));
        }, async (response) => {
            if ((response.status < 200) || (response.status > 299))
                return Promise.resolve(this.formErrorResponse(response));
            else
                return Promise.resolve(new SettingsAdmin_1.SettingsResult(SettingsAdmin_1.SettingsStatus.UnknownError, "Unexpected Status " + JSON.stringify(response)));
        });
    }
    async saveUserSetting(requestContext, settings, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.saveAnySetting(requestContext, true, settings, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);
    }
    async getUserSetting(requestContext, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.getAnySetting(requestContext, true, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);
    }
    async deleteUserSetting(requestContext, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.deleteAnySetting(requestContext, true, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);
    }
    async getUserSettingsByNamespace(requestContext, namespace, applicationSpecific, projectId, iModelId) {
        return this.getAnySettingsByNamespace(requestContext, true, namespace, applicationSpecific, false, projectId, iModelId);
    }
    async saveSharedSetting(requestContext, settings, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.saveAnySetting(requestContext, false, settings, settingNamespace, settingName, applicationSpecific, true, projectId, iModelId);
    }
    async getSharedSetting(requestContext, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.getAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, true, projectId, iModelId);
    }
    async deleteSharedSetting(requestContext, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.deleteAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, true, projectId, iModelId);
    }
    async getSharedSettingsByNamespace(requestContext, namespace, applicationSpecific, projectId, iModelId) {
        return this.getAnySettingsByNamespace(requestContext, false, namespace, applicationSpecific, true, projectId, iModelId);
    }
    async saveSetting(requestContext, settings, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.saveAnySetting(requestContext, false, settings, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);
    }
    async getSetting(requestContext, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.getAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);
    }
    async deleteSetting(requestContext, settingNamespace, settingName, applicationSpecific, projectId, iModelId) {
        return this.deleteAnySetting(requestContext, false, settingNamespace, settingName, applicationSpecific, false, projectId, iModelId);
    }
    async getSettingsByNamespace(requestContext, namespace, applicationSpecific, projectId, iModelId) {
        return this.getAnySettingsByNamespace(requestContext, false, namespace, applicationSpecific, false, projectId, iModelId);
    }
}
ConnectSettingsClient.searchKey = "ProductSettingsService.RP";
exports.ConnectSettingsClient = ConnectSettingsClient;


/***/ }),

/***/ "./lib/Token.js":
/*!**********************!*\
  !*** ./lib/Token.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(Buffer) {
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Authentication */
Object.defineProperty(exports, "__esModule", { value: true });
const xpath = __webpack_require__(/*! xpath */ "../../common/temp/node_modules/.registry.npmjs.org/xpath/0.0.27/node_modules/xpath/xpath.js");
const xmldom_1 = __webpack_require__(/*! xmldom */ "../../common/temp/node_modules/.registry.npmjs.org/xmldom/0.1.27/node_modules/xmldom/dom-parser.js");
const UserInfo_1 = __webpack_require__(/*! ./UserInfo */ "./lib/UserInfo.js");
const js_base64_1 = __webpack_require__(/*! js-base64 */ "../../common/temp/node_modules/.registry.npmjs.org/js-base64/2.5.1/node_modules/js-base64/base64.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
var IncludePrefix;
(function (IncludePrefix) {
    IncludePrefix[IncludePrefix["Yes"] = 0] = "Yes";
    IncludePrefix[IncludePrefix["No"] = 1] = "No";
})(IncludePrefix = exports.IncludePrefix || (exports.IncludePrefix = {}));
/** Base class for JWT and SAML tokens
 * @beta
 */
class Token {
    constructor() {
    }
    /** @internal */
    getSaml() {
        if (this._saml)
            return this._saml;
        if (!this._samlAssertion)
            return undefined;
        this._saml = js_base64_1.Base64.encode(this._samlAssertion);
        return this._saml;
    }
    /** @internal */
    getSamlAssertion() {
        if (this._samlAssertion)
            return this._samlAssertion;
        if (!this._saml)
            return undefined;
        this._samlAssertion = js_base64_1.Base64.decode(this._saml);
        return this._samlAssertion;
    }
    /** @internal */
    getUserInfo() {
        if (this._userInfo || this._jwt)
            return this._userInfo;
        if (!this.parseSamlAssertion())
            return undefined;
        return this._userInfo;
    }
    /** @internal */
    setUserInfo(userInfo) {
        this._userInfo = userInfo;
    }
    /** @internal */
    getExpiresAt() {
        if (this._expiresAt || this._jwt)
            return this._expiresAt;
        if (!this.parseSamlAssertion())
            return undefined;
        return this._expiresAt;
    }
    /** @internal */
    getStartsAt() {
        if (this._startsAt || this._jwt)
            return this._startsAt;
        if (!this.parseSamlAssertion())
            return undefined;
        return this._startsAt;
    }
    /** @internal */
    parseSamlAssertion() {
        this._samlAssertion = this.getSamlAssertion();
        if (!this._samlAssertion)
            return false;
        const select = xpath.useNamespaces({
            ds: "http://www.w3.org/2000/09/xmldsig#",
            saml: "urn:oasis:names:tc:SAML:1.0:assertion",
        });
        const dom = (new xmldom_1.DOMParser()).parseFromString(this._samlAssertion);
        this._x509Certificate = select("/saml:Assertion/ds:Signature/ds:KeyInfo/ds:X509Data/ds:X509Certificate/text()", dom).toString();
        const startsAtStr = select("string(/saml:Assertion/saml:Conditions/@NotBefore)", dom).toString();
        this._startsAt = new Date(startsAtStr);
        const expiresAtStr = select("string(/saml:Assertion/saml:Conditions/@NotOnOrAfter)", dom).toString();
        const extractAttribute = (attributeName) => select("/saml:Assertion/saml:AttributeStatement/saml:Attribute[@AttributeName='" +
            attributeName + "']/saml:AttributeValue/text()", dom).toString();
        const id = extractAttribute("userid");
        const email = {
            id: extractAttribute("emailaddress"),
        };
        const profile = {
            name: extractAttribute("name"),
            firstName: extractAttribute("givenname"),
            lastName: extractAttribute("surname"),
        };
        const organization = {
            id: extractAttribute("organizationid"),
            name: extractAttribute("organization"),
        };
        const featureTracking = {
            ultimateSite: extractAttribute("ultimatesite"),
            usageCountryIso: extractAttribute("usagecountryiso"),
        };
        this._userInfo = new UserInfo_1.UserInfo(id, email, profile, organization, featureTracking);
        this._startsAt = new Date(startsAtStr);
        this._expiresAt = new Date(expiresAtStr);
        return !!this._x509Certificate && !!this._startsAt && !!this._expiresAt;
    }
}
exports.Token = Token;
/** Token issued by Active Secure Token Service or Federated Authentication Service for user authentication/authorization
 * @internal
 */
class AuthorizationToken extends Token {
    /** Sets up a new AuthorizationToken based on the SAML that was passed in.
     * Does NOT validate the resulting token.
     * @internal
     */
    static fromSamlAssertion(samlAssertion) {
        const token = new AuthorizationToken();
        token._samlAssertion = samlAssertion;
        return token;
    }
    /** Creates a string representation of the contained token
     * @internal
     */
    toTokenString(includePrefix = IncludePrefix.Yes) {
        if (!this.parseSamlAssertion() || !this._x509Certificate)
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Invalid access token");
        const prefix = (includePrefix === IncludePrefix.Yes) ? "X509 access_token=" : "";
        return prefix + Buffer.from(this._x509Certificate, "utf8").toString("base64");
    }
}
exports.AuthorizationToken = AuthorizationToken;
/** Token issued by DelegationSecureTokenService for API access
 * @beta
 */
class AccessToken extends Token {
    /** Returns true if it's a Jason Web Token, and false if it's a SAML token
     * @internal
     */
    get isJwt() {
        return !!this._jwt;
    }
    /** Sets up a new AccessToken based on the SAML that was passed in.
     * Does NOT validate the resulting token.
     * @internal
     */
    static fromSamlAssertion(samlAssertion) {
        const token = new AccessToken();
        token._samlAssertion = samlAssertion;
        return token;
    }
    /** Sets up a new AccessToken based on some generic token abstraction used for iModelBank use cases
     * @internal
     */
    static fromForeignProjectAccessTokenJson(foreignJsonStr) {
        if (!foreignJsonStr.startsWith(`{\"${this.foreignProjectAccessTokenJsonProperty}\":`))
            return undefined;
        const props = JSON.parse(foreignJsonStr);
        if (props[this.foreignProjectAccessTokenJsonProperty] === undefined)
            return undefined;
        const tok = new AccessToken();
        tok._foreignJwt = foreignJsonStr;
        tok._userInfo = props[this.foreignProjectAccessTokenJsonProperty].userInfo;
        return tok;
    }
    /** Create an AccessToken from a SAML string for Windows Federated Authentication workflows.
     * Does NOT validate the token.
     * @internal
     */
    static fromSamlTokenString(accessTokenStr, includesPrefix = IncludePrefix.Yes) {
        let saml = accessTokenStr;
        if (includesPrefix === IncludePrefix.Yes) {
            const prefixLength = AccessToken._samlTokenPrefix.length;
            if (accessTokenStr.substr(0, prefixLength).toLowerCase() !== AccessToken._samlTokenPrefix.toLowerCase())
                throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Invalid saml token");
            saml = accessTokenStr.slice(6);
            if (!saml)
                throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Invalid saml token");
        }
        const token = new AccessToken();
        token._saml = saml;
        return token;
    }
    /** Create an AccessToken from a JWT token for OIDC workflows
     * Does NOT validate the token.
     * @internal
     */
    static fromJsonWebTokenString(jwt, startsAt, expiresAt, userInfo) {
        const token = new AccessToken();
        token._jwt = jwt;
        token._startsAt = startsAt;
        token._expiresAt = expiresAt;
        token._userInfo = userInfo;
        return token;
    }
    /**
     * Convert this AccessToken to a string
     * @param includePrefix Include the token prefix to identify JWT or SAML tokens
     * @internal
     */
    toTokenString(includePrefix = IncludePrefix.Yes) {
        if (this._jwt)
            return (includePrefix === IncludePrefix.Yes) ? AccessToken._jwtTokenPrefix + " " + this._jwt : this._jwt;
        const saml = this.getSaml();
        if (saml)
            return (includePrefix === IncludePrefix.Yes) ? AccessToken._samlTokenPrefix + " " + saml : saml;
        if (this._foreignJwt) {
            return js_base64_1.Base64.encode(this._foreignJwt); // TODO: migrate iModelBank to support Oidc tokens (_jwt)
        }
        throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Cannot convert invalid access token to string");
    }
    /**
     * Create an AccessToken from a string. The token must include the prefix to differentiate between JWT and SAML.
     * @param tokenStr String representation of the token
     * @internal
     */
    static fromTokenString(tokenStr) {
        if (tokenStr.startsWith(AccessToken._jwtTokenPrefix)) {
            const jwtString = tokenStr.substr(AccessToken._jwtTokenPrefix.length + 1);
            return AccessToken.fromJsonWebTokenString(jwtString);
        }
        if (tokenStr.startsWith(AccessToken._samlTokenPrefix)) {
            tokenStr.substr(AccessToken._samlTokenPrefix.length + 1);
            const samlString = tokenStr.substr(AccessToken._samlTokenPrefix.length + 1);
            return AccessToken.fromSamlTokenString(samlString, IncludePrefix.No);
        }
        if (tokenStr.startsWith(`{\"${AccessToken.foreignProjectAccessTokenJsonProperty}\":`)) {
            const accessToken = AccessToken.fromForeignProjectAccessTokenJson(tokenStr);
            if (!accessToken)
                throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Invalid access token");
        }
        throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Invalid access token");
    }
    /**
     * Creates an AccessToken from an untyped JSON object
     * @param jsonObj
     * @internal
     */
    static fromJson(jsonObj) {
        if (jsonObj._jwt)
            return AccessToken.fromJsonWebTokenString(jsonObj._jwt, jsonObj._startsAt, jsonObj._expiresAt, jsonObj._userInfo);
        if (jsonObj._foreignJwt) {
            const foreignTok = AccessToken.fromForeignProjectAccessTokenJson(jsonObj._foreignJwt);
            if (foreignTok !== undefined)
                return foreignTok;
        }
        return AccessToken.fromSamlAssertion(jsonObj._samlAssertion);
    }
}
AccessToken._samlTokenPrefix = "Token";
AccessToken._jwtTokenPrefix = "Bearer";
AccessToken.foreignProjectAccessTokenJsonProperty = "ForeignProjectAccessToken";
exports.AccessToken = AccessToken;

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js */ "../../common/temp/node_modules/.registry.npmjs.org/buffer/4.9.1/node_modules/buffer/index.js").Buffer))

/***/ }),

/***/ "./lib/UserInfo.js":
/*!*************************!*\
  !*** ./lib/UserInfo.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Authentication */
Object.defineProperty(exports, "__esModule", { value: true });
/** Information on the authenticated user.
 * @beta
 */
class UserInfo {
    constructor(
    /** Id of the user */
    id, 
    /** Email details */
    email, 
    /** Profile of the user */
    profile, 
    /** Organization the user belongs to */
    organization, 
    /** Feature tracking information associated with the user */
    featureTracking) {
        this.id = id;
        this.email = email;
        this.profile = profile;
        this.organization = organization;
        this.featureTracking = featureTracking;
    }
    static fromJson(jsonObj) {
        if (!jsonObj)
            return undefined;
        const id = jsonObj.sub;
        const email = jsonObj.email ? { id: jsonObj.email, isVerified: jsonObj.email_verified } : undefined;
        const profile = jsonObj.given_name ? { name: jsonObj.name, preferredUserName: jsonObj.preferred_username, firstName: jsonObj.given_name, lastName: jsonObj.family_name } : undefined;
        const organization = jsonObj.org ? { id: jsonObj.org, name: jsonObj.org_name } : undefined;
        const featureTracking = jsonObj.feature_tracking ? { ultimateSite: jsonObj.ultimate_site, usageCountryIso: jsonObj.usage_country_iso } : undefined;
        return new UserInfo(id, email, profile, organization, featureTracking);
    }
}
exports.UserInfo = UserInfo;


/***/ }),

/***/ "./lib/WsgClient.js":
/*!**************************!*\
  !*** ./lib/WsgClient.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module BaseClients */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
const Client_1 = __webpack_require__(/*! ./Client */ "./lib/Client.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const ImsClients_1 = __webpack_require__(/*! ./ImsClients */ "./lib/ImsClients.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ./ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const Request_1 = __webpack_require__(/*! ./Request */ "./lib/Request.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.Clients;
/** Error that was returned by a WSG based service.
 * @beta
 */
class WsgError extends Request_1.ResponseError {
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, getMetaData);
    }
    /** Attempt to parse the error from the response.
     * Attempts to parse error data in a format that is returned by WSG services.
     * This method only accesses data that was parsed by parent class to avoid dependencies on http libraries.
     * @param response Response from the server.
     * @returns Parsed error.
     */
    static parse(response, log = true) {
        const responseError = Request_1.ResponseError.parse(response, false);
        const wsgError = new WsgError(bentleyjs_core_1.WSStatus.Unknown);
        deepAssign(wsgError, responseError);
        if (wsgError._data) {
            if (typeof wsgError._data === "object") {
                if (wsgError._data.errorMessage || wsgError._data.errorId) {
                    wsgError.message = wsgError._data.errorMessage || wsgError.message;
                    wsgError.name = wsgError._data.errorId || wsgError.name;
                    wsgError.description = wsgError._data.errorDescription || wsgError.description;
                    wsgError.errorNumber = WsgError.getWSStatusId(wsgError.name ? wsgError.name : "");
                    if (log)
                        wsgError.log();
                    return wsgError;
                }
            }
            else {
                if (wsgError.status === 302 && wsgError._data.indexOf("ims.bentley.com") >= 0) {
                    const authenticationError = new Client_1.AuthenticationError(bentleyjs_core_1.WSStatus.LoginRequired);
                    deepAssign(authenticationError, responseError);
                    authenticationError.name = "Authentication Error";
                    authenticationError.message = "Authentication Error - Check if the accessToken is valid";
                    return authenticationError;
                }
            }
        }
        if (log)
            responseError.log();
        return responseError;
    }
    /**
     * Decides whether request should be retried or not
     * @param error Error
     * @param response Response
     */
    static shouldRetry(error, response) {
        if (response === undefined || response === null) {
            return super.shouldRetry(error, response);
        }
        if (super.parseHttpStatus(response.statusType) === bentleyjs_core_1.HttpStatus.Success) {
            return false;
        }
        const parsedError = WsgError.parse({ response }, false);
        if (!(parsedError instanceof WsgError)) {
            return super.shouldRetry(error, response);
        }
        const errorCodesToRetry = [bentleyjs_core_1.WSStatus.LoginFailed,
            bentleyjs_core_1.WSStatus.SslRequired,
            bentleyjs_core_1.WSStatus.NotEnoughRights,
            bentleyjs_core_1.WSStatus.RepositoryNotFound,
            bentleyjs_core_1.WSStatus.SchemaNotFound,
            bentleyjs_core_1.WSStatus.ClassNotFound,
            bentleyjs_core_1.WSStatus.PropertyNotFound,
            bentleyjs_core_1.WSStatus.InstanceNotFound,
            bentleyjs_core_1.WSStatus.FileNotFound,
            bentleyjs_core_1.WSStatus.NotSupported,
            bentleyjs_core_1.WSStatus.NoServerLicense,
            bentleyjs_core_1.WSStatus.NoClientLicense,
            bentleyjs_core_1.WSStatus.TooManyBadLoginAttempts,
            bentleyjs_core_1.HttpStatus.ServerError,
            bentleyjs_core_1.HttpStatus.ClientError,
            bentleyjs_core_1.WSStatus.Unknown];
        const errorStatus = WsgError.getErrorStatus(parsedError.name !== undefined ?
            WsgError.getWSStatusId(parsedError.name) : bentleyjs_core_1.WSStatus.Unknown, response.statusType);
        return errorCodesToRetry.includes(errorStatus);
    }
    /**
     * Gets error status from current WSError and HTTP Status type
     * @param error Error returned by request
     * @param response Response returned by request
     */
    static getErrorStatus(errorId, httpStatusType) {
        if (bentleyjs_core_1.WSStatus.Unknown !== errorId) {
            return errorId;
        }
        if (super.parseHttpStatus(httpStatusType) === bentleyjs_core_1.HttpStatus.ServerError) {
            return bentleyjs_core_1.HttpStatus.ServerError;
        }
        if (super.parseHttpStatus(httpStatusType) === bentleyjs_core_1.HttpStatus.ClientError) {
            return bentleyjs_core_1.HttpStatus.ClientError;
        }
        return bentleyjs_core_1.WSStatus.Unknown;
    }
    /**
     * Get WSError from error string
     * @param error error to be returned in WSError enum
     */
    static getWSStatusId(error) {
        switch (error) {
            case "LoginFailed":
                return bentleyjs_core_1.WSStatus.LoginFailed;
            case "SslRequired":
                return bentleyjs_core_1.WSStatus.SslRequired;
            case "NotEnoughRights":
                return bentleyjs_core_1.WSStatus.NotEnoughRights;
            case "DatasourceNotFound":
                return bentleyjs_core_1.WSStatus.RepositoryNotFound;
            case "RepositoryNotFound":
                return bentleyjs_core_1.WSStatus.RepositoryNotFound;
            case "SchemaNotFound":
                return bentleyjs_core_1.WSStatus.SchemaNotFound;
            case "ClassNotFound":
                return bentleyjs_core_1.WSStatus.ClassNotFound;
            case "PropertyNotFound":
                return bentleyjs_core_1.WSStatus.PropertyNotFound;
            case "LinkTypeNotFound":
                return bentleyjs_core_1.WSStatus.ClassNotFound;
            case "ObjectNotFound":
                return bentleyjs_core_1.WSStatus.InstanceNotFound;
            case "InstanceNotFound":
                return bentleyjs_core_1.WSStatus.InstanceNotFound;
            case "FileNotFound":
                return bentleyjs_core_1.WSStatus.FileNotFound;
            case "NotSupported":
                return bentleyjs_core_1.WSStatus.NotSupported;
            case "NoServerLicense":
                return bentleyjs_core_1.WSStatus.NoServerLicense;
            case "NoClientLicense":
                return bentleyjs_core_1.WSStatus.NoClientLicense;
            case "TooManyBadLoginAttempts":
                return bentleyjs_core_1.WSStatus.TooManyBadLoginAttempts;
            default:
                return bentleyjs_core_1.WSStatus.Unknown;
        }
    }
    /**
     * Logs this error
     */
    log() {
        bentleyjs_core_1.Logger.logError(loggerCategory, this.logMessage(), this.getMetaData());
    }
}
exports.WsgError = WsgError;
/**
 * Provider for wsg RequestOptions, used by WsgClient to set defaults.
 * @internal
 */
class DefaultWsgRequestOptionsProvider extends Client_1.DefaultRequestOptionsProvider {
    /**
     * Creates an instance of DefaultWsgRequestOptionsProvider and sets up the default options.
     */
    constructor() {
        super();
        this._defaultOptions.errorCallback = WsgError.parse;
        this._defaultOptions.retryCallback = WsgError.shouldRetry;
    }
}
exports.DefaultWsgRequestOptionsProvider = DefaultWsgRequestOptionsProvider;
/**
 * Base class for Client implementations of services that are based on WSG
 * @beta
 */
class WsgClient extends Client_1.Client {
    /**
     * Creates an instance of Client.
     * @param apiVersion ApiVersion if the service supports it
     */
    constructor(apiVersion) {
        super();
        this.apiVersion = apiVersion;
        this.apiVersion = apiVersion;
    }
    /**
     * Augments request options with defaults returned by the DefaultWsgRequestOptionsProvider.
     * @note that the options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to augment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!WsgClient._defaultWsgRequestOptionsProvider)
            WsgClient._defaultWsgRequestOptionsProvider = new DefaultWsgRequestOptionsProvider();
        return WsgClient._defaultWsgRequestOptionsProvider.assignOptions(options);
    }
    /**
     * Gets the URL of the service.
     * Attempts to discover and cache the URL from the URL Discovery Service. If not
     * found uses the default URL provided by client implementations. Note that for consistency
     * sake, the URL is stripped of any trailing "/"
     * @param excludeApiVersion Pass true to optionally exclude the API version from the URL.
     * @returns URL for the service
     */
    async getUrl(requestContext, excludeApiVersion) {
        if (this._url) {
            return Promise.resolve(this._url);
        }
        return super.getUrl(requestContext)
            .then(async (url) => {
            this._url = url;
            if (!excludeApiVersion) {
                this._url += "/" + this.apiVersion;
            }
            return Promise.resolve(this._url); // TODO: On the server this really needs a lifetime!!
        });
    }
    /**
     * Gets the (delegation) access token to access the service
     * @param authTokenInfo Access token.
     * @returns Resolves to the (delegation) access token.
     * @internal
     */
    async getAccessToken(requestContext, authorizationToken) {
        const imsClient = new ImsClients_1.ImsDelegationSecureTokenClient();
        return imsClient.getToken(requestContext, authorizationToken, this.getRelyingPartyUrl());
    }
    /** used by clients to delete strongly typed instances through the standard WSG REST API */
    async deleteInstance(requestContext, relativeUrlPath, instance, requestOptions) {
        requestContext.enter();
        const url = await this.getUrl(requestContext) + relativeUrlPath;
        requestContext.enter();
        const untypedInstance = instance ? ECJsonTypeMap_1.ECJsonTypeMap.toJson("wsg", instance) : undefined;
        const options = {
            method: "DELETE",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            body: {
                instance: untypedInstance,
            },
        };
        if (requestOptions) {
            options.body.requestOptions = requestOptions;
        }
        await this.setupOptionDefaults(options);
        return Request_1.request(requestContext, url, options).then(async () => Promise.resolve());
    }
    /**
     * Used by clients to post strongly typed instances through standard WSG REST API
     * @param requestContext The client request context
     * @param typedConstructor Used by clients to post a strongly typed instance through the REST API that's expected to return a standard response.
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instance Strongly typed instance to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instance that's returned back from the server.
     */
    async postInstance(requestContext, typedConstructor, relativeUrlPath, instance, requestOptions) {
        const url = await this.getUrl(requestContext) + relativeUrlPath;
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Sending POST request", () => ({ url }));
        const untypedInstance = ECJsonTypeMap_1.ECJsonTypeMap.toJson("wsg", instance);
        const options = {
            method: "POST",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            body: {
                instance: untypedInstance,
            },
        };
        if (requestOptions) {
            options.body.requestOptions = requestOptions;
        }
        await this.setupOptionDefaults(options);
        requestContext.enter();
        const res = await Request_1.request(requestContext, url, options);
        requestContext.enter();
        if (!res.body || !res.body.changedInstance || !res.body.changedInstance.instanceAfterChange) {
            return Promise.reject(new Error(`POST to URL ${url} executed successfully, but did not return the expected result.`));
        }
        const ecJsonInstance = res.body.changedInstance.instanceAfterChange;
        const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", ecJsonInstance);
        // console.log(JSON.stringify(res.body.instances));
        if (!typedInstance) {
            return Promise.reject(new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`));
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Successful POST request", () => ({ url }));
        return Promise.resolve(typedInstance);
    }
    /** Used by clients to post multiple strongly typed instances through standard WSG REST API
     * @param requestContext Client request context
     * @param typedConstructor Used by clients to post a strongly typed instances through the REST API that's expected to return a standard response.
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instances Strongly typed instances to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instances that's returned back from the server.
     */
    async postInstances(requestContext, typedConstructor, relativeUrlPath, instances, requestOptions) {
        requestContext.enter();
        const url = await this.getUrl(requestContext) + relativeUrlPath;
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Sending POST request", () => ({ url }));
        const untypedInstances = instances.map((value) => ECJsonTypeMap_1.ECJsonTypeMap.toJson("wsg", value));
        const options = {
            method: "POST",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            body: {
                instances: untypedInstances,
            },
        };
        if (requestOptions) {
            options.body.requestOptions = requestOptions;
        }
        await this.setupOptionDefaults(options);
        requestContext.enter();
        const res = await Request_1.request(requestContext, url, options);
        requestContext.enter();
        if (!res.body || !res.body.changedInstances) {
            return Promise.reject(new Error(`POST to URL ${url} executed successfully, but did not return the expected result.`));
        }
        const changedInstances = res.body.changedInstances.map((value) => {
            const untypedInstance = value.instanceAfterChange;
            if (!untypedInstance) {
                throw new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`);
            }
            const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", untypedInstance);
            if (!typedInstance) {
                throw new Error(`POST to URL ${url} executed successfully, but could not convert response to a strongly typed instance.`);
            }
            return typedInstance;
        });
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Successful POST request", () => ({ url }));
        return Promise.resolve(changedInstances);
    }
    // @todo Use lower level utilities instead of the node based Request API.
    // @todo Deserialize stream directly to the type, instead of creating an intermediate JSON object.
    /**
     * Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.
     * @param requestContext Client request context
     * @param typedConstructor Constructor function for the type
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    async getInstances(requestContext, typedConstructor, relativeUrlPath, queryOptions) {
        requestContext.enter();
        const url = await this.getUrl(requestContext) + relativeUrlPath;
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Sending GET request", () => ({ url }));
        let useSkipToken = false;
        let instancesLeft = -1;
        if (queryOptions) {
            if (!queryOptions.$top) {
                // Top was undefined. All instances must be returned by using SkipToken.
                queryOptions.$top = queryOptions.$pageSize;
                useSkipToken = true;
            }
            else if (queryOptions.$pageSize) {
                // Top and PageSize are defined. If Top is less or equal to PageSize then single request should be performed.
                // Otherwise multiple request should be performed by using SkipToken.
                if (queryOptions.$top > queryOptions.$pageSize) {
                    instancesLeft = queryOptions.$top;
                    queryOptions.$top = queryOptions.$pageSize;
                    useSkipToken = true;
                }
            }
            // Clear PageSize so that it won't be included in url.
            queryOptions.$pageSize = undefined;
        }
        let skipToken = "";
        const typedInstances = new Array();
        do {
            if (useSkipToken && instancesLeft > 0) {
                // Top was greater than PageSize. Update Top if this is the last page.
                if (instancesLeft > queryOptions.$top) {
                    instancesLeft -= queryOptions.$top;
                }
                else {
                    queryOptions.$top = instancesLeft;
                    useSkipToken = false;
                }
            }
            const options = {
                method: "GET",
                qs: queryOptions,
                accept: "application/json",
            };
            if (skipToken.length === 0) {
                options.headers = {
                    authorization: requestContext.accessToken.toTokenString(),
                };
            }
            else {
                options.headers = {
                    authorization: requestContext.accessToken.toTokenString(),
                    skiptoken: skipToken,
                };
            }
            await this.setupOptionDefaults(options);
            requestContext.enter();
            const res = await Request_1.request(requestContext, url, options);
            requestContext.enter();
            if (!res.body || !res.body.hasOwnProperty("instances")) {
                return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return any instances.`));
            }
            // console.log(JSON.stringify(res.body.instances));
            for (const ecJsonInstance of res.body.instances) {
                const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", ecJsonInstance);
                if (typedInstance) {
                    typedInstances.push(typedInstance);
                }
            }
            skipToken = res.header.skiptoken;
        } while (skipToken && useSkipToken);
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Successful GET request", () => ({ url }));
        return Promise.resolve(typedInstances);
    }
    getQueryRequestBody(queryOptions) {
        const addPart = (query, key, value) => {
            if (query !== "")
                query += "&";
            query += `${key}=${value}`;
            return query;
        };
        let result = "";
        if (queryOptions.$filter) {
            result = addPart(result, "$filter", queryOptions.$filter);
        }
        if (queryOptions.$orderby) {
            result = addPart(result, "$orderby", queryOptions.$orderby);
        }
        if (queryOptions.$select) {
            result = addPart(result, "$select", queryOptions.$select);
        }
        if (queryOptions.$skip) {
            result = addPart(result, "$skip", queryOptions.$skip.toString(10));
        }
        if (queryOptions.$top) {
            result = addPart(result, "$top", queryOptions.$top.toString(10));
        }
        return result;
    }
    /** Used by clients to get strongly typed instances from standard WSG REST queries that return EC JSON instances.
     * @param typedConstructor Constructor function for the type
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    async postQuery(requestContext, typedConstructor, relativeUrlPath, queryOptions) {
        requestContext.enter();
        const url = `${await this.getUrl(requestContext)}${relativeUrlPath}$query`;
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Sending POST request", () => ({ url }));
        const options = {
            method: "POST",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            body: this.getQueryRequestBody(queryOptions),
        };
        await this.setupOptionDefaults(options);
        requestContext.enter();
        const res = await Request_1.request(requestContext, url, options);
        requestContext.enter();
        if (!res.body || !res.body.hasOwnProperty("instances")) {
            return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return any instances.`));
        }
        // console.log(JSON.stringify(res.body.instances));
        const typedInstances = new Array();
        for (const ecJsonInstance of res.body.instances) {
            const typedInstance = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(typedConstructor, "wsg", ecJsonInstance);
            if (typedInstance) {
                typedInstances.push(typedInstance);
            }
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Successful POST request", () => ({ url }));
        return Promise.resolve(typedInstances);
    }
}
WsgClient.configHostRelyingPartyUri = "imjs_default_relying_party_uri";
WsgClient.configUseHostRelyingPartyUriAsFallback = "imjs_use_default_relying_party_uri_as_fallback";
exports.WsgClient = WsgClient;


/***/ }),

/***/ "./lib/imodelbank/IModelBankClient.js":
/*!********************************************!*\
  !*** ./lib/imodelbank/IModelBankClient.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const IModelClient_1 = __webpack_require__(/*! ../IModelClient */ "./lib/IModelClient.js");
const IModelBankHandler_1 = __webpack_require__(/*! ./IModelBankHandler */ "./lib/imodelbank/IModelBankHandler.js");
/** Class that allows access to different iModelHub class handlers.
 * Handlers should be accessed through an instance of this class, rather than constructed directly.
 * @internal
 */
class IModelBankClient extends IModelClient_1.IModelClient {
    /** Creates an instance of IModelBankClient.
     * @param url Url to iModel Bank instance.
     */
    constructor(url, handler) {
        super(new IModelBankHandler_1.IModelBankHandler(url, handler));
    }
}
exports.IModelBankClient = IModelBankClient;


/***/ }),

/***/ "./lib/imodelbank/IModelBankFileSystemContextClient.js":
/*!*************************************************************!*\
  !*** ./lib/imodelbank/IModelBankFileSystemContextClient.js ***!
  \*************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ConnectClients_1 = __webpack_require__(/*! ../ConnectClients */ "./lib/ConnectClients.js");
const Errors_1 = __webpack_require__(/*! ../imodelhub/Errors */ "./lib/imodelhub/Errors.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const Request_1 = __webpack_require__(/*! ../Request */ "./lib/Request.js");
const WsgClient_1 = __webpack_require__(/*! ../WsgClient */ "./lib/WsgClient.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelBank;
/** @internal */
class IModelBankFileSystemContextClient {
    constructor(baseUri) {
        this.baseUri = baseUri;
    }
    async queryContextProps(requestContext, projectName) {
        requestContext.enter();
        const url = this.baseUri + "/sv1.0/Repositories/IModelBankFileSystem--main/IModelBankFileSystem/Context";
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Sending GET request to ${url}`);
        const queryOptions = {
            $select: "*",
            $filter: `name+eq+'${projectName}'`,
        };
        const options = {
            method: "GET",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            qs: queryOptions,
            accept: "application/json",
        };
        const res = await Request_1.request(requestContext, url, options);
        requestContext.enter();
        if (!res.body) {
            return Promise.reject(new Error(`Query to URL ${url} executed successfully, but did NOT return anything.`));
        }
        const props = res.body;
        if (props.length === 0)
            return Promise.reject(new WsgClient_1.WsgError(bentleyjs_core_1.WSStatus.InstanceNotFound));
        if (props.length !== 1)
            return Promise.reject(new Errors_1.IModelHubClientError(bentleyjs_core_1.IModelHubStatus.InvalidArgumentError));
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Successful GET request to ${url}`);
        return props;
    }
    async queryAssetByName(requestContext, assetName) {
        const props = await this.queryContextProps(requestContext, assetName);
        requestContext.enter();
        const asset = new ConnectClients_1.Asset();
        asset.wsgId = asset.ecId = props[0].id;
        asset.name = props[0].name;
        return Promise.resolve(asset);
    }
    async queryProjectByName(requestContext, projectName) {
        const props = await this.queryContextProps(requestContext, projectName);
        requestContext.enter();
        const project = new ConnectClients_1.Project();
        project.wsgId = project.ecId = props[0].id;
        project.name = props[0].name;
        return Promise.resolve(project);
    }
    async createContext(requestContext, name) {
        requestContext.enter();
        const url = this.baseUri + "/sv1.0/Repositories/IModelBankFileSystem--main/IModelBankFileSystem/Context";
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Sending POST request to ${url}`);
        const body = { name, id: "", description: "" };
        const options = {
            method: "POST",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            body,
        };
        return Request_1.request(requestContext, url, options).then(async () => Promise.resolve());
    }
    async deleteContext(requestContext, contextId) {
        requestContext.enter();
        const url = this.baseUri + "/sv1.0/Repositories/IModelBankFileSystem--main/IModelBankFileSystem/Context/" + contextId;
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Sending DELETE request to ${url}`);
        const options = {
            method: "DELETE",
            headers: { authorization: requestContext.accessToken.toTokenString() },
        };
        return Request_1.request(requestContext, url, options).then(async () => Promise.resolve());
    }
}
exports.IModelBankFileSystemContextClient = IModelBankFileSystemContextClient;


/***/ }),

/***/ "./lib/imodelbank/IModelBankHandler.js":
/*!*********************************************!*\
  !*** ./lib/imodelbank/IModelBankHandler.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelBank */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const BaseHandler_1 = __webpack_require__(/*! ../imodelhub/BaseHandler */ "./lib/imodelhub/BaseHandler.js");
/**
 * This class acts as the WsgClient for other iModelBank Handlers.
 * @beta
 */
class IModelBankHandler extends BaseHandler_1.IModelBaseHandler {
    /**
     * Creates an instance of IModelBankWsgClient.
     * @param handler The upload/download handler to use -- backends only.
     * @param keepAliveDuration TBD
     */
    constructor(url, handler, keepAliveDuration = 30000) {
        super(keepAliveDuration, handler);
        this._baseUrl = url;
    }
    getUrlSearchKey() { bentleyjs_core_1.assert(false, "Bentley cloud-specific method should be factored out of WsgClient base class"); return ""; }
    async getUrl(_requestContext, excludeApiVersion) {
        if (this._url)
            return Promise.resolve(this._url);
        this._url = this._baseUrl;
        if (!excludeApiVersion) {
            this._url += "/" + this.apiVersion;
        }
        return Promise.resolve(this._url);
    }
}
exports.IModelBankHandler = IModelBankHandler;


/***/ }),

/***/ "./lib/imodelhub/BaseHandler.js":
/*!**************************************!*\
  !*** ./lib/imodelhub/BaseHandler.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const WsgClient_1 = __webpack_require__(/*! ../WsgClient */ "./lib/WsgClient.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const ImsClients_1 = __webpack_require__(/*! ../ImsClients */ "./lib/ImsClients.js");
const CustomRequestOptions_1 = __webpack_require__(/*! ./CustomRequestOptions */ "./lib/imodelhub/CustomRequestOptions.js");
const Config_1 = __webpack_require__(/*! ../Config */ "./lib/Config.js");
/**
 * Provides default options for iModelHub requests.
 */
class DefaultIModelHubRequestOptionsProvider extends WsgClient_1.DefaultWsgRequestOptionsProvider {
    constructor(agent) {
        super();
        this._defaultOptions.errorCallback = Errors_1.IModelHubError.parse;
        this._defaultOptions.retryCallback = Errors_1.IModelHubError.shouldRetry;
        this._defaultOptions.agent = agent;
    }
}
/**
 * This class acts as the WsgClient for other iModelHub Handlers.
 * @beta
 */
class IModelBaseHandler extends WsgClient_1.WsgClient {
    /**
     * Create an instance of IModelBaseHandler.
     * @internal
     */
    constructor(keepAliveDuration = 30000, fileHandler) {
        super("sv1.1");
        this._customRequestOptions = new CustomRequestOptions_1.CustomRequestOptions();
        this._fileHandler = fileHandler;
        const isMobile = typeof (self) !== "undefined" && self.imodeljsMobile;
        if (!(typeof window === "undefined") && !isMobile) {
            // tslint:disable-next-line:no-var-requires
            this._agent = __webpack_require__(/*! https */ "../../common/temp/node_modules/.registry.npmjs.org/https-browserify/1.0.0/node_modules/https-browserify/index.js").Agent({ keepAlive: keepAliveDuration > 0, keepAliveMsecs: keepAliveDuration, secureProtocol: "TLSv1_2_method" });
        }
    }
    formatContextIdForUrl(contextId) { return contextId; }
    getFileHandler() { return this._fileHandler; }
    /**
     * Augment request options with defaults returned by the DefaultIModelHubRequestOptionsProvider. Note that the options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to augment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!this._defaultIModelHubOptionsProvider)
            this._defaultIModelHubOptionsProvider = new DefaultIModelHubRequestOptionsProvider(this._agent);
        return this._defaultIModelHubOptionsProvider.assignOptions(options);
    }
    /**
     * Get name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return IModelBaseHandler.searchKey;
    }
    /**
     * Gets theRelyingPartyUrl for the service.
     * @returns RelyingPartyUrl for the service.
     */
    getRelyingPartyUrl() {
        if (Config_1.Config.App.has(IModelBaseHandler.configRelyingPartyUri))
            return Config_1.Config.App.get(IModelBaseHandler.configRelyingPartyUri) + "/";
        if (Config_1.Config.App.getBoolean(WsgClient_1.WsgClient.configUseHostRelyingPartyUriAsFallback, true)) {
            if (Config_1.Config.App.has(WsgClient_1.WsgClient.configHostRelyingPartyUri))
                return Config_1.Config.App.get(WsgClient_1.WsgClient.configHostRelyingPartyUri) + "/";
        }
        throw new Error(`RelyingPartyUrl not set. Set it in Config.App using key ${IModelBaseHandler.configRelyingPartyUri}`);
    }
    /**
     * Get the agent used for imodelhub connection pooling.
     * @returns The agent used for imodelhub connection pooling.
     */
    getAgent() {
        return this._agent;
    }
    /**
     * Get the URL of the service. This method attempts to discover and cache the URL from the URL Discovery Service. If not found uses the default URL provided by client implementations. Note that for consistency sake, the URL is stripped of any trailing "/"
     * @returns URL for the service
     */
    async getUrl(requestContext) {
        return super.getUrl(requestContext);
    }
    /**
     * Get the (delegation) access token to access the service
     * @param requestContext The client request context
     * @param authorizationToken Authorization token.
     * @returns Resolves to the (delegation) access token.
     * @internal
     */
    async getAccessToken(requestContext, authorizationToken) {
        const imsClient = new ImsClients_1.ImsDelegationSecureTokenClient();
        return imsClient.getToken(requestContext, authorizationToken, this.getRelyingPartyUrl());
    }
    /**
     * Send a delete request. Sends a request without body.
     * @param requestContext The client request context
     * @param relativeUrlPath Relative path to the REST resource.
     * @returns Promise resolves after successfully deleting REST resource at the specified path.
     */
    async delete(requestContext, relativeUrlPath) {
        return super.delete(requestContext, relativeUrlPath);
    }
    /**
     * Delete a strongly typed instance. Sends a request body with a WSG instance.
     * @param requestContext The client request context
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instance Instance to be deleted.
     * @param requestOptions WSG options for the request.
     * @returns Promise resolves after successfully deleting instance.
     */
    async deleteInstance(requestContext, relativeUrlPath, instance, requestOptions) {
        if (this._customRequestOptions.isSet) {
            if (!requestOptions) {
                requestOptions = {};
            }
            requestOptions.CustomOptions = this._customRequestOptions.insertCustomOptions(requestOptions.CustomOptions);
        }
        return super.deleteInstance(requestContext, relativeUrlPath, instance, requestOptions);
    }
    /**
     * Post a strongly typed instance. Sends a request body with a WSG instance.
     * @param requestContext The client request context
     * @param typedConstructor Used to construct the resulting instances from the response.
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instance Strongly typed instance to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instance that's returned back from the server.
     */
    async postInstance(requestContext, typedConstructor, relativeUrlPath, instance, requestOptions) {
        if (this._customRequestOptions.isSet) {
            if (!requestOptions) {
                requestOptions = {};
            }
            requestOptions.CustomOptions = this._customRequestOptions.insertCustomOptions(requestOptions.CustomOptions);
        }
        return super.postInstance(requestContext, typedConstructor, relativeUrlPath, instance, requestOptions);
    }
    /**
     * Post multiple strongly typed instances. Sends a request body with WSG instances.
     * @param requestContext The client request context
     * @param typedConstructor Used to construct the resulting instances from the response.
     * @param relativeUrlPath Relative path to the REST resource.
     * @param instances Strongly typed instances to be posted.
     * @param requestOptions WSG options for the request.
     * @returns The posted instances that's returned back from the server.
     */
    async postInstances(requestContext, typedConstructor, relativeUrlPath, instances, requestOptions) {
        return super.postInstances(requestContext, typedConstructor, relativeUrlPath, instances, requestOptions);
    }
    /**
     * Get multiple strongly typed instances.
     * @param requestContext The client request context
     * @param typedConstructor Used to construct the resulting instances from the response.
     * @param token Delegation token of the authorized user.
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    async getInstances(requestContext, typedConstructor, relativeUrlPath, queryOptions) {
        return super.getInstances(requestContext, typedConstructor, relativeUrlPath, queryOptions);
    }
    /**
     * Get multiple strongly typed instances. Sends query in the request's body. This can be used for queries that are too long to fit in URL.
     * @param requestContext The client request context
     * @param typedConstructor Used to construct the resulting instances from the response.
     * @param relativeUrlPath Relative path to the REST resource.
     * @param queryOptions Query options.
     * @returns Array of strongly typed instances.
     */
    async postQuery(requestContext, typedConstructor, relativeUrlPath, queryOptions) {
        return super.postQuery(requestContext, typedConstructor, relativeUrlPath, queryOptions);
    }
    /**
     * Get an instance of CustomRequestOptions, which can be used to set custom request parameters for all future requests made by this handler.
     */
    getCustomRequestOptions() {
        return this._customRequestOptions;
    }
}
IModelBaseHandler.searchKey = "iModelHubApi";
IModelBaseHandler.configRelyingPartyUri = "imjs_imodelhub_relying_party_uri";
exports.IModelBaseHandler = IModelBaseHandler;


/***/ }),

/***/ "./lib/imodelhub/Briefcases.js":
/*!*************************************!*\
  !*** ./lib/imodelhub/Briefcases.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/** Controls whether the user has exclusive or shared access to a local briefcase
 * @internal
 */
var BriefcaseAccessMode;
(function (BriefcaseAccessMode) {
    BriefcaseAccessMode[BriefcaseAccessMode["Shared"] = 0] = "Shared";
    BriefcaseAccessMode[BriefcaseAccessMode["Exclusive"] = 1] = "Exclusive";
})(BriefcaseAccessMode = exports.BriefcaseAccessMode || (exports.BriefcaseAccessMode = {}));
/**
 * Briefcase is a copy of the master file, that user acquires to work with the iModel. Briefcase instance represents metadata about a copy of iModel's master file.
 *
 * File properties describe the file that would be downloaded through downloadUrl. It is the most recently updated copy of master file that is stored on iModelHub. These copies do not necessarily have the latest [[ChangeSet]] applied to them.
 *
 * briefcaseId is the id that user needs to write into the local copy of master file and use for other iModelHub requests. briefcaseId ranges from 2 to 16777215, see [BriefcaseId]($backend).
 * @internal
 */
let Briefcase = class Briefcase extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], Briefcase.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
], Briefcase.prototype, "fileDescription", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], Briefcase.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
], Briefcase.prototype, "fileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId"),
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "briefcaseId")
], Briefcase.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserOwned"),
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "userId")
], Briefcase.prototype, "userId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MergedChangeSetId")
], Briefcase.prototype, "mergedChangeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.AcquiredDate")
], Briefcase.prototype, "acquiredDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsReadOnly"),
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "isReadOnly")
], Briefcase.prototype, "isReadOnly", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], Briefcase.prototype, "downloadUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "accessMode")
], Briefcase.prototype, "accessMode", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "localPathname")
], Briefcase.prototype, "localPathname", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "lastAccessedAt")
], Briefcase.prototype, "lastAccessedAt", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("ecdb", "iModelId")
], Briefcase.prototype, "iModelId", void 0);
Briefcase = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Briefcase", { schemaPropertyName: "schemaName", classPropertyName: "className" }),
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("ecdb", "ServiceStore.Briefcase", { classKeyPropertyName: "className" })
], Briefcase);
exports.Briefcase = Briefcase;
/**
 * Query object for getting [[Briefcase]]s. You can use this to modify the [[BriefcaseHandler.get]] results.
 * @internal
 */
class BriefcaseQuery extends Query_1.Query {
    /**
     * Query single [[Briefcase]] by its id. If briefcase is not found, request will be rejected with a [[WsgError]] and status [WSStatus.InstanceNotFound]($bentley).
     * @param id Id of the Briefcase.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid Briefcase id value.
     */
    byId(id) {
        Errors_1.ArgumentCheck.validBriefcaseId("id", id);
        this._byId = id;
        return this;
    }
    /**
     * Used by handler to get the id that is queried.
     * @returns Value that was set with byId method.
     * @internal
     */
    getId() {
        return this._byId;
    }
    /**
     * Query will additionally select [[Briefcase]] file download URL. This is needed to use the Briefcase object with [[BriefcaseHandler.download]].
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
    /**
     * Query will select [[Briefcase]]s owned by this user.
     * @returns This query.
     */
    ownedByMe() {
        this.addFilter("UserOwned+eq+'@me'");
        return this;
    }
}
exports.BriefcaseQuery = BriefcaseQuery;
/**
 * Handler for managing [[Briefcase]]s. Use [[IModelClient.Briefcases]] to get an instance of this class.
 * In most cases, you should use [IModelDb]($backend) methods instead.
 * @internal
 */
class BriefcaseHandler {
    /** Constructor for BriefcaseHandler. Use [[IModelClient]] instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     * @internal
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /** Get relative url for Briefcase requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param briefcaseId Id of the briefcase.
     * @internal
     */
    getRelativeUrl(iModelId, briefcaseId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/Briefcase/${briefcaseId || ""}`;
    }
    /** Acquire a [[Briefcase]] for the specified iModel. This assigns you a new briefcaseId and returns you a download link.
     * A briefcase is automatically acquired when calling [IModelDb.open]($backend) or [IModelDb.create]($backend). You should use this method only when you want to acquire the briefcaseId without downloading the file. If you need just the download link, you can call [[BriefcaseHandler.get]] with [[BriefcaseQuery.selectDownloadUrl]].
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @returns The acquired Briefcase instance.
     * @throws [[IModelHubError]] with [IModelHubStatus.MaximumNumberOfBriefcasesPerUser]($bentley) or [IModelHubStatus.MaximumNumberOfBriefcasesPerUserPerMinute]($bentley) if a limit of Briefcases for that user was reached. Users should use the Briefcases they have previously acquired. If that is no longer possible, they should delete them, to be able to acquire new ones.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, iModelId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Acquiring briefcase for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        let briefcase = new Briefcase();
        briefcase = await this._handler.postInstance(requestContext, Briefcase, this.getRelativeUrl(iModelId), briefcase);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Acquired briefcase for iModel", () => briefcase);
        return briefcase;
    }
    /** Delete the [[Briefcase]] from iModelHub. This frees up the id to be reused later and allows user to acquire additional briefcases if one of the briefcase limits was reached.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param briefcaseId Id of the Briefcase to be deleted.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async delete(requestContext, iModelId, briefcaseId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Deleting briefcase from iModel", () => ({ iModelId, briefcaseId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, briefcaseId));
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Deleted briefcase from iModel", () => ({ iModelId, briefcaseId }));
    }
    /** Get the [[Briefcase]]s.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried Briefcases or select different data from them.
     * @returns Briefcases that match the query.
     * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[BriefcaseQuery.byId]] is used and a Briefcase with the specified id could not be found.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new BriefcaseQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying briefcases for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const id = query.getId();
        const briefcases = await this._handler.getInstances(requestContext, Briefcase, this.getRelativeUrl(iModelId, id), query.getQueryOptions());
        requestContext.enter();
        for (const briefcase of briefcases) {
            briefcase.iModelId = iModelId;
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Queried briefcases for iModel", () => ({ iModelId, count: briefcases.length }));
        return briefcases;
    }
    /** Download the latest copy of master file. This only downloads the file and does not write the [[Briefcase]] id into it. Use [IModelDb.open]($backend) instead if you want to get a Briefcase file you can work with.
     * This method does not work on the browser. Directory containing the Briefcase file is created if it does not exist. If there is an error during download, any partially downloaded file is deleted from disk.
     * @param requestContext The client request context
     * @param briefcase Briefcase to download. This needs to include a download link. See [[BriefcaseQuery.selectDownloadUrl]].
     * @param path Path where briefcase file should be downloaded, including filename.
     * @param progressCallback Callback for tracking progress.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.NotSupportedInBrowser]($bentley) if called in a browser.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.FileHandlerNotSet]($bentley) if [[FileHandler]] instance was not set for [[IModelClient]].
     * @throws [[ResponseError]] if the briefcase cannot be downloaded.
     */
    async download(requestContext, briefcase, path, progressCallback) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Started downloading briefcase", () => (Object.assign({}, briefcase, { path })));
        Errors_1.ArgumentCheck.defined("briefcase", briefcase);
        Errors_1.ArgumentCheck.defined("path", path);
        if (typeof window !== "undefined")
            return Promise.reject(Errors_1.IModelHubClientError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubClientError.fileHandler());
        if (!briefcase.downloadUrl)
            return Promise.reject(Errors_1.IModelHubClientError.missingDownloadUrl("briefcase"));
        await this._fileHandler.downloadFile(requestContext, briefcase.downloadUrl, path, parseInt(briefcase.fileSize, 10), progressCallback);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Finished downloading briefcase", () => (Object.assign({}, briefcase, { path })));
    }
}
exports.BriefcaseHandler = BriefcaseHandler;


/***/ }),

/***/ "./lib/imodelhub/ChangeSets.js":
/*!*************************************!*\
  !*** ./lib/imodelhub/ChangeSets.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/**
 * Specifies types of changes in a [[ChangeSet]].
 * @beta
 */
var ChangesType;
(function (ChangesType) {
    /** [[ChangeSet]] contains regular file changes (e.g. changes to elements or models). */
    ChangesType[ChangesType["Regular"] = 0] = "Regular";
    /** [[ChangeSet]] only contains schema changes. */
    ChangesType[ChangesType["Schema"] = 1] = "Schema";
})(ChangesType = exports.ChangesType || (exports.ChangesType = {}));
/**
 * [ChangeSet]($docs/learning/Glossary.md#changeset) represents a file containing changes to the iModel. A single ChangeSet contains changes made on a single [[Briefcase]] file and pushed as a single file. ChangeSets form a linear change history of the iModel. If a user wants to push their changes to iModelHub, they first have to merge all ChangeSet they do not have yet. Only a single briefcase is allowed to push their changes at a time.
 * @beta
 */
let ChangeSet = class ChangeSet extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Id")
], ChangeSet.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], ChangeSet.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], ChangeSet.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], ChangeSet.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Index")
], ChangeSet.prototype, "index", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ParentId")
], ChangeSet.prototype, "parentId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SeedFileId")
], ChangeSet.prototype, "seedFileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
], ChangeSet.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserCreated")
], ChangeSet.prototype, "userCreated", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.PushDate")
], ChangeSet.prototype, "pushDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ContainingChanges")
], ChangeSet.prototype, "changesType", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsUploaded")
], ChangeSet.prototype, "isUploaded", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], ChangeSet.prototype, "downloadUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.UploadUrl")
], ChangeSet.prototype, "uploadUrl", void 0);
ChangeSet = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.ChangeSet", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], ChangeSet);
exports.ChangeSet = ChangeSet;
/**
 * Query object for getting [[ChangeSet]]s. You can use this to modify the query. See [[ChangeSetHandler.get]].
 * @beta
 */
class ChangeSetQuery extends Query_1.StringIdQuery {
    /** Constructor that sets default page size. */
    constructor() {
        super();
        this.pageSize(ChangeSetQuery.defaultPageSize);
    }
    /**
     * Query will additionally select [[ChangeSet]] file download URL. This is needed to use the ChangeSet object with [[ChangeSetHandler.download]].
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
    /** @internal */
    checkValue(id) {
        Errors_1.ArgumentCheck.validChangeSetId("id", id);
    }
    /**
     * Query [[ChangeSet]]s that are after the specified ChangeSet. This overrides any previously applied ChangeSetQuery filters. Query will return all of the ChangeSets that are newer than the one specified by id. ChangeSet specified by the id will not be included in the results. Returned ChangeSets will be in an ascending order.
     * @param id Id of a ChangeSet.
     * @returns This query.
     */
    fromId(id) {
        Errors_1.ArgumentCheck.validChangeSetId("id", id);
        this._query.$filter = `FollowingChangeSet-backward-ChangeSet.Id+eq+'${id}'`;
        return this;
    }
    /**
     * Change the order of results to be from newest [[ChangeSet]]s to the oldest ones.
     * @returns This query.
     */
    latest() {
        this._query.$orderby = "Index+desc";
        return this;
    }
    /**
     * Query [[ChangeSet]]s between two specified ChangeSets. This overrides any previously applied ChangeSetQuery filters. This query will work when either of the ChangeSet ids points to an earlier ChangeSet. Latest ChangeSet specified by this range will be included in the results, but the earliest will be excluded. If the second ChangeSet id is not specified, it's assumed that it's the same as an empty id, and query will return all ChangeSets from the start up to the ChangeSet with the first id. Returned ChangeSets will be in an ascending order.
     * @param firstChangeSetId Id of the first changeSet.
     * @param secondChangeSetId Id of the second changeSet.
     * @returns This query.
     */
    betweenChangeSets(firstChangeSetId, secondChangeSetId) {
        Errors_1.ArgumentCheck.validChangeSetId("firstChangeSetId", firstChangeSetId);
        if (secondChangeSetId)
            Errors_1.ArgumentCheck.validChangeSetId("secondChangeSetId", secondChangeSetId);
        let query;
        if (!secondChangeSetId) {
            query = `CumulativeChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}'`;
        }
        else {
            query = `(CumulativeChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}'`;
            query += `+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${secondChangeSetId}')`;
            query += `+or+(CumulativeChangeSet-backward-ChangeSet.Id+eq+'${secondChangeSetId}'`;
            query += `+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${firstChangeSetId}')`;
        }
        this._query.$filter = query;
        return this;
    }
    /**
     * Query [[ChangeSet]]s included in the specified [[Version]]. This overrides any previously applied ChangeSetQuery filters. Query will return all of the ChangeSets from the start up to the one specified by versionId. ChangeSet specified by versionId will be included in the results. Returned ChangeSets will be in an ascending order.
     * @param versionId Id of the version.
     * @returns This query.
     */
    getVersionChangeSets(versionId) {
        Errors_1.ArgumentCheck.validGuid("versionId", versionId);
        this._query.$filter = `CumulativeChangeSet-backward-Version.Id+eq+'${versionId}'`;
        return this;
    }
    /**
     * Query [[ChangeSet]]s after the specified [[Version]]. This overrides any previously applied ChangeSetQuery filters. Query will return all of the ChangeSets that are newer than the one specified by versionId. ChangeSet specified by versionId will not be included in the results. Returned ChangeSets will be in an ascending order.
     * @param versionId Id of the version.
     * @returns This query.
     */
    afterVersion(versionId) {
        Errors_1.ArgumentCheck.validGuid("versionId", versionId);
        this._query.$filter = `FollowingChangeSet-backward-Version.Id+eq+'${versionId}'`;
        return this;
    }
    /**
     * Query [[ChangeSet]]s between two specified [[Version]]s. This overrides any previously applied ChangeSetQuery filters. This query will work when either of the Version ids points to an earlier ChangeSet. Latest ChangeSet specified by this range will be included in the results, but the earliest will be excluded. Returned ChangeSets will be in an ascending order.
     * @param sourceVersionId Id of the source version.
     * @param destinationVersionId Id of the destination version.
     * @returns This query.
     */
    betweenVersions(sourceVersionId, destinationVersionId) {
        Errors_1.ArgumentCheck.validGuid("sourceVersionId", sourceVersionId);
        Errors_1.ArgumentCheck.validGuid("destinationVersionId", destinationVersionId);
        let query;
        query = `(FollowingChangeSet-backward-Version.Id+eq+'${sourceVersionId}'`;
        query += `+and+CumulativeChangeSet-backward-Version.Id+eq+'${destinationVersionId}')`;
        query += `+or+(FollowingChangeSet-backward-Version.Id+eq+'${destinationVersionId}'`;
        query += `+and+CumulativeChangeSet-backward-Version.Id+eq+'${sourceVersionId}')`;
        this._query.$filter = query;
        return this;
    }
    /**
     * Query [[ChangeSet]]s between the specified [[Version]] and another [[ChangeSet]]. This overrides any previously applied ChangeSetQuery filters. This query will work when either versionId or changeSetId points to an earlier ChangeSet. Latest ChangeSet specified by this range will be included in the results, but the earliest will be excluded. Returned ChangeSets will be in an ascending order.
     * @param versionId Id of the version.
     * @param changeSetId Id of the changeSet.
     * @returns This query.
     */
    betweenVersionAndChangeSet(versionId, changeSetId) {
        Errors_1.ArgumentCheck.validGuid("versionId", versionId);
        Errors_1.ArgumentCheck.validChangeSetId("changeSetId", changeSetId);
        let query;
        query = `(CumulativeChangeSet-backward-Version.Id+eq+'${versionId}'+and+FollowingChangeSet-backward-ChangeSet.Id+eq+'${changeSetId}')`;
        query += `+or+`;
        query += `(FollowingChangeSet-backward-Version.Id+eq+'${versionId}'+and+CumulativeChangeSet-backward-ChangeSet.Id+eq+'${changeSetId}')`;
        this._query.$filter = query;
        return this;
    }
    /**
     * Query changeSets by the seed file id. Should be obsolete, because seed file replacement is deprecated.
     * @param seedFileId Id of the seed file.
     * @returns This query.
     * @internal
     */
    bySeedFileId(seedFileId) {
        Errors_1.ArgumentCheck.validGuid("seedFileId", seedFileId);
        this.addFilter(`SeedFileId+eq+'${seedFileId}'`);
        return this;
    }
}
/**
 * Default page size which is used when querying ChangeSets
 * @internal
 */
ChangeSetQuery.defaultPageSize = 1000;
exports.ChangeSetQuery = ChangeSetQuery;
/** Queue for limiting number of promises executed in parallel. */
class ParallelQueue {
    constructor() {
        this._queue = [];
        this._parallelDownloads = 10;
    }
    /** Add a promise to the queue. */
    push(downloadFunc) {
        this._queue.push(downloadFunc);
    }
    /** Wait for all promises in the queue to finish. */
    async waitAll() {
        let i = 0;
        const promises = new Array();
        const indexes = new Array();
        const completed = new Array();
        while (this._queue.length > 0 || promises.length > 0) {
            while (this._queue.length > 0 && promises.length < this._parallelDownloads) {
                const currentIndex = i++;
                promises.push(this._queue[0]().then(() => completed.push(currentIndex)));
                indexes.push(currentIndex);
                this._queue.shift();
            }
            await Promise.race(promises);
            while (completed.length > 0) {
                const completedIndex = completed.shift();
                const index = indexes.findIndex((value) => value === completedIndex);
                if (index !== undefined) {
                    promises.splice(index, 1);
                    indexes.splice(index, 1);
                }
            }
        }
    }
}
/**
 * Handler for managing [[ChangeSet]]s. Use [[IModelClient.ChangeSets]] to get an instance of this class. In most cases, you should use [IModelDb]($backend) methods instead.
 * @beta
 */
class ChangeSetHandler {
    /**
     * Constructor for ChangeSetHandler. Should use [[IModelClient]] instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     * @internal
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /** Get relative url for ChangeSet requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param changeSetId Id of the ChangeSet.
     * @internal
     */
    getRelativeUrl(iModelId, changeSetId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/ChangeSet/${changeSetId || ""}`;
    }
    /** Get the [[ChangeSet]]s for the iModel.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried ChangeSets or select different data from them.
     * @returns ChangeSets that match the query.
     * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[InstanceIdQuery.byId]] is used and a [[ChangeSet]] with the specified id could not be found.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new ChangeSetQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Started querying ChangeSets`, () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const id = query.getId();
        const changeSets = await this._handler.getInstances(requestContext, ChangeSet, this.getRelativeUrl(iModelId, id), query.getQueryOptions());
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Finished querying ChangeSets`, () => ({ iModelId, count: changeSets.length }));
        return changeSets;
    }
    /**
     * Download the specified [[ChangeSet]]s. If you want to [pull]($docs/learning/Glossary.md#pull) and [merge]($docs/learning/Glossary.md#merge) ChangeSets from iModelHub to your [[Briefcase]], you should use [IModelDb.pullAndMergeChanges]($backend) instead.
     *
     * This method creates the directory containing the ChangeSets if necessary. If there is an error in downloading some of the ChangeSets, all partially downloaded ChangeSets are deleted from disk.
     * @param requestContext The client request context
     * @param changeSets ChangeSets to download. These need to include a download link. See [[ChangeSetQuery.selectDownloadUrl]].
     * @param path Path of directory where the ChangeSets should be downloaded.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley), if one of the required arguments is undefined or empty.
     * @param progressCallback Callback for tracking progress.
     * @throws [[ResponseError]] if the download fails.
     */
    async download(requestContext, changeSets, path, progressCallback) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Downloading ${changeSets.length} changesets`);
        Errors_1.ArgumentCheck.nonEmptyArray("changeSets", changeSets);
        Errors_1.ArgumentCheck.defined("path", path);
        if (typeof window !== "undefined")
            return Promise.reject(Errors_1.IModelHubClientError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubClientError.fileHandler());
        changeSets.forEach((changeSet) => {
            if (!changeSet.downloadUrl)
                throw Errors_1.IModelHubClientError.missingDownloadUrl("changeSets");
        });
        let totalSize = 0;
        let downloadedSize = 0;
        changeSets.forEach((value) => totalSize += parseInt(value.fileSize, 10));
        const queue = new ParallelQueue();
        const fileHandler = this._fileHandler;
        changeSets.forEach((changeSet) => queue.push(async () => {
            const downloadUrl = changeSet.downloadUrl;
            const downloadPath = fileHandler.join(path, changeSet.fileName);
            let previouslyDownloaded = 0;
            const callback = (progress) => {
                downloadedSize += (progress.loaded - previouslyDownloaded);
                previouslyDownloaded = progress.loaded;
                progressCallback({ loaded: downloadedSize, total: totalSize, percent: downloadedSize / totalSize });
            };
            return fileHandler.downloadFile(requestContext, downloadUrl, downloadPath, parseInt(changeSet.fileSize, 10), progressCallback ? callback : undefined);
        }));
        await queue.waitAll();
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Downloaded ${changeSets.length} changesets`);
    }
    /**
     * Upload a [[ChangeSet]] file. If you want to [push]($docs/learning/Glossary.md#push) your changes to iModelHub, use [IModelDb.pushChanges]($backend) instead. This method is only a part of that workflow.
     *
     * ChangeSets have to be uploaded in a linear order. If another user is uploading, or changeSet.parentId does not point to the latest ChangeSet on iModelHub, this method will fail. User will have to download all of the newer ChangeSets, merge them into their [[Briefcase]] and calculate a new ChangeSet id.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param changeSet Information of the ChangeSet to be uploaded.
     * @param path Path of the ChangeSet file to be uploaded.
     * @param progressCallback Callback for tracking upload progress.
     * @throws [IModelHubStatus.BriefcaseDoesNotBelongToUser]($bentley) if Briefcase specified by changeSet.briefcaseId belongs to another user.
     * @throws [IModelHubStatus.AnotherUserPushing]($bentley) if another user is currently uploading a ChangeSet.
     * @throws [IModelHubStatus.PullIsRequired]($bentley) if there are newer ChangeSets on iModelHub, that need to be downloaded and merged, before upload is possible.
     * @throws [IModelHubStatus.ChangeSetAlreadyExists]($bentley) if a ChangeSet with this id already exists. This usually happens if previous upload attempt has succeeded.
     * @throws [IModelHubStatus.ChangeSetPointsToBadSeed]($bentley) if changeSet.seedFileId is not set to the correct file id. That file id should match to the value written to the Briefcase file. See [IModelDb.setGuid]($backend).
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, iModelId, changeSet, path, progressCallback) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Started uploading ChangeSet", () => (Object.assign({ iModelId }, changeSet)));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.defined("changeSet", changeSet);
        Errors_1.ArgumentCheck.defined("path", path);
        if (typeof window !== "undefined")
            return Promise.reject(Errors_1.IModelHubClientError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubClientError.fileHandler());
        if (!this._fileHandler.exists(path) || this._fileHandler.isDirectory(path))
            return Promise.reject(Errors_1.IModelHubClientError.fileNotFound());
        const postChangeSet = await this._handler.postInstance(requestContext, ChangeSet, this.getRelativeUrl(iModelId), changeSet);
        await this._fileHandler.uploadFile(requestContext, postChangeSet.uploadUrl, path, progressCallback);
        requestContext.enter();
        postChangeSet.uploadUrl = undefined;
        postChangeSet.downloadUrl = undefined;
        postChangeSet.isUploaded = true;
        const confirmChangeSet = await this._handler.postInstance(requestContext, ChangeSet, this.getRelativeUrl(iModelId, postChangeSet.id), postChangeSet);
        requestContext.enter();
        changeSet.isUploaded = true;
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Finished uploading ChangeSet", () => (Object.assign({ iModelId }, changeSet)));
        return confirmChangeSet;
    }
}
exports.ChangeSetHandler = ChangeSetHandler;


/***/ }),

/***/ "./lib/imodelhub/Checkpoints.js":
/*!**************************************!*\
  !*** ./lib/imodelhub/Checkpoints.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/**
 * Checkpoint is a copy of the master file, that is intended to be read-only and reduces amount of merging required to get an iModel to a specific previous state.
 *
 * File properties describe the file that would be downloaded through downloadUrl.
 * @alpha
 */
let Checkpoint = class Checkpoint extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], Checkpoint.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
], Checkpoint.prototype, "fileDescription", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], Checkpoint.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
], Checkpoint.prototype, "fileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.State")
], Checkpoint.prototype, "state", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MergedChangeSetId")
], Checkpoint.prototype, "mergedChangeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], Checkpoint.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], Checkpoint.prototype, "downloadUrl", void 0);
Checkpoint = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Checkpoint", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Checkpoint);
exports.Checkpoint = Checkpoint;
/**
 * Query object for getting [[Checkpoint]]s. You can use this to modify the [[CheckpointHandler.get]] results.
 * @alpha
 */
class CheckpointQuery extends Query_1.Query {
    /** Query will return closest [[Checkpoint]] to target [[ChangeSet]], based on ChangeSets size.
     * This query can return a Checkpoint that is ahead of the specified ChangeSet, if reversing ChangeSets would be faster than merging forward. This resets all previously set filters.
     * @returns This query.
     */
    nearestCheckpoint(targetChangeSetId) {
        this.filter(`NearestCheckpoint-backward-ChangeSet.Id+eq+'${targetChangeSetId}'`);
        return this;
    }
    /** Query will return closest [[Checkpoint]] to target [[ChangeSet]] that does not exceed the specified ChangeSet.
     * This query returns a closest Checkpoint that will reach target ChangeSet by only merging forward. This resets all previously set filters.
     * @returns This query.
     */
    precedingCheckpoint(targetChangeSetId) {
        this.filter(`PrecedingCheckpoint-backward-ChangeSet.Id+eq+'${targetChangeSetId}'`);
        return this;
    }
    /** Query will return [[Checkpoint]] with specified [[ChangeSet]] id.
     * @returns This query.
     */
    byChangeSetId(changeSetId) {
        this.addFilter(`MergedChangeSetId+eq+'${changeSetId}'`, "and");
        return this;
    }
    /** Query will additionally select [[Checkpoint]] file download URL. This is needed to use the Checkpoint object with [[CheckpointHandler.download]].
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
}
exports.CheckpointQuery = CheckpointQuery;
/**
 * Handler for managing [[Checkpoint]]s. Use [[IModelClient.checkpoints]] to get an instance of this class.
 * In most cases, you should use [IModelDb]($backend) methods instead.
 * @alpha
 */
class CheckpointHandler {
    /** Constructor for CheckpointHandler. Use [[IModelClient]] instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     * @alpha
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /** Get relative url for Checkpoint requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @alpha
     */
    getRelativeUrl(iModelId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/Checkpoint/`;
    }
    /** Get the [[Checkpoint]]s.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried Checkpoints or select different data from them.
     * @returns Checkpoints that match the query.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new CheckpointQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying checkpoints for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const checkpoints = await this._handler.getInstances(requestContext, Checkpoint, this.getRelativeUrl(iModelId), query.getQueryOptions());
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Queried checkpoints for iModel", () => ({ iModelId, count: checkpoints.length }));
        return checkpoints;
    }
    /** Download the specified checkpoint file. This only downloads the file and does not update the [[Checkpoint]] id. Use [IModelDb.open]($backend) instead if you want to get a usable checkpoint file.
     * This method does not work on the browser. Directory containing the Checkpoint file is created if it does not exist. If there is an error during download, any partially downloaded file is deleted from disk.
     * @param requestContext The client request context
     * @param checkpoint Checkpoint to download. This needs to include a download link. See [[CheckpointQuery.selectDownloadUrl]].
     * @param path Path where checkpoint file should be downloaded, including filename.
     * @param progressCallback Callback for tracking progress.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.NotSupportedInBrowser]($bentley) if called in a browser.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.FileHandlerNotSet]($bentley) if [[FileHandler]] instance was not set for [[IModelClient]].
     * @throws [[ResponseError]] if the checkpoint cannot be downloaded.
     */
    async download(requestContext, checkpoint, path, progressCallback) {
        requestContext.enter();
        Errors_1.ArgumentCheck.defined("checkpoint", checkpoint);
        Errors_1.ArgumentCheck.defined("path", path);
        if (typeof window !== "undefined")
            return Promise.reject(Errors_1.IModelHubClientError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubClientError.fileHandler());
        if (!checkpoint.downloadUrl)
            return Promise.reject(Errors_1.IModelHubClientError.missingDownloadUrl("checkpoint"));
        const perfLogger = new bentleyjs_core_1.PerfLogger("Downloading checkpoint", () => (Object.assign({}, checkpoint, { path })));
        await this._fileHandler.downloadFile(requestContext, checkpoint.downloadUrl, path, parseInt(checkpoint.fileSize, 10), progressCallback);
        requestContext.enter();
        perfLogger.dispose();
    }
}
exports.CheckpointHandler = CheckpointHandler;


/***/ }),

/***/ "./lib/imodelhub/Client.js":
/*!*********************************!*\
  !*** ./lib/imodelhub/Client.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
Object.defineProperty(exports, "__esModule", { value: true });
const IModelClient_1 = __webpack_require__(/*! ../IModelClient */ "./lib/IModelClient.js");
const BaseHandler_1 = __webpack_require__(/*! ./BaseHandler */ "./lib/imodelhub/BaseHandler.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
/**
 * Class that allows access to different iModelHub class handlers. Handlers should be accessed through an instance of this class, rather than constructed directly.
 * @beta
 */
class IModelHubClient extends IModelClient_1.IModelClient {
    /**
     * Create an instance of IModelHubClient.
     * @param fileHandler File handler to handle file upload/download and file system operations.
     * @param iModelBaseHandler WSG Client for iModel Hub operations.
     */
    constructor(fileHandler, iModelBaseHandler = new BaseHandler_1.IModelBaseHandler()) {
        super(iModelBaseHandler, fileHandler);
    }
    /**
     * Get the (delegation) access token to access the service
     * @param requestContext The client request context
     * @param authorizationToken Authorization token.
     * @returns Resolves to the (delegation) access token.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if authorizationToken is undefined.
     * @throws [[ResponseError]] if request to delegation service failed.
     * @throws Error if failed to parse response.
     * @internal
     */
    async getAccessToken(requestContext, authorizationToken) {
        Errors_1.ArgumentCheck.defined("authorizationToken", authorizationToken);
        return this._handler.getAccessToken(requestContext, authorizationToken);
    }
}
exports.IModelHubClient = IModelHubClient;


/***/ }),

/***/ "./lib/imodelhub/Codes.js":
/*!********************************!*\
  !*** ./lib/imodelhub/Codes.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Request_1 = __webpack_require__(/*! ./../Request */ "./lib/Request.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/**
 * [Code]($common) state describes whether the code is currently in use or owned by a [[Briefcase]].
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
var CodeState;
(function (CodeState) {
    /** Code with this state is not persisted in iModelHub. Code that is updated to 'Available' state is deleted from the iModelHub. */
    CodeState[CodeState["Available"] = 0] = "Available";
    /** Code is reserved by the [[Briefcase]], no one else is allowed to change its state. */
    CodeState[CodeState["Reserved"] = 1] = "Reserved";
    /** Code is used in a [[ChangeSet]] committed to the iModelHub. */
    CodeState[CodeState["Used"] = 2] = "Used";
    /** Retired Code can not be reserved or used. It can only be deleted and then reserved again */
    CodeState[CodeState["Retired"] = 3] = "Retired";
})(CodeState = exports.CodeState || (exports.CodeState = {}));
/** Base class for [Code]($common)s.
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class CodeBase extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CodeSpecId")
], CodeBase.prototype, "codeSpecId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CodeScope")
], CodeBase.prototype, "codeScope", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.State")
], CodeBase.prototype, "state", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], CodeBase.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
], CodeBase.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.QueryOnly")
], CodeBase.prototype, "queryOnly", void 0);
exports.CodeBase = CodeBase;
/**
 * Code instance. Codes ensure uniqueness of names in the file.
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
let HubCode = class HubCode extends CodeBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Value")
], HubCode.prototype, "value", void 0);
HubCode = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Code", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], HubCode);
exports.HubCode = HubCode;
/**
 * MultiCode: Data about codes grouped by CodeSpecId, State and Briefcase
 * @internal
 */
let MultiCode = class MultiCode extends CodeBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Values")
], MultiCode.prototype, "values", void 0);
MultiCode = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.MultiCode", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], MultiCode);
exports.MultiCode = MultiCode;
/**
 * Encodes part of the code to be used in URI
 * @param str Part of the code.
 * @returns Encoded part of a code.
 */
function encodeForCodeId(str) {
    return encodeURIComponent(str.replace("-", "_0x2D_"))
        .replace("~", "~7E")
        .replace("*", "~2A")
        .replace("%", "~");
}
/**
 * Gets encoded instance id for a code to be used in an URI.
 * @param code Code to get instance id for.
 * @returns Encoded code instance id.
 */
function getCodeInstanceId(code) {
    if (!code || !code.codeSpecId || !code.codeScope || !code.value)
        return undefined;
    return `'${code.codeSpecId}-${encodeForCodeId(code.codeScope)}-${encodeForCodeId(code.value)}'`;
}
/**
 * Provider for default CodeUpdateOptions, used by CodeHandler to set defaults.
 * @internal
 */
class DefaultCodeUpdateOptionsProvider {
    /**  Creates an instance of DefaultRequestOptionsProvider and sets up the default options. */
    constructor() {
        this._defaultOptions = {
            codesPerRequest: 2000,
        };
    }
    /**
     * Augments options with the provider's default values. The options passed in override any defaults where necessary.
     * @param options Options that should be augmented.
     */
    async assignOptions(options) {
        const clonedOptions = Object.assign({}, options);
        deepAssign(options, this._defaultOptions);
        deepAssign(options, clonedOptions); // ensure the supplied options override the defaults
        return Promise.resolve();
    }
}
exports.DefaultCodeUpdateOptionsProvider = DefaultCodeUpdateOptionsProvider;
/**
 * Error for conflicting [Code]($common)s. It contains an array of Codes that failed to acquire. This is returned when calling [[CodeHandler.update]] with [[CodeUpdateOptions.deniedCodes]] set to true.
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class ConflictingCodesError extends Errors_1.IModelHubError {
    /**
     * Create ConflictingCodesError from IModelHubError instance.
     * @param error IModelHubError to get error data from.
     * @returns Undefined if the error is not for a code conflict, otherwise newly created error instance.
     * @internal
     */
    static fromError(error) {
        if (error.errorNumber !== bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase &&
            error.errorNumber !== bentleyjs_core_1.IModelHubStatus.ConflictsAggregate) {
            return undefined;
        }
        const result = new ConflictingCodesError(error.errorNumber);
        deepAssign(result, error);
        result.addCodes(error);
        return result;
    }
    /**
     * Amend this error instance with conflicting codes from another IModelHubError.
     * @param error Error to get additional conflicting codes from.
     * @internal
     */
    addCodes(error) {
        if (!error.data || !error.data.ConflictingCodes) {
            return;
        }
        if (!this.conflictingCodes) {
            this.conflictingCodes = [];
        }
        for (const value of error.data.ConflictingCodes) {
            const instance = { className: "Code", schemaName: "iModelScope", properties: value };
            const code = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(HubCode, "wsg", instance);
            if (code) {
                this.conflictingCodes.push(code);
            }
        }
    }
}
exports.ConflictingCodesError = ConflictingCodesError;
/**
 * Query object for getting [Code]($common)s. You can use this to modify the query. See [[CodeHandler.get]].
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class CodeQuery extends Query_1.Query {
    /** Constructor that sets default page size. */
    constructor() {
        super();
        this._isMultiCodeQuery = true;
        this.pageSize(CodeQuery.defaultPageSize);
    }
    /**
     * Used by the handler to check whether codes in query can be grouped.
     * @internal
     */
    get isMultiCodeQuery() {
        return this._isMultiCodeQuery;
    }
    /**
     * Query Codes by [[Briefcase]] id.
     * @param briefcaseId Id of the Briefcase.
     * @returns This query.
     * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if briefcaseId is undefined or has an invalid [[Briefcase]] id value.
     */
    byBriefcaseId(briefcaseId) {
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        this.addFilter(`BriefcaseId+eq+${briefcaseId}`);
        return this;
    }
    /**
     * Query Codes by CodeSpec id.
     * @param codeSpecId Id of the CodeSpec.
     * @returns This query.
     * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if codeSpecId is undefined or empty.
     */
    byCodeSpecId(codeSpecId) {
        Errors_1.ArgumentCheck.defined("codeSpecId", codeSpecId);
        this.addFilter(`CodeSpecId+eq+'${codeSpecId}'`);
        return this;
    }
    /**
     * Query Codes by Code scope.
     * @param codeScope Scope of the Code.
     * @returns This query.
     * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if codeScope is undefined or empty.
     */
    byCodeScope(codeScope) {
        Errors_1.ArgumentCheck.defined("codeScope", codeScope);
        this.addFilter(`CodeScope+eq+'${codeScope}'`);
        return this;
    }
    /**
     * Query [Code]($common)s by their instance ids.
     * @param codes Codes to query. They must have their codeSpec, scope and value set.
     * @returns This query.
     * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if codes array is undefined, empty or it contains invalid [Code]($common) values.
     */
    byCodes(codes) {
        Errors_1.ArgumentCheck.nonEmptyArray("codes", codes);
        this._isMultiCodeQuery = false;
        if (codes.length < 1) {
            throw Errors_1.IModelHubClientError.invalidArgument("codes");
        }
        let filter = "$id+in+[";
        let index = 0;
        for (const code of codes) {
            const id = getCodeInstanceId(code);
            Errors_1.ArgumentCheck.valid(`codes[${index}]`, id);
            if (0 !== index++)
                filter += ",";
            filter += id;
        }
        filter += "]";
        this.addFilter(filter);
        return this;
    }
    /**
     * Query unavailable [Code]($common)s. It will include all Codes owned by other [[Briefcase]]s.
     * @param briefcaseId Id of the Briefcase.
     * @returns This query.
     * @throws [[IModelHubError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if briefcaseId is undefined or has an invalid [[Briefcase]] id value.
     */
    unavailableCodes(briefcaseId) {
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        const filter = `BriefcaseId+ne+${briefcaseId}`;
        this.addFilter(filter);
        return this;
    }
}
/**
 * Default page size which is used when querying Codes
 * @internal
 */
CodeQuery.defaultPageSize = 10000;
exports.CodeQuery = CodeQuery;
/** Type of [[CodeSequence]] results.
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
var CodeSequenceType;
(function (CodeSequenceType) {
    /** Return largest already used value. */
    CodeSequenceType[CodeSequenceType["LargestUsed"] = 0] = "LargestUsed";
    /** Return next available value in the sequence. */
    CodeSequenceType[CodeSequenceType["NextAvailable"] = 1] = "NextAvailable";
})(CodeSequenceType = exports.CodeSequenceType || (exports.CodeSequenceType = {}));
/** Sequence of [Code]($common)s matching a pattern. This class allows getting next available index based [Code]($common)
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
let CodeSequence = class CodeSequence extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CodeSpecId")
], CodeSequence.prototype, "codeSpecId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CodeScope")
], CodeSequence.prototype, "codeScope", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ValuePattern")
], CodeSequence.prototype, "valuePattern", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Value")
], CodeSequence.prototype, "value", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.StartIndex")
], CodeSequence.prototype, "startIndex", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IncrementBy")
], CodeSequence.prototype, "incrementBy", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Type")
], CodeSequence.prototype, "type", void 0);
CodeSequence = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.CodeSequence", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], CodeSequence);
exports.CodeSequence = CodeSequence;
/**
 * Handler for querying [[CodeSequence]]s. Use [[CodeHandler.Sequences]] to get an instance of this class.
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class CodeSequenceHandler {
    /**
     * Constructor for CodeHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get relative url for Code sequence requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     */
    getRelativeUrl(iModelId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/CodeSequence/`;
    }
    /** Get an index value based on the [[CodeSequence]]. This only suggests the last used or next available index value in the sequence and does not reserve the Code.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param sequence Code sequence describing the format of the Code value.
     * @returns Resolves to the suggested index value.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, sequence) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying code sequence for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const result = await this._handler.postInstance(requestContext, CodeSequence, this.getRelativeUrl(iModelId), sequence);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Queried code sequence for iModel", () => ({ iModelId }));
        return result.value;
    }
}
exports.CodeSequenceHandler = CodeSequenceHandler;
/**
 * Handler for managing [Code]($common)s. Use [[IModelClient.Codes]] to get an instance of this class. In most cases, you should use [ConcurrencyControl]($backend) methods instead. You can read more about concurrency control [here]($docs/learning/backend/concurrencycontrol).
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class CodeHandler {
    /**
     * Constructor for CodeHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get handler for querying [[CodeSequence]]s. */
    get sequences() {
        return new CodeSequenceHandler(this._handler);
    }
    /** Get relative url for Code requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param codeId Id of the code.
     */
    getRelativeUrl(iModelId, multiCode = true, codeId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/${multiCode ? "MultiCode" : "Code"}/${codeId || ""}`;
    }
    /** Convert Codes to MultiCodes. */
    static convertCodesToMultiCodes(codes) {
        const map = new Map();
        for (const code of codes) {
            const id = `${code.codeScope}-${code.codeSpecId}-${code.state}`;
            if (map.has(id)) {
                map.get(id).values.push(code.value);
            }
            else {
                const multiCode = new MultiCode();
                multiCode.changeState = "new";
                multiCode.briefcaseId = code.briefcaseId;
                multiCode.codeScope = code.codeScope;
                multiCode.codeSpecId = code.codeSpecId;
                multiCode.state = code.state;
                multiCode.values = [code.value];
                map.set(id, multiCode);
            }
        }
        return Array.from(map.values());
    }
    /** Convert MultiCodes to Codes. */
    static convertMultiCodesToCodes(multiCodes) {
        const result = [];
        for (const multiCode of multiCodes) {
            for (const value of multiCode.values) {
                const code = new HubCode();
                code.briefcaseId = multiCode.briefcaseId;
                code.codeScope = multiCode.codeScope;
                code.codeSpecId = multiCode.codeSpecId;
                code.state = multiCode.state;
                code.value = value;
                result.push(code);
            }
        }
        return result;
    }
    /**
     * Augment update options with defaults returned by the DefaultCodeUpdateOptionsProvider. The options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to augment with the defaults.
     * @returns Promise resolves after the defaults are setup.
     */
    async setupOptionDefaults(options) {
        if (!CodeHandler._defaultUpdateOptionsProvider)
            CodeHandler._defaultUpdateOptionsProvider = new DefaultCodeUpdateOptionsProvider();
        return CodeHandler._defaultUpdateOptionsProvider.assignOptions(options);
    }
    /** Send partial request for code updates */
    async updateInternal(requestContext, iModelId, codes, updateOptions) {
        requestContext.enter();
        let requestOptions;
        if (updateOptions) {
            requestOptions = {};
            requestOptions.CustomOptions = {};
            if (updateOptions.deniedCodes === false) {
                requestOptions.CustomOptions.DetailedError_Codes = "false";
            }
            if (updateOptions.unlimitedReporting) {
                requestOptions.CustomOptions.DetailedError_MaximumInstances = "-1";
            }
            if (updateOptions.continueOnConflict) {
                requestOptions.CustomOptions.ConflictStrategy = "Continue";
            }
            if (Object.getOwnPropertyNames(requestOptions.CustomOptions).length === 0)
                requestOptions = undefined;
        }
        const result = await this._handler.postInstances(requestContext, MultiCode, `/Repositories/iModel--${iModelId}/$changeset`, CodeHandler.convertCodesToMultiCodes(codes), requestOptions);
        return CodeHandler.convertMultiCodesToCodes(result);
    }
    /**
     * Update multiple [Code]($common)s. This call can simultaneously reserve new Codes and update states of already owned Codes. If large amount of Codes are updated, they are split across multiple requests. See [[CodeUpdateOptions.codesPerRequest]]. Default is 2000 Codes per request.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param codes Codes to update. Requires briefcaseId, state, codeSpecId, codeScope and value to be set on every instance. briefcaseId must be the same for every Code. Set queryOnly to true to just check if a Code can be reserved.
     * @param updateOptions Options for the update request. You can set this to change how conflicts are handled or to handle different amount of Codes per request.
     * @returns The code that was just obtained from the server.
     * @throws [[ConflictingCodesError]] when [[CodeUpdateOptions.deniedCodes]] is set and conflicts occured. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) for more information.
     * @throws [[AggregateResponseError]] when multiple requests where sent and more than 1 of the following errors occured.
     * @throws [[IModelHubError]] with status indicating a conflict. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) section for more information.
     * @throws [[IModelHubError]] with [IModelHubStatus.InvalidBriefcase]($bentley) when including Codes with different briefcaseId values in the request.
     * @throws [[IModelHubError]] with [IModelHubStatus.OperationFailed]($bentley) when including multiple identical Codes in the request.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, iModelId, codes, updateOptions) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Requesting codes for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.nonEmptyArray("codes", codes);
        updateOptions = updateOptions || {};
        await this.setupOptionDefaults(updateOptions);
        const result = [];
        let conflictError;
        const aggregateError = new Errors_1.AggregateResponseError();
        for (let i = 0; i < codes.length; i += updateOptions.codesPerRequest) {
            const chunk = codes.slice(i, i + updateOptions.codesPerRequest);
            try {
                result.push(...await this.updateInternal(requestContext, iModelId, chunk, updateOptions));
                requestContext.enter();
            }
            catch (error) {
                requestContext.enter();
                if (error instanceof Request_1.ResponseError) {
                    if (updateOptions && updateOptions.deniedCodes && error instanceof Errors_1.IModelHubError && (error.errorNumber === bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase ||
                        error.errorNumber === bentleyjs_core_1.IModelHubStatus.ConflictsAggregate)) {
                        if (conflictError) {
                            conflictError.addCodes(error);
                        }
                        else {
                            conflictError = ConflictingCodesError.fromError(error);
                        }
                        if (!updateOptions.continueOnConflict) {
                            return Promise.reject(conflictError);
                        }
                    }
                    else {
                        aggregateError.errors.push(error);
                    }
                }
            }
        }
        if (conflictError) {
            return Promise.reject(conflictError);
        }
        if (aggregateError.errors.length > 0) {
            return Promise.reject(aggregateError.errors.length > 1 ? aggregateError : aggregateError.errors[0]);
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Requested ${codes.length} codes for iModel`, () => ({ iModelId }));
        return result;
    }
    /**
     * Get the [Code]($common)s that have been issued for the iModel.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried Codes or select different data from them.
     * @returns Resolves to an array of Codes matching the query.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new CodeQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying codes for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        let codes;
        if (query.isMultiCodeQuery) {
            const multiCodes = await this._handler.getInstances(requestContext, MultiCode, this.getRelativeUrl(iModelId), query.getQueryOptions());
            requestContext.enter();
            codes = CodeHandler.convertMultiCodesToCodes(multiCodes);
        }
        else {
            codes = await this._handler.postQuery(requestContext, HubCode, this.getRelativeUrl(iModelId, false), query.getQueryOptions());
            requestContext.enter();
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Queried ${codes.length} codes for iModel`, () => ({ iModelId }));
        return codes;
    }
    /** Delete all [Code]($common)s owned by the specified [[Briefcase]].
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param briefcaseId Id of the Briefcacase.
     * @throws [[IModelHubError]] with [IModelHubStatus.BriefcaseDoesNotExist]($bentley) if [[Briefcase]] with specified briefcaseId does not exist. This can happen if number was not given as a Briefcase id yet, or Briefcase with that id was already deleted.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if [[Briefcase]] belongs to another user and user sending the request does not have ManageResources permission.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async deleteAll(requestContext, iModelId, briefcaseId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Deleting all codes from briefcase", () => ({ briefcaseId, iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, false, `DiscardReservedCodes-${briefcaseId}`));
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Deleted all codes from briefcase", () => ({ briefcaseId, iModelId }));
    }
}
exports.CodeHandler = CodeHandler;


/***/ }),

/***/ "./lib/imodelhub/CustomRequestOptions.js":
/*!***********************************************!*\
  !*** ./lib/imodelhub/CustomRequestOptions.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Class that provides custom request options for all future requests
 * @internal
 */
class CustomRequestOptions {
    setCustomOptions(customOptions) {
        this._customOptions = customOptions;
    }
    insertCustomOptions(customOptions) {
        if (!this._customOptions) {
            return customOptions;
        }
        if (!customOptions) {
            customOptions = {};
        }
        customOptions = Object.assign({}, customOptions, this._customOptions);
        return customOptions;
    }
    get isSet() {
        return null != this._customOptions;
    }
}
exports.CustomRequestOptions = CustomRequestOptions;


/***/ }),

/***/ "./lib/imodelhub/Errors.js":
/*!*********************************!*\
  !*** ./lib/imodelhub/Errors.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const WsgClient_1 = __webpack_require__(/*! ./../WsgClient */ "./lib/WsgClient.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/**
 * Error returned from iModelHub service.
 * @beta
 */
class IModelHubError extends WsgClient_1.WsgError {
    /** @internal */
    constructor(errorNumber, message, getMetaData) {
        super(errorNumber, message, getMetaData);
    }
    /**
     * Get IModelHubStatus from the string value returned by the service.
     * @param error Error id returned by the service.
     * @returns IModelHubStatus id
     */
    static getErrorId(error) {
        const id = bentleyjs_core_1.IModelHubStatus[error.slice(IModelHubError._idPrefix.length)];
        return id ? id : bentleyjs_core_1.IModelHubStatus.Unknown;
    }
    /**
     * Check whether error could have extended data.
     * @param id Id of the error.
     * @returns True if service can return extended data for this error id.
     */
    static requiresExtendedData(id) {
        switch (id) {
            case bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.iModelAlreadyExists:
            case bentleyjs_core_1.IModelHubStatus.FileAlreadyExists:
            case bentleyjs_core_1.IModelHubStatus.PullIsRequired:
            case bentleyjs_core_1.IModelHubStatus.CodeStateInvalid:
            case bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.ConflictsAggregate:
                return true;
            default:
                return false;
        }
    }
    /**
     * Make extended data available publically.
     */
    copyExtendedData() {
        this.data = this._data;
    }
    /**
     * Create IModelHubError from id.
     * @param id Id of the error.
     * @param message Message for the error.
     * @returns Created error.
     * @internal
     */
    static fromId(id, message) {
        const error = new IModelHubError(id);
        error.name = bentleyjs_core_1.IModelHubStatus[id];
        error.message = message;
        return error;
    }
    /**
     * Attempt to parse IModelHubError from server response.
     * @param response Response from the server.
     * @returns Parsed error.
     * @internal
     */
    static parse(response, log = true) {
        const wsgError = super.parse(response, false);
        if (wsgError instanceof WsgClient_1.WsgError && wsgError.name && wsgError.name.startsWith(IModelHubError._idPrefix)) {
            const errorId = IModelHubError.getErrorId(wsgError.name);
            const error = new IModelHubError(errorId);
            deepAssign(error, wsgError);
            error.errorNumber = errorId;
            if (IModelHubError.requiresExtendedData(error.errorNumber)) {
                error.copyExtendedData();
            }
            if (log)
                error.log();
            return error;
        }
        if (log)
            wsgError.log();
        return wsgError;
    }
    /**
     * Decides whether request should be retried or not.
     * @param error Error returned by request
     * @param response Response returned by request
     * @internal
     */
    static shouldRetry(error, response) {
        if (response === undefined || response === null) {
            return super.shouldRetry(error, response);
        }
        if (super.parseHttpStatus(response.statusType) === bentleyjs_core_1.HttpStatus.Success) {
            return false;
        }
        const parsedError = IModelHubError.parse({ response }, false);
        if (!(parsedError instanceof WsgClient_1.WsgError)) {
            return super.shouldRetry(error, response);
        }
        if ((parsedError instanceof IModelHubError)) {
            return false;
        }
        const errorCodesToRetry = [bentleyjs_core_1.HttpStatus.ServerError,
            bentleyjs_core_1.WSStatus.Unknown];
        const errorStatus = super.getErrorStatus(parsedError.name !== undefined ?
            super.getWSStatusId(parsedError.name) : bentleyjs_core_1.WSStatus.Unknown, response.statusType);
        return errorCodesToRetry.includes(errorStatus);
    }
    /**
     * Get log function.
     * @internal
     */
    getLogLevel() {
        switch (this.errorNumber) {
            case bentleyjs_core_1.IModelHubStatus.AnotherUserPushing:
            case bentleyjs_core_1.IModelHubStatus.PullIsRequired:
            case bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase:
            case bentleyjs_core_1.IModelHubStatus.CodeReservedByAnotherBriefcase:
                return bentleyjs_core_1.Logger.logWarning;
            default:
                return bentleyjs_core_1.Logger.logError;
        }
    }
    /**
     * Logs this error.
     * @internal
     */
    log() {
        (this.getLogLevel())(loggerCategory, this.logMessage(), this.getMetaData());
    }
}
IModelHubError._idPrefix = "iModelHub.";
exports.IModelHubError = IModelHubError;
/**
 * Errors for incorrect iModelHub requests.
 * @beta
 */
class IModelHubClientError extends IModelHubError {
    /** Creates IModelHubClientError from id.
     * @param id Id of the error.
     * @param message Message for the error.
     * @returns Created error.
     * @internal
     */
    static fromId(id, message) {
        const error = new IModelHubClientError(id, message);
        error.log();
        return error;
    }
    /** Create error for undefined arguments being passed.
     * @param argumentName Undefined argument name
     * @returns Created error.
     * @internal
     */
    static undefinedArgument(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.UndefinedArgumentError, `Argument ${argumentName} is null or undefined`);
    }
    /** Create error for invalid arguments being passed.
     * @param argumentName Invalid argument name
     * @returns Created error.
     * @internal
     */
    static invalidArgument(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.InvalidArgumentError, `Argument ${argumentName} has an invalid value.`);
    }
    /** Create error for arguments being passed that are missing download URL.
     * @param argumentName Argument name
     * @returns Created error.
     * @internal
     */
    static missingDownloadUrl(argumentName) {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.MissingDownloadUrlError, `Supplied ${argumentName} must include download URL. Use selectDownloadUrl() when getting ${argumentName}.`);
    }
    /** Create error for seed file initialization timing out.
     * @returns Created error.
     * @internal
     */
    static initializationTimeout() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.InitializationTimeout, `Timed out waiting for Seed File initialization.`);
    }
    /** Create error for incompatible operation being used in browser.
     * @returns Created error.
     * @internal
     */
    static browser() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.NotSupportedInBrowser, "Operation is not supported in browser.");
    }
    /** Create error for incompatible operation being used in browser.
     * @returns Created error.
     * @internal
     */
    static fileHandler() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.FileHandlerNotSet, "File handler is required to be set for file download / upload.");
    }
    /** Create error for a missing file.
     * @returns Created error.
     * @internal
     */
    static fileNotFound() {
        return this.fromId(bentleyjs_core_1.IModelHubStatus.FileNotFound, "Could not find the file to upload.");
    }
}
exports.IModelHubClientError = IModelHubClientError;
/** @internal */
class ArgumentCheck {
    static defined(argumentName, argument) {
        if (!argument)
            throw IModelHubClientError.undefinedArgument(argumentName);
    }
    static definedNumber(argumentName, argument) {
        if (typeof argument !== "number")
            throw IModelHubClientError.undefinedArgument(argumentName);
    }
    static valid(argumentName, argument) {
        if (!argument)
            throw IModelHubClientError.invalidArgument(argumentName);
    }
    static validGuid(argumentName, argument) {
        this.defined(argumentName, argument);
        if (!bentleyjs_core_1.Guid.isGuid(argument))
            throw IModelHubClientError.invalidArgument(argumentName);
    }
    static nonEmptyArray(argumentName, argument) {
        this.defined(argumentName, argument);
        if (argument.length < 1)
            throw IModelHubClientError.invalidArgument(argumentName);
    }
    /** Check if Briefcase Id is valid. */
    static isBriefcaseIdValid(briefcaseId) {
        return briefcaseId > 1 && briefcaseId < 16 * 1024 * 1024;
    }
    /** Check if Briefcase Id argument is valid. */
    static validBriefcaseId(argumentName, argument) {
        this.definedNumber(argumentName, argument);
        if (!this.isBriefcaseIdValid(argument))
            throw IModelHubClientError.invalidArgument(argumentName);
    }
    static isValidChangeSetId(changeSetId) {
        const pattern = new RegExp("^[0-9A-Fa-f]+$");
        return changeSetId.length === 40 && pattern.test(changeSetId);
    }
    static validChangeSetId(argumentName, argument) {
        this.defined(argumentName, argument);
        if (!this.isValidChangeSetId(argument))
            throw IModelHubClientError.invalidArgument(argumentName);
    }
}
exports.ArgumentCheck = ArgumentCheck;
/** Class for aggregating errors from multiple requests. Only thrown when more than 1 error has occurred.
 * @internal
 */
class AggregateResponseError extends Error {
    constructor() {
        super(...arguments);
        /** Errors that happened over multiple requests. */
        this.errors = [];
    }
}
exports.AggregateResponseError = AggregateResponseError;


/***/ }),

/***/ "./lib/imodelhub/Events.js":
/*!*********************************!*\
  !*** ./lib/imodelhub/Events.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHubEvents */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Request_1 = __webpack_require__(/*! ./../Request */ "./lib/Request.js");
const Codes_1 = __webpack_require__(/*! ./Codes */ "./lib/imodelhub/Codes.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const EventsBase_1 = __webpack_require__(/*! ./EventsBase */ "./lib/imodelhub/EventsBase.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/** Base type for all iModelHub events.
 * @beta
 */
class IModelHubEvent extends EventsBase_1.IModelHubBaseEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.iModelId = this.eventTopic;
    }
}
exports.IModelHubEvent = IModelHubEvent;
/** Base type for iModelHub events that have BriefcaseId.
 * @beta
 */
class BriefcaseEvent extends IModelHubEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.briefcaseId = obj.BriefcaseId;
    }
}
exports.BriefcaseEvent = BriefcaseEvent;
/** Sent when one or more [[Lock]]s are updated. Lock updates can be very frequent, so it's recommended to not to subscribe to LockEvents, if it's not necessary.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
class LockEvent extends BriefcaseEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.lockType = parseInt(obj.LockType, 10);
        this.lockLevel = parseInt(obj.LockLevel, 10);
        this.objectIds = obj.ObjectIds.map((value) => bentleyjs_core_1.Id64.fromJSON(value));
        this.releasedWithChangeSet = obj.ReleasedWithChangeSet;
    }
}
exports.LockEvent = LockEvent;
/** Sent when all [[Lock]]s for a [[Briefcase]] are deleted. Can occur when calling [[LockHandler.deleteAll]] or [[BriefcaseHandler.delete]].
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
class AllLocksDeletedEvent extends BriefcaseEvent {
}
exports.AllLocksDeletedEvent = AllLocksDeletedEvent;
/** Sent when a [[ChangeSet]] is successfully pushed. See [[ChangeSetHandler.create]]. It's sent when a new [[ChangeSet]] is successfully pushed to an iModel. See [[ChangeSetPrePushEvent]] for the event indicating the start of a ChangeSet push.
 * @beta
 */
class ChangeSetPostPushEvent extends BriefcaseEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.changeSetId = obj.ChangeSetId;
        this.changeSetIndex = obj.ChangeSetIndex;
    }
}
exports.ChangeSetPostPushEvent = ChangeSetPostPushEvent;
/** Sent when a [[ChangeSet]] push has started. See [[ChangeSetHandler.create]]. ChangeSetPrePushEvent indicates that iModelHub allowed one of the [[Briefcase]]s to push a ChangeSet and all other push attempts will fail, until this push times out or succeeds. See [[ChangeSetPostPushEvent]] for an event indicating a successful push.
 * @beta
 */
class ChangeSetPrePushEvent extends IModelHubEvent {
}
exports.ChangeSetPrePushEvent = ChangeSetPrePushEvent;
/** Sent when one or more [Code]($common)s are updated. See [[CodeHandler.update]]. Code updates can be very frequent, so it's recommended to not to subscribe to CodeEvents, if it's not necessary.
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class CodeEvent extends BriefcaseEvent {
    constructor() {
        super(...arguments);
        /** State Codes were updated to. */
        this.state = Codes_1.CodeState.Reserved;
    }
    /** Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.codeSpecId = bentleyjs_core_1.Id64.fromJSON(obj.CodeSpecId);
        this.codeScope = obj.CodeScope;
        this.values = obj.Values;
        this.state = obj.State;
    }
}
exports.CodeEvent = CodeEvent;
/** Sent when all [Code]($common)s for a [[Briefcase]] are deleted. Can occur when calling [[CodeHandler.deleteAll]] or [[BriefcaseHandler.delete]].
 * @alpha Hide Code API while focused on readonly viewing scenarios
 */
class AllCodesDeletedEvent extends BriefcaseEvent {
}
exports.AllCodesDeletedEvent = AllCodesDeletedEvent;
/** Sent when a [[Briefcase]] is deleted. See [[BriefcaseHandler.delete]].
 * @internal
 */
class BriefcaseDeletedEvent extends BriefcaseEvent {
}
exports.BriefcaseDeletedEvent = BriefcaseDeletedEvent;
/** Sent when an iModel is deleted. See [[IModelHandler.delete]]. [[EventSubscription]] will be deleted 5 minutes after iModel is deleted, removing all events from subscription queues, making it possible for this event to be missed if not retrieved immediately.
 * @beta
 */
class IModelDeletedEvent extends IModelHubEvent {
}
exports.IModelDeletedEvent = IModelDeletedEvent;
/** Sent when a new named [[Version]] is created. See [[VersionHandler.create]].
 * @beta
 */
class VersionEvent extends IModelHubEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.versionId = obj.VersionId;
        this.versionName = obj.VersionName;
        this.changeSetId = obj.ChangeSetId;
    }
}
exports.VersionEvent = VersionEvent;
/** Get constructor from EventType name. */
function ConstructorFromEventType(type) {
    switch (type) {
        case "LockEvent":
            return LockEvent;
        case "AllLocksDeletedEvent":
            return AllLocksDeletedEvent;
        case "ChangeSetPostPushEvent":
            return ChangeSetPostPushEvent;
        case "ChangeSetPrePushEvent":
            return ChangeSetPrePushEvent;
        case "CodeEvent":
            return CodeEvent;
        case "AllCodesDeletedEvent":
            return AllCodesDeletedEvent;
        case "BriefcaseDeletedEvent":
            return BriefcaseDeletedEvent;
        case "iModelDeletedEvent":
            return IModelDeletedEvent;
        case "VersionEvent":
            return VersionEvent;
    }
}
/** Parse [[IModelHubEvent]] from response object.
 * @param response Response object to parse.
 * @returns Appropriate event object.
 * @internal
 */
function ParseEvent(response) {
    const constructor = ConstructorFromEventType(response.header["content-type"]);
    const event = new constructor();
    event.fromJson(response.body);
    return event;
}
exports.ParseEvent = ParseEvent;
/** Subscription to receive [[IModelHubEvent]]s. Each subscription has a separate queue for events that it hasn't read yet. Subscriptions are deleted, if they are inactive for an hour. Use wsgId of this instance for the methods that require subscriptionId. See [[EventSubscriptionHandler]].
 * @beta
 */
let EventSubscription = class EventSubscription extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.EventTypes")
], EventSubscription.prototype, "eventTypes", void 0);
EventSubscription = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.EventSubscription", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], EventSubscription);
exports.EventSubscription = EventSubscription;
/** Shared access signature token for getting [[IModelHubEvent]]s. It's used to authenticate for [[EventHandler.getEvent]]. To receive an instance call [[EventHandler.getSASToken]].
 * @beta
 */
let EventSAS = class EventSAS extends EventsBase_1.BaseEventSAS {
};
EventSAS = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.EventSAS", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], EventSAS);
exports.EventSAS = EventSAS;
/** Handler for managing [[EventSubscription]]s. Use [[EventHandler.Subscriptions]] to get an instance of this class.
 * @beta
 */
class EventSubscriptionHandler {
    /** Constructor for EventSubscriptionHandler.
     * @param handler Handler for WSG requests.
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get relative url for EventSubscription requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param instanceId Id of the subscription.
     */
    getRelativeUrl(iModelId, instanceId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/EventSubscription/${instanceId || ""}`;
    }
    /** Create an [[EventSubscription]].
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param events Array of EventTypes to subscribe to.
     * @return Created EventSubscription instance.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, iModelId, events) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Creating event subscription on iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.nonEmptyArray("events", events);
        let subscription = new EventSubscription();
        subscription.eventTypes = events;
        subscription = await this._handler.postInstance(requestContext, EventSubscription, this.getRelativeUrl(iModelId), subscription);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Created event subscription on iModel", () => ({ iModelId }));
        return subscription;
    }
    /** Update an [[EventSubscription]]. Can change the [[EventType]]s specified in the subscription. Must be a valid subscription that was previously created with [[EventSubscriptionHandler.create]] that hasn't expired.
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param subscription Updated EventSubscription.
     * @return EventSubscription instance from iModelHub after update.
     * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if [[EventSubscription]] does not exist with the specified subscription.wsgId.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, iModelId, subscription) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Updating event subscription on iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.defined("subscription", subscription);
        Errors_1.ArgumentCheck.validGuid("subscription.wsgId", subscription.wsgId);
        const updatedSubscription = await this._handler.postInstance(requestContext, EventSubscription, this.getRelativeUrl(iModelId, subscription.wsgId), subscription);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Updated event subscription on iModel", () => ({ iModelId }));
        return updatedSubscription;
    }
    /** Delete an [[EventSubscription]].
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param eventSubscriptionId Id of the EventSubscription.
     * @returns Resolves if the EventSubscription has been successfully deleted.
     * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if EventSubscription does not exist with the specified subscription.wsgId.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async delete(requestContext, iModelId, eventSubscriptionId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Deleting event subscription ${eventSubscriptionId} from iModel`, () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.validGuid("eventSubscriptionId", eventSubscriptionId);
        await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, eventSubscriptionId));
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Deleted event subscription ${eventSubscriptionId} from iModel`, () => ({ iModelId }));
    }
}
exports.EventSubscriptionHandler = EventSubscriptionHandler;
/** Handler for receiving [[IModelHubEvent]]s. Use [[IModelClient.Events]] to get an instance of this class.
 * @beta
 */
class EventHandler extends EventsBase_1.EventBaseHandler {
    /** Constructor for EventHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        super();
        this._handler = handler;
    }
    /** Get a handler for managing [[EventSubscription]]s. */
    get subscriptions() {
        if (!this._subscriptionHandler) {
            this._subscriptionHandler = new EventSubscriptionHandler(this._handler);
        }
        return this._subscriptionHandler;
    }
    /** Get relative url for EventSAS requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     */
    getEventSASRelativeUrl(iModelId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/EventSAS/`;
    }
    /** Get event SAS Token. Used to authenticate for [[EventHandler.getEvent]].
     * @param requestContext The client request context
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @return SAS Token to connect to the topic.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async getSASToken(requestContext, iModelId) {
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Getting event SAS token from iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const eventSAS = await this._handler.postInstance(requestContext, EventSAS, this.getEventSASRelativeUrl(iModelId), new EventSAS());
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Got event SAS token from iModel", () => ({ iModelId }));
        return eventSAS;
    }
    /** Get absolute url for event requests.
     * @param baseAddress Base address for the serviceBus.
     * @param subscriptionId Id of the subscription.
     * @param timeout Optional timeout for long polling.
     */
    getEventUrl(baseAddress, subscriptionId, timeout) {
        let url = `${baseAddress}/Subscriptions/${subscriptionId}/messages/head`;
        if (timeout) {
            url = url + `?timeout=${timeout}`;
        }
        return url;
    }
    /** Get [[IModelHubEvent]] from the [[EventSubscription]]. You can use long polling timeout, to have requests return when events are available (or request times out), rather than returning immediately when no events are found.
     * @param requestContext The client request context
     * @param sasToken SAS Token used to authenticate. See [[EventSAS.sasToken]].
     * @param baseAddress Address for the events. See [[EventSAS.baseAddress]].
     * @param subscriptionId Id of the subscription to the topic. See [[EventSubscription]].
     * @param timeout Optional timeout duration in seconds for request, when using long polling.
     * @return IModelHubEvent if it exists, undefined otherwise.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     * @throws [[ResponseError]] if request has failed.
     */
    async getEvent(requestContext, sasToken, baseAddress, subscriptionId, timeout) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Getting event from subscription", () => ({ subscriptionId }));
        Errors_1.ArgumentCheck.defined("sasToken", sasToken);
        Errors_1.ArgumentCheck.defined("baseAddress", baseAddress);
        Errors_1.ArgumentCheck.validGuid("subscriptionId", subscriptionId);
        const options = await this.getEventRequestOptions(EventsBase_1.GetEventOperationToRequestType.GetDestructive, sasToken, timeout);
        const result = await Request_1.request(requestContext, this.getEventUrl(baseAddress, subscriptionId, timeout), options);
        requestContext.enter();
        if (result.status === 204) {
            bentleyjs_core_1.Logger.logTrace(loggerCategory, "No events found on subscription", () => ({ subscriptionId }));
            return undefined;
        }
        const event = ParseEvent(result);
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Got event from subscription", () => ({ subscriptionId }));
        return Promise.resolve(event);
    }
    /** Create a listener for long polling events from an [[EventSubscription]]. When event is received from the subscription, every registered listener callback is called. This continuously waits for events until all created listeners for that subscriptionId are deleted. [[EventSAS]] token expirations are handled automatically, [[AccessToken]] expiration is handled by calling authenticationCallback to get a new token.
     * @param requestContext The client request context
     * @param authenticationCallback Callback used to get AccessToken. Only the first registered authenticationCallback for this subscriptionId will be used.
     * @param subscriptionId Id of EventSubscription.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param listener Callback that is called when an [[IModelHubEvent]] is received.
     * @returns Function that deletes the created listener.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     */
    createListener(requestContext, authenticationCallback, subscriptionId, iModelId, listener) {
        requestContext.enter();
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.defined("authenticationCallback", authenticationCallback);
        Errors_1.ArgumentCheck.validGuid("subscriptionId", subscriptionId);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const subscription = new EventsBase_1.ListenerSubscription();
        subscription.authenticationCallback = authenticationCallback;
        subscription.getEvent = async (sasToken, baseAddress, id, timeout) => this.getEvent(requestContext, sasToken, baseAddress, id, timeout);
        subscription.getSASToken = async (requestContextArg) => this.getSASToken(requestContextArg, iModelId);
        subscription.id = subscriptionId;
        return EventsBase_1.EventListener.create(subscription, listener);
    }
}
exports.EventHandler = EventHandler;


/***/ }),

/***/ "./lib/imodelhub/EventsBase.js":
/*!*************************************!*\
  !*** ./lib/imodelhub/EventsBase.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHubEvents */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const Request_1 = __webpack_require__(/*! ../Request */ "./lib/Request.js");
const Client_1 = __webpack_require__(/*! ../Client */ "./lib/Client.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const AuthorizedClientRequestContext_1 = __webpack_require__(/*! ../AuthorizedClientRequestContext */ "./lib/AuthorizedClientRequestContext.js");
/** Base class for event shared access signatures. */
class BaseEventSAS extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BaseAddress")
], BaseEventSAS.prototype, "baseAddress", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.EventServiceSASToken")
], BaseEventSAS.prototype, "sasToken", void 0);
exports.BaseEventSAS = BaseEventSAS;
/** Base type for all iModelHub global events
 * @beta
 */
class IModelHubBaseEvent {
    /**
     * Constructor for an event to pass members required for non-destructive reads.
     * @param handler Base handler for WSG requests.
     * @param sasToken Token for authenticating for event requests.
     * @internal
     */
    constructor(handler, sasToken) {
        this._handler = handler;
        this._sasToken = sasToken;
    }
    /**
     * Construct this event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        this.eventTopic = obj.EventTopic;
        this.fromEventSubscriptionId = obj.FromEventSubscriptionId;
        this.toEventSubscriptionId = obj.ToEventSubscriptionId;
        this._lockUrl = obj.location;
    }
    /**
     * Remove a single event from queue.
     * @returns true if operation succeeded, false otherwise.
     */
    async delete(requestContext) {
        if (this._handler && this._lockUrl && this._sasToken) {
            const options = await getEventBaseOperationRequestOptions(this._handler, ModifyEventOperationToRequestType.Delete, this._sasToken);
            const result = await Request_1.request(requestContext, this._lockUrl, options);
            if (result.status === 200)
                return Promise.resolve(true);
        }
        return Promise.resolve(false);
    }
}
exports.IModelHubBaseEvent = IModelHubBaseEvent;
/** @internal */
var ModifyEventOperationToRequestType;
(function (ModifyEventOperationToRequestType) {
    /** Deleted event from queue */
    ModifyEventOperationToRequestType["Delete"] = "DELETE";
})(ModifyEventOperationToRequestType = exports.ModifyEventOperationToRequestType || (exports.ModifyEventOperationToRequestType = {}));
/** @internal */
var GetEventOperationToRequestType;
(function (GetEventOperationToRequestType) {
    /** Get event request options, destructive get. */
    GetEventOperationToRequestType["GetDestructive"] = "DELETE";
    /** Get event request options, non destructive get. */
    GetEventOperationToRequestType["GetPeek"] = "POST";
})(GetEventOperationToRequestType = exports.GetEventOperationToRequestType || (exports.GetEventOperationToRequestType = {}));
/**
 * Get base request options for event operations.
 * @param method Method for request.
 * @param sasToken Service Bus SAS Token.
 * @param requestTimeout Timeout for the request.
 * @return Event if it exists.
 * @internal
 */
async function getEventBaseOperationRequestOptions(handler, method, sasToken, requestTimeout) {
    const options = {
        method,
        headers: { authorization: sasToken },
        agent: handler.getAgent(),
        retries: 0,
    };
    // Request timeout is in seconds, wait 50% more than the expected timeout from server
    if (requestTimeout)
        options.timeout = {
            deadline: requestTimeout * 1500,
            response: requestTimeout * 1500,
        };
    await new Client_1.DefaultRequestOptionsProvider().assignOptions(options);
    return options;
}
exports.getEventBaseOperationRequestOptions = getEventBaseOperationRequestOptions;
/** @internal */
class EventBaseHandler {
    /** Get service bus parser depending on the environment. */
    setServiceBusOptions(options) {
        const parse = (message) => {
            if (!message)
                return undefined;
            return JSON.parse(message.substring(message.indexOf("{"), message.lastIndexOf("}") + 1));
        };
        if (typeof window !== "undefined") {
            options.parser = (_, message) => parse(message);
        }
        else {
            options.buffer = true;
            options.parser = (res, cb) => {
                res.on("data", (chunk) => { res.text += chunk; });
                res.on("end", () => {
                    try {
                        if (res.statusCode === 200 || res.statusCode === 201) {
                            cb(null, parse(res.text));
                        }
                        else if (res.statusCode === 204) {
                            cb(null, "");
                        }
                        else {
                            cb(res, null);
                        }
                    }
                    catch (err) {
                        cb(err, null);
                    }
                });
            };
        }
    }
    /**
     * Get event request options, gets event from queue.
     * @param sasToken Service Bus SAS Token.
     * @param requestTimeout Timeout for the request.
     * @return Event if it exists.
     */
    async getEventRequestOptions(operation, sasToken, requestTimeout) {
        const options = await getEventBaseOperationRequestOptions(this._handler, operation, sasToken, requestTimeout);
        this.setServiceBusOptions(options);
        return options;
    }
}
exports.EventBaseHandler = EventBaseHandler;
/** @internal */
class ListenerSubscription {
}
exports.ListenerSubscription = ListenerSubscription;
/** @internal */
class EventListener {
    /** @internal */
    static create(subscription, listener) {
        if (!this._subscriptions) {
            this._subscriptions = new Map();
        }
        let existingSubscription = this._subscriptions.get(subscription.id);
        let deleteListener;
        if (!existingSubscription) {
            existingSubscription = subscription;
            existingSubscription.listeners = new bentleyjs_core_1.BeEvent();
            deleteListener = subscription.listeners.addListener(listener);
            this.getEvents(subscription); // tslint:disable-line:no-floating-promises
        }
        else {
            deleteListener = subscription.listeners.addListener(listener);
        }
        this._subscriptions.set(subscription.id, existingSubscription);
        const subscriptionId = subscription.id;
        return () => {
            deleteListener();
            const sub = this._subscriptions.get(subscriptionId);
            if (sub) {
                if (sub.listeners && sub.listeners.numberOfListeners === 0)
                    this._subscriptions.delete(subscription.id);
            }
        };
    }
    static async getEvents(subscription) {
        let accessToken = await subscription.authenticationCallback();
        let eventSAS;
        mainLoop: while (subscription.listeners.numberOfListeners > 0) {
            try {
                const requestContext = new AuthorizedClientRequestContext_1.AuthorizedClientRequestContext(accessToken);
                eventSAS = (await subscription.getSASToken(requestContext));
            }
            catch (err) {
                if (err.status === 401) {
                    try {
                        accessToken = await subscription.authenticationCallback();
                    }
                    catch (_a) {
                        break;
                    }
                }
                else {
                    break;
                }
            }
            while (subscription.listeners.numberOfListeners > 0) {
                try {
                    const event = await subscription.getEvent(eventSAS.sasToken, eventSAS.baseAddress, subscription.id, 60);
                    if (event)
                        subscription.listeners.raiseEvent(event);
                }
                catch (err) {
                    if (err.status === 401) {
                        break;
                    }
                    else {
                        break mainLoop;
                    }
                }
            }
        }
        this._subscriptions.delete(subscription.id);
    }
}
exports.EventListener = EventListener;


/***/ }),

/***/ "./lib/imodelhub/GlobalEvents.js":
/*!***************************************!*\
  !*** ./lib/imodelhub/GlobalEvents.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHubGlobalEvents */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Request_1 = __webpack_require__(/*! ./../Request */ "./lib/Request.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const EventsBase_1 = __webpack_require__(/*! ./EventsBase */ "./lib/imodelhub/EventsBase.js");
const ConnectClients_1 = __webpack_require__(/*! ../ConnectClients */ "./lib/ConnectClients.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/** Base type for all iModelHub global events.
 * @beta
 */
class IModelHubGlobalEvent extends EventsBase_1.IModelHubBaseEvent {
    /** Construct this global event from object instance.
     * @param obj Object instance.
     * @internal
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.iModelId = obj.iModelId;
        this.projectId = obj.ProjectId;
        this.contextId = obj.ContextId;
        const contextTypeId = obj.ContextTypeId;
        switch (contextTypeId) {
            case ConnectClients_1.ContextType.Asset:
            case ConnectClients_1.ContextType.Project:
                this.contextTypeId = contextTypeId;
                break;
            default:
                this.contextTypeId = ConnectClients_1.ContextType.Unknown;
        }
    }
}
exports.IModelHubGlobalEvent = IModelHubGlobalEvent;
/** Sent when an iModel is put into the archive. See [[IModelHandler.delete]].
 * @beta Rename to SoftIModelDeleteEvent
 */
class SoftiModelDeleteEvent extends IModelHubGlobalEvent {
}
exports.SoftiModelDeleteEvent = SoftiModelDeleteEvent;
/** Sent when an archived iModel is completely deleted from the storage. Sent after some time passes after [[IModelHandler.delete]] and iModel is no longer kept in the archive. iModel is kept at least 30 days in the archive.
 * @beta Rename to HardIModelDeleteEvent
 */
class HardiModelDeleteEvent extends IModelHubGlobalEvent {
}
exports.HardiModelDeleteEvent = HardiModelDeleteEvent;
/** Sent when an iModel is created. See [[IModelHandler.create]].
 * @beta
 */
class IModelCreatedEvent extends IModelHubGlobalEvent {
}
exports.IModelCreatedEvent = IModelCreatedEvent;
/** Sent when a [[ChangeSet]] is pushed. See [[ChangeSetHandler.create]]. Sent together with [[ChangeSetPostPushEvent]].
 * @beta
 */
class ChangeSetCreatedEvent extends IModelHubGlobalEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.changeSetId = obj.ChangeSetId;
        this.changeSetIndex = obj.ChangeSetIndex;
        this.briefcaseId = obj.BriefcaseId;
    }
}
exports.ChangeSetCreatedEvent = ChangeSetCreatedEvent;
/** Sent when a named [[Version]] is created. See [[VersionHandler.create]].
 * @beta
 */
class NamedVersionCreatedEvent extends IModelHubGlobalEvent {
    /** Construct this event from object instance.
     * @param obj Object instance.
     */
    fromJson(obj) {
        super.fromJson(obj);
        this.versionId = obj.VersionId;
        this.versionName = obj.VersionName;
        this.changeSetId = obj.ChangeSetId;
    }
}
exports.NamedVersionCreatedEvent = NamedVersionCreatedEvent;
/** Get constructor from GlobalEventType name. */
function ConstructorFromEventType(type) {
    switch (type) {
        case "SoftiModelDeleteEvent":
            return SoftiModelDeleteEvent;
        case "HardiModelDeleteEvent":
            return HardiModelDeleteEvent;
        case "iModelCreatedEvent":
            return IModelCreatedEvent;
        case "ChangeSetCreatedEvent":
            return ChangeSetCreatedEvent;
        case "NamedVersionCreatedEvent":
            return NamedVersionCreatedEvent;
    }
}
/** Parse [[IModelHubGlobalEvent]] from response object.
 * @param response Response object to parse.
 * @returns Appropriate global event object.
 * @internal
 */
function ParseGlobalEvent(response, handler, sasToken) {
    const constructor = ConstructorFromEventType(response.header["content-type"]);
    const globalEvent = new constructor(handler, sasToken);
    globalEvent.fromJson(Object.assign({}, response.header, response.body));
    return globalEvent;
}
exports.ParseGlobalEvent = ParseGlobalEvent;
/** Subscription to receive [[IModelHubGlobalEvent]]s. Each subscription has a separate queue for events that it hasn't read yet. Global event subscriptions do not expire and must be deleted by the user. Use wsgId of this instance for the methods that require subscriptionId. See [[GlobalEventSubscriptionHandler]].
 * @beta
 */
let GlobalEventSubscription = class GlobalEventSubscription extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.EventTypes")
], GlobalEventSubscription.prototype, "eventTypes", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SubscriptionId")
], GlobalEventSubscription.prototype, "subscriptionId", void 0);
GlobalEventSubscription = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "GlobalScope.GlobalEventSubscription", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], GlobalEventSubscription);
exports.GlobalEventSubscription = GlobalEventSubscription;
/** Shared access signature token for getting [[IModelHubGlobalEvent]]s. It's used to authenticate for [[GlobalEventHandler.getEvent]]. To receive an instance call [[GlobalEventHandler.getSASToken]].
 * @beta
 */
let GlobalEventSAS = class GlobalEventSAS extends EventsBase_1.BaseEventSAS {
};
GlobalEventSAS = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "GlobalScope.GlobalEventSAS", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], GlobalEventSAS);
exports.GlobalEventSAS = GlobalEventSAS;
/** Handler for managing [[GlobalEventSubscription]]s.
 * Use [[GlobalEventHandler.Subscriptions]] to get an instance of this class.
 * @beta
 */
class GlobalEventSubscriptionHandler {
    /** Constructor for GlobalEventSubscriptionHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get relative url for GlobalEventSubscription requests.
     * @param instanceId Id of the subscription.
     */
    getRelativeUrl(instanceId) {
        return `/Repositories/Global--Global/GlobalScope/GlobalEventSubscription/${instanceId || ""}`;
    }
    /** Create a [[GlobalEventSubscription]]. You can use this to get or update the existing subscription instance, if you only have the original subscriptionId.
     * @param requestContext The client request context
     * @param subscriptionId Guid to be used by global event subscription. It will be a part of the resulting subscription id.
     * @param globalEvents Array of GlobalEventTypes to subscribe to.
     * @return Created GlobalEventSubscription instance.
     * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionAlreadyExists]($bentley) if [[GlobalEventSubscription]] already exists with the specified subscriptionId.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, subscriptionId, globalEvents) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Creating global event subscription", () => ({ subscriptionId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("subscriptionId", subscriptionId);
        let subscription = new GlobalEventSubscription();
        subscription.eventTypes = globalEvents;
        subscription.subscriptionId = subscriptionId;
        subscription = await this._handler.postInstance(requestContext, GlobalEventSubscription, this.getRelativeUrl(), subscription);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Created global event subscription", () => ({ subscriptionId }));
        return subscription;
    }
    /** Update a [[GlobalEventSubscription]]. Can change the [[GlobalEventType]]s specified in the subscription. Must be a valid subscription that was previously created with [[GlobalEventSubscriptionHandler.create]].
     * @param requestContext The client request context.
     * @param subscription Updated GlobalEventSubscription.
     * @return GlobalEventSubscription instance from iModelHub after update.
     * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if [[GlobalEventSubscription]] does not exist with the specified subscription.wsgId.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, subscription) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Updating global event subscription with instance id: ${subscription.wsgId}`, () => ({ subscriptionId: subscription.subscriptionId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.defined("subscription", subscription);
        Errors_1.ArgumentCheck.validGuid("subscription.wsgId", subscription.wsgId);
        const updatedSubscription = await this._handler.postInstance(requestContext, GlobalEventSubscription, this.getRelativeUrl(subscription.wsgId), subscription);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Updated global event subscription with instance id: ${subscription.wsgId}`, () => ({ subscriptionId: subscription.subscriptionId }));
        return updatedSubscription;
    }
    /** Delete a [[GlobalEventSubscription]].
     * @param requestContext The client request context.
     * @param subscriptionId WSG Id of the GlobalEventSubscription.
     * @returns Resolves if the GlobalEventSubscription has been successfully deleted.
     * @throws [[IModelHubError]] with [IModelHubStatus.EventSubscriptionDoesNotExist]($bentley) if GlobalEventSubscription does not exist with the specified subscription.wsgId.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async delete(requestContext, subscriptionId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Deleting global event subscription", () => ({ subscriptionId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("subscriptionInstanceId", subscriptionId);
        await this._handler.delete(requestContext, this.getRelativeUrl(subscriptionId));
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Deleted global event subscription", () => ({ subscriptionId }));
    }
}
exports.GlobalEventSubscriptionHandler = GlobalEventSubscriptionHandler;
/** Type of [[GlobalEventHandler.getEvent]] operations.
 * @beta
 */
var GetEventOperationType;
(function (GetEventOperationType) {
    /** Event will be immediately removed from queue. */
    GetEventOperationType[GetEventOperationType["Destructive"] = 0] = "Destructive";
    /** Event will be locked instead of removed. It has to be later removed via [[IModelHubBaseEvent.delete]]. */
    GetEventOperationType[GetEventOperationType["Peek"] = 1] = "Peek";
})(GetEventOperationType = exports.GetEventOperationType || (exports.GetEventOperationType = {}));
/** Handler for receiving [[IModelHubGlobalEvent]]s.
 * Use [[IModelClient.GlobalEvents]] to get an instance of this class.
 * @beta
 */
class GlobalEventHandler extends EventsBase_1.EventBaseHandler {
    /** Constructor for GlobalEventHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        super();
        this._handler = handler;
    }
    /** Get a handler for managing [[GlobalEventSubscription]]s. */
    get subscriptions() {
        if (!this._subscriptionHandler) {
            this._subscriptionHandler = new GlobalEventSubscriptionHandler(this._handler);
        }
        return this._subscriptionHandler;
    }
    /** Get relative url for GlobalEventSAS requests. */
    getGlobalEventSASRelativeUrl() {
        return `/Repositories/Global--Global/GlobalScope/GlobalEventSAS/`;
    }
    /** Get global event SAS Token. Used to authenticate for [[GlobalEventHandler.getEvent]].
     * @param requestContext The client request context
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async getSASToken(requestContext) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Getting global event SAS token");
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        const globalEventSAS = await this._handler.postInstance(requestContext, GlobalEventSAS, this.getGlobalEventSASRelativeUrl(), new GlobalEventSAS());
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Got global event SAS token");
        return globalEventSAS;
    }
    /** Get absolute url for global event requests.
     * @param baseAddress Base address for the serviceBus.
     * @param subscriptionId Id of the subscription instance.
     * @param timeout Optional timeout for long polling.
     */
    getGlobalEventUrl(baseAddress, subscriptionId, timeout) {
        let url = `${baseAddress}/Subscriptions/${subscriptionId}/messages/head`;
        if (timeout) {
            url = url + `?timeout=${timeout}`;
        }
        return url;
    }
    /** Get an [[IModelHubGlobalEvent]] from the [[GlobalEventSubscription]]. You can use long polling timeout, to have requests return when events are available (or request times out), rather than returning immediately when no events are found.
     * @param requestContext The client request context
     * @param sasToken SAS Token used to authenticate. See [[GlobalEventSAS.sasToken]].
     * @param baseAddress Address for the events. See [[GlobalEventSAS.baseAddress]].
     * @param subscriptionId Id of the subscription to the topic. See [[GlobalEventSubscription]].
     * @param timeout Optional timeout duration in seconds for request, when using long polling.
     * @return IModelHubGlobalEvent if it exists, undefined otherwise.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     * @throws [[ResponseError]] if request has failed.
     */
    async getEvent(requestContext, sasToken, baseAddress, subscriptionId, timeout, getOperation = GetEventOperationType.Destructive) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Getting global event from subscription", () => ({ subscriptionId }));
        Errors_1.ArgumentCheck.defined("sasToken", sasToken);
        Errors_1.ArgumentCheck.defined("baseAddress", baseAddress);
        Errors_1.ArgumentCheck.defined("subscriptionInstanceId", subscriptionId);
        let options;
        if (getOperation === GetEventOperationType.Destructive)
            options = await this.getEventRequestOptions(EventsBase_1.GetEventOperationToRequestType.GetDestructive, sasToken, timeout);
        else if (getOperation === GetEventOperationType.Peek)
            options = await this.getEventRequestOptions(EventsBase_1.GetEventOperationToRequestType.GetPeek, sasToken, timeout);
        else // Unknown operation type.
            return undefined;
        const result = await Request_1.request(requestContext, this.getGlobalEventUrl(baseAddress, subscriptionId, timeout), options);
        requestContext.enter();
        if (result.status === 204) {
            bentleyjs_core_1.Logger.logTrace(loggerCategory, "No events found on subscription", () => ({ subscriptionId }));
            return undefined;
        }
        const event = ParseGlobalEvent(result, this._handler, sasToken);
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Got Global Event from subscription", () => ({ subscriptionId }));
        return Promise.resolve(event);
    }
    /** Create a listener for long polling events from a [[GlobalEventSubscription]]. When event is received from the subscription, every registered listener callback is called. This continuously waits for events until all created listeners for that subscriptionInstanceId are deleted. [[GlobalEventSAS]] token expirations are handled automatically, [[AccessToken]] expiration is handled by calling authenticationCallback to get a new token.
     * @param authenticationCallback Callback used to get AccessToken. Only the first registered authenticationCallback for this subscriptionId will be used.
     * @param subscriptionInstanceId Id of GlobalEventSubscription.
     * @param listener Callback that is called when an [[IModelHubGlobalEvent]] is received.
     * @returns Function that deletes the created listener.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     */
    createListener(requestContext, authenticationCallback, subscriptionInstanceId, listener) {
        requestContext.enter();
        Errors_1.ArgumentCheck.defined("subscriptionInstanceId", subscriptionInstanceId);
        const subscription = new EventsBase_1.ListenerSubscription();
        subscription.authenticationCallback = authenticationCallback;
        subscription.getEvent = async (sasToken, baseAddress, id, timeout) => this.getEvent(requestContext, sasToken, baseAddress, id, timeout);
        subscription.getSASToken = async (reqContext) => this.getSASToken(reqContext);
        subscription.id = subscriptionInstanceId;
        return EventsBase_1.EventListener.create(subscription, listener);
    }
}
exports.GlobalEventHandler = GlobalEventHandler;


/***/ }),

/***/ "./lib/imodelhub/Locks.js":
/*!********************************!*\
  !*** ./lib/imodelhub/Locks.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const deepAssign = __webpack_require__(/*! deep-assign */ "../../common/temp/node_modules/.registry.npmjs.org/deep-assign/2.0.0/node_modules/deep-assign/index.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Request_1 = __webpack_require__(/*! ./../Request */ "./lib/Request.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/**
 * [[Lock]] type describes the kind of object that is locked.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
var LockType;
(function (LockType) {
    /** Lock for the entire file. This is a global Lock that can only be taken with objectId 1. */
    LockType[LockType["Db"] = 0] = "Db";
    /** Lock for a model. It should be acquired together with a [[LockLevel.Shared]] Db Lock. */
    LockType[LockType["Model"] = 1] = "Model";
    /** Lock for a single element. It should be acquired together with a [[LockLevel.Shared]] Model Lock. */
    LockType[LockType["Element"] = 2] = "Element";
    /** Lock used to change schemas. This is a global Lock that can only be taken with objectId 1. This lock cannot have [[LockLevel.Shared]]. */
    LockType[LockType["Schemas"] = 3] = "Schemas";
    /** Lock used to change CodeSpecs. This is a global Lock that can only be taken with objectId 1. This lock cannot have [[LockLevel.Shared]]. */
    LockType[LockType["CodeSpecs"] = 4] = "CodeSpecs";
})(LockType = exports.LockType || (exports.LockType = {}));
/**
 * [[Lock]] level describes how restrictive the Lock is.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
var LockLevel;
(function (LockLevel) {
    /** Lock is not owned. */
    LockLevel[LockLevel["None"] = 0] = "None";
    /** Lock can be owned by multiple [[Briefcase]]s. Shared Lock is usually acquired together with Locks for lower level objects that depend on this object. */
    LockLevel[LockLevel["Shared"] = 1] = "Shared";
    /** Lock can only be owned by a single briefcase. Exclusive Lock is required to modify model or element when using pessimistic concurrency. */
    LockLevel[LockLevel["Exclusive"] = 2] = "Exclusive";
})(LockLevel = exports.LockLevel || (exports.LockLevel = {}));
/**
 * Gets encoded instance id for a lock to be used in an URI.
 * @param lock Lock to get instance id for.
 * @returns Encoded lock instance id.
 * @internal
 */
function getLockInstanceId(lock) {
    if (!lock || lock.briefcaseId === undefined || lock.lockType === undefined || !lock.objectId)
        return undefined;
    return `${lock.lockType}-${lock.objectId}-${lock.briefcaseId}`;
}
/** Provider for default LockUpdateOptions, used by LockHandler to set defaults.
 * @internal
 */
class DefaultLockUpdateOptionsProvider {
    /** Creates an instance of DefaultRequestOptionsProvider and sets up the default options. */
    constructor() {
        this._defaultOptions = {
            locksPerRequest: 2000,
        };
    }
    /** Augments options with the provider's default values.
     * @note The options passed in override any defaults where necessary.
     * @param options Options that should be augmented.
     */
    async assignOptions(options) {
        const clonedOptions = Object.assign({}, options);
        deepAssign(options, this._defaultOptions);
        deepAssign(options, clonedOptions); // ensure the supplied options override the defaults
        return Promise.resolve();
    }
}
exports.DefaultLockUpdateOptionsProvider = DefaultLockUpdateOptionsProvider;
/**
 * Error for conflicting [[Lock]]s. It contains an array of Locks that failed to acquire. This is returned when calling [[LockHandler.update]] with [[LockUpdateOptions.deniedLocks]] set to true.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
class ConflictingLocksError extends Errors_1.IModelHubError {
    /** Create ConflictingLocksError from IModelHubError instance.
     * @param error IModelHubError to get error data from.
     * @returns Undefined if the error is not for a lock conflict, otherwise newly created error instance.
     * @internal
     */
    static fromError(error) {
        if (error.errorNumber !== bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase
            && error.errorNumber !== bentleyjs_core_1.IModelHubStatus.ConflictsAggregate) {
            return undefined;
        }
        const result = new ConflictingLocksError(error.errorNumber);
        deepAssign(result, error);
        result.addLocks(error);
        return result;
    }
    /**
     * Amends this error instance with conflicting locks from another IModelHubError.
     * @param error Error to get additional conflicting locks from.
     * @internal
     */
    addLocks(error) {
        if (!error.data || !error.data.ConflictingLocks) {
            return;
        }
        if (!this.conflictingLocks) {
            this.conflictingLocks = [];
        }
        for (const value of error.data.ConflictingLocks) {
            const instance = { className: "Lock", schemaName: "iModelScope", properties: value };
            const lock = ECJsonTypeMap_1.ECJsonTypeMap.fromJson(Lock, "wsg", instance);
            if (lock) {
                this.conflictingLocks.push(lock);
            }
        }
    }
}
exports.ConflictingLocksError = ConflictingLocksError;
/**
 * Base class for [[Lock]]s.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
class LockBase extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LockType")
], LockBase.prototype, "lockType", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.LockLevel")
], LockBase.prototype, "lockLevel", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.BriefcaseId")
], LockBase.prototype, "briefcaseId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.SeedFileId")
], LockBase.prototype, "seedFileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ReleasedWithChangeSet")
], LockBase.prototype, "releasedWithChangeSet", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ReleasedWithChangeSetIndex")
], LockBase.prototype, "releasedWithChangeSetIndex", void 0);
exports.LockBase = LockBase;
/**
 * Lock instance. When using pessimistic concurrency, locks ensure that only a single user can modify an object at a time.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
let Lock = class Lock extends LockBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ObjectId")
], Lock.prototype, "objectId", void 0);
Lock = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Lock", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Lock);
exports.Lock = Lock;
/**
 * MultiLock: data about locks grouped by BriefcaseId, LockLevel and LockType.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
let MultiLock = class MultiLock extends LockBase {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ObjectIds")
], MultiLock.prototype, "objectIds", void 0);
MultiLock = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.MultiLock", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], MultiLock);
exports.MultiLock = MultiLock;
/**
 * Query object for getting [[Lock]]s. You can use this to modify the [[LockHandler.get]] results.
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
class LockQuery extends Query_1.Query {
    /** Constructor that sets default page size. */
    constructor() {
        super();
        this._isMultiLockQuery = true;
        this.pageSize(LockQuery.defaultPageSize);
    }
    /**
     * Used by the handler to check whether locks in query can be grouped.
     * @internal
     */
    get isMultiLockQuery() {
        return this._isMultiLockQuery;
    }
    /**
     * Query [[Lock]]s by [[Briefcase]] id.
     * @param briefcaseId Id of the Briefcase.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if briefcaseId is undefined or it contains an invalid [[Briefcase]] id value.
     */
    byBriefcaseId(briefcaseId) {
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        this.addFilter(`BriefcaseId+eq+${briefcaseId}`);
        return this;
    }
    /**
     * Query [[Lock]]s by [[LockType]].
     * @param lockType Lock type to query.
     * @returns This query.
     */
    byLockType(lockType) {
        this.addFilter(`LockType+eq+${lockType}`);
        return this;
    }
    /**
     * Query [[Lock]]s by [[LockLevel]].
     * @param lockLevel Lock level to query.
     * @returns This query.
     */
    byLockLevel(lockLevel) {
        this.addFilter(`LockLevel+eq+${lockLevel}`);
        return this;
    }
    /**
     * Query [[Lock]]s by ObjectId.
     * @param objectId Id of the object.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) if objectId is undefined.
     */
    byObjectId(objectId) {
        Errors_1.ArgumentCheck.defined("objectId", objectId);
        this._isMultiLockQuery = false;
        this.addFilter(`ObjectId+eq+'${objectId}'`);
        return this;
    }
    /**
     * Query [[Lock]]s by [[ChangeSet]] id that it was released with.
     * @param changesetId Id of the ChangeSet.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if changeSetId is undefined or empty, or it contains an invalid [[ChangeSet]] id value.
     */
    byReleasedWithChangeSet(changeSetId) {
        Errors_1.ArgumentCheck.validChangeSetId("changeSetId", changeSetId);
        this.addFilter(`ReleasedWithChangeSet+eq+'${changeSetId}'`);
        return this;
    }
    /**
     * Query [[Lock]]s by [[ChangeSet]] index that it was released with.
     * @param changeSetIndex Index of the changeSet.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley)
     * if changeSetIndex is undefined.
     */
    byReleasedWithChangeSetIndex(changeSetIndex) {
        Errors_1.ArgumentCheck.definedNumber("changeSetIndex", changeSetIndex);
        this.addFilter(`ReleasedWithChangeSetIndex+eq+${changeSetIndex}`);
        return this;
    }
    /**
     * Query [[Lock]]s by their instance ids.
     * @param locks Locks to query. They must have their BriefcaseId, LockType and ObjectId set.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if locks array is undefined or empty, or it contains invalid [[Lock]] values.
     */
    byLocks(locks) {
        Errors_1.ArgumentCheck.nonEmptyArray("locks", locks);
        let filter = "$id+in+[";
        let index = 0;
        for (const lock of locks) {
            const id = getLockInstanceId(lock);
            Errors_1.ArgumentCheck.valid(`locks[${index}]`, id);
            if (0 !== index++)
                filter += ",";
            filter += `'${id}'`;
        }
        filter += "]";
        this.addFilter(filter);
        this._isMultiLockQuery = false;
        return this;
    }
    /**
     * Query unavailable [[Lock]]s. It will include all Locks owned by other [[Briefcase]]s and locks that were released with a newer [[ChangeSet]].
     * @param briefcaseId Id of the Briefcase.
     * @param lastChangeSetIndex Index of the last ChangeSet that user has pulled.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the values is undefined or briefcaseId is not in a valid [[Briefcase]] id value.
     */
    unavailableLocks(briefcaseId, lastChangeSetIndex) {
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        Errors_1.ArgumentCheck.defined("lastChangeSetIndex", lastChangeSetIndex);
        let filter = `BriefcaseId+ne+${briefcaseId}`;
        filter += `+and+(LockLevel+gt+0+or+ReleasedWithChangeSetIndex+gt+${lastChangeSetIndex})`;
        this.addFilter(filter);
        return this;
    }
}
/**
 * Default page size which is used when querying Locks
 * @internal
 */
LockQuery.defaultPageSize = 10000;
exports.LockQuery = LockQuery;
/**
 * Handler for managing [[Lock]]s. Use [[IModelClient.Locks]] to get an instance of this class.
 * In most cases, you should use [ConcurrencyControl]($backend) methods instead. You can read more about concurrency control [here]($docs/learning/backend/concurrencycontrol).
 * @alpha Hide Lock API while focused on readonly viewing scenarios
 */
class LockHandler {
    /**
     * Constructor for LockHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    getRelativeUrl(iModelId, multilock = true, lockId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/${multilock ? "MultiLock" : "Lock"}/${lockId || ""}`;
    }
    static convertLocksToMultiLocks(locks) {
        const map = new Map();
        for (const lock of locks) {
            const id = `${lock.lockType}-${lock.lockLevel}`;
            if (map.has(id)) {
                map.get(id).objectIds.push(lock.objectId);
            }
            else {
                const multiLock = new MultiLock();
                multiLock.changeState = "new";
                multiLock.briefcaseId = lock.briefcaseId;
                multiLock.seedFileId = lock.seedFileId;
                multiLock.releasedWithChangeSet = lock.releasedWithChangeSet;
                multiLock.releasedWithChangeSetIndex = lock.releasedWithChangeSetIndex;
                multiLock.lockLevel = lock.lockLevel;
                multiLock.lockType = lock.lockType;
                multiLock.objectIds = [lock.objectId];
                map.set(id, multiLock);
            }
        }
        return Array.from(map.values());
    }
    static convertMultiLocksToLocks(multiLocks) {
        const result = [];
        for (const multiLock of multiLocks) {
            for (const value of multiLock.objectIds) {
                const lock = new Lock();
                lock.objectId = value;
                lock.briefcaseId = multiLock.briefcaseId;
                if (lock.seedFileId)
                    lock.seedFileId = multiLock.seedFileId;
                lock.lockLevel = multiLock.lockLevel;
                lock.lockType = multiLock.lockType;
                result.push(lock);
            }
        }
        return result;
    }
    /** Augment update options with defaults returned by the DefaultLockUpdateOptionsProvider.
     * The options passed in by clients override any defaults where necessary.
     * @param options Options the caller wants to eaugment with the defaults.
     */
    async setupOptionDefaults(options) {
        if (!LockHandler._defaultUpdateOptionsProvider)
            LockHandler._defaultUpdateOptionsProvider = new DefaultLockUpdateOptionsProvider();
        return LockHandler._defaultUpdateOptionsProvider.assignOptions(options);
    }
    /** Send partial request for lock updates */
    async updateInternal(requestContext, iModelId, locks, updateOptions) {
        requestContext.enter();
        let requestOptions;
        if (updateOptions) {
            requestOptions = {};
            requestOptions.CustomOptions = {};
            if (updateOptions.deniedLocks === false) {
                requestOptions.CustomOptions.DetailedError_Codes = "false";
            }
            if (updateOptions.unlimitedReporting) {
                requestOptions.CustomOptions.DetailedError_MaximumInstances = "-1";
            }
            if (updateOptions.continueOnConflict) {
                requestOptions.CustomOptions.ConflictStrategy = "Continue";
            }
            if (Object.getOwnPropertyNames(requestOptions.CustomOptions).length === 0) {
                requestOptions = undefined;
            }
        }
        const result = await this._handler.postInstances(requestContext, MultiLock, `/Repositories/iModel--${iModelId}/$changeset`, LockHandler.convertLocksToMultiLocks(locks), requestOptions);
        requestContext.enter();
        return LockHandler.convertMultiLocksToLocks(result);
    }
    /** Update multiple [[Lock]]s. This call can simultaneously acquire new Locks and update states of already owned Locks. If large amount of Locks are updated, they are split across multiple requests. See [[LockUpdateOptions.locksPerRequest]]. Default is 2000 Locks per request.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param locks Locks to acquire. Requires briefcaseId, seedFileId to be set for every
     * Lock instance. They must be consistent throughout all of the Locks.
     * @param updateOptions Options for the update request. You can set this to change
     * how conflicts are handled or to handle different amount of Locks per request.
     * @returns Updated Lock values.
     * @throws [[ConflictingLocksError]] when [[LockUpdateOptions.deniedLocks]] is set and conflicts occured. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) for more information.
     * @throws [[AggregateResponseError]] when multiple requests where sent and more than 1 of the following errors occured.
     * @throws [[IModelHubError]] with status indicating a conflict. See [Handling Conflicts]($docs/learning/iModelHub/CodesAndLocksConflicts.md) section for more information.
     * @throws [[IModelHubError]] with [IModelHubStatus.InvalidBriefcase]($bentley) when including locks with different briefcaseId values in the request.
     * @throws [[IModelHubError]] with [IModelHubStatus.OperationFailed]($bentley) when including multiple identical locks in the request.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, iModelId, locks, updateOptions) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Requesting locks", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.nonEmptyArray("locks", locks);
        updateOptions = updateOptions || {};
        await this.setupOptionDefaults(updateOptions);
        const result = [];
        let conflictError;
        const aggregateError = new Errors_1.AggregateResponseError();
        for (let i = 0; i < locks.length; i += updateOptions.locksPerRequest) {
            const chunk = locks.slice(i, i + updateOptions.locksPerRequest);
            try {
                result.push(...await this.updateInternal(requestContext, iModelId, chunk, updateOptions));
                requestContext.enter();
            }
            catch (error) {
                requestContext.enter();
                if (error instanceof Request_1.ResponseError) {
                    if (updateOptions && updateOptions.deniedLocks && error instanceof Errors_1.IModelHubError
                        && (error.errorNumber === bentleyjs_core_1.IModelHubStatus.LockOwnedByAnotherBriefcase || error.errorNumber === bentleyjs_core_1.IModelHubStatus.ConflictsAggregate)) {
                        if (conflictError) {
                            conflictError.addLocks(error);
                        }
                        else {
                            conflictError = ConflictingLocksError.fromError(error);
                        }
                        if (!updateOptions.continueOnConflict) {
                            return Promise.reject(conflictError);
                        }
                    }
                    else {
                        aggregateError.errors.push(error);
                    }
                }
            }
        }
        if (conflictError) {
            return Promise.reject(conflictError);
        }
        if (aggregateError.errors.length > 0) {
            return Promise.reject(aggregateError.errors.length > 1 ? aggregateError : aggregateError.errors[0]);
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Requested ${locks.length} locks for iModel`, () => ({ iModelId }));
        return result;
    }
    /** Get the [[Lock]]s that have been issued for the iModel.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried Locks or select different data from them.
     * @returns Resolves to an array of Locks matching the query.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new LockQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying locks", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        let locks;
        if (query.isMultiLockQuery) {
            const result = await this._handler.getInstances(requestContext, MultiLock, this.getRelativeUrl(iModelId), query.getQueryOptions());
            requestContext.enter();
            locks = LockHandler.convertMultiLocksToLocks(result);
        }
        else {
            locks = await this._handler.postQuery(requestContext, Lock, this.getRelativeUrl(iModelId, false), query.getQueryOptions());
            requestContext.enter();
            locks = locks.map((value) => {
                const result = new Lock();
                result.briefcaseId = value.briefcaseId;
                result.lockLevel = value.lockLevel;
                result.lockType = value.lockType;
                result.objectId = value.objectId;
                if (value.seedFileId)
                    result.seedFileId = value.seedFileId;
                return result;
            });
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Queried ${locks.length} locks for iModel`, () => ({ iModelId }));
        return locks;
    }
    /** Delete all [[Lock]]s owned by the specified [[Briefcase]].
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param briefcaseId Id of the Briefcacase.
     * @throws [[IModelHubError]] with [IModelHubStatus.BriefcaseDoesNotExist]($bentley) if [[Briefcase]] with specified briefcaseId does not exist. This can happen if number was not given as a Briefcase id yet, or Briefcase with that id was already deleted.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if [[Briefcase]] belongs to another user and user sending the request does not have ManageResources permission.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async deleteAll(requestContext, iModelId, briefcaseId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Deleting all locks from briefcase", () => ({ iModelId, briefcaseId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.validBriefcaseId("briefcaseId", briefcaseId);
        await this._handler.delete(requestContext, this.getRelativeUrl(iModelId, false, `DeleteAll-${briefcaseId}`));
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Deleted all locks from briefcase", () => ({ iModelId, briefcaseId }));
    }
}
exports.LockHandler = LockHandler;


/***/ }),

/***/ "./lib/imodelhub/Query.js":
/*!********************************!*\
  !*** ./lib/imodelhub/Query.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
Object.defineProperty(exports, "__esModule", { value: true });
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
/** Base class for iModelHub Query objects. Query objects are used to modify the results when getting instances from iModelHub.
 * @beta
 */
class Query {
    constructor() {
        this._query = {};
    }
    /**
     * Translate this object into QueryOptions.
     * @internal
     */
    getQueryOptions() {
        return this._query;
    }
    /**
     * Reset QueryOptions.
     * @internal
     */
    resetQueryOptions() {
        this._query = {};
    }
    /**
     * Append a part of the filter.
     * @internal
     */
    addFilter(filter, operator = "and") {
        if (!this._query.$filter) {
            this._query.$filter = "";
        }
        else {
            this._query.$filter += `+${operator}+`;
        }
        this._query.$filter += filter;
    }
    /**
     * Set filter to the specified filter string. This resets all previously set filters.
     * @param filter Filter string to set for the query.
     * @returns This query.
     */
    filter(filter) {
        this._query.$filter = filter;
        return this;
    }
    /**
     * Append a part of the select.
     * @internal
     */
    addSelect(select) {
        if (this._query.$select) {
            this._query.$select += ",";
        }
        this._query.$select += select;
        return this;
    }
    /**
     * Set select to specified select string. This resets all previously set selects.
     * @param select Select string to set for the query.
     * @returns This query.
     */
    select(select) {
        this._query.$select = select;
        return this;
    }
    /**
     * Select only top entries from the query. This is applied after [[Query.skip]].
     * @param n Number of top entries to select.
     * @returns This query.
     */
    top(n) {
        this._query.$top = n;
        return this;
    }
    /**
     * Skip first entries in the query. This is applied before [[Query.top]].
     * @param n Number of entries to skip.
     * @returns This query.
     */
    skip(n) {
        this._query.$skip = n;
        return this;
    }
    /**
     * Set order for the query. This resets any other orders set.
     * @param orderBy Order string to set.
     * @returns This query.
     */
    orderBy(orderBy) {
        this._query.$orderby = orderBy;
        return this;
    }
    /**
     * Select all entries from the query by pages.
     * @param n Maximum number of entries in a single response.
     * @returns This query.
     */
    pageSize(n) {
        this._query.$pageSize = n;
        return this;
    }
}
exports.Query = Query;
/** Query for instances with string based instance ids.
 * @beta
 */
class StringIdQuery extends Query {
    /**
     * Query single instance by its id.
     * @param id Id of the instance to query.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.
     */
    byId(id) {
        this.checkValue(id);
        this._byId = id;
        this._query.$pageSize = undefined;
        return this;
    }
    /** @internal */
    checkValue(id) {
        Errors_1.ArgumentCheck.valid("id", id);
    }
    /**
     * Used by iModelHub handlers to get the id that is queried.
     * @internal
     */
    getId() {
        return this._byId;
    }
}
exports.StringIdQuery = StringIdQuery;
/** Query for instances with Guid based instance ids.
 * @beta
 */
class InstanceIdQuery extends Query {
    /**
     * Query single instance by its id.
     * @param id Id of the instance to query.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.
     */
    byId(id) {
        Errors_1.ArgumentCheck.validGuid("id", id);
        this._byId = id;
        this._query.$pageSize = undefined;
        return this;
    }
    /**
     * Used by iModelHub handlers to get the id that is queried.
     * @internal
     */
    getId() {
        return this._byId;
    }
}
exports.InstanceIdQuery = InstanceIdQuery;
/**
 * Add select for the download URL to the query.
 * @internal
 */
function addSelectFileAccessKey(query) {
    if (!query.$select)
        query.$select = "*";
    query.$select += ",FileAccessKey-forward-AccessKey.DownloadURL";
}
exports.addSelectFileAccessKey = addSelectFileAccessKey;


/***/ }),

/***/ "./lib/imodelhub/Thumbnails.js":
/*!*************************************!*\
  !*** ./lib/imodelhub/Thumbnails.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Request_1 = __webpack_require__(/*! ./../Request */ "./lib/Request.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/** Base class for Thumbnails.
 * @alpha
 */
class Thumbnail extends ECJsonTypeMap_1.WsgInstance {
}
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "instanceId")
], Thumbnail.prototype, "id", void 0);
exports.Thumbnail = Thumbnail;
/** Small [[Thumbnail]] class. Small Thumbnail is a 400x250 PNG image.
 * @alpha
 */
let SmallThumbnail = class SmallThumbnail extends Thumbnail {
};
SmallThumbnail = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.SmallThumbnail", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], SmallThumbnail);
exports.SmallThumbnail = SmallThumbnail;
/** Large [[Thumbnail]] class. Large Thumbnail is a 800x500 PNG image.
 * @alpha
 */
let LargeThumbnail = class LargeThumbnail extends Thumbnail {
};
LargeThumbnail = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.LargeThumbnail", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], LargeThumbnail);
exports.LargeThumbnail = LargeThumbnail;
/**
 * Query object for getting [[Thumbnail]]s. You can use this to modify the [[ThumbnailHandler.get]] results.
 * @alpha
 */
class ThumbnailQuery extends Query_1.InstanceIdQuery {
    /**
     * Query [[Thumbnail]]s by [[Version]] id.
     * @param versionId Id of the version.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if versionId is undefined or it is not a valid [GuidString]($bentley) value.
     */
    byVersionId(versionId) {
        Errors_1.ArgumentCheck.validGuid("versionId", versionId);
        this.addFilter(`HasThumbnail-backward-Version.Id+eq+'${versionId}'`);
        return this;
    }
}
exports.ThumbnailQuery = ThumbnailQuery;
/**
 * Handler for retrieving [[Thumbnail]]s. Use [[IModelClient.Thumbnails]] to get an instance of this class.
 * @alpha
 */
class ThumbnailHandler {
    /**
     * Constructor for ThumbnailHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get relative url for tip Thumbnail requests.
     * @param contextId Id of the context ([[Project]] or [[Asset]]).
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param size Size of the thumbnail.
     */
    getRelativeContextUrl(contextId, iModelId, size) {
        return `/Repositories/Context--${this._handler.formatContextIdForUrl(contextId)}/ContextScope/${size}Thumbnail/${iModelId.toString()}/$file`;
    }
    /** Get relative url for Thumbnail requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param size Size of the thumbnail.
     * @param thumbnailId Id of the thumbnail.
     */
    getRelativeUrl(iModelId, size, thumbnailId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/${size}Thumbnail/${thumbnailId || ""}`;
    }
    /** Check if given thumbnail is TipThumbnail.
     * @param thumbnail SmallThumbnail, LargeThumbnail or TipThumbnail.
     */
    isTipThumbnail(thumbnail) {
        return thumbnail.contextId !== undefined;
    }
    /** Download the thumbnail.
     * @param requestContext The client request context.
     * @param url Url to download thumbnail.
     * @return String for the PNG image that includes the base64 encoded array of the image bytes.
     */
    async downloadThumbnail(requestContext, url) {
        requestContext.enter();
        const options = {
            method: "GET",
            headers: { authorization: requestContext.accessToken.toTokenString() },
            responseType: "arraybuffer",
            agent: this._handler.getAgent(),
        };
        const response = await Request_1.request(requestContext, url, options);
        requestContext.enter();
        const byteArray = new Uint8Array(response.body);
        if (!byteArray || byteArray.length === 0) {
            return Promise.reject(new Error("Expected an image to be returned from the query"));
        }
        const base64Data = Base64.btoa(String.fromCharCode(...byteArray));
        return "data:image/png;base64," + base64Data;
    }
    /** Download the latest iModel's thumbnail.
     * @param requestContext The client request context.
     * @param contextId Id of the connect context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param size Size of the thumbnail. Pass 'Small' for 400x250 PNG image, and 'Large' for a 800x500 PNG image.
     * @return String for the PNG image that includes the base64 encoded array of the image bytes.
     */
    async downloadTipThumbnail(requestContext, contextId, iModelId, size) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Downloading tip ${size}Thumbnail`, () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("contextId", contextId);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const url = await this._handler.getUrl(requestContext) + this.getRelativeContextUrl(contextId, iModelId, size);
        const pngImage = await this.downloadThumbnail(requestContext, url);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Downloaded tip ${size}Thumbnail`, () => ({ iModelId }));
        return pngImage;
    }
    /** Get the [[Thumbnail]]s. Returned Thumbnails are ordered from the latest [[ChangeSet]] to the oldest.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param size Size of the thumbnail.
     * @param query Optional query object to filter the queried Thumbnails.
     * @return Array of Thumbnails of the specified size that match the query.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, size, query = new ThumbnailQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying iModel thumbnails", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        let thumbnails = [];
        if (size === "Small")
            thumbnails = await this._handler.getInstances(requestContext, SmallThumbnail, this.getRelativeUrl(iModelId, size, query.getId()), query.getQueryOptions());
        else
            thumbnails = await this._handler.getInstances(requestContext, LargeThumbnail, this.getRelativeUrl(iModelId, size, query.getId()), query.getQueryOptions());
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Queried iModel thumbnails", () => ({ iModelId }));
        return thumbnails;
    }
    /** Download a [[Thumbnail]].
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param thumbnail Small, Large or Tip thumbnail. Use [[ThumbnailHandler.get]] to get a [[SmallThumbnail]] or [[LargeThumbnail]] instance or provide Tip thumbnail information by constructing a [[TipThumbnail]] instance.
     * @return Base64 encoded string containing the PNG image.
     * @throws Error if a successful server response contains no content.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if one of the arguments is undefined or has an invalid value.
     * @throws [[ResponseError]] if a network issue occurs.
     */
    async download(requestContext, iModelId, thumbnail) {
        requestContext.enter();
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        if (this.isTipThumbnail(thumbnail)) {
            return this.downloadTipThumbnail(requestContext, thumbnail.contextId, iModelId, thumbnail.size);
        }
        const size = thumbnail instanceof SmallThumbnail ? "Small" : "Large";
        const thumbnailId = thumbnail.id;
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Downloading ${size}Thumbnail ${thumbnailId} for iModel`, () => ({ iModelId }));
        const url = await this._handler.getUrl(requestContext) + this.getRelativeUrl(iModelId, size, thumbnailId) + "/$file";
        const pngImage = await this.downloadThumbnail(requestContext, url);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Downloaded ${size}Thumbnail ${thumbnailId} for iModel`, () => ({ iModelId }));
        return pngImage;
    }
}
exports.ThumbnailHandler = ThumbnailHandler;


/***/ }),

/***/ "./lib/imodelhub/Users.js":
/*!********************************!*\
  !*** ./lib/imodelhub/Users.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/** Information about the user, allowing to identify them based on their id.
 * @alpha
 */
let HubUserInfo = class HubUserInfo extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Id")
], HubUserInfo.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], HubUserInfo.prototype, "firstName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Surname")
], HubUserInfo.prototype, "lastName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Email")
], HubUserInfo.prototype, "email", void 0);
HubUserInfo = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.UserInfo", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], HubUserInfo);
exports.HubUserInfo = HubUserInfo;
/** Statistics of user created and owned instances on the iModel.
 * @alpha
 */
let UserStatistics = class UserStatistics extends HubUserInfo {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.BriefcasesCount")
], UserStatistics.prototype, "briefcasesCount", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.OwnedLocksCount")
], UserStatistics.prototype, "ownedLocksCount", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.PushedChangeSetsCount")
], UserStatistics.prototype, "pushedChangeSetsCount", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasStatistics].relatedInstance[Statistics].properties.LastChangeSetPushDate")
], UserStatistics.prototype, "lastChangeSetPushDate", void 0);
UserStatistics = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.UserInfo", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], UserStatistics);
exports.UserStatistics = UserStatistics;
/**
 * Query object for getting User Statistics. You can use this to modify the [[UserStatisticsHandler.get]] results.
 * @alpha
 */
class UserStatisticsQuery extends Query_1.Query {
    /**
     * Constructor for UserStatisticsQuery.
     * @internal
     */
    constructor() {
        super();
        this._statisticsPrefix = "HasStatistics-forward-Statistics";
        this._queriedByIds = false;
        this.select(`*`);
    }
    /**
     * Query single instance by its id.
     * @param id Id of the instance to query.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.
     */
    byId(id) {
        Errors_1.ArgumentCheck.validGuid("id", id);
        this._byId = id;
        return this;
    }
    /**
     * Used by iModelHub handlers to get the id that is queried.
     * @internal
     */
    getId() {
        return this._byId;
    }
    /**
     * Query User Statistics by ids.
     * @param ids Ids of the users.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if ids array is undefined or empty, or it contains invalid [GuidString]($bentley) values.
     */
    byIds(ids) {
        Errors_1.ArgumentCheck.nonEmptyArray("ids", ids);
        let filter = "$id+in+[";
        ids.forEach((id, index) => {
            Errors_1.ArgumentCheck.validGuid(`ids[${index}]`, id);
            if (index > 0)
                filter += ",";
            filter += `'${id}'`;
        });
        filter += "]";
        this.addFilter(filter);
        this._queriedByIds = true;
        return this;
    }
    /** Select all statistics. */
    selectAll() {
        return this.addSelect(`${this._statisticsPrefix}.*`);
    }
    /** Select currently owned [[Briefcase]]s count. */
    selectBriefcasesCount() {
        return this.addSelect(`${this._statisticsPrefix}.BriefcasesCount`);
    }
    /** Select total pushed [[ChangeSet]]s count. */
    selectPushedChangeSetsCount() {
        return this.addSelect(`${this._statisticsPrefix}.PushedChangeSetsCount`);
    }
    /** Select currently owned [[Lock]]s count. */
    selectOwnedLocksCount() {
        return this.addSelect(`${this._statisticsPrefix}.OwnedLocksCount`);
    }
    /** Select the last [[ChangeSet]] push date. */
    selectLastChangeSetPushDate() {
        return this.addSelect(`${this._statisticsPrefix}.LastChangeSetPushDate`);
    }
    /**
     * Returns whether was object queried by ids or no
     * @internal
     */
    get isQueriedByIds() {
        return this._queriedByIds;
    }
}
exports.UserStatisticsQuery = UserStatisticsQuery;
/**
 * Handler for querying [[UserStatistics]]. Use [[UserInfoHandler.Statistics]] to get an instance of this class.
 * @alpha
 */
class UserStatisticsHandler {
    /**
     * Constructor for UserStatistics. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get relative url for UserStatistics requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param userId Id of the user.
     */
    getRelativeUrl(iModelId, userId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/UserInfo/${userId ? userId : ""}`;
    }
    /** Get [[UserStatistics]].
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried [[UserStatistics]] or select different data from them.
     * @returns Array of [[UserStatistics]] for users matching the query.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new UserStatisticsQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying user statistics for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        // if there are no specific selects defined, select all statistics
        if (query.getQueryOptions().$select === "*") {
            query.selectAll();
        }
        let userStatistics;
        if (query.isQueriedByIds) {
            userStatistics = await this._handler.postQuery(requestContext, UserStatistics, this.getRelativeUrl(iModelId), query.getQueryOptions());
        }
        else {
            userStatistics = await this._handler.getInstances(requestContext, UserStatistics, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());
        }
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Queried ${userStatistics.length} user statistics for iModel`, () => ({ iModelId }));
        return userStatistics;
    }
}
exports.UserStatisticsHandler = UserStatisticsHandler;
/** Query object for getting [[HubUserInfo]]. You can use this to modify the [[UserInfoHandler.get]] results.
 * @alpha
 */
class UserInfoQuery extends Query_1.Query {
    constructor() {
        super(...arguments);
        this._queriedByIds = false;
    }
    /** Query UserInfo by user ids.
     * @param ids Ids of the users.
     * @returns This query.
     * @throws [[IModelHubClientError]] if ids array is empty.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if ids array is undefined or empty, or it contains non-Guid values.
     */
    byIds(ids) {
        Errors_1.ArgumentCheck.nonEmptyArray("ids", ids);
        let filter = "$id+in+[";
        ids.forEach((id, index) => {
            Errors_1.ArgumentCheck.validGuid(`id[${index}]`, id);
            if (index > 0)
                filter += ",";
            filter += `'${id}'`;
        });
        filter += "]";
        this.addFilter(filter);
        this._queriedByIds = true;
        return this;
    }
    /** @internal */
    get isQueriedByIds() {
        return this._queriedByIds;
    }
    /** Query single instance by its id.
     * @param id Id of the instance to query.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if id is undefined or it is not a valid [GuidString]($bentley) value.
     */
    byId(id) {
        Errors_1.ArgumentCheck.validGuid("id", id);
        this._byId = id;
        return this;
    }
    /** Used by iModelHub handlers to get the id that is queried.
     * @internal
     */
    getId() {
        return this._byId;
    }
}
exports.UserInfoQuery = UserInfoQuery;
/** Handler for querying [[HubUserInfo]]. Use [[IModelClient.Users]] to get an instance of this class.
 * @alpha
 */
class UserInfoHandler {
    /** Constructor for UserInfoHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get the handler for querying [[UserStatistics]]. */
    get statistics() {
        return new UserStatisticsHandler(this._handler);
    }
    /** Get relative url for UserInfo requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param userId Id of the user.
     */
    getRelativeUrl(iModelId, userId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/UserInfo/${userId || ""}`;
    }
    /** Get the information on users who have accessed the iModel.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried users or select different data from them.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new UserInfoQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying users for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        let users;
        if (query.isQueriedByIds) {
            users = await this._handler.postQuery(requestContext, HubUserInfo, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());
        }
        else {
            users = await this._handler.getInstances(requestContext, HubUserInfo, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());
        }
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Queried users for iModel", () => ({ iModelId }));
        return users;
    }
}
exports.UserInfoHandler = UserInfoHandler;


/***/ }),

/***/ "./lib/imodelhub/Versions.js":
/*!***********************************!*\
  !*** ./lib/imodelhub/Versions.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
/**
 * Named Version is a specific [[ChangeSet]] given a name to differentiate it from others. It can be used to represent some significant milestone for the iModel (e.g. a review version).
 * @beta
 */
let Version = class Version extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "instanceId")
], Version.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], Version.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], Version.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserCreated")
], Version.prototype, "userCreated", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], Version.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.ChangeSetId")
], Version.prototype, "changeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasThumbnail].relatedInstance[SmallThumbnail].instanceId")
], Version.prototype, "smallThumbnailId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[HasThumbnail].relatedInstance[LargeThumbnail].instanceId")
], Version.prototype, "largeThumbnailId", void 0);
Version = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.Version", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], Version);
exports.Version = Version;
/**
 * Query object for getting [[Version]]s. You can use this to modify the [[VersionHandler.get]] results.
 * @beta
 */
class VersionQuery extends Query_1.InstanceIdQuery {
    /**
     * Query [[Version]] by its name.
     * @param name Name of the Version.
     * @returns This query.
     * @throws [IModelHubClientError]($clients) with [IModelHubStatus.UndefinedArgumentError]($bentley) if name is undefined or empty.
     */
    byName(name) {
        Errors_1.ArgumentCheck.defined("name", name);
        this.addFilter(`Name+eq+'${name}'`);
        return this;
    }
    /**
     * Query version by its [[ChangeSet]] id.
     * @param changesetId Id of the ChangeSet.
     * @returns This query.
     * @throws [IModelHubClientError]($clients) with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if changeSetId is undefined or not a valid [[ChangeSet.id]] format.
     */
    byChangeSet(changesetId) {
        Errors_1.ArgumentCheck.validChangeSetId("changesetId", changesetId);
        this.addFilter(`ChangeSetId+eq+'${changesetId}'`);
        return this;
    }
    /**
     * Query will additionally select ids of [[Thumbnail]]s for given [[ThumbnailSize]]s.
     * @returns This query.
     * @throws [[IModelHubClientError]] with [IModelHubStatus.UndefinedArgumentError]($bentley) or [IModelHubStatus.InvalidArgumentError]($bentley) if sizes array is undefined or empty.
     * @alpha
     */
    selectThumbnailId(...sizes) {
        Errors_1.ArgumentCheck.nonEmptyArray("sizes", sizes);
        if (!this._query.$select)
            this._query.$select = "*";
        for (const size of sizes) {
            this._query.$select += `,HasThumbnail-forward-${size}Thumbnail.*`;
        }
        return this;
    }
}
exports.VersionQuery = VersionQuery;
/**
 * Handler for managing [[Version]]s. Use [[IModelClient.Versions]] to get an instance of this class.
 * @beta
 */
class VersionHandler {
    /**
     * Constructor for VersionHandler.
     * @param handler Handler for WSG requests.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /** Get relative url for Version requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param versionId Id of the version.
     */
    getRelativeUrl(iModelId, versionId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/Version/${versionId || ""}`;
    }
    /** Get the named [[Version]]s of an iModel. Returned Versions are ordered from the latest [[ChangeSet]] to the oldest.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried Versions or select different data from them.
     * @returns Versions that match the query.
     * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[InstanceIdQuery.byId]] is used and a [[Version]] with the specified id could not be found.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, iModelId, query = new VersionQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying named versions for iModel", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        const versions = await this._handler.getInstances(requestContext, Version, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Queried named versions for iModel", () => ({ iModelId }));
        return versions;
    }
    /** Create a named [[Version]] of an iModel.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param changeSetId Id of the [[ChangeSet]] to create a named Version for.
     * @param name Name of the new named Version.
     * @param description Description of the new named Version.
     * @returns Created Version instance.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have ManageVersions permission.
     * @throws [[IModelHubError]] with [IModelHubStatus.ChangeSetDoesNotExist]($bentley) if the [[ChangeSet]] with specified changeSetId does not exist.
     * @throws [[IModelHubError]] with [IModelHubStatus.VersionAlreadyExists]($bentley) if a named [[Version]] already exists with the specified name.
     * @throws [[IModelHubError]] with [IModelHubStatus.ChangeSetAlreadyHasVersion]($bentley) if the [[ChangeSet]] with specified changeSetId already has a named [[Version]] associated with it.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, iModelId, changeSetId, name, description) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Creating named version for iModel", () => ({ iModelId, changeSetId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.validChangeSetId("changeSetId", changeSetId);
        Errors_1.ArgumentCheck.defined("name", name);
        let version = new Version();
        version.changeSetId = changeSetId;
        version.name = name;
        version.description = description;
        version = await this._handler.postInstance(requestContext, Version, this.getRelativeUrl(iModelId), version);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Created named version for iModel", () => ({ iModelId, changeSetId }));
        return version;
    }
    /** Update the named [[Version]] of an iModel. Only the description can be changed when updating the named Version.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param version Named version to update.
     * @returns Updated Version instance from iModelHub.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have ManageVersions permission.
     * @throws [[IModelHubError]] with [IModelHubStatus.VersionAlreadyExists]($bentley) if a named [[Version]] already exists with the specified name.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, iModelId, version) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Updating named version for iModel", () => ({ iModelId, changeSetId: version.changeSetId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.validGuid("version.wsgId", version.wsgId);
        const updatedVersion = await this._handler.postInstance(requestContext, Version, this.getRelativeUrl(iModelId, version.id), version);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Updated named version for iModel", () => ({ iModelId, changeSetId: version.changeSetId }));
        return updatedVersion;
    }
}
exports.VersionHandler = VersionHandler;


/***/ }),

/***/ "./lib/imodelhub/iModels.js":
/*!**********************************!*\
  !*** ./lib/imodelhub/iModels.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module iModelHub */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const ECJsonTypeMap_1 = __webpack_require__(/*! ./../ECJsonTypeMap */ "./lib/ECJsonTypeMap.js");
const Errors_1 = __webpack_require__(/*! ./Errors */ "./lib/imodelhub/Errors.js");
const Query_1 = __webpack_require__(/*! ./Query */ "./lib/imodelhub/Query.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.IModelHub;
const iModelTemplateEmpty = "Empty";
/**
 * HubIModel represents an iModel on iModelHub. Getting a valid HubIModel instance from iModelHub is required for majority of iModelHub method calls, as wsgId of this object needs to be passed as iModelId argument to those methods.
 *
 * For iModel representation in iModel.js, see [IModel]($common). For the file that is used for that iModel, see [IModelDb]($backend).
 * @beta
 */
let HubIModel = class HubIModel extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "instanceId")
], HubIModel.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Description")
], HubIModel.prototype, "description", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Name")
], HubIModel.prototype, "name", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserCreated")
], HubIModel.prototype, "userCreated", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.CreatedDate")
], HubIModel.prototype, "createdDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Initialized")
], HubIModel.prototype, "initialized", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.iModelTemplate")
], HubIModel.prototype, "iModelTemplate", void 0);
HubIModel = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "ContextScope.iModel", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], HubIModel);
exports.HubIModel = HubIModel;
/** Initialization state of seed file. Can be queried with [[IModelHandler.getInitializationState]]. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).
 * @beta
 */
var InitializationState;
(function (InitializationState) {
    /** Initialization was successful. */
    InitializationState[InitializationState["Successful"] = 0] = "Successful";
    /** Initialization has not started, seed file has not yet been uploaded. */
    InitializationState[InitializationState["NotStarted"] = 1] = "NotStarted";
    /** Initialization has been scheduled and has not completed yet. */
    InitializationState[InitializationState["Scheduled"] = 2] = "Scheduled";
    /** Initialization failed with a generic error. */
    InitializationState[InitializationState["Failed"] = 3] = "Failed";
    /** Initialization failed due to file having outdated schemas. */
    InitializationState[InitializationState["OutdatedFile"] = 4] = "OutdatedFile";
    /** Initialization failed due to file having [[Code]] values that are too long. */
    InitializationState[InitializationState["CodeTooLong"] = 5] = "CodeTooLong";
    /** Initialization failed due to file being a [[Briefcase]]. Only standalone and master files are supported for iModel creation, see [BriefcaseId]($backend). */
    InitializationState[InitializationState["SeedFileIsBriefcase"] = 6] = "SeedFileIsBriefcase";
})(InitializationState = exports.InitializationState || (exports.InitializationState = {}));
/** SeedFile
 * @internal
 */
let SeedFile = class SeedFile extends ECJsonTypeMap_1.WsgInstance {
};
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "instanceId")
], SeedFile.prototype, "id", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileName")
], SeedFile.prototype, "fileName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileDescription")
], SeedFile.prototype, "fileDescription", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileSize")
], SeedFile.prototype, "fileSize", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.FileId")
], SeedFile.prototype, "fileId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.Index")
], SeedFile.prototype, "index", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IModelName")
], SeedFile.prototype, "iModelName", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.MergedChangeSetId")
], SeedFile.prototype, "mergedChangeSetId", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UserUploaded")
], SeedFile.prototype, "userUploaded", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.UploadedDate")
], SeedFile.prototype, "uploadedDate", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.IsUploaded")
], SeedFile.prototype, "isUploaded", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "properties.InitializationState")
], SeedFile.prototype, "initializationState", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.DownloadUrl")
], SeedFile.prototype, "downloadUrl", void 0);
__decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.propertyToJson("wsg", "relationshipInstances[FileAccessKey].relatedInstance[AccessKey].properties.UploadUrl")
], SeedFile.prototype, "uploadUrl", void 0);
SeedFile = __decorate([
    ECJsonTypeMap_1.ECJsonTypeMap.classToJson("wsg", "iModelScope.SeedFile", { schemaPropertyName: "schemaName", classPropertyName: "className" })
], SeedFile);
exports.SeedFile = SeedFile;
/** Query object for getting SeedFiles. You can use this to modify the query. See [[SeedFileHandler.get]]. */
class SeedFileQuery extends Query_1.InstanceIdQuery {
    /**
     * Query will additionally select SeedFile file download URL.
     * @returns This query.
     */
    selectDownloadUrl() {
        Query_1.addSelectFileAccessKey(this._query);
        return this;
    }
    /**
     * Change the order to latest changesets first in the query.
     * @returns This query.
     */
    latest() {
        this._query.$orderby = "Index+desc";
        return this;
    }
}
/** Handler for all methods related to @see SeedFile instances. */
class SeedFileHandler {
    /** Constructor for SeedFileHandler. Should use @see IModelHandler instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
    }
    /** Get relative url for SeedFile requests.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param fileId Id of the Seed File.
     */
    getRelativeUrl(iModelId, fileId) {
        return `/Repositories/iModel--${iModelId}/iModelScope/SeedFile/${fileId || ""}`;
    }
    /** Get the seed files given the id of the iModel.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param query Optional query object to filter the queried SeedFiles or select different data from them.
     * @returns Resolves to the seed file.
     */
    async get(requestContext, iModelId, query = new SeedFileQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Started querying seed files", () => ({ iModelId }));
        const seedFiles = await this._handler.getInstances(requestContext, SeedFile, this.getRelativeUrl(iModelId, query.getId()), query.getQueryOptions());
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Finished querying seed files", () => ({ iModelId, count: seedFiles.length }));
        return seedFiles;
    }
    /** Upload the seed file. Use [[confirmUploadSeedFile]] to confirm the completion of the upload.
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param seedFile Information of the SeedFile to be uploaded.
     * @param seedPath Path of the SeedFile to be uploaded.
     * @param progressCallback Callback for tracking progress.
     */
    async uploadSeedFile(requestContext, iModelId, seedPath, seedFileDescription, progressCallback) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Started uploading seed file", () => ({ iModelId, seedPath }));
        const seedFile = new SeedFile();
        seedFile.fileName = this._fileHandler.basename(seedPath);
        seedFile.fileSize = this._fileHandler.getFileSize(seedPath).toString();
        if (seedFileDescription)
            seedFile.fileDescription = seedFileDescription;
        const createdSeedFile = await this._handler.postInstance(requestContext, SeedFile, this.getRelativeUrl(iModelId), seedFile);
        requestContext.enter();
        await this._fileHandler.uploadFile(requestContext, createdSeedFile.uploadUrl, seedPath, progressCallback);
        requestContext.enter();
        createdSeedFile.uploadUrl = undefined;
        createdSeedFile.downloadUrl = undefined;
        createdSeedFile.isUploaded = true;
        const confirmSeedFile = await this._handler.postInstance(requestContext, SeedFile, this.getRelativeUrl(iModelId, createdSeedFile.id), createdSeedFile);
        requestContext.enter();
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Finished uploading seed file", () => confirmSeedFile);
        return confirmSeedFile;
    }
}
/**
 * Query object for getting [[HubIModel]] instances. You can use this to modify the [[IModelsHandler.get]] results.
 * @beta
 */
class IModelQuery extends Query_1.InstanceIdQuery {
    /**
     * Query iModel by its name.
     * @param name Name of the iModel.
     * @returns This query.
     * @throws [IModelHubClientError]($clients) with [IModelHubStatus.UndefinedArgumentError]($bentley) if name is undefined or empty.
     */
    byName(name) {
        Errors_1.ArgumentCheck.defined("name", name);
        this.addFilter(`Name+eq+'${name}'`);
        return this;
    }
}
exports.IModelQuery = IModelQuery;
/**
 * Handler for managing [[HubIModel]] instances. Use [[IModelHubClient.IModels]] to get an instance of this handler.
 * @note Use [[IModelHubClient.IModel]] for the preferred single iModel per context workflow.
 * @beta
 */
class IModelsHandler {
    /** Constructor for IModelsHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for WSG requests.
     * @param fileHandler Handler for file system.
     * @note Use [[IModelHubClient.IModel]] for the preferred single iModel per context workflow.
     * @internal
     */
    constructor(handler, fileHandler) {
        this._handler = handler;
        this._fileHandler = fileHandler;
        this._seedFileHandler = new SeedFileHandler(this._handler, this._fileHandler);
    }
    /** Get relative url for iModel requests.
     * @param contextId Id of the context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     */
    getRelativeUrl(contextId, iModelId) {
        return `/Repositories/Context--${this._handler.formatContextIdForUrl(contextId)}/ContextScope/iModel/${iModelId || ""}`;
    }
    /** Get iModels that belong to the specified context.
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param query Optional query object to filter the queried iModels or select different data from them.
     * @returns [[HubIModel]] instances that match the query.
     * @throws [[WsgError]] with [WSStatus.InstanceNotFound]($bentley) if [[InstanceIdQuery.byId]] is used and an HubIModel with the specified id could not be found.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, contextId, query = new IModelQuery()) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Started querying iModels in context`, () => ({ contextId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.defined("contextId", contextId); // contextId is a GUID for iModelHub and a JSON representation of an IModelBankAccessContext for iModelBank.
        const imodels = await this._handler.getInstances(requestContext, HubIModel, this.getRelativeUrl(contextId, query.getId()), query.getQueryOptions());
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Finished querying iModels in context`, () => ({ contextId, count: imodels.length }));
        return imodels;
    }
    /**
     * Delete an iModel with specified id from a context. This method is not supported in iModelBank.
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param iModelId Id of the iModel to be deleted. See [[HubIModel]].
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel with specified id does not exist.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have DeleteiModel permission.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async delete(requestContext, contextId, iModelId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Started deleting iModel", () => ({ iModelId, contextId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("contextId", contextId);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        if (this._handler.getCustomRequestOptions().isSet) {
            // to add custom request options, request with body is needed.
            const imodel = new HubIModel();
            imodel.id = iModelId;
            imodel.changeState = "deleted";
            await this._handler.deleteInstance(requestContext, this.getRelativeUrl(contextId, iModelId), imodel);
        }
        else {
            await this._handler.delete(requestContext, this.getRelativeUrl(contextId, iModelId));
        }
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Finished deleting iModel", () => ({ iModelId, contextId }));
    }
    /** Create an iModel instance
     * @param requestContext The client request context.
     * @param contextId Id of the connect context.
     * @param iModelName Name of the iModel on the Hub.
     * @param description Description of the iModel on the Hub.
     * @param iModelTemplate iModel template.
     * @internal
     */
    async createIModelInstance(requestContext, contextId, iModelName, description, iModelTemplate) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, `Creating iModel with name ${iModelName}`, () => ({ contextId }));
        let imodel;
        const iModel = new HubIModel();
        iModel.name = iModelName;
        if (description)
            iModel.description = description;
        if (iModelTemplate)
            iModel.iModelTemplate = iModelTemplate;
        try {
            imodel = await this._handler.postInstance(requestContext, HubIModel, this.getRelativeUrl(contextId), iModel);
            requestContext.enter();
            bentleyjs_core_1.Logger.logTrace(loggerCategory, `Created iModel instance with name ${iModelName}`, () => ({ contextId }));
        }
        catch (err) {
            requestContext.enter();
            if (!(err instanceof Errors_1.IModelHubError) || bentleyjs_core_1.IModelHubStatus.iModelAlreadyExists !== err.errorNumber) {
                bentleyjs_core_1.Logger.logWarning(loggerCategory, `Can not create iModel: ${err.message}`, () => ({ contextId }));
                return Promise.reject(err);
            }
            const initialized = err.data.iModelInitialized;
            if (initialized) {
                bentleyjs_core_1.Logger.logWarning(loggerCategory, `Error creating iModel: iModel with name ${iModelName} already exists and is initialized`, () => ({ contextId }));
                return Promise.reject(err);
            }
            bentleyjs_core_1.Logger.logInfo(loggerCategory, `Querying iModel by name ${iModelName}`, () => ({ contextId }));
            const imodels = await this.get(requestContext, contextId, new IModelQuery().byName(iModelName));
            requestContext.enter();
            bentleyjs_core_1.Logger.logTrace(loggerCategory, `Queried iModel by name ${iModelName}`, () => ({ contextId }));
            if (imodels.length > 0) {
                imodel = imodels[0];
            }
            else {
                bentleyjs_core_1.Logger.logTrace(loggerCategory, `iModel by name: iModel ${iModelName} not found`, () => ({ contextId }));
                return Promise.reject(new Error(`iModel by name: iModel ${iModelName} not found`));
            }
        }
        return imodel;
    }
    /** Get the [[InitializationState]] for the specified iModel. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @returns State of the seed file initialization.
     * @throws [[IModelHubError]] with [IModelHubStatus.FileDoesNotExist]($bentley) if the seed file was not found.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async getInitializationState(requestContext, iModelId) {
        const seedFiles = await this._seedFileHandler.get(requestContext, iModelId, new SeedFileQuery().latest());
        requestContext.enter();
        if (seedFiles.length < 1)
            return Promise.reject(new Errors_1.IModelHubError(bentleyjs_core_1.IModelHubStatus.FileDoesNotExist));
        return seedFiles[0].initializationState;
    }
    /** Create an iModel from given seed file. In most cases [IModelDb.create]($backend) should be used instead. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).
     * This method does not work on browsers. If iModel creation fails before finishing file upload, partially created iModel is deleted. This method is not supported in iModelBank.
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param name Name of the iModel on the Hub.
     * @param path iModel seed file path. If not defined, iModel will be created from an empty file.
     * @param description Description of the iModel on the Hub.
     * @param progressCallback Callback for tracking progress.
     * @param timeOutInMiliseconds Time to wait for iModel initialization.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, contextId, name, path, description, progressCallback, timeOutInMilliseconds = 120000) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Creating iModel", () => ({ contextId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("contextId", contextId);
        Errors_1.ArgumentCheck.defined("name", name);
        const imodelFromTemplate = !path;
        if (typeof window !== "undefined")
            return Promise.reject(Errors_1.IModelHubClientError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubClientError.fileHandler());
        if (!!path && (!this._fileHandler.exists(path) || this._fileHandler.isDirectory(path)))
            return Promise.reject(Errors_1.IModelHubClientError.fileNotFound());
        const imodelTemplate = imodelFromTemplate ? iModelTemplateEmpty : undefined;
        const imodel = await this.createIModelInstance(requestContext, contextId, name, description, imodelTemplate);
        requestContext.enter();
        if (imodelFromTemplate) {
            return imodel;
        }
        try {
            await this._seedFileHandler.uploadSeedFile(requestContext, imodel.id, path, description, progressCallback);
        }
        catch (err) {
            await this.delete(requestContext, contextId, imodel.id);
            return Promise.reject(err);
        }
        requestContext.enter();
        const errorMessage = "Cannot upload SeedFile " + path;
        const retryDelay = timeOutInMilliseconds / 10;
        for (let retries = 10; retries > 0; --retries) {
            try {
                const initState = await this.getInitializationState(requestContext, imodel.id);
                requestContext.enter();
                if (initState === InitializationState.Successful) {
                    bentleyjs_core_1.Logger.logTrace(loggerCategory, "Created iModel", () => ({ contextId, iModelId: imodel.id }));
                    imodel.initialized = true;
                    return imodel;
                }
                if (initState !== InitializationState.NotStarted && initState !== InitializationState.Scheduled) {
                    bentleyjs_core_1.Logger.logWarning(loggerCategory, errorMessage);
                    return Promise.reject(new Errors_1.IModelHubError(bentleyjs_core_1.IModelHubStatus.SeedFileInitializationFailed, `Seed file initialization failed with status ${InitializationState[initState]}`));
                }
                await new Promise((resolve) => setTimeout(resolve, retryDelay));
                requestContext.enter();
            }
            catch (err) {
                requestContext.enter();
                bentleyjs_core_1.Logger.logWarning(loggerCategory, errorMessage);
                return Promise.reject(err);
            }
        }
        bentleyjs_core_1.Logger.logWarning(loggerCategory, errorMessage);
        return Promise.reject(Errors_1.IModelHubClientError.initializationTimeout());
    }
    /** Update iModel's name and/or description
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param imodel iModel to update. See [[HubIModel]].
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelIsNotInitialized]$(bentley) if iModel is not initialized.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelAlreadyExists]$(bentley) if iModel with specified name already exists.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, contextId, imodel) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Updating iModel", () => ({ contextId, iModelId: imodel.id }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("contextId", contextId);
        const updatedIModel = await this._handler.postInstance(requestContext, HubIModel, this.getRelativeUrl(contextId, imodel.id), imodel);
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "Updated iModel", () => ({ contextId, iModelId: imodel.id }));
        return updatedIModel;
    }
    /** Method to download the seed file for iModel. This will download the original seed file, that was uploaded when creating iModel. To download a file that was updated with ChangeSets on iModelHub, see [[BriefcaseHandler.download]].
     * @param requestContext The client request context.
     * @param iModelId Id of the iModel. See [[HubIModel]].
     * @param path Path to download the seed file to, including file name.
     * @param progressCallback Callback for tracking progress.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async download(requestContext, iModelId, path, progressCallback) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Started downloading seed file", () => ({ iModelId }));
        Errors_1.ArgumentCheck.defined("requestContext", requestContext);
        Errors_1.ArgumentCheck.validGuid("iModelId", iModelId);
        Errors_1.ArgumentCheck.defined("path", path);
        if (typeof window !== "undefined")
            return Promise.reject(Errors_1.IModelHubClientError.browser());
        if (!this._fileHandler)
            return Promise.reject(Errors_1.IModelHubClientError.fileHandler());
        const seedFiles = await this._seedFileHandler.get(requestContext, iModelId, new SeedFileQuery().selectDownloadUrl().latest());
        requestContext.enter();
        if (!seedFiles || !seedFiles[0] || !seedFiles[0].downloadUrl)
            return Promise.reject(Errors_1.IModelHubError.fromId(bentleyjs_core_1.IModelHubStatus.FileDoesNotExist, "Failed to get seed file."));
        await this._fileHandler.downloadFile(requestContext, seedFiles[0].downloadUrl, path, parseInt(seedFiles[0].fileSize, 10), progressCallback);
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Finished downloading seed file", () => ({ iModelId }));
    }
}
exports.IModelsHandler = IModelsHandler;
/**
 * Handler for managing [[HubIModel]] instance. Use [[IModelHubClient.IModel]] to get an instance of this handler.
 * @note Use [[IModelHubClient.IModels]] if multiple iModels per context are supported.
 * @beta
 */
class IModelHandler {
    /**
     * Constructor for IModelHandler. Should use @see IModelClient instead of directly constructing this.
     * @param handler Handler for managing [[HubIModel]] instances.
     * @note Use [[IModelHubClient.IModels]] if multiple iModels per context are supported.
     * @internal
     */
    constructor(handler) {
        this._handler = handler;
    }
    /**
     * Get iModel that belong to the specified context.
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @returns [[HubIModel]] instances that match the query.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async get(requestContext, contextId) {
        requestContext.enter();
        bentleyjs_core_1.Logger.logInfo(loggerCategory, "Querying iModel", () => ({ contextId }));
        const query = new IModelQuery().orderBy("CreatedDate+asc").top(1);
        const imodels = await this._handler.get(requestContext, contextId, query);
        if (imodels.length < 1)
            return Promise.reject(new Errors_1.IModelHubError(bentleyjs_core_1.IModelHubStatus.iModelDoesNotExist));
        return imodels[0];
    }
    /**
     * Delete an iModel from a context. This method is not supported in iModelBank.
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have DeleteiModel permission.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async delete(requestContext, contextId) {
        const imodel = await this.get(requestContext, contextId);
        await this._handler.delete(requestContext, contextId, imodel.id);
    }
    /**
     * Get the [[InitializationState]] for the specified iModel. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @returns State of the seed file initialization.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.
     * @throws [[IModelHubError]] with [IModelHubStatus.FileDoesNotExist]($bentley) if the seed file was not found.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async getInitializationState(requestContext, contextId) {
        const imodel = await this.get(requestContext, contextId);
        return this._handler.getInitializationState(requestContext, imodel.id);
    }
    /**
     * Create an iModel from given seed file. In most cases [IModelDb.create]($backend) should be used instead. See [iModel creation]($docs/learning/iModelHub/iModels/CreateiModel.md).
     *
     * This method does not work on browsers. If iModel creation fails before finishing file upload, partially created iModel is deleted. This method is not supported in iModelBank.
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param name Name of the iModel on the Hub.
     * @param path iModel seed file path. If not defined, iModel will be created from an empty file.
     * @param description Description of the iModel on the Hub.
     * @param progressCallback Callback for tracking progress.
     * @param timeOutInMiliseconds Time to wait for iModel initialization.
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async create(requestContext, contextId, name, path, description, progressCallback, timeOutInMilliseconds = 120000) {
        requestContext.enter();
        let imodelExists = true;
        try {
            await this.get(requestContext, contextId);
            requestContext.enter();
        }
        catch (err) {
            if (err instanceof Errors_1.IModelHubError && err.errorNumber === bentleyjs_core_1.IModelHubStatus.iModelDoesNotExist)
                imodelExists = false;
            else
                throw err;
        }
        if (imodelExists)
            return Promise.reject(new Errors_1.IModelHubError(bentleyjs_core_1.IModelHubStatus.iModelAlreadyExists));
        return this._handler.create(requestContext, contextId, name, path, description, progressCallback, timeOutInMilliseconds);
    }
    /**
     * Update iModel's name and/or description
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param imodel iModel to update. See [[HubIModel]].
     * @throws [[IModelHubError]] with [IModelHubStatus.UserDoesNotHavePermission]($bentley) if the user does not have CreateiModel permission.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelIsNotInitialized]$(bentley) if iModel is not initialized.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelAlreadyExists]$(bentley) if iModel with specified name already exists.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async update(requestContext, contextId, imodel) {
        return this._handler.update(requestContext, contextId, imodel);
    }
    /**
     * Method to download the seed file for iModel. This will download the original seed file, that was uploaded when creating iModel. To download a file that was updated with ChangeSets on iModelHub, see [[BriefcaseHandler.download]].
     * @param requestContext The client request context.
     * @param contextId Id for the iModel's context. For iModelHub it should be the id of the connect context ([[Project]] or [[Asset]]).
     * @param path Path where seed file should be downloaded, including filename.
     * @param progressCallback Callback for tracking progress.
     * @throws [[IModelHubError]] with [IModelHubStatus.iModelDoesNotExist]$(bentley) if iModel does not exist.
     * @throws [Common iModelHub errors]($docs/learning/iModelHub/CommonErrors)
     */
    async download(requestContext, contextId, path, progressCallback) {
        const imodel = await this.get(requestContext, contextId);
        await this._handler.download(requestContext, imodel.id, path, progressCallback);
    }
}
exports.IModelHandler = IModelHandler;


/***/ }),

/***/ "./lib/imodeljs-clients.js":
/*!*********************************!*\
  !*** ./lib/imodeljs-clients.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(/*! ./ECJsonTypeMap */ "./lib/ECJsonTypeMap.js"));
__export(__webpack_require__(/*! ./Client */ "./lib/Client.js"));
__export(__webpack_require__(/*! ./Config */ "./lib/Config.js"));
__export(__webpack_require__(/*! ./Token */ "./lib/Token.js"));
__export(__webpack_require__(/*! ./UserInfo */ "./lib/UserInfo.js"));
__export(__webpack_require__(/*! ./ConnectClients */ "./lib/ConnectClients.js"));
__export(__webpack_require__(/*! ./WsgClient */ "./lib/WsgClient.js"));
__export(__webpack_require__(/*! ./IModelClient */ "./lib/IModelClient.js"));
__export(__webpack_require__(/*! ./ImsClients */ "./lib/ImsClients.js"));
__export(__webpack_require__(/*! ./ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js"));
__export(__webpack_require__(/*! ./Config */ "./lib/Config.js"));
__export(__webpack_require__(/*! ./Request */ "./lib/Request.js"));
__export(__webpack_require__(/*! ./RealityDataServicesClient */ "./lib/RealityDataServicesClient.js"));
__export(__webpack_require__(/*! ./SettingsAdmin */ "./lib/SettingsAdmin.js"));
__export(__webpack_require__(/*! ./SettingsClient */ "./lib/SettingsClient.js"));
__export(__webpack_require__(/*! ./AuthorizedClientRequestContext */ "./lib/AuthorizedClientRequestContext.js"));
__export(__webpack_require__(/*! ./imodelbank/IModelBankClient */ "./lib/imodelbank/IModelBankClient.js"));
__export(__webpack_require__(/*! ./imodelbank/IModelBankHandler */ "./lib/imodelbank/IModelBankHandler.js"));
__export(__webpack_require__(/*! ./imodelbank/IModelBankFileSystemContextClient */ "./lib/imodelbank/IModelBankFileSystemContextClient.js"));
__export(__webpack_require__(/*! ./imodelhub/BaseHandler */ "./lib/imodelhub/BaseHandler.js"));
__export(__webpack_require__(/*! ./imodelhub/Client */ "./lib/imodelhub/Client.js"));
__export(__webpack_require__(/*! ./imodelhub/Query */ "./lib/imodelhub/Query.js"));
__export(__webpack_require__(/*! ./imodelhub/Errors */ "./lib/imodelhub/Errors.js"));
__export(__webpack_require__(/*! ./imodelhub/Briefcases */ "./lib/imodelhub/Briefcases.js"));
__export(__webpack_require__(/*! ./imodelhub/ChangeSets */ "./lib/imodelhub/ChangeSets.js"));
__export(__webpack_require__(/*! ./imodelhub/Checkpoints */ "./lib/imodelhub/Checkpoints.js"));
__export(__webpack_require__(/*! ./imodelhub/Codes */ "./lib/imodelhub/Codes.js"));
__export(__webpack_require__(/*! ./imodelhub/Events */ "./lib/imodelhub/Events.js"));
__export(__webpack_require__(/*! ./imodelhub/GlobalEvents */ "./lib/imodelhub/GlobalEvents.js"));
__export(__webpack_require__(/*! ./imodelhub/iModels */ "./lib/imodelhub/iModels.js"));
__export(__webpack_require__(/*! ./imodelhub/Locks */ "./lib/imodelhub/Locks.js"));
__export(__webpack_require__(/*! ./imodelhub/Users */ "./lib/imodelhub/Users.js"));
__export(__webpack_require__(/*! ./imodelhub/Versions */ "./lib/imodelhub/Versions.js"));
__export(__webpack_require__(/*! ./imodelhub/Thumbnails */ "./lib/imodelhub/Thumbnails.js"));
__export(__webpack_require__(/*! ./oidc/OidcClient */ "./lib/oidc/OidcClient.js"));
__export(__webpack_require__(/*! ./ulas/LogEntryConverter */ "./lib/ulas/LogEntryConverter.js"));
__export(__webpack_require__(/*! ./ulas/UlasClient */ "./lib/ulas/UlasClient.js"));
if (( true) && (typeof window !== "undefined") && window) {
    if (!window.iModelJsVersions)
        window.iModelJsVersions = new Map();
    window.iModelJsVersions.set("imodeljs-clients", "1.0.0");
}
/** @docs-package-description
 * The imodeljs-clients package allows sending requests to various CONNECT services.
 *
 * It works both on [backend]($docs/learning/backend/index.md) and [frontend]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description Authentication
 * Classes for managing [AccessToken]($clients) used for all requests in other classes.
 */
/**
 * @docs-group-description BaseClients
 * Base classes for creating service clients.
 */
/**
 * @docs-group-description ConnectServices
 * Classes for communicating with various CONNECT services.
 */
/**
 * @docs-group-description iModelHub
 * Classes for communicating directly with [iModelHub]($docs/learning/iModelHub/index.md).
 */
/**
 * @docs-group-description iModelHubEvents
 * Classes for receiving [IModelHubEvent]($clients)s. See [working with events]($docs/learning/iModelHub/Events).
 */
/**
 * @docs-group-description iModelHubGlobalEvents
 * Classes for receiving [IModelHubGlobalEvent]($clients)s. See [working with global events]($docs/learning/iModelHub/GlobalEvents). **Currently only available to internal Bentley products.**
 */
/**
 * @docs-group-description iModels
 * Classes for abstracting access to [iModelHub]($docs/learning/iModelHub/index.md). See [iModelBank]($docs/reference/imodeljs-clients/imodelbank).
 */
/**
 * @docs-group-description Settings
 * Classes for saving and retrieving application-, project-, and iModel- specific [Settings]($docs/learning/frontend/Settings.md)
 */
/**
 * @docs-group-description OtherServices
 * Classes for communicating with various other services.
 */
/**
 * @docs-group-description Utils
 * Utilities for implementing clients.
 */


/***/ }),

/***/ "./lib/oidc/OidcClient.js":
/*!********************************!*\
  !*** ./lib/oidc/OidcClient.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const Client_1 = __webpack_require__(/*! ../Client */ "./lib/Client.js");
/** @beta */
class OidcClient extends Client_1.Client {
    constructor() {
        super();
    }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() {
        return OidcClient.searchKey;
    }
}
OidcClient.searchKey = "IMSOpenID";
exports.OidcClient = OidcClient;


/***/ }),

/***/ "./lib/ulas/LogEntryConverter.js":
/*!***************************************!*\
  !*** ./lib/ulas/LogEntryConverter.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const UlasClient_1 = __webpack_require__(/*! ./UlasClient */ "./lib/ulas/UlasClient.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.UlasClient;
/** @internal */
class LogEntryConverter {
    /**
     * Extracts the application version from the supplied request context
     * @param requestContext The client request context
     * @returns The application version for the request context
     */
    static getApplicationVersion(requestContext) {
        const applicationVersion = requestContext.applicationVersion;
        const defaultVersion = { major: 1, minor: 0 };
        if (!applicationVersion) {
            bentleyjs_core_1.Logger.logWarning(loggerCategory, "ApplicationVersion was not specified. Set up IModelApp.applicationVersion for frontend applications, or IModelHost.applicationVersion for agents", () => ({ applicationVersion }));
            return defaultVersion;
        }
        const versionSplit = applicationVersion.split(".");
        const length = versionSplit.length;
        if (length < 2) {
            bentleyjs_core_1.Logger.logWarning(loggerCategory, "ApplicationVersion is not valid", () => ({ applicationVersion }));
            return defaultVersion;
        }
        const major = parseInt(versionSplit[0], 10);
        if (typeof major === "undefined") {
            bentleyjs_core_1.Logger.logWarning(loggerCategory, "ApplicationVersion is not valid", () => ({ applicationVersion }));
            return defaultVersion;
        }
        const minor = parseInt(versionSplit[1], 10);
        if (typeof minor === "undefined") {
            bentleyjs_core_1.Logger.logWarning(loggerCategory, "ApplicationVersion is not valid", () => ({ applicationVersion }));
            return { major, minor: 0 };
        }
        let sub1;
        let sub2;
        if (length > 2) {
            sub1 = parseInt(versionSplit[2], 10) || undefined;
            if (length > 3 && sub1) {
                sub2 = parseInt(versionSplit[3], 10) || undefined;
            }
        }
        return { major, minor, sub1, sub2 };
    }
    /**
     * Extracts the application id from the supplied request context
     * @param requestContext The client request context
     * @returns The application id for the request context
     */
    static getApplicationId(requestContext) {
        const defaultId = 2686; // iModel.js
        if (!requestContext.applicationId) {
            bentleyjs_core_1.Logger.logWarning(loggerCategory, "ApplicationId was not specified. Set up IModelApp.applicationId for frontend applications, or IModelHost.applicationId for agents");
            return defaultId;
        }
        return parseInt(requestContext.applicationId, 10) || defaultId;
    }
    /**
     * Extracts the session id from the supplied request context
     * @param requestContext The client request context
     * @returns The session id for the request context
     */
    static getSessionId(requestContext) {
        if (!bentleyjs_core_1.Guid.isGuid(requestContext.sessionId)) {
            bentleyjs_core_1.Logger.logWarning(loggerCategory, "Specified sessionId is not a valid Guid. Set up IModelApp.sessionId for frontend applications, or IModelHost.sessionId for agents");
            return bentleyjs_core_1.Guid.empty;
        }
        return requestContext.sessionId;
    }
    static toUsageLogJson(requestContext, entry) {
        const productId = LogEntryConverter.getApplicationId(requestContext);
        const productVersion = LogEntryConverter.getApplicationVersion(requestContext);
        const sessionId = LogEntryConverter.getSessionId(requestContext);
        const hID = LogEntryConverter.prepareMachineName(entry.hostName);
        const ver = LogEntryConverter.toVersionNumber(productVersion);
        const uType = LogEntryConverter.usageTypeToString(entry.usageType);
        return {
            hID,
            polID: LogEntryConverter._policyFileId,
            secID: LogEntryConverter._securableId,
            prdid: productId,
            fstr: LogEntryConverter._featureString,
            ver,
            projID: entry.contextId,
            corID: sessionId,
            lVer: LogEntryConverter._logEntryVersion,
            lSrc: LogEntryConverter._logPostingSource,
            uType,
        };
    }
    static toFeatureLogJson(requestContext, entries) {
        const json = [];
        const productId = LogEntryConverter.getApplicationId(requestContext);
        const productVersion = LogEntryConverter.getApplicationVersion(requestContext);
        const sessionId = LogEntryConverter.getSessionId(requestContext);
        const ver = LogEntryConverter.toVersionNumber(productVersion);
        for (const entry of entries) {
            const hID = LogEntryConverter.prepareMachineName(entry.hostName);
            const evTimeZ = entry.timestamp;
            let sDateZ;
            let eDateZ;
            let corID;
            const startEntry = entry;
            const endEntry = entry;
            const defaultDate = "0001-01-01T00:00:00Z";
            if (!!startEntry.entryId) {
                sDateZ = evTimeZ;
                eDateZ = defaultDate;
                corID = startEntry.entryId;
            }
            else if (!!endEntry.startEntryId) {
                sDateZ = defaultDate;
                eDateZ = evTimeZ;
                corID = endEntry.startEntryId;
            }
            else {
                sDateZ = evTimeZ;
                eDateZ = evTimeZ;
                corID = sessionId;
            }
            const uType = LogEntryConverter.usageTypeToString(entry.usageType);
            const uData = [];
            for (const att of entry.usageData) {
                uData.push({ name: att.name, value: att.value.toString() });
            }
            const entryJson = {
                hID,
                polID: LogEntryConverter._policyFileId,
                secID: LogEntryConverter._securableId,
                prdid: productId,
                fstr: LogEntryConverter._featureString,
                ver,
                projID: entry.contextId,
                corID,
                lVer: LogEntryConverter._logEntryVersion,
                lSrc: LogEntryConverter._logPostingSource,
                uType,
                ftrID: entry.featureId,
                sDateZ,
                eDateZ,
                uData,
            };
            json.push(entryJson);
        }
        return json;
    }
    static toVersionNumber(version) {
        // version must be encoded into a single number where each version digit is padded out to 4 digits
        // and the version is always considered to have 4 digits.
        // Ex: 3.99.4 -> 3.99.4.0 -> 3009900040000
        let verNumber = !!version.sub2 ? version.sub2 : 0;
        verNumber += 10000 * (!!version.sub1 ? version.sub1 : 0);
        verNumber += Math.pow(10000, 2) * version.minor;
        verNumber += Math.pow(10000, 3) * version.major;
        return verNumber;
    }
    static prepareMachineName(machineName) {
        if (!machineName || machineName.length === 0)
            return "";
        if (machineName === "::1" || machineName === "127.0.0.1")
            return "localhost";
        return machineName.toLowerCase();
    }
    /* private static prepareUserName(userName: string, machineName: string): string {
      if (!userName || userName.length === 0)
        return "";
  
      let preparedUserName: string = userName;
  
      const backslashPos: number = userName.indexOf("\\");
      if (backslashPos >= 0)
        preparedUserName = userName.substr(backslashPos + 1);
      else {
        const slashPos: number = userName.indexOf("/");
        if (slashPos >= 0)
          preparedUserName = userName.substr(slashPos + 1);
      }
  
      preparedUserName = preparedUserName.toLowerCase();
      if (!!machineName && machineName.length > 0 && (preparedUserName.includes("administrator") || preparedUserName.includes("system")))
        preparedUserName = `${machineName.toLowerCase()}\\${preparedUserName}`;
  
      return preparedUserName;
    } */
    static usageTypeToString(val) {
        switch (val) {
            case UlasClient_1.UsageType.Beta:
                return "Beta";
            case UlasClient_1.UsageType.HomeUse:
                return "HomeUse";
            case UlasClient_1.UsageType.PreActivation:
                return "PreActivation";
            case UlasClient_1.UsageType.Production:
                return "Production";
            case UlasClient_1.UsageType.Trial:
                return "Trial";
            default:
                throw new Error("Unhandled UsageType enum value");
        }
    }
}
// for now this is always 1
LogEntryConverter._logEntryVersion = 1;
// this is a real-time client, i.e. it sends the requests right away without caching or aggregating.
LogEntryConverter._logPostingSource = "RealTime";
// fStr argument is empty for now
LogEntryConverter._featureString = "";
LogEntryConverter._policyFileId = bentleyjs_core_1.Guid.createValue();
LogEntryConverter._securableId = bentleyjs_core_1.Guid.createValue();
exports.LogEntryConverter = LogEntryConverter;


/***/ }),

/***/ "./lib/ulas/UlasClient.js":
/*!********************************!*\
  !*** ./lib/ulas/UlasClient.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Client_1 = __webpack_require__(/*! ../Client */ "./lib/Client.js");
const Config_1 = __webpack_require__(/*! ../Config */ "./lib/Config.js");
const ImsClients_1 = __webpack_require__(/*! ../ImsClients */ "./lib/ImsClients.js");
const ClientsLoggerCategory_1 = __webpack_require__(/*! ../ClientsLoggerCategory */ "./lib/ClientsLoggerCategory.js");
const Request_1 = __webpack_require__(/*! ../Request */ "./lib/Request.js");
const Token_1 = __webpack_require__(/*! ../Token */ "./lib/Token.js");
const LogEntryConverter_1 = __webpack_require__(/*! ./LogEntryConverter */ "./lib/ulas/LogEntryConverter.js");
const loggerCategory = ClientsLoggerCategory_1.ClientsLoggerCategory.UlasClient;
/** Represents one of the potential usage types.
 * See also
 *  - [[UsageLogEntry]], [[FeatureLogEntry]]
 *  - *UsageType* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)
 *  site (section *Models*)
 * @internal
 */
var UsageType;
(function (UsageType) {
    UsageType[UsageType["Production"] = 0] = "Production";
    UsageType[UsageType["Trial"] = 1] = "Trial";
    UsageType[UsageType["Beta"] = 2] = "Beta";
    UsageType[UsageType["HomeUse"] = 3] = "HomeUse";
    UsageType[UsageType["PreActivation"] = 4] = "PreActivation";
})(UsageType = exports.UsageType || (exports.UsageType = {}));
/**
 * Usage log entry data that is submitted to the ULAS Posting Service.
 * See also
 *  - [[UlasClient]]
 *  - *UsageLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)
 *  site (section *Models*)
 * @internal
 */
class UsageLogEntry {
    /** Creates a new UsageLogEntry object.
     *  This also sets the timestamp against which the usage will be logged.
     *  @param hostName Name of the client machine from which usage is logged.
     *  @param usageType Usage type (see [[UsageType]])
     *  @param contextId The GUID of the context that the usage should be associated with.
     */
    constructor(hostName, usageType, contextId) {
        this.hostName = hostName;
        this.usageType = usageType;
        this.contextId = contextId;
        this.timestamp = new Date().toISOString();
    }
}
exports.UsageLogEntry = UsageLogEntry;
/**
 * Feature log entry data that is submitted to the ULAS Posting Service.
 * See also
 *  - [[UlasClient]]
 *  - *FeatureLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)
 *  site (section *Models*)
 * @internal
 */
class FeatureLogEntry {
    /** Creates a new FeatureLogEntry object.
     *  This also sets the timestamp against which the feature will be logged.
     *  @param featureId Feature ID from the Global Feature Registry which is being logged.
     *  @param hostName Name of the client machine from which the feature is being logged.
     *  @param usageType Usage type (see [[UsageType]])
     *  @param contextId The GUID of the context that the usage should be associated with.
     */
    constructor(featureId, hostName, usageType, contextId) {
        this.featureId = featureId;
        this.hostName = hostName;
        this.usageType = usageType;
        this.contextId = contextId;
        this.usageData = [];
        this.timestamp = new Date().toISOString();
    }
}
exports.FeatureLogEntry = FeatureLogEntry;
/**
 * Start point of a duration Feature log entry that is submitted to the ULAS Posting Service.
 * See also
 *  - [[UlasClient]]
 *  - [[FeatureLogEntry]]
 *  - *FeatureLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)
 *  site (section *Models*)
 * @internal
 */
class FeatureStartedLogEntry extends FeatureLogEntry {
    /** Creates a new FeatureStartedLogEntry object.
     *  @param featureId Feature ID from the Global Feature Registry which is being logged.
     *  @param hostName Name of the client machine from which the feature is being logged.
     *  @param usageType Usage type (see [[UsageType]])
     *  @param contextId The GUID of the context that the usage should be associated with.
     */
    constructor(featureId, hostName, usageType, contextId) {
        super(featureId, hostName, usageType, contextId);
        this.entryId = bentleyjs_core_1.Guid.createValue();
    }
}
exports.FeatureStartedLogEntry = FeatureStartedLogEntry;
/**
 * End point of a duration Feature log entry that is submitted to the ULAS Posting Service.
 * See also
 *  - [[UlasClient]]
 *  - [[FeatureStartedLogEntry]]
 *  - *FeatureLogEntry* entry on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)
 *  site (section *Models*)
 * @internal
 */
class FeatureEndedLogEntry extends FeatureLogEntry {
    /** Creates a new FeatureEndedLogEntry object.
     *  @param featureId Feature ID from the Global Feature Registry which is being logged.
     *  @param startEntryId ID of the corresponding [[FeatureStartedLogEntry]]
     *  @param hostName Name of the client machine from which the feature is being logged.
     *  @param usageType Usage type (see [[UsageType]])
     *  @param contextId The GUID of the context that the usage should be associated with.
     */
    constructor(featureId, startEntryId, hostName, usageType, contextId) {
        super(featureId, hostName, usageType, contextId);
        this.startEntryId = startEntryId;
    }
    /** Creates a new FeatureEndedLogEntry from the specified FeatureStartedLogEntry.
     *  @param startEntry Corresponding [[FeatureStartedLogEntry]]
     *  @return Corresponding FeatureEndedLogEntry.
     */
    static fromStartEntry(startEntry) {
        const endEntry = new FeatureEndedLogEntry(startEntry.featureId, startEntry.entryId, startEntry.hostName, startEntry.usageType, startEntry.contextId);
        endEntry.usageData = startEntry.usageData;
        return endEntry;
    }
}
exports.FeatureEndedLogEntry = FeatureEndedLogEntry;
/**
 * Client for the Bentley Usage Logging & Analysis Services (ULAS).
 * See also the two `POST` requests on [ULAS Swagger](https://qa-connect-ulastm.bentley.com/Bentley.ULAS.SwaggerUI/SwaggerWebApp/?urls.primaryName=ULAS%20Posting%20Service%20v1)
 * @internal
 */
class UlasClient extends Client_1.Client {
    /** Creates an instance of UlasClient. */
    constructor() { super(); }
    /**
     * Gets name/key to query the service URLs from the URL Discovery Service ("Buddi")
     * @returns Search key for the URL.
     */
    getUrlSearchKey() { return UlasClient._buddiSearchKey; }
    async setupOptionDefaults(options) {
        await super.setupOptionDefaults(options);
        options.useCorsProxy = true;
    }
    /**
     * Gets theRelyingPartyUrl for the service.
     * @returns RelyingPartyUrl for the service.
     */
    getRelyingPartyUrl() {
        if (Config_1.Config.App.has(UlasClient._configRelyingPartyUri))
            return Config_1.Config.App.get(UlasClient._configRelyingPartyUri) + "/";
        else
            return Config_1.Config.App.get(UlasClient._configDefaultRelyingPartyUri) + "/";
    }
    /**
     * Gets the (delegation) access token to access the service
     * @param requestContext The client request context.
     * @param authTokenInfo Access token.
     * @returns Resolves to the (delegation) access token.
     * @internal
     */
    async getAccessToken(requestContext, authorizationToken) {
        const imsClient = new ImsClients_1.ImsDelegationSecureTokenClient();
        return imsClient.getToken(requestContext, authorizationToken, this.getRelyingPartyUrl());
    }
    /**
     * Logs usage via the ULAS service
     * @param requestContext The client request context.
     * @param hostName The client host name.
     * @param usageType The client usage type
     * @returns Response from the service.
     */
    async logUsage(requestContext, entry) {
        requestContext.enter();
        const entryJson = LogEntryConverter_1.LogEntryConverter.toUsageLogJson(requestContext, entry);
        return this.logEntry(requestContext, entryJson, false);
    }
    /**
     * Logs one ore more feature entries via the ULAS service
     * @param requestContext The client request context.
     * @param entries One or more feature log entries.
     * @returns Response from the service.
     */
    async logFeature(requestContext, ...entries) {
        requestContext.enter();
        if (entries.length === 0)
            throw new Error("At least one FeatureLogEntry must be passed to UlasClient.logFeatures.");
        const entriesJson = LogEntryConverter_1.LogEntryConverter.toFeatureLogJson(requestContext, entries);
        return this.logEntry(requestContext, entriesJson, true);
    }
    async logEntry(requestContext, entryJson, isFeatureEntry) {
        requestContext.enter();
        let postUrl = (await this.getUrl(requestContext));
        requestContext.enter();
        if (isFeatureEntry)
            postUrl += "/featureLog";
        const token = requestContext.accessToken;
        const authString = !token.getSamlAssertion() ? token.toTokenString() : "SAML " + token.toTokenString(Token_1.IncludePrefix.No);
        const options = {
            method: "POST",
            headers: { authorization: authString },
            body: entryJson,
        };
        await this.setupOptionDefaults(options);
        requestContext.enter();
        if (bentleyjs_core_1.Logger.isEnabled(loggerCategory, bentleyjs_core_1.LogLevel.Trace))
            bentleyjs_core_1.Logger.logTrace(loggerCategory, `Sending ${isFeatureEntry ? "Feature" : "Usage"} Log REST request...`, () => ({ url: postUrl, body: entryJson }));
        const resp = await Request_1.request(requestContext, postUrl, options);
        requestContext.enter();
        const requestDetails = { url: postUrl, body: entryJson, response: resp };
        if (bentleyjs_core_1.Logger.isEnabled(loggerCategory, bentleyjs_core_1.LogLevel.Trace))
            bentleyjs_core_1.Logger.logTrace(loggerCategory, `Sent ${isFeatureEntry ? "Feature" : "Usage"} Log REST request.`, () => requestDetails);
        const respBody = resp.body;
        if (!respBody || !respBody.status || respBody.status.toLowerCase() !== "success")
            throw new Error(`Post ${isFeatureEntry ? "Feature" : "Usage"} Log REST request failed ${!!respBody.msg ? ": " + respBody.msg : ""}. Details: ${JSON.stringify(requestDetails)}`);
        return { status: bentleyjs_core_1.BentleyStatus.SUCCESS, message: !!respBody.msg ? respBody.msg : "", time: !!respBody.time ? respBody.time : -1, requestId: respBody.reqID };
    }
}
UlasClient._buddiSearchKey = "UsageLoggingServices.RealtimeLogging.Url";
UlasClient._configRelyingPartyUri = "imjs_ulas_relying_party_uri";
UlasClient._configDefaultRelyingPartyUri = "imjs_default_relying_party_uri";
exports.UlasClient = UlasClient;


/***/ }),

/***/ 0:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ 1:
/*!**********************!*\
  !*** util (ignored) ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ }),

/***/ "@bentley/bentleyjs-core":
/*!*********************************!*\
  !*** external "bentleyjs_core" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;

/***/ }),

/***/ "@bentley/geometry-core":
/*!********************************!*\
  !*** external "geometry_core" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__;

/***/ })

},[["./lib/imodeljs-clients.js","runtime"]]]);
});
//# sourceMappingURL=imodeljs-clients.js.map