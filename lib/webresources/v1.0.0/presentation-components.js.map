{"version":3,"file":"presentation-components.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_b\\5\\s\\presentation\\components\\lib\\propertygrid\\WithUnifiedSelection.scss","file:///D:\\vsts_b\\5\\s\\presentation\\components\\lib\\tree\\WithFilteringSupport.scss","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\css-loader\\2.1.1\\webpack@4.32.2\\node_modules\\css-loader\\dist\\runtime\\api.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\style-loader\\0.21.0\\node_modules\\style-loader\\lib\\addStyles.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\style-loader\\0.21.0\\node_modules\\style-loader\\lib\\urls.js","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\selection\\SelectionChangeEvent.ts","file:///D:\\vsts_b\\5\\s\\presentation\\frontend\\src\\selection\\SelectionManager.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\DataProvidersFactory.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\common\\ContentBuilder.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\common\\ContentDataProvider.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\common\\PageContainer.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\common\\StyleHelper.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\common\\Utils.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\labels\\LabelsProvider.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\presentation-components.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\propertygrid\\DataProvider.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\propertygrid\\WithUnifiedSelection.tsx","webpack://presentation_components/./lib/propertygrid/WithUnifiedSelection.scss?9431","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\table\\DataProvider.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\table\\WithUnifiedSelection.tsx","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\tree\\DataProvider.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\tree\\FilteredDataProvider.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\tree\\Utils.ts","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\tree\\WithFilteringSupport.tsx","webpack://presentation_components/./lib/tree/WithFilteringSupport.scss?08b4","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\tree\\WithUnifiedSelection.tsx","file:///D:\\vsts_b\\5\\s\\presentation\\components\\src\\viewport\\WithUnifiedSelection.tsx","file:///external \"bentleyjs_core\"","file:///external \"imodeljs_frontend\"","file:///external \"presentation_common\"","file:///external \"presentation_frontend\"","file:///external \"ui_components\"","file:///external \"ui_core\"","file:///external {\"root\":\"_\",\"commonjs2\":\"lodash\",\"commonjs\":\"lodash\",\"amd\":\"lodash\"}","file:///external {\"root\":\"React\",\"commonjs2\":\"react\",\"commonjs\":\"react\",\"amd\":\"react\"}"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bentleyjs_core\"), require(\"imodeljs_frontend\"), require(\"presentation_common\"), require(\"presentation_frontend\"), require(\"ui_components\"), require(\"ui_core\"), require(\"lodash\"), require(\"react\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"presentation_components\", [\"bentleyjs_core\", \"imodeljs_frontend\", \"presentation_common\", \"presentation_frontend\", \"ui_components\", \"ui_core\", \"lodash\", \"react\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"presentation_components\"] = factory(require(\"bentleyjs_core\"), require(\"imodeljs_frontend\"), require(\"presentation_common\"), require(\"presentation_frontend\"), require(\"ui_components\"), require(\"ui_core\"), require(\"lodash\"), require(\"react\"));\n\telse\n\t\troot[\"presentation_components\"] = factory(root[\"bentleyjs_core\"], root[\"imodeljs_frontend\"], root[\"presentation_common\"], root[\"presentation_frontend\"], root[\"ui_components\"], root[\"ui_core\"], root[\"_\"], root[\"React\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_frontend__, __WEBPACK_EXTERNAL_MODULE__bentley_presentation_common__, __WEBPACK_EXTERNAL_MODULE__bentley_presentation_frontend__, __WEBPACK_EXTERNAL_MODULE__bentley_ui_components__, __WEBPACK_EXTERNAL_MODULE__bentley_ui_core__, __WEBPACK_EXTERNAL_MODULE_lodash__, __WEBPACK_EXTERNAL_MODULE_react__) {\nreturn ","exports = module.exports = require(\"../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.id, \"/*---------------------------------------------------------------------------------------------\\r\\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\\r\\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\\r\\n*--------------------------------------------------------------------------------------------*/\\n.pcomponents-property-grid-with-unified-selection {\\n  position: relative;\\n  height: 100%; }\\n  .pcomponents-property-grid-with-unified-selection > span {\\n    position: relative;\\n    display: block;\\n    text-align: center;\\n    position: relative;\\n    top: 50%;\\n    -webkit-transform: translateY(-50%);\\n        -ms-transform: translateY(-50%);\\n            transform: translateY(-50%); }\\n\", \"\"]);\n\n","exports = module.exports = require(\"../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/runtime/api.js\")(false);\n// Module\nexports.push([module.id, \"/*---------------------------------------------------------------------------------------------\\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\\n*--------------------------------------------------------------------------------------------*/\\n.filteredTree {\\n  position: relative;\\n  width: 100%;\\n  height: 100%; }\\n  .filteredTree .filteredTreeOverlay {\\n    position: absolute;\\n    top: 0;\\n    left: 0;\\n    width: 100%;\\n    height: 100%;\\n    z-index: 9999;\\n    background-color: rgba(255, 255, 255, 0.8); }\\n\", \"\"]);\n\n","\"use strict\";\n\n/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/\n// css base code, injected by the css-loader\nmodule.exports = function (useSourceMap) {\n  var list = []; // return the list of modules as css string\n\n  list.toString = function toString() {\n    return this.map(function (item) {\n      var content = cssWithMappingToString(item, useSourceMap);\n\n      if (item[2]) {\n        return '@media ' + item[2] + '{' + content + '}';\n      } else {\n        return content;\n      }\n    }).join('');\n  }; // import a list of modules into the list\n\n\n  list.i = function (modules, mediaQuery) {\n    if (typeof modules === 'string') {\n      modules = [[null, modules, '']];\n    }\n\n    var alreadyImportedModules = {};\n\n    for (var i = 0; i < this.length; i++) {\n      var id = this[i][0];\n\n      if (id != null) {\n        alreadyImportedModules[id] = true;\n      }\n    }\n\n    for (i = 0; i < modules.length; i++) {\n      var item = modules[i]; // skip already imported module\n      // this implementation is not 100% perfect for weird media query combinations\n      // when a module is imported multiple times with different media queries.\n      // I hope this will never occur (Hey this way we have smaller bundles)\n\n      if (item[0] == null || !alreadyImportedModules[item[0]]) {\n        if (mediaQuery && !item[2]) {\n          item[2] = mediaQuery;\n        } else if (mediaQuery) {\n          item[2] = '(' + item[2] + ') and (' + mediaQuery + ')';\n        }\n\n        list.push(item);\n      }\n    }\n  };\n\n  return list;\n};\n\nfunction cssWithMappingToString(item, useSourceMap) {\n  var content = item[1] || '';\n  var cssMapping = item[3];\n\n  if (!cssMapping) {\n    return content;\n  }\n\n  if (useSourceMap && typeof btoa === 'function') {\n    var sourceMapping = toComment(cssMapping);\n    var sourceURLs = cssMapping.sources.map(function (source) {\n      return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';\n    });\n    return [content].concat(sourceURLs).concat([sourceMapping]).join('\\n');\n  }\n\n  return [content].join('\\n');\n} // Adapted from convert-source-map (MIT)\n\n\nfunction toComment(sourceMap) {\n  // eslint-disable-next-line no-undef\n  var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n  var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;\n  return '/*# ' + data + ' */';\n}","/*\n\tMIT License http://www.opensource.org/licenses/mit-license.php\n\tAuthor Tobias Koppers @sokra\n*/\n\nvar stylesInDom = {};\n\nvar\tmemoize = function (fn) {\n\tvar memo;\n\n\treturn function () {\n\t\tif (typeof memo === \"undefined\") memo = fn.apply(this, arguments);\n\t\treturn memo;\n\t};\n};\n\nvar isOldIE = memoize(function () {\n\t// Test for IE <= 9 as proposed by Browserhacks\n\t// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n\t// Tests for existence of standard globals is to allow style-loader\n\t// to operate correctly into non-standard environments\n\t// @see https://github.com/webpack-contrib/style-loader/issues/177\n\treturn window && document && document.all && !window.atob;\n});\n\nvar getTarget = function (target) {\n  return document.querySelector(target);\n};\n\nvar getElement = (function (fn) {\n\tvar memo = {};\n\n\treturn function(target) {\n                // If passing function in options, then use it for resolve \"head\" element.\n                // Useful for Shadow Root style i.e\n                // {\n                //   insertInto: function () { return document.querySelector(\"#foo\").shadowRoot }\n                // }\n                if (typeof target === 'function') {\n                        return target();\n                }\n                if (typeof memo[target] === \"undefined\") {\n\t\t\tvar styleTarget = getTarget.call(this, target);\n\t\t\t// Special case to return head of iframe instead of iframe itself\n\t\t\tif (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n\t\t\t\ttry {\n\t\t\t\t\t// This will throw an exception if access to iframe is blocked\n\t\t\t\t\t// due to cross-origin restrictions\n\t\t\t\t\tstyleTarget = styleTarget.contentDocument.head;\n\t\t\t\t} catch(e) {\n\t\t\t\t\tstyleTarget = null;\n\t\t\t\t}\n\t\t\t}\n\t\t\tmemo[target] = styleTarget;\n\t\t}\n\t\treturn memo[target]\n\t};\n})();\n\nvar singleton = null;\nvar\tsingletonCounter = 0;\nvar\tstylesInsertedAtTop = [];\n\nvar\tfixUrls = require(\"./urls\");\n\nmodule.exports = function(list, options) {\n\tif (typeof DEBUG !== \"undefined\" && DEBUG) {\n\t\tif (typeof document !== \"object\") throw new Error(\"The style-loader cannot be used in a non-browser environment\");\n\t}\n\n\toptions = options || {};\n\n\toptions.attrs = typeof options.attrs === \"object\" ? options.attrs : {};\n\n\t// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n\t// tags it will allow on a page\n\tif (!options.singleton && typeof options.singleton !== \"boolean\") options.singleton = isOldIE();\n\n\t// By default, add <style> tags to the <head> element\n        if (!options.insertInto) options.insertInto = \"head\";\n\n\t// By default, add <style> tags to the bottom of the target\n\tif (!options.insertAt) options.insertAt = \"bottom\";\n\n\tvar styles = listToStyles(list, options);\n\n\taddStylesToDom(styles, options);\n\n\treturn function update (newList) {\n\t\tvar mayRemove = [];\n\n\t\tfor (var i = 0; i < styles.length; i++) {\n\t\t\tvar item = styles[i];\n\t\t\tvar domStyle = stylesInDom[item.id];\n\n\t\t\tdomStyle.refs--;\n\t\t\tmayRemove.push(domStyle);\n\t\t}\n\n\t\tif(newList) {\n\t\t\tvar newStyles = listToStyles(newList, options);\n\t\t\taddStylesToDom(newStyles, options);\n\t\t}\n\n\t\tfor (var i = 0; i < mayRemove.length; i++) {\n\t\t\tvar domStyle = mayRemove[i];\n\n\t\t\tif(domStyle.refs === 0) {\n\t\t\t\tfor (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();\n\n\t\t\t\tdelete stylesInDom[domStyle.id];\n\t\t\t}\n\t\t}\n\t};\n};\n\nfunction addStylesToDom (styles, options) {\n\tfor (var i = 0; i < styles.length; i++) {\n\t\tvar item = styles[i];\n\t\tvar domStyle = stylesInDom[item.id];\n\n\t\tif(domStyle) {\n\t\t\tdomStyle.refs++;\n\n\t\t\tfor(var j = 0; j < domStyle.parts.length; j++) {\n\t\t\t\tdomStyle.parts[j](item.parts[j]);\n\t\t\t}\n\n\t\t\tfor(; j < item.parts.length; j++) {\n\t\t\t\tdomStyle.parts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\t\t} else {\n\t\t\tvar parts = [];\n\n\t\t\tfor(var j = 0; j < item.parts.length; j++) {\n\t\t\t\tparts.push(addStyle(item.parts[j], options));\n\t\t\t}\n\n\t\t\tstylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};\n\t\t}\n\t}\n}\n\nfunction listToStyles (list, options) {\n\tvar styles = [];\n\tvar newStyles = {};\n\n\tfor (var i = 0; i < list.length; i++) {\n\t\tvar item = list[i];\n\t\tvar id = options.base ? item[0] + options.base : item[0];\n\t\tvar css = item[1];\n\t\tvar media = item[2];\n\t\tvar sourceMap = item[3];\n\t\tvar part = {css: css, media: media, sourceMap: sourceMap};\n\n\t\tif(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});\n\t\telse newStyles[id].parts.push(part);\n\t}\n\n\treturn styles;\n}\n\nfunction insertStyleElement (options, style) {\n\tvar target = getElement(options.insertInto)\n\n\tif (!target) {\n\t\tthrow new Error(\"Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.\");\n\t}\n\n\tvar lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];\n\n\tif (options.insertAt === \"top\") {\n\t\tif (!lastStyleElementInsertedAtTop) {\n\t\t\ttarget.insertBefore(style, target.firstChild);\n\t\t} else if (lastStyleElementInsertedAtTop.nextSibling) {\n\t\t\ttarget.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);\n\t\t} else {\n\t\t\ttarget.appendChild(style);\n\t\t}\n\t\tstylesInsertedAtTop.push(style);\n\t} else if (options.insertAt === \"bottom\") {\n\t\ttarget.appendChild(style);\n\t} else if (typeof options.insertAt === \"object\" && options.insertAt.before) {\n\t\tvar nextSibling = getElement(options.insertInto + \" \" + options.insertAt.before);\n\t\ttarget.insertBefore(style, nextSibling);\n\t} else {\n\t\tthrow new Error(\"[Style Loader]\\n\\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\\n Must be 'top', 'bottom', or Object.\\n (https://github.com/webpack-contrib/style-loader#insertat)\\n\");\n\t}\n}\n\nfunction removeStyleElement (style) {\n\tif (style.parentNode === null) return false;\n\tstyle.parentNode.removeChild(style);\n\n\tvar idx = stylesInsertedAtTop.indexOf(style);\n\tif(idx >= 0) {\n\t\tstylesInsertedAtTop.splice(idx, 1);\n\t}\n}\n\nfunction createStyleElement (options) {\n\tvar style = document.createElement(\"style\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\n\taddAttrs(style, options.attrs);\n\tinsertStyleElement(options, style);\n\n\treturn style;\n}\n\nfunction createLinkElement (options) {\n\tvar link = document.createElement(\"link\");\n\n\tif(options.attrs.type === undefined) {\n\t\toptions.attrs.type = \"text/css\";\n\t}\n\toptions.attrs.rel = \"stylesheet\";\n\n\taddAttrs(link, options.attrs);\n\tinsertStyleElement(options, link);\n\n\treturn link;\n}\n\nfunction addAttrs (el, attrs) {\n\tObject.keys(attrs).forEach(function (key) {\n\t\tel.setAttribute(key, attrs[key]);\n\t});\n}\n\nfunction addStyle (obj, options) {\n\tvar style, update, remove, result;\n\n\t// If a transform function was defined, run it on the css\n\tif (options.transform && obj.css) {\n\t    result = options.transform(obj.css);\n\n\t    if (result) {\n\t    \t// If transform returns a value, use that instead of the original css.\n\t    \t// This allows running runtime transformations on the css.\n\t    \tobj.css = result;\n\t    } else {\n\t    \t// If the transform function returns a falsy value, don't add this css.\n\t    \t// This allows conditional loading of css\n\t    \treturn function() {\n\t    \t\t// noop\n\t    \t};\n\t    }\n\t}\n\n\tif (options.singleton) {\n\t\tvar styleIndex = singletonCounter++;\n\n\t\tstyle = singleton || (singleton = createStyleElement(options));\n\n\t\tupdate = applyToSingletonTag.bind(null, style, styleIndex, false);\n\t\tremove = applyToSingletonTag.bind(null, style, styleIndex, true);\n\n\t} else if (\n\t\tobj.sourceMap &&\n\t\ttypeof URL === \"function\" &&\n\t\ttypeof URL.createObjectURL === \"function\" &&\n\t\ttypeof URL.revokeObjectURL === \"function\" &&\n\t\ttypeof Blob === \"function\" &&\n\t\ttypeof btoa === \"function\"\n\t) {\n\t\tstyle = createLinkElement(options);\n\t\tupdate = updateLink.bind(null, style, options);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\n\t\t\tif(style.href) URL.revokeObjectURL(style.href);\n\t\t};\n\t} else {\n\t\tstyle = createStyleElement(options);\n\t\tupdate = applyToTag.bind(null, style);\n\t\tremove = function () {\n\t\t\tremoveStyleElement(style);\n\t\t};\n\t}\n\n\tupdate(obj);\n\n\treturn function updateStyle (newObj) {\n\t\tif (newObj) {\n\t\t\tif (\n\t\t\t\tnewObj.css === obj.css &&\n\t\t\t\tnewObj.media === obj.media &&\n\t\t\t\tnewObj.sourceMap === obj.sourceMap\n\t\t\t) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tupdate(obj = newObj);\n\t\t} else {\n\t\t\tremove();\n\t\t}\n\t};\n}\n\nvar replaceText = (function () {\n\tvar textStore = [];\n\n\treturn function (index, replacement) {\n\t\ttextStore[index] = replacement;\n\n\t\treturn textStore.filter(Boolean).join('\\n');\n\t};\n})();\n\nfunction applyToSingletonTag (style, index, remove, obj) {\n\tvar css = remove ? \"\" : obj.css;\n\n\tif (style.styleSheet) {\n\t\tstyle.styleSheet.cssText = replaceText(index, css);\n\t} else {\n\t\tvar cssNode = document.createTextNode(css);\n\t\tvar childNodes = style.childNodes;\n\n\t\tif (childNodes[index]) style.removeChild(childNodes[index]);\n\n\t\tif (childNodes.length) {\n\t\t\tstyle.insertBefore(cssNode, childNodes[index]);\n\t\t} else {\n\t\t\tstyle.appendChild(cssNode);\n\t\t}\n\t}\n}\n\nfunction applyToTag (style, obj) {\n\tvar css = obj.css;\n\tvar media = obj.media;\n\n\tif(media) {\n\t\tstyle.setAttribute(\"media\", media)\n\t}\n\n\tif(style.styleSheet) {\n\t\tstyle.styleSheet.cssText = css;\n\t} else {\n\t\twhile(style.firstChild) {\n\t\t\tstyle.removeChild(style.firstChild);\n\t\t}\n\n\t\tstyle.appendChild(document.createTextNode(css));\n\t}\n}\n\nfunction updateLink (link, options, obj) {\n\tvar css = obj.css;\n\tvar sourceMap = obj.sourceMap;\n\n\t/*\n\t\tIf convertToAbsoluteUrls isn't defined, but sourcemaps are enabled\n\t\tand there is no publicPath defined then lets turn convertToAbsoluteUrls\n\t\ton by default.  Otherwise default to the convertToAbsoluteUrls option\n\t\tdirectly\n\t*/\n\tvar autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;\n\n\tif (options.convertToAbsoluteUrls || autoFixUrls) {\n\t\tcss = fixUrls(css);\n\t}\n\n\tif (sourceMap) {\n\t\t// http://stackoverflow.com/a/26603875\n\t\tcss += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n\t}\n\n\tvar blob = new Blob([css], { type: \"text/css\" });\n\n\tvar oldSrc = link.href;\n\n\tlink.href = URL.createObjectURL(blob);\n\n\tif(oldSrc) URL.revokeObjectURL(oldSrc);\n}\n","\n/**\n * When source maps are enabled, `style-loader` uses a link element with a data-uri to\n * embed the css on the page. This breaks all relative urls because now they are relative to a\n * bundle instead of the current page.\n *\n * One solution is to only use full urls, but that may be impossible.\n *\n * Instead, this function \"fixes\" the relative urls to be absolute according to the current page location.\n *\n * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.\n *\n */\n\nmodule.exports = function (css) {\n  // get current location\n  var location = typeof window !== \"undefined\" && window.location;\n\n  if (!location) {\n    throw new Error(\"fixUrls requires window.location\");\n  }\n\n\t// blank or null?\n\tif (!css || typeof css !== \"string\") {\n\t  return css;\n  }\n\n  var baseUrl = location.protocol + \"//\" + location.host;\n  var currentDir = baseUrl + location.pathname.replace(/\\/[^\\/]*$/, \"/\");\n\n\t// convert each url(...)\n\t/*\n\tThis regular expression is just a way to recursively match brackets within\n\ta string.\n\n\t /url\\s*\\(  = Match on the word \"url\" with any whitespace after it and then a parens\n\t   (  = Start a capturing group\n\t     (?:  = Start a non-capturing group\n\t         [^)(]  = Match anything that isn't a parentheses\n\t         |  = OR\n\t         \\(  = Match a start parentheses\n\t             (?:  = Start another non-capturing groups\n\t                 [^)(]+  = Match anything that isn't a parentheses\n\t                 |  = OR\n\t                 \\(  = Match a start parentheses\n\t                     [^)(]*  = Match anything that isn't a parentheses\n\t                 \\)  = Match a end parentheses\n\t             )  = End Group\n              *\\) = Match anything and then a close parens\n          )  = Close non-capturing group\n          *  = Match anything\n       )  = Close capturing group\n\t \\)  = Match a close parens\n\n\t /gi  = Get all matches, not the first.  Be case insensitive.\n\t */\n\tvar fixedCss = css.replace(/url\\s*\\(((?:[^)(]|\\((?:[^)(]+|\\([^)(]*\\))*\\))*)\\)/gi, function(fullMatch, origUrl) {\n\t\t// strip quotes (if they exist)\n\t\tvar unquotedOrigUrl = origUrl\n\t\t\t.trim()\n\t\t\t.replace(/^\"(.*)\"$/, function(o, $1){ return $1; })\n\t\t\t.replace(/^'(.*)'$/, function(o, $1){ return $1; });\n\n\t\t// already a full url? no change\n\t\tif (/^(#|data:|http:\\/\\/|https:\\/\\/|file:\\/\\/\\/|\\s*$)/i.test(unquotedOrigUrl)) {\n\t\t  return fullMatch;\n\t\t}\n\n\t\t// convert the url to a full url\n\t\tvar newUrl;\n\n\t\tif (unquotedOrigUrl.indexOf(\"//\") === 0) {\n\t\t  \t//TODO: should we add protocol?\n\t\t\tnewUrl = unquotedOrigUrl;\n\t\t} else if (unquotedOrigUrl.indexOf(\"/\") === 0) {\n\t\t\t// path should be relative to the base url\n\t\t\tnewUrl = baseUrl + unquotedOrigUrl; // already starts with '/'\n\t\t} else {\n\t\t\t// path should be relative to current directory\n\t\t\tnewUrl = currentDir + unquotedOrigUrl.replace(/^\\.\\//, \"\"); // Strip leading './'\n\t\t}\n\n\t\t// send back the fixed url(...)\n\t\treturn \"url(\" + JSON.stringify(newUrl) + \")\";\n\t});\n\n\t// send back the fixed css\n\treturn fixedCss;\n};\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport { BeEvent } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { KeySet } from \"@bentley/presentation-common\";\nimport { ISelectionProvider } from \"./ISelectionProvider\";\n\n/**\n * An interface for selection change listeners.\n * @public\n */\nexport declare type SelectionChangesListener = (args: SelectionChangeEventArgs, provider: ISelectionProvider) => void;\n\n/**\n * An event broadcasted on selection changes\n * @public\n */\nexport class SelectionChangeEvent extends BeEvent<SelectionChangesListener> { }\n\n/**\n * The type of selection change\n * @public\n */\nexport enum SelectionChangeType {\n  /** Added to selection. */\n  Add,\n\n  /** Removed from selection. */\n  Remove,\n\n  /** Selection was replaced. */\n  Replace,\n\n  /** Selection was cleared. */\n  Clear,\n}\n\n/**\n * The event object that's sent when the selection changes.\n * @public\n */\nexport interface SelectionChangeEventArgs {\n  /** The name of the selection source which caused the selection change. */\n  source: string;\n\n  /** Level of the selection. */\n  level: number;\n\n  /** The selection change type. */\n  changeType: SelectionChangeType;\n\n  /** Set of keys affected by this selection change event. */\n  keys: Readonly<KeySet>;\n\n  /** iModel connection with which the selection is associated with. */\n  imodel: IModelConnection;\n\n  /** The timestamp of when the selection change happened */\n  timestamp: Date;\n\n  /** Ruleset Id. */\n  rulesetId?: string;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport { IDisposable, GuidString, Guid, Id64Arg, Id64, Id64Array } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection, SelectionSetEvent, SelectionSetEventType, ElementLocateManager, IModelApp } from \"@bentley/imodeljs-frontend\";\nimport { KeySet, Keys, SelectionScope } from \"@bentley/presentation-common\";\nimport { ISelectionProvider } from \"./ISelectionProvider\";\nimport { SelectionChangeEvent, SelectionChangeEventArgs, SelectionChangeType } from \"./SelectionChangeEvent\";\nimport { SelectionScopesManager } from \"./SelectionScopesManager\";\n\n/**\n * Properties for creating [[SelectionManager]].\n * @public\n */\nexport interface SelectionManagerProps {\n  /** A manager for [selection scopes]($docs/learning/unified-selection/Terminology#selection-scope) */\n  scopes: SelectionScopesManager;\n}\n\n/**\n * The selection manager which stores the overall selection.\n * @public\n */\nexport class SelectionManager implements ISelectionProvider {\n  private _selectionContainerMap = new Map<IModelConnection, SelectionContainer>();\n  private _imodelToolSelectionSyncHandlers = new Map<IModelConnection, { requestorsCount: number, handler: ToolSelectionSyncHandler }>();\n\n  /** An event which gets broadcasted on selection changes */\n  public readonly selectionChange: SelectionChangeEvent;\n\n  /** Manager for [selection scopes]($docs/learning/unified-selection/Terminology#selection-scope) */\n  public readonly scopes: SelectionScopesManager;\n\n  /**\n   * Creates an instance of SelectionManager.\n   */\n  constructor(props: SelectionManagerProps) {\n    this.selectionChange = new SelectionChangeEvent();\n    this.scopes = props.scopes;\n    IModelConnection.onClose.addListener((imodel: IModelConnection) => {\n      this.onConnectionClose(imodel);\n    });\n  }\n\n  private onConnectionClose(imodel: IModelConnection): void {\n    this.clearSelection(\"Connection Close Event\", imodel);\n    this._selectionContainerMap.delete(imodel);\n  }\n\n  private getContainer(imodel: IModelConnection): SelectionContainer {\n    let selectionContainer = this._selectionContainerMap.get(imodel);\n    if (!selectionContainer) {\n      selectionContainer = new SelectionContainer();\n      this._selectionContainerMap.set(imodel, selectionContainer);\n    }\n    return selectionContainer;\n  }\n\n  /**\n   * Request the manager to sync with imodel's tool selection (see `IModelConnection.selectionSet`).\n   */\n  public setSyncWithIModelToolSelection(imodel: IModelConnection, sync = true) {\n    const registration = this._imodelToolSelectionSyncHandlers.get(imodel);\n    if (sync) {\n      if (!registration || registration.requestorsCount === 0) {\n        this._imodelToolSelectionSyncHandlers.set(imodel, { requestorsCount: 1, handler: new ToolSelectionSyncHandler(imodel, IModelApp.locateManager, this) });\n      } else {\n        this._imodelToolSelectionSyncHandlers.set(imodel, { ...registration, requestorsCount: registration.requestorsCount + 1 });\n      }\n    } else {\n      if (registration && registration.requestorsCount > 0) {\n        const requestorsCount = registration.requestorsCount - 1;\n        if (requestorsCount > 0) {\n          this._imodelToolSelectionSyncHandlers.set(imodel, { ...registration, requestorsCount });\n        } else {\n          this._imodelToolSelectionSyncHandlers.delete(imodel);\n          registration.handler.dispose();\n        }\n      }\n    }\n  }\n\n  /** Get the selection levels currently stored in this manager for the specified imodel */\n  public getSelectionLevels(imodel: IModelConnection): number[] {\n    return this.getContainer(imodel).getSelectionLevels();\n  }\n\n  /** Get the selection currently stored in this manager */\n  public getSelection(imodel: IModelConnection, level: number = 0): Readonly<KeySet> {\n    return this.getContainer(imodel).getSelection(level);\n  }\n\n  private handleEvent(evt: SelectionChangeEventArgs): void {\n    const container = this.getContainer(evt.imodel);\n    const selectedItemsSet = container.getSelection(evt.level);\n    const guidBefore = selectedItemsSet.guid;\n    switch (evt.changeType) {\n      case SelectionChangeType.Add:\n        selectedItemsSet.add(evt.keys);\n        break;\n      case SelectionChangeType.Remove:\n        selectedItemsSet.delete(evt.keys);\n        break;\n      case SelectionChangeType.Replace:\n        if (selectedItemsSet.size !== evt.keys.size || !selectedItemsSet.hasAll(evt.keys)) {\n          // note: the above check is only needed to avoid changing\n          // guid of the keyset if we're replacing keyset with the same keys\n          selectedItemsSet.clear().add(evt.keys);\n        }\n        break;\n      case SelectionChangeType.Clear:\n        selectedItemsSet.clear();\n        break;\n    }\n\n    if (selectedItemsSet.guid === guidBefore)\n      return;\n\n    container.clear(evt.level + 1);\n    this.selectionChange.raiseEvent(evt, this);\n  }\n\n  /**\n   * Add keys to the selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param keys Keys to add\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public addToSelection(source: string, imodel: IModelConnection, keys: Keys, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Add,\n      keys: new KeySet(keys),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Remove keys from current selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param keys Keys to remove\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public removeFromSelection(source: string, imodel: IModelConnection, keys: Keys, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Remove,\n      keys: new KeySet(keys),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Replace current selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param keys Keys to add\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public replaceSelection(source: string, imodel: IModelConnection, keys: Keys, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Replace,\n      keys: new KeySet(keys),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Clear current selection\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public clearSelection(source: string, imodel: IModelConnection, level: number = 0, rulesetId?: string): void {\n    const evt: SelectionChangeEventArgs = {\n      source,\n      level,\n      imodel,\n      changeType: SelectionChangeType.Clear,\n      keys: new KeySet(),\n      timestamp: new Date(),\n      rulesetId,\n    };\n    this.handleEvent(evt);\n  }\n\n  /**\n   * Add keys to selection after applying [selection scope]($docs/learning/unified-selection/Terminology#selection-scope) on them.\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param ids Element IDs to add\n   * @param scope Selection scope to apply\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public async addToSelectionWithScope(source: string, imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string, level: number = 0, rulesetId?: string): Promise<void> {\n    const scopedKeys = await this.scopes.computeSelection(imodel, ids, scope);\n    this.addToSelection(source, imodel, scopedKeys, level, rulesetId);\n  }\n\n  /**\n   * Remove keys from current selection after applying [selection scope]($docs/learning/unified-selection/Terminology#selection-scope) on them.\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param ids Element IDs to remove\n   * @param scope Selection scope to apply\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public async removeFromSelectionWithScope(source: string, imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string, level: number = 0, rulesetId?: string): Promise<void> {\n    const scopedKeys = await this.scopes.computeSelection(imodel, ids, scope);\n    this.removeFromSelection(source, imodel, scopedKeys, level, rulesetId);\n  }\n\n  /**\n   * Replace current selection with keys after applying [selection scope]($docs/learning/unified-selection/Terminology#selection-scope) on them.\n   * @param source Name of the selection source\n   * @param imodel iModel associated with the selection\n   * @param ids Element IDs to replace with\n   * @param scope Selection scope to apply\n   * @param level Selection level (see [Selection levels]($docs/learning/unified-selection/Terminology#selection-level))\n   * @param rulesetId ID of the ruleset in case the selection was changed from a rules-driven control\n   */\n  public async replaceSelectionWithScope(source: string, imodel: IModelConnection, ids: Id64Arg, scope: SelectionScope | string, level: number = 0, rulesetId?: string): Promise<void> {\n    const scopedKeys = await this.scopes.computeSelection(imodel, ids, scope);\n    this.replaceSelection(source, imodel, scopedKeys, level, rulesetId);\n  }\n}\n\n/** @internal */\nclass SelectionContainer {\n  private readonly _selectedItemsSetMap: Map<number, KeySet>;\n\n  constructor() {\n    this._selectedItemsSetMap = new Map<number, KeySet>();\n  }\n\n  public getSelection(level: number): KeySet {\n    let selectedItemsSet = this._selectedItemsSetMap.get(level);\n    if (!selectedItemsSet) {\n      selectedItemsSet = new KeySet();\n      this._selectedItemsSetMap.set(level, selectedItemsSet);\n    }\n    return selectedItemsSet;\n  }\n\n  public getSelectionLevels(): number[] {\n    const levels = new Array<number>();\n    for (const entry of this._selectedItemsSetMap.entries()) {\n      if (!entry[1].isEmpty)\n        levels.push(entry[0]);\n    }\n    return levels.sort();\n  }\n\n  public clear(level: number) {\n    const keys = this._selectedItemsSetMap.keys();\n    for (const key of keys) {\n      if (key >= level) {\n        const selectedItemsSet = this._selectedItemsSetMap.get(key)!;\n        selectedItemsSet.clear();\n      }\n    }\n  }\n}\n\n/** @internal */\nexport const TRANSIENT_ELEMENT_CLASSNAME = \"/TRANSIENT\";\n\n/** @internal */\nexport class ToolSelectionSyncHandler implements IDisposable {\n\n  private _selectionSourceName = \"Tool\";\n  private _logicalSelection: SelectionManager;\n  private _locateManager: ElementLocateManager;\n  private _imodel: IModelConnection;\n  private _imodelToolSelectionListenerDisposeFunc: () => void;\n  private _asyncsInProgress = new Set<GuidString>();\n\n  public constructor(imodel: IModelConnection, locateManager: ElementLocateManager, logicalSelection: SelectionManager) {\n    this._imodel = imodel;\n    this._locateManager = locateManager;\n    this._logicalSelection = logicalSelection;\n    this._imodelToolSelectionListenerDisposeFunc = imodel.selectionSet.onChanged.addListener(this.onToolSelectionChanged);\n  }\n\n  public dispose() {\n    this._imodelToolSelectionListenerDisposeFunc();\n  }\n\n  /** note: used only it tests */\n  public get pendingAsyncs() { return this._asyncsInProgress; }\n\n  // tslint:disable-next-line:naming-convention\n  private onToolSelectionChanged = async (ev: SelectionSetEvent): Promise<void> => {\n    // this component only cares about its own imodel\n    const imodel = ev.set.iModel;\n    if (imodel !== this._imodel)\n      return;\n\n    // determine the level of selection changes\n    // wip: may want to allow selecting at different levels?\n    const selectionLevel = 0;\n\n    let ids: Id64Arg;\n    switch (ev.type) {\n      case SelectionSetEventType.Add:\n        ids = ev.added;\n        break;\n      case SelectionSetEventType.Replace:\n        ids = ev.set.elements;\n        break;\n      default:\n        ids = ev.removed;\n        break;\n    }\n\n    // determine the scope id\n    // note: _always_ use \"element\" scope for fence selection\n    let scopeId = getScopeId(this._logicalSelection.scopes.activeScope);\n    const currHit = this._locateManager.currHit;\n    const isSingleSelectionFromPick = (undefined !== currHit && 1 === Id64.sizeOf(ids) && Id64.has(ids, currHit.sourceId));\n    if (!isSingleSelectionFromPick)\n      scopeId = \"element\";\n\n    // we're always using scoped selection changer even if the scope is set to \"element\" - that\n    // makes sure we're adding to selection keys with concrete classes and not \"BisCore:Element\", which\n    // we can't because otherwise our keys compare fails (presentation components load data with\n    // concrete classes)\n    const changer = new ScopedSelectionChanger(this._selectionSourceName, this._imodel, this._logicalSelection, scopeId);\n\n    // we know what to do immediately on `clear` events\n    if (SelectionSetEventType.Clear === ev.type) {\n      await changer.clear(selectionLevel);\n      return;\n    }\n\n    const parsedIds = parseIds(ids);\n    const asyncId = Guid.createValue();\n    this._asyncsInProgress.add(asyncId);\n    try {\n      switch (ev.type) {\n        case SelectionSetEventType.Add:\n          await changer.add(parsedIds.transient, parsedIds.persistent, selectionLevel);\n          break;\n        case SelectionSetEventType.Replace:\n          await changer.replace(parsedIds.transient, parsedIds.persistent, selectionLevel);\n          break;\n        case SelectionSetEventType.Remove:\n          await changer.remove(parsedIds.transient, parsedIds.persistent, selectionLevel);\n          break;\n      }\n    } finally {\n      this._asyncsInProgress.delete(asyncId);\n    }\n  }\n}\n\nconst getScopeId = (scope: SelectionScope | string | undefined): string => {\n  if (!scope)\n    return \"element\";\n  if (typeof scope === \"string\")\n    return scope;\n  return scope.id;\n};\n\nconst parseIds = (ids: Id64Arg): { persistent: Id64Arg, transient: Id64Arg } => {\n  let allPersistent = true;\n  let allTransient = true;\n  Id64.iterate(ids, (id) => {\n    if (Id64.isTransient(id))\n      allPersistent = false;\n    else\n      allTransient = false;\n    if (!allPersistent && !allTransient)\n      return false;\n    return true;\n  });\n\n  // avoid making a copy if ids are only persistent or only transient\n  if (allPersistent) {\n    return { persistent: ids, transient: [] };\n  } else if (allTransient) {\n    return { persistent: [], transient: ids };\n  }\n\n  // if `ids` contain mixed ids, we have to copy.. use Array instead of\n  // a Set for performance\n  const persistentElementIds: Id64Array = [];\n  const transientElementIds: Id64Array = [];\n  Id64.forEach(ids, (id) => {\n    if (Id64.isTransient(id))\n      transientElementIds.push(id);\n    else\n      persistentElementIds.push(id);\n  });\n  return { persistent: persistentElementIds, transient: transientElementIds };\n};\n\n/** @internal */\nclass ScopedSelectionChanger {\n  public readonly name: string;\n  public readonly imodel: IModelConnection;\n  public readonly manager: SelectionManager;\n  public readonly scope: SelectionScope | string;\n  public constructor(name: string, imodel: IModelConnection, manager: SelectionManager, scope: SelectionScope | string) {\n    this.name = name;\n    this.imodel = imodel;\n    this.manager = manager;\n    this.scope = scope;\n  }\n  public async clear(level: number): Promise<void> {\n    this.manager.clearSelection(this.name, this.imodel, level);\n  }\n  public async add(transientIds: Id64Arg, persistentIds: Id64Arg, level: number): Promise<void> {\n    const keys = await this.manager.scopes.computeSelection(this.imodel, persistentIds, this.scope);\n    Id64.forEach(transientIds, (id) => keys.add({ className: TRANSIENT_ELEMENT_CLASSNAME, id }));\n    this.manager.addToSelection(this.name, this.imodel, keys, level);\n  }\n  public async remove(transientIds: Id64Arg, persistentIds: Id64Arg, level: number): Promise<void> {\n    const keys = await this.manager.scopes.computeSelection(this.imodel, persistentIds, this.scope);\n    Id64.forEach(transientIds, (id) => keys.add({ className: TRANSIENT_ELEMENT_CLASSNAME, id }));\n    this.manager.removeFromSelection(this.name, this.imodel, keys, level);\n  }\n  public async replace(transientIds: Id64Arg, persistentIds: Id64Arg, level: number): Promise<void> {\n    const keys = await this.manager.scopes.computeSelection(this.imodel, persistentIds, this.scope);\n    Id64.forEach(transientIds, (id) => keys.add({ className: TRANSIENT_ELEMENT_CLASSNAME, id }));\n    this.manager.replaceSelection(this.name, this.imodel, keys, level);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Core */\r\n\r\nimport { RulesetsFactory, Omit } from \"@bentley/presentation-common\";\r\nimport { PropertyRecord } from \"@bentley/imodeljs-frontend\";\r\nimport { IPresentationPropertyDataProvider } from \"./propertygrid/DataProvider\";\r\nimport {\r\n  IPresentationTableDataProvider, PresentationTableDataProvider,\r\n  PresentationTableDataProviderProps,\r\n} from \"./table/DataProvider\";\r\n\r\n/**\r\n * Data structure holding initialization properties for [[DataProvidersFactory]]\r\n * @public\r\n */\r\nexport interface DataProvidersFactoryProps {\r\n  /** Rulesets' factory to use when creating data providers */\r\n  rulesetsFactory?: RulesetsFactory;\r\n}\r\n\r\n/**\r\n * A factory class than can be used to create presentation data providers targeted towards\r\n * specific use cases.\r\n *\r\n * @public\r\n */\r\nexport class DataProvidersFactory {\r\n  private _rulesetsFactory: RulesetsFactory;\r\n\r\n  /** Constructor. */\r\n  public constructor(props?: DataProvidersFactoryProps) {\r\n    this._rulesetsFactory = props && props.rulesetsFactory ? props.rulesetsFactory : new RulesetsFactory();\r\n  }\r\n\r\n  /**\r\n   * Create a table data provider which returns instances of the same class and\r\n   * having the same property value as the provided property record.\r\n   * @param propertiesProvider A field identifying which property of the record we should use\r\n   * @param record A record whose similar instances should be found\r\n   * @param props Configuration properties for the created provider\r\n   */\r\n  public async createSimilarInstancesTableDataProvider(propertiesProvider: IPresentationPropertyDataProvider, record: PropertyRecord,\r\n    props: Omit<PresentationTableDataProviderProps, \"imodel\" | \"ruleset\">,\r\n  ): Promise<IPresentationTableDataProvider & { description: string }> {\r\n    const content = await propertiesProvider.getContent();\r\n    if (!content || content.contentSet.length === 0)\r\n      throw new Error(\"Properties provider has no content. Where did record come from?\");\r\n\r\n    const field = content.descriptor.getFieldByName(record.property.name, true);\r\n    if (!field)\r\n      throw new Error(\"Properties provider doesn't have a property with provided record. Where did record come from?\");\r\n\r\n    const result = this._rulesetsFactory.createSimilarInstancesRuleset(field, content.contentSet[0]);\r\n    return new TableDataProviderWithDescription({\r\n      ...props,\r\n      imodel: propertiesProvider.imodel,\r\n      ruleset: result.ruleset,\r\n      description: result.description,\r\n    });\r\n  }\r\n}\r\n\r\nclass TableDataProviderWithDescription extends PresentationTableDataProvider {\r\n  public readonly description: string;\r\n  public constructor(props: (PresentationTableDataProviderProps & { description: string })) {\r\n    const { description, ...baseProps } = props;\r\n    super(baseProps);\r\n    this.description = description;\r\n  }\r\n  protected shouldRequestContentForEmptyKeyset() { return true; }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport {\n  ValuesDictionary, PresentationError, PresentationStatus,\n  Field, Item, DisplayValue, Value, PropertyValueFormat,\n  NestedContentValue, NestedContentField,\n  TypeDescription, StructTypeDescription, ArrayTypeDescription,\n} from \"@bentley/presentation-common\";\nimport { Omit } from \"@bentley/ui-core\";\nimport {\n  PropertyRecord, PropertyValue, PropertyValueFormat as UiPropertyValueFormat,\n  ArrayValue, StructValue, PrimitiveValue,\n  PropertyDescription, PropertyEditorInfo, EnumerationChoicesInfo,\n} from \"@bentley/imodeljs-frontend\";\n\nconst createArrayValue = (propertyDescription: PropertyDescription, arrayDescription: ArrayTypeDescription, values: Value[], displayValues: DisplayValue[]): ArrayValue => {\n  const records = new Array<PropertyRecord>();\n  assert(values.length === displayValues.length);\n  for (let i = 0; i < values.length; ++i) {\n    const memberDescription = {\n      name: propertyDescription.name,\n      displayLabel: propertyDescription.displayLabel,\n      typename: arrayDescription.memberType.typeName,\n    } as PropertyDescription;\n    const record = createRecord(memberDescription, arrayDescription.memberType,\n      values[i], displayValues[i], true, false);\n    records.push(record);\n  }\n  return {\n    valueFormat: UiPropertyValueFormat.Array,\n    items: records,\n    itemsTypeName: arrayDescription.memberType.typeName,\n  };\n};\n\nconst createStructValue = (description: StructTypeDescription, valueObj: ValuesDictionary<Value>, displayValueObj: ValuesDictionary<DisplayValue>): StructValue => {\n  const members: { [name: string]: PropertyRecord } = {};\n  for (const memberTypeDescription of description.members) {\n    const memberPropertyDescription = {\n      name: memberTypeDescription.name,\n      displayLabel: memberTypeDescription.label,\n      typename: memberTypeDescription.type.typeName,\n    } as PropertyDescription;\n    const record = createRecord(memberPropertyDescription, memberTypeDescription.type,\n      valueObj[memberTypeDescription.name], displayValueObj[memberTypeDescription.name], true, false);\n    members[memberTypeDescription.name] = record;\n  }\n  return {\n    valueFormat: UiPropertyValueFormat.Struct,\n    members,\n  } as StructValue;\n};\n\nconst createPrimitiveValue = (value: Value, displayValue: DisplayValue): PrimitiveValue => {\n  return {\n    valueFormat: UiPropertyValueFormat.Primitive,\n    value,\n    displayValue,\n  } as PrimitiveValue;\n};\n\nconst createValue = (propertyDescription: PropertyDescription, typeDescription: TypeDescription, isMerged: boolean, value: Value, displayValue: DisplayValue): PropertyValue => {\n  if (undefined === value && undefined === displayValue) {\n    return {\n      valueFormat: UiPropertyValueFormat.Primitive,\n      value,\n      displayValue: \"\",\n    };\n  }\n  if (!isMerged) {\n    if (typeDescription.valueFormat === PropertyValueFormat.Array) {\n      if (!Value.isArray(value) || !DisplayValue.isArray(displayValue))\n        throw new PresentationError(PresentationStatus.InvalidArgument, \"value and displayValue should both be arrays\");\n      return createArrayValue(propertyDescription, typeDescription, value, displayValue);\n    }\n    if (typeDescription.valueFormat === PropertyValueFormat.Struct) {\n      if (!Value.isMap(value) || !DisplayValue.isMap(displayValue))\n        throw new PresentationError(PresentationStatus.InvalidArgument, \"value and displayValue should both be of map type\");\n      return createStructValue(typeDescription, value, displayValue);\n    }\n  }\n  return createPrimitiveValue(value, displayValue);\n};\n\nconst createRecordDescription = (typeDescription: TypeDescription, displayValue: Omit<DisplayValue, \"undefined\">): string | undefined => {\n  if (PropertyValueFormat.Array === typeDescription.valueFormat || PropertyValueFormat.Struct === typeDescription.valueFormat)\n    return undefined;\n  if (PropertyValueFormat.Primitive !== typeDescription.valueFormat || !DisplayValue.isPrimitive(displayValue))\n    throw new PresentationError(PresentationStatus.InvalidArgument, \"displayValue is of wrong type\");\n  return displayValue.toString();\n};\n\nconst createRecord = (propertyDescription: PropertyDescription, typeDescription: TypeDescription,\n  value: Value, displayValue: DisplayValue, isReadOnly: boolean, isMerged: boolean, extendedData?: { [key: string]: any }): PropertyRecord => {\n  const valueObj = createValue(propertyDescription, typeDescription, isMerged, value, displayValue);\n  const record = new PropertyRecord(valueObj, propertyDescription);\n  if (displayValue)\n    record.description = createRecordDescription(typeDescription, displayValue);\n  if (isMerged)\n    record.isMerged = true;\n  if (isReadOnly)\n    record.isReadonly = true;\n  if (extendedData)\n    record.extendedData = extendedData;\n  return record;\n};\n\nconst createNestedStructRecord = (field: NestedContentField, nestedContent: NestedContentValue, path?: Field[]): PropertyRecord => {\n  path = path ? [...path] : undefined;\n  let pathField: Field | undefined;\n  if (path && 0 !== path.length) {\n    pathField = path.shift();\n  }\n\n  const item = new Item(nestedContent.primaryKeys, \"\", \"\",\n    field.contentClassInfo, nestedContent.values, nestedContent.displayValues, nestedContent.mergedFieldNames);\n\n  const members: { [name: string]: PropertyRecord } = {};\n  for (const nestedField of field.nestedFields) {\n    if (pathField && pathField !== nestedField)\n      continue;\n    members[nestedField.name] = ContentBuilder.createPropertyRecord(nestedField, item, path);\n  }\n  const value: StructValue = {\n    valueFormat: UiPropertyValueFormat.Struct,\n    members,\n  };\n  const record = new PropertyRecord(value, ContentBuilder.createPropertyDescription(field));\n  record.isReadonly = field.isReadonly;\n  record.isMerged = false;\n  return record;\n};\n\nconst createNestedContentRecord = (field: NestedContentField, item: Item, path?: Field[]): PropertyRecord => {\n  const isMerged = item.isFieldMerged(field.name);\n  let value: PropertyValue;\n\n  if (isMerged) {\n    const displayValue = item.displayValues[field.name];\n    if (!DisplayValue.isPrimitive(displayValue))\n      throw new PresentationError(PresentationStatus.Error, \"displayValue should be primitive\");\n    // if the value is merged, just take the display value\n    value = {\n      valueFormat: UiPropertyValueFormat.Primitive,\n      value: undefined,\n      displayValue: (undefined !== displayValue) ? displayValue.toString() : \"\",\n    };\n  } else {\n    const dictionaryValue = item.values[field.name];\n    if (!Value.isNestedContent(dictionaryValue))\n      throw new PresentationError(PresentationStatus.Error, \"value should be nested content\");\n    // nested content value is in NestedContent[] format\n    const nestedContentArray: NestedContentValue[] = dictionaryValue;\n    value = {\n      valueFormat: UiPropertyValueFormat.Array,\n      items: nestedContentArray.map((r) => createNestedStructRecord(field, r, path)),\n      itemsTypeName: field.type.typeName,\n    };\n    // if array contains just one value, replace it with the value\n    if (1 === value.items.length)\n      value = value.items[0].value!;\n  }\n\n  const record = new PropertyRecord(value, ContentBuilder.createPropertyDescription(field));\n  if (isMerged)\n    record.isMerged = true;\n  if (field.isReadonly || isMerged)\n    record.isReadonly = true;\n  if (item.extendedData)\n    record.extendedData = item.extendedData;\n  return record;\n};\n\n/**\n * A helper class which creates `ui-components` objects from `presentation` objects.\n * @internal\n */\nexport class ContentBuilder {\n  /**\n   * Create a property record for specified field and item\n   * @param field Content field to create the record for\n   * @param item Content item containing the values for `field`\n   * @param path Optional path that specifies a path of fields to be\n   * included in the record. Only makes sense if `field` is `NestedContentField`.\n   * Should start from the first nested field inside `field`.\n   */\n  public static createPropertyRecord(field: Field, item: Item, path?: Field[]): PropertyRecord {\n    if (field.isNestedContentField())\n      return createNestedContentRecord(field, item, path);\n\n    const isValueReadOnly = field.isReadonly || item.isFieldMerged(field.name);\n    return createRecord(ContentBuilder.createPropertyDescription(field), field.type,\n      item.values[field.name], item.displayValues[field.name],\n      isValueReadOnly, item.isFieldMerged(field.name), item.extendedData);\n  }\n\n  /**\n   * Create a property description for the specified field\n   * @param field Content field to create description for\n   */\n  public static createPropertyDescription(field: Field): PropertyDescription {\n    const descr: PropertyDescription = {\n      name: field.name,\n      displayLabel: field.label,\n      typename: field.type.typeName,\n    };\n    if (field.editor) {\n      descr.editor = { name: field.editor.name, params: [] } as PropertyEditorInfo;\n    }\n    if (field.type.valueFormat === PropertyValueFormat.Primitive && \"enum\" === field.type.typeName && field.isPropertiesField()) {\n      const enumInfo = field.properties[0].property.enumerationInfo!;\n      descr.enum = {\n        choices: enumInfo.choices,\n        isStrict: enumInfo.isStrict,\n      } as EnumerationChoicesInfo;\n    }\n    return descr;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport * as _ from \"lodash\";\nimport { IDisposable, Logger } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport {\n  KeySet, PageOptions, SelectionInfo,\n  ContentRequestOptions, Content, Descriptor, Field,\n  Ruleset, RegisteredRuleset, DescriptorOverrides,\n} from \"@bentley/presentation-common\";\nimport { Presentation } from \"@bentley/presentation-frontend\";\nimport { IPresentationDataProvider } from \"./IPresentationDataProvider\";\n\n/**\n * Properties for invalidating content cache.\n * @public\n */\nexport interface CacheInvalidationProps {\n  /**\n   * Invalidate content descriptor. Should be set when invalidating\n   * after changing anything that affects how the descriptor is built:\n   * `keys`, `selectionInfo`, `imodel`, `rulesetId`.\n   */\n  descriptor?: boolean;\n\n  /**\n   * Invalidate configured content descriptor. Should be set when\n   * invalidating something that affects how descriptor is configured\n   * in the `configureContentDescriptor` callback, e.g. hidden fields,\n   * sorting, filtering, etc.\n   */\n  descriptorConfiguration?: boolean;\n\n  /**\n   * Invalidate cached content size. Should be set after changing anything\n   * that may affect content size. Generally, it should always be set when\n   * the `descriptor` flag is set. Additionally, it should also be set after\n   * setting `filterExpression` or similar descriptor properties.\n   */\n  size?: boolean;\n\n  /**\n   * Invalidate cached content. Should be set after changing anything that may\n   * affect content. Generally, it should always be set when the `descriptor`\n   * flag is set. Additionally, it should also be set after setting `sortingField`,\n   * `sortDirection`, `filterExpression` and similar fields.\n   */\n  content?: boolean;\n}\n/** @public */\nnamespace CacheInvalidationProps {\n  /**\n   * Create CacheInvalidationProps to fully invalidate all caches.\n   */\n  export const full = (): CacheInvalidationProps => ({ descriptor: true, descriptorConfiguration: true, size: true, content: true });\n}\n\n/**\n * Interface for all presentation-driven content providers.\n * @public\n */\nexport interface IContentDataProvider extends IPresentationDataProvider, IDisposable {\n  /** Display type used to format content */\n  readonly displayType: string;\n  /** Keys defining what to request content for */\n  keys: KeySet;\n  /** Information about selection event that results in content change */\n  selectionInfo: SelectionInfo | undefined;\n\n  /**\n   * Get the content descriptor.\n   */\n  getContentDescriptor: () => Promise<Descriptor | undefined>;\n\n  /**\n   * Get the number of content records.\n   */\n  getContentSetSize: () => Promise<number>;\n\n  /**\n   * Get the content.\n   * @param pageOptions Paging options.\n   */\n  getContent: (pageOptions?: PageOptions) => Promise<Content | undefined>;\n}\n\n/**\n * Base class for all presentation-driven content providers.\n * @public\n */\nexport class ContentDataProvider implements IContentDataProvider {\n  private _imodel: IModelConnection;\n  private _rulesetId: string;\n  private _displayType: string;\n  private _keys: KeySet;\n  private _previousKeysGuid: string;\n  private _selectionInfo?: SelectionInfo;\n  private _registeredRuleset?: RegisteredRuleset;\n  private _isDisposed?: boolean;\n  private _pagingSize?: number;\n\n  /**\n   * Constructor.\n   * @param imodel IModel to pull data from.\n   * @param ruleset Id of the ruleset to use when requesting content or a ruleset itself.\n   * @param displayType The content display type which this provider is going to\n   * load data for.\n   */\n  constructor(imodel: IModelConnection, ruleset: string | Ruleset, displayType: string) {\n    this._rulesetId = (typeof ruleset === \"string\") ? ruleset : ruleset.id;\n    this._displayType = displayType;\n    this._imodel = imodel;\n    this._keys = new KeySet();\n    this._previousKeysGuid = this._keys.guid;\n    this.invalidateCache(CacheInvalidationProps.full());\n    if (typeof ruleset === \"object\") {\n      this.registerRuleset(ruleset); // tslint:disable-line: no-floating-promises\n    }\n  }\n\n  /** Destructor. Must be called to clean up.  */\n  public dispose() {\n    this._isDisposed = true;\n    this.disposeRegisteredRuleset();\n  }\n\n  private disposeRegisteredRuleset() {\n    if (!this._registeredRuleset)\n      return;\n\n    this._registeredRuleset.dispose();\n    this._registeredRuleset = undefined;\n  }\n\n  private async registerRuleset(ruleset: Ruleset) {\n    this._registeredRuleset = await Presentation.presentation.rulesets().add(ruleset);\n    if (this._isDisposed) {\n      // ensure we don't keep a hanging registered ruleset if the data provider\n      // gets destroyed before the ruleset finishes registration\n      this.disposeRegisteredRuleset();\n    }\n  }\n\n  /** Display type used to format content */\n  public get displayType(): string { return this._displayType; }\n\n  /**\n   * Paging options for obtaining content.\n   *\n   * Presentation data providers, when used with paging, have ability to save one backend request for size / count. That\n   * can only be achieved when `pagingSize` property is set on the data provider and it's value matches size which is used when\n   * requesting content. To help developers notice this problem, data provider emits a warning similar to this:\n   * ```\n   * ContentDataProvider.pagingSize doesn't match pageOptions in ContentDataProvider.getContent call. Make sure you set provider's pagingSize to avoid excessive backend requests.\n   * ```\n   * To fix the issue, developers should make sure the page size used for requesting data is also set for the data provider:\n   * ```TS\n   * const pageSize = 10;\n   * const provider = new ContentDataProvider(imodel, rulesetId, displayType);\n   * provider.pagingSize = pageSize;\n   * // only one backend request is made for the two following requests:\n   * provider.getContentSetSize();\n   * provider.getContent({ start: 0, size: pageSize });\n   * ```\n   */\n  public get pagingSize(): number | undefined { return this._pagingSize; }\n  public set pagingSize(value: number | undefined) { this._pagingSize = value; }\n\n  /** IModel to pull data from */\n  public get imodel(): IModelConnection { return this._imodel; }\n  public set imodel(imodel: IModelConnection) {\n    if (this._imodel === imodel)\n      return;\n\n    this._imodel = imodel;\n    this.invalidateCache(CacheInvalidationProps.full());\n  }\n\n  /** Id of the ruleset to use when requesting content */\n  public get rulesetId(): string { return this._rulesetId; }\n  public set rulesetId(value: string) {\n    if (this._rulesetId === value)\n      return;\n\n    this._rulesetId = value;\n    this.invalidateCache(CacheInvalidationProps.full());\n  }\n\n  /** Keys defining what to request content for */\n  public get keys() { return this._keys; }\n  public set keys(keys: KeySet) {\n    if (keys.guid === this._previousKeysGuid)\n      return;\n\n    this._keys = keys;\n    this._previousKeysGuid = this._keys.guid;\n    this.invalidateCache(CacheInvalidationProps.full());\n  }\n\n  /** Information about selection event that results in content change */\n  public get selectionInfo() { return this._selectionInfo; }\n  public set selectionInfo(info: SelectionInfo | undefined) {\n    if (this._selectionInfo === info)\n      return;\n\n    this._selectionInfo = info;\n    this.invalidateCache(CacheInvalidationProps.full());\n  }\n\n  /**\n   * Invalidates cached content.\n   */\n  protected invalidateCache(props: CacheInvalidationProps): void {\n    if (props.descriptor && this.getDefaultContentDescriptor)\n      this.getDefaultContentDescriptor.cache.clear!();\n    if (props.descriptorConfiguration && this.getContentDescriptor)\n      this.getContentDescriptor.cache.clear!();\n    if ((props.content || props.size) && this._getContentAndSize)\n      this._getContentAndSize.cache.clear!();\n  }\n\n  private createRequestOptions(): ContentRequestOptions<IModelConnection> {\n    return {\n      imodel: this._imodel,\n      rulesetId: this._rulesetId,\n    };\n  }\n\n  /**\n   * Called to configure the content descriptor. This is the place where concrete\n   * provider implementations can control things like sorting, filtering, hiding fields, etc.\n   *\n   * The default method implementation takes care of hiding properties. Subclasses\n   * should call the base class method to not lose this functionality.\n   */\n  protected configureContentDescriptor(descriptor: Readonly<Descriptor>): Descriptor {\n    const fields = descriptor.fields.slice();\n    const fieldsCount = fields.length;\n    for (let i = fieldsCount - 1; i >= 0; --i) {\n      const field = fields[i];\n      if (this.shouldExcludeFromDescriptor(field))\n        fields.splice(i, 1);\n    }\n    return new Descriptor({ ...descriptor, fields });\n  }\n\n  /**\n   * Called to check whether the content descriptor needs advanced configuration. If yes,\n   * descriptor is requested from the backend and `configureContentDescriptor()` is called\n   * to configure it before requesting content. If not, the provider calls\n   * `getDescriptorOverrides()` to get basic configuration and immediately requests\n   * content - that saves a trip to the backend.\n   */\n  protected shouldConfigureContentDescriptor(): boolean { return true; }\n\n  /**\n   * Called to check if content should be requested even when `keys` is empty. If this\n   * method returns `false`, then content is not requested and this saves a trip\n   * to the backend.\n   */\n  protected shouldRequestContentForEmptyKeyset(): boolean { return false; }\n\n  /** Called to check whether the field should be excluded from the descriptor. */\n  protected shouldExcludeFromDescriptor(field: Field): boolean { return this.isFieldHidden(field); }\n\n  /** Called to check whether the field should be hidden. */\n  protected isFieldHidden(_field: Field): boolean { return false; }\n\n  /**\n   * Get the content descriptor overrides.\n   *\n   * **Note:** The method is only called if `shouldConfigureContentDescriptor()` returns `false` -\n   * in that case when requesting content we skip requesting descriptor and instead just pass\n   * overrides.\n   */\n  protected getDescriptorOverrides(): DescriptorOverrides {\n    return {\n      displayType: this.displayType,\n      contentFlags: 0,\n      hiddenFieldNames: [],\n    };\n  }\n\n  // tslint:disable-next-line:naming-convention\n  private getDefaultContentDescriptor = _.memoize(async (): Promise<Descriptor | undefined> => {\n    return Presentation.presentation.getContentDescriptor(this.createRequestOptions(),\n      this._displayType, this.keys, this.selectionInfo);\n  });\n\n  /**\n   * Get the content descriptor.\n   */\n  public getContentDescriptor = _.memoize(async (): Promise<Descriptor | undefined> => {\n    if (!this.shouldRequestContentForEmptyKeyset() && this.keys.isEmpty)\n      return undefined;\n\n    const descriptor = await this.getDefaultContentDescriptor();\n    if (!descriptor)\n      return undefined;\n\n    return this.configureContentDescriptor(descriptor);\n  });\n\n  /**\n   * Get the number of content records.\n   */\n  public async getContentSetSize(): Promise<number> {\n    const paging = undefined !== this.pagingSize ? { start: 0, size: this.pagingSize } : undefined;\n    const contentAndSize = await this._getContentAndSize(paging);\n    if (undefined !== contentAndSize)\n      return contentAndSize.size!;\n    return 0;\n  }\n\n  /**\n   * Get the content.\n   * @param pageOptions Paging options.\n   */\n  public async getContent(pageOptions?: PageOptions): Promise<Content | undefined> {\n    if (undefined !== pageOptions && pageOptions.size !== this.pagingSize) {\n      const msg = `ContentDataProvider.pagingSize doesn't match pageOptions in ContentDataProvider.getContent call.\n        Make sure you set provider's pagingSize to avoid excessive backend requests.`;\n      Logger.logWarning(\"Presentation.Components\", msg);\n    }\n    const contentAndSize = await this._getContentAndSize(pageOptions);\n    if (undefined !== contentAndSize)\n      return contentAndSize.content;\n    return undefined;\n  }\n\n  private _getContentAndSize = _.memoize(async (pageOptions?: PageOptions) => {\n    if (!this.shouldRequestContentForEmptyKeyset() && this.keys.isEmpty)\n      return undefined;\n\n    let descriptorOrOverrides;\n    if (this.shouldConfigureContentDescriptor()) {\n      descriptorOrOverrides = await this.getContentDescriptor();\n      if (!descriptorOrOverrides)\n        return undefined;\n    } else {\n      descriptorOrOverrides = this.getDescriptorOverrides();\n    }\n\n    const requestSize = undefined !== pageOptions && 0 === pageOptions.start && undefined !== pageOptions.size;\n    const options = { ...this.createRequestOptions(), paging: pageOptions };\n    if (requestSize)\n      return Presentation.presentation.getContentAndSize(options, descriptorOrOverrides, this.keys);\n\n    const content = await Presentation.presentation.getContent(options, descriptorOrOverrides, this.keys);\n    if (!content)\n      return undefined;\n\n    const size = (undefined === pageOptions || undefined === pageOptions.size) ? content.contentSet.length : undefined;\n    return { content, size };\n  }, createKeyForPageOptions);\n}\n\nconst createKeyForPageOptions = (pageOptions?: PageOptions) => {\n  if (!pageOptions)\n    return \"0/0\";\n  return `${(pageOptions.start) ? pageOptions.start : 0}/${(pageOptions.size) ? pageOptions.size : 0}`;\n};\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\n/**\n * Position of a page in a container.\n * @internal\n */\nexport interface Position {\n  index: number;\n  start: number;\n  end: number;\n}\n\n/**\n * A structure to store a page of data\n * @internal\n */\nexport interface Page<TItem> {\n  readonly position: Position;\n  items?: TItem[];\n}\n\n/**\n * Container which helps with paging by manages specified number of pages\n * and disposing others\n * @internal\n */\nexport class PageContainer<TItem, TPage extends Page<TItem> = Page<TItem>> {\n  private _pageSize: number;\n  private _maxPages: number;\n  private _pages: TPage[] = [];\n\n  /** Constructor */\n  constructor(pageSize: number, maxPages: number) {\n    this._pageSize = pageSize;\n    this._maxPages = maxPages;\n  }\n\n  /** Get page size used by this container */\n  public get pageSize() { return this._pageSize; }\n  public set pageSize(value: number) {\n    if (this._pageSize === value)\n      return;\n    this._pageSize = value;\n    this.invalidatePages();\n  }\n\n  /** Drop all pages */\n  public invalidatePages(): void { this._pages = []; }\n\n  /** Get a page containing an item with the specified index. */\n  public getPage(itemIndex: number): TPage | undefined {\n    for (const page of this._pages) {\n      if (page.position.start <= itemIndex && itemIndex <= page.position.end)\n        return page;\n    }\n    return undefined;\n  }\n\n  /**\n   * Get item at the specified index or undefined if\n   * there's no item with such index loaded.\n   */\n  public getItem(index: number): TItem | undefined {\n    const page = this.getPage(index);\n    if (!page || !page.items)\n      return undefined;\n    return page.items[index - page.position.start];\n  }\n\n  /** Get index of the specified item */\n  public getIndex(item: TItem): number {\n    for (const page of this._pages) {\n      if (!page.items)\n        continue;\n      for (let i = 0; i < page.items.length; ++i) {\n        const row = page.items[i];\n        if (row === item)\n          return page.position.start + i;\n      }\n    }\n    return -1;\n  }\n\n  /** Reserve space for a page */\n  public reservePage(index: number): TPage {\n    // find the place for the new page to insert\n    let pageIndex: number = 0;\n    for (const p of this._pages) {\n      if (p.position.start >= index)\n        break;\n      pageIndex++;\n    }\n    const pageBefore = (pageIndex > 0) ? this._pages[pageIndex - 1] : undefined;\n    const pageAfter = (pageIndex < this._pages.length) ? this._pages[pageIndex] : undefined;\n\n    // determine the start of the page for the specified index\n    let pageStartIndex = index;\n    let pageSize = this.pageSize;\n    if (undefined !== pageAfter && pageStartIndex > pageAfter.position.start - this.pageSize) {\n      pageStartIndex = pageAfter.position.start - this.pageSize;\n    }\n    if (undefined !== pageBefore && pageBefore.position.end > pageStartIndex) {\n      pageStartIndex = pageBefore.position.end + 1;\n    }\n    if (pageBefore && pageAfter && (pageAfter.position.start - pageBefore.position.end) < pageSize)\n      pageSize = pageAfter.position.start - pageBefore.position.end - 1;\n    if (pageStartIndex < 0) {\n      pageSize += pageStartIndex;\n      pageStartIndex = 0;\n    }\n    if (pageSize <= 0)\n      throw new Error(\"Invalid page size\");\n\n    // insert the new page\n    const position = {\n      index: pageIndex,\n      start: pageStartIndex,\n      end: pageStartIndex + pageSize - 1,\n    };\n    const page = { position } as any;\n    this._pages.splice(position.index, 0, page);\n    this.reIndexPages(position.index);\n    this.disposeFarthestPages(position);\n    return page;\n  }\n\n  private reIndexPages(startIndex: number): void {\n    for (let i = startIndex + 1; i < this._pages.length; ++i)\n      this._pages[i].position.index = i;\n  }\n\n  private disposeFarthestPages(position: Position): void {\n    if (this._pages.length > this._maxPages) {\n      // we drop the page that's furthest from the newly created one\n      const distanceToFront = position.index;\n      const distanceToBack = this._pages.length - position.index - 1;\n      if (distanceToBack > distanceToFront)\n        this._pages.pop();\n      else\n        this._pages.splice(0, 1);\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport { Node } from \"@bentley/presentation-common\";\n\n/** @internal */\nexport interface ColorMap {\n  [name: string]: number;\n}\n\nconst colors: ColorMap = {\n  AliceBlue: 0xF0F8FFFF,\n  AntiqueWhite: 0xFAEBD7FF,\n  Aqua: 0x00FFFFFF,\n  Aquamarine: 0x7FFFD4FF,\n  Azure: 0xF0FFFFFF,\n  Beige: 0xF5F5DCFF,\n  Bisque: 0xFFE4C4FF,\n  Black: 0x000000FF,\n  BlanchedAlmond: 0xFFEBCDFF,\n  Blue: 0x0000FFFF,\n  BlueViolet: 0x8A2BE2FF,\n  Brown: 0xA52A2AFF,\n  BurlyWood: 0xDEB887FF,\n  CadetBlue: 0x5F9EA0FF,\n  Chartreuse: 0x7FFF00FF,\n  Chocolate: 0xD2691EFF,\n  Coral: 0xFF7F50FF,\n  CornflowerBlue: 0x6495EDFF,\n  Cornsilk: 0xFFF8DCFF,\n  Crimson: 0xDC143CFF,\n  Cyan: 0x00FFFFFF,\n  DarkBlue: 0x00008BFF,\n  DarkCyan: 0x008B8BFF,\n  DarkGoldenrod: 0xB8860BFF,\n  DarkGray: 0xA9A9A9FF,\n  DarkGreen: 0x006400FF,\n  DarkKhaki: 0xBDB76BFF,\n  DarkMagenta: 0x8B008BFF,\n  DarkOliveGreen: 0x556B2FFF,\n  DarkOrange: 0xFF8C00FF,\n  DarkOrchid: 0x9932CCFF,\n  DarkRed: 0x8B0000FF,\n  DarkSalmon: 0xE9967AFF,\n  DarkSeaGreen: 0x8FBC8BFF,\n  DarkSlateBlue: 0x483D8BFF,\n  DarkSlateGray: 0x2F4F4FFF,\n  DarkTurquoise: 0x00CED1FF,\n  DarkViolet: 0x9400D3FF,\n  DeepPink: 0xFF1493FF,\n  DeepSkyBlue: 0x00BFFFFF,\n  DimGray: 0x696969FF,\n  DodgerBlue: 0x1E90FFFF,\n  Firebrick: 0xB22222FF,\n  FloralWhite: 0xFFFAF0FF,\n  ForestGreen: 0x228B22FF,\n  Fuchsia: 0xFF00FFFF,\n  Gainsboro: 0xDCDCDCFF,\n  GhostWhite: 0xF8F8FFFF,\n  Gold: 0xFFD700FF,\n  Goldenrod: 0xDAA520FF,\n  Gray: 0x808080FF,\n  Green: 0x008000FF,\n  GreenYellow: 0xADFF2FFF,\n  Honeydew: 0xF0FFF0FF,\n  HotPink: 0xFF69B4FF,\n  IndianRed: 0xCD5C5CFF,\n  Indigo: 0x4B0082FF,\n  Ivory: 0xFFFFF0FF,\n  Khaki: 0xF0E68CFF,\n  Lavender: 0xE6E6FAFF,\n  LavenderBlush: 0xFFF0F5FF,\n  LawnGreen: 0x7CFC00FF,\n  LemonChiffon: 0xFFFACDFF,\n  LightBlue: 0xADD8E6FF,\n  LightCoral: 0xF08080FF,\n  LightCyan: 0xE0FFFFFF,\n  LightGoldenrodYellow: 0xFAFAD2FF,\n  LightGray: 0xD3D3D3FF,\n  LightGreen: 0x90EE90FF,\n  LightPink: 0xFFB6C1FF,\n  LightSalmon: 0xFFA07AFF,\n  LightSeaGreen: 0x20B2AAFF,\n  LightSkyBlue: 0x87CEFAFF,\n  LightSlateGray: 0x778899FF,\n  LightSteelBlue: 0xB0C4DEFF,\n  LightYellow: 0xFFFFE0FF,\n  Lime: 0x00FF00FF,\n  LimeGreen: 0x32CD32FF,\n  Linen: 0xFAF0E6FF,\n  Magenta: 0xFF00FFFF,\n  Maroon: 0x800000FF,\n  MediumAquamarine: 0x66CDAAFF,\n  MediumBlue: 0x0000CDFF,\n  MediumOrchid: 0xBA55D3FF,\n  MediumPurple: 0x9370DBFF,\n  MediumSeaGreen: 0x3CB371FF,\n  MediumSlateBlue: 0x7B68EEFF,\n  MediumSpringGreen: 0x00FA9AFF,\n  MediumTurquoise: 0x48D1CCFF,\n  MediumVioletRed: 0xC71585FF,\n  MidnightBlue: 0x191970FF,\n  MintCream: 0xF5FFFAFF,\n  MistyRose: 0xFFE4E1FF,\n  Moccasin: 0xFFE4B5FF,\n  NavajoWhite: 0xFFDEADFF,\n  Navy: 0x000080FF,\n  OldLace: 0xFDF5E6FF,\n  Olive: 0x808000FF,\n  OliveDrab: 0x6B8E23FF,\n  Orange: 0xFFA500FF,\n  OrangeRed: 0xFF4500FF,\n  Orchid: 0xDA70D6FF,\n  PaleGoldenrod: 0xEEE8AAFF,\n  PaleGreen: 0x98FB98FF,\n  PaleTurquoise: 0xAFEEEEFF,\n  PaleVioletRed: 0xDB7093FF,\n  PapayaWhip: 0xFFEFD5FF,\n  PeachPuff: 0xFFDAB9FF,\n  Peru: 0xCD853FFF,\n  Pink: 0xFFC0CBFF,\n  Plum: 0xDDA0DDFF,\n  PowderBlue: 0xB0E0E6FF,\n  Purple: 0x800080FF,\n  Red: 0xFF0000FF,\n  RosyBrown: 0xBC8F8FFF,\n  RoyalBlue: 0x4169E1FF,\n  SaddleBrown: 0x8B4513FF,\n  Salmon: 0xFA8072FF,\n  SandyBrown: 0xF4A460FF,\n  SeaGreen: 0x2E8B57FF,\n  SeaShell: 0xFFF5EEFF,\n  Sienna: 0xA0522DFF,\n  Silver: 0xC0C0C0FF,\n  SkyBlue: 0x87CEEBFF,\n  SlateBlue: 0x6A5ACDFF,\n  SlateGray: 0x708090FF,\n  Snow: 0xFFFAFAFF,\n  SpringGreen: 0x00FF7FFF,\n  SteelBlue: 0x4682B4FF,\n  Tan: 0xD2B48CFF,\n  Teal: 0x008080FF,\n  Thistle: 0xD8BFD8FF,\n  Tomato: 0xFF6347FF,\n  Transparent: 0xFFFFFFFF,\n  Turquoise: 0x40E0D0FF,\n  Violet: 0xEE82EEFF,\n  Wheat: 0xF5DEB3FF,\n  White: 0xFFFFFFFF,\n  WhiteSmoke: 0xF5F5F5FF,\n  Yellow: 0xFFFF00FF,\n  YellowGreen: 0x9ACD32FF,\n};\n\n/** @internal */\nexport class StyleHelper {\n  public static get availableColors(): ColorMap { return colors; }\n\n  private static getColor(name: string): number {\n    name = name.trim();\n    if (name.indexOf(\"#\") === 0 && name.length === 7)\n      return StyleHelper.getColorFromHex(name);\n    else if (name.toUpperCase().indexOf(\"RGB(\") === 0)\n      return StyleHelper.getColorFromRGB(name);\n    return StyleHelper.getColorFromColorName(name);\n  }\n\n  /** Get color number from a named color. @see `colors` map for available names. */\n  private static getColorFromColorName(name: string): number {\n    if (colors.hasOwnProperty(name))\n      return colors[name];\n    throw new Error(\"Invalid color name\");\n  }\n\n  /** Get color number from an RGB format: `rgb(r,g,b)` */\n  private static getColorFromRGB(name: string): number {\n    name = name.substring(name.indexOf(\"(\") + 1, name.indexOf(\")\"));\n    const components = name.split(\",\");\n    const r: number = Number(components[0]);\n    const g: number = Number(components[1]);\n    const b: number = Number(components[2]);\n    return r << 24 | g << 16 | b << 8 | 255;\n  }\n\n  /** Get color number from HEX format: `#ff3300` */\n  private static getColorFromHex(name: string): number {\n    name = name.substr(1, 7);\n    let color: number = parseInt(\"0x\" + name, 16);\n    color = color << 8 | 255;\n    return color;\n  }\n\n  public static isBold(node: Node): boolean { return node.fontStyle ? (node.fontStyle.indexOf(\"Bold\") !== -1) : false; }\n  public static isItalic(node: Node): boolean { return node.fontStyle ? (node.fontStyle.indexOf(\"Italic\") !== -1) : false; }\n  public static getForeColor(node: Node): number | undefined { return node.foreColor ? StyleHelper.getColor(node.foreColor) : undefined; }\n  public static getBackColor(node: Node): number | undefined { return node.backColor ? StyleHelper.getColor(node.backColor) : undefined; }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Core */\n\nimport * as React from \"react\";\nimport { I18NNamespace } from \"@bentley/imodeljs-i18n\";\nimport { Presentation } from \"@bentley/presentation-frontend\";\n\n/**\n * An interface of something that has a priority.\n * @internal\n */\nexport interface IPrioritized {\n  priority: number;\n}\n\n/**\n * A sorting algorithm for `Array.sort` that sorts items by priority.\n * Higher priority items appear first in the list.\n *\n * @internal\n */\nexport const prioritySortFunction = (a: IPrioritized, b: IPrioritized): number => {\n  if (a.priority > b.priority)\n    return -1;\n  if (a.priority < b.priority)\n    return 1;\n  return 0;\n};\n\nlet localizationNamespace: I18NNamespace | undefined;\n/**\n * Translate a string with the specified id from `PresentationComponents`\n * localization namespace. The `stringId` should not contain namespace - it's\n * prepended automatically.\n *\n * @internal\n */\nexport const translate = async (stringId: string): Promise<string> => {\n  const localizationNamespaceName = \"PresentationComponents\";\n  if (!localizationNamespace) {\n    localizationNamespace = Presentation.i18n.registerNamespace(localizationNamespaceName);\n  }\n  await localizationNamespace.readFinished;\n  stringId = `${localizationNamespaceName}:${stringId}`;\n  return Presentation.i18n.translate(stringId);\n};\n\n/**\n * Creates a display name for the supplied component\n * @internal\n */\nexport const getDisplayName = <P>(component: React.ComponentType<P>): string => {\n  if (component.displayName)\n    return component.displayName;\n  if (component.name)\n    return component.name;\n  return \"Component\";\n};\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module DisplayLabels */\r\n\r\nimport * as _ from \"lodash\";\r\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\r\nimport { InstanceKey } from \"@bentley/presentation-common\";\r\nimport { Presentation } from \"@bentley/presentation-frontend\";\r\n\r\n/**\r\n * Interface for presentation rules-driven labels provider.\r\n * @public\r\n */\r\nexport interface IPresentationLabelsProvider {\r\n  /** [[IModelConnection]] used by this data provider */\r\n  readonly imodel: IModelConnection;\r\n  /**\r\n   * Get label for instance identified with the given key.\r\n   */\r\n  getLabel(key: InstanceKey): Promise<string>;\r\n  /**\r\n   * Get labels for instances identified with the given keys.\r\n   */\r\n  getLabels(keys: InstanceKey[]): Promise<string[]>;\r\n}\r\n\r\n/**\r\n * Presentation Rules-driven labels provider implementation.\r\n * @public\r\n */\r\nexport class LabelsProvider implements IPresentationLabelsProvider {\r\n\r\n  public readonly imodel: IModelConnection;\r\n\r\n  /** Constructor. */\r\n  constructor(imodel: IModelConnection) {\r\n    this.imodel = imodel;\r\n  }\r\n\r\n  private async getLabelInternal(key: InstanceKey) {\r\n    return Presentation.presentation.getDisplayLabel({ imodel: this.imodel }, key);\r\n  }\r\n\r\n  // tslint:disable-next-line:naming-convention\r\n  private getMemoizedLabel = _.memoize(this.getLabelInternal, (k) => JSON.stringify(k));\r\n\r\n  /**\r\n   * Returns label for the specified instance key\r\n   * @param key Key of instance to get label for\r\n   * @param memoize Should the result the memoized by the provider.\r\n   */\r\n  public async getLabel(key: InstanceKey, memoize = false): Promise<string> {\r\n    return memoize ? this.getMemoizedLabel(key) : this.getLabelInternal(key);\r\n  }\r\n\r\n  private async getLabelsInternal(keys: InstanceKey[]) {\r\n    return Presentation.presentation.getDisplayLabels({ imodel: this.imodel }, keys);\r\n  }\r\n\r\n  // tslint:disable-next-line:naming-convention\r\n  private getMemoizedLabels = _.memoize(this.getLabelsInternal, (k) => JSON.stringify(k));\r\n\r\n  /**\r\n   * Returns labels for the specified instance keys.\r\n   * @param keys Keys of instances to get labels for\r\n   * @param memoize Should the result be memoized by the provider.\r\n   */\r\n  public async getLabels(keys: InstanceKey[], memoize = false): Promise<string[]> {\r\n    return memoize ? this.getMemoizedLabels(keys) : this.getLabelsInternal(keys);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Components */\r\n\r\n/** @module Common */\r\nexport { IPresentationDataProvider } from \"./common/IPresentationDataProvider\";\r\nexport { ContentBuilder } from \"./common/ContentBuilder\";\r\nexport { IContentDataProvider, ContentDataProvider, CacheInvalidationProps } from \"./common/ContentDataProvider\";\r\nexport { DataProvidersFactory, DataProvidersFactoryProps } from \"./DataProvidersFactory\";\r\n\r\n/** @module PropertyGrid */\r\nexport { IPresentationPropertyDataProvider, PresentationPropertyDataProvider } from \"./propertygrid/DataProvider\";\r\nexport { propertyGridWithUnifiedSelection, PropertyGridWithUnifiedSelectionProps } from \"./propertygrid/WithUnifiedSelection\";\r\n\r\n/** @module Table */\r\nexport { IPresentationTableDataProvider, PresentationTableDataProvider, PresentationTableDataProviderProps } from \"./table/DataProvider\";\r\nexport { tableWithUnifiedSelection, TableWithUnifiedSelectionProps } from \"./table/WithUnifiedSelection\";\r\n\r\n/** @module Tree */\r\nexport { PresentationTreeDataProvider } from \"./tree/DataProvider\";\r\nexport { IPresentationTreeDataProvider } from \"./tree/IPresentationTreeDataProvider\";\r\nexport { treeWithUnifiedSelection, TreeWithUnifiedSelectionProps } from \"./tree/WithUnifiedSelection\";\r\nexport { treeWithFilteringSupport, TreeWithFilteringSupportProps } from \"./tree/WithFilteringSupport\";\r\n\r\n/** @module Viewport */\r\nexport { viewWithUnifiedSelection, ViewWithUnifiedSelectionProps } from \"./viewport/WithUnifiedSelection\";\r\n\r\n/** @module DisplayLabels */\r\nexport { IPresentationLabelsProvider, LabelsProvider } from \"./labels/LabelsProvider\";\r\n\r\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\r\ndeclare var BUILD_SEMVER: string;\r\n/* istanbul ignore next */\r\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\r\n  if (!(window as any).iModelJsVersions)\r\n    (window as any).iModelJsVersions = new Map<string, string>();\r\n  (window as any).iModelJsVersions.set(\"presentation-components\", BUILD_SEMVER);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module PropertyGrid */\n\nimport * as _ from \"lodash\";\nimport {\n  PropertyData, PropertyDataChangeEvent, PropertyCategory, IPropertyDataProvider,\n} from \"@bentley/ui-components\";\nimport { IModelConnection, PropertyRecord, PropertyValueFormat, PropertyValue } from \"@bentley/imodeljs-frontend\";\nimport {\n  CategoryDescription, Descriptor, DescriptorOverrides,\n  Field, NestedContentField, DefaultContentDisplayTypes, Item,\n  PresentationError, PresentationStatus, ContentFlags,\n} from \"@bentley/presentation-common\";\nimport { ContentDataProvider, IContentDataProvider, CacheInvalidationProps } from \"../common/ContentDataProvider\";\nimport { ContentBuilder } from \"../common/ContentBuilder\";\nimport { prioritySortFunction, translate } from \"../common/Utils\";\n\nconst favoritesCategoryName = \"Favorite\";\nlet favoritesCategoryPromise: Promise<CategoryDescription> | undefined;\nconst getFavoritesCategory = async (): Promise<CategoryDescription> => {\n  if (!favoritesCategoryPromise) {\n    favoritesCategoryPromise = Promise.all([\n      translate(\"categories.favorite.label\"),\n      translate(\"categories.favorite.description\"),\n    ]).then(([label, description]): CategoryDescription => ({\n      name: favoritesCategoryName,\n      label,\n      description,\n      priority: Number.MAX_VALUE,\n      expand: true,\n    }));\n  }\n  return favoritesCategoryPromise;\n};\n\ninterface PropertyPaneCallbacks {\n  isFavorite(field: Field): boolean;\n  isHidden(field: Field): boolean;\n  sortCategories(categories: CategoryDescription[]): void;\n  sortFields(category: CategoryDescription, fields: Field[]): void;\n}\n\ninterface CategorizedFields {\n  categories: CategoryDescription[];\n  fields: { [categoryName: string]: Field[] };\n}\n\ninterface CategorizedRecords {\n  categories: PropertyCategory[];\n  records: { [categoryName: string]: PropertyRecord[] };\n}\n\nconst isValueEmpty = (v: PropertyValue): boolean => {\n  switch (v.valueFormat) {\n    case PropertyValueFormat.Primitive:\n      return (null === v.value || undefined === v.value || \"\" === v.value);\n    case PropertyValueFormat.Array:\n      return 0 === v.items.length;\n    case PropertyValueFormat.Struct:\n      return 0 === Object.keys(v.members).length;\n  }\n  /* istanbul ignore next */\n  throw new PresentationError(PresentationStatus.InvalidArgument, \"Unknown property value format\");\n};\n\nclass PropertyDataBuilder {\n  private _descriptor: Descriptor;\n  private _contentItem: Item;\n  private _includeWithNoValues: boolean;\n  private _callbacks: PropertyPaneCallbacks;\n\n  constructor(descriptor: Descriptor, item: Item, includeWithNoValues: boolean, callbacks: PropertyPaneCallbacks) {\n    this._descriptor = descriptor;\n    this._contentItem = item;\n    this._callbacks = callbacks;\n    this._includeWithNoValues = includeWithNoValues;\n  }\n\n  private async createCategorizedFields(): Promise<CategorizedFields> {\n    const favoritesCategory = await getFavoritesCategory();\n    const categories = new Array<CategoryDescription>();\n    const categoryFields: { [categoryName: string]: Field[] } = {};\n    const includeField = (category: CategoryDescription, field: Field, onlyIfFavorite: boolean) => {\n      if (field.isNestedContentField()) {\n        includeFields(field.nestedFields, true);\n      }\n      if (onlyIfFavorite && favoritesCategoryName !== field.category.name)\n        return;\n      if (!categoryFields.hasOwnProperty(category.name)) {\n        categories.push(category);\n        categoryFields[category.name] = new Array<Field>();\n      }\n      categoryFields[category.name].push(field);\n    };\n    const includeFields = (fields: Field[], onlyIfFavorite: boolean) => {\n      fields.forEach((field) => {\n        if (favoritesCategoryName !== field.category.name && this._callbacks.isFavorite(field))\n          includeField(favoritesCategory, field, false);\n        includeField(field.category, field, onlyIfFavorite);\n      });\n    };\n    includeFields(this._descriptor.fields, false);\n\n    // sort categories\n    this._callbacks.sortCategories(categories);\n\n    // sort fields\n    for (const category of categories)\n      this._callbacks.sortFields(category, categoryFields[category.name]);\n\n    return {\n      categories,\n      fields: categoryFields,\n    } as CategorizedFields;\n  }\n\n  private createRecord(field: Field): PropertyRecord {\n    let pathToRootField: Field[] | undefined;\n    if (field.parent) {\n      pathToRootField = [field];\n      let parentField = field.parent;\n      while (parentField.parent) {\n        pathToRootField.push(parentField);\n        parentField = parentField.parent;\n      }\n      field = parentField;\n      pathToRootField.reverse();\n    }\n    return ContentBuilder.createPropertyRecord(field, this._contentItem, pathToRootField);\n  }\n\n  private createCategorizedRecords(fields: CategorizedFields): CategorizedRecords {\n    const result: CategorizedRecords = {\n      categories: [],\n      records: {},\n    };\n    for (const category of fields.categories) {\n      const records = new Array<PropertyRecord>();\n      const addRecord = (field: Field, record: PropertyRecord) => {\n        if (category.name !== favoritesCategoryName) {\n          // note: favorite fields should be displayed even if they're hidden\n          if (this._callbacks.isHidden(field))\n            return;\n          if (!this._includeWithNoValues && !record.isMerged && isValueEmpty(record.value))\n            return;\n        }\n        records.push(record);\n      };\n      const handleNestedContentRecord = (field: NestedContentField, record: PropertyRecord) => {\n        if (1 === fields.fields[category.name].length) {\n          // note: special handling if this is the only field in the category\n          if (record.value.valueFormat === PropertyValueFormat.Array && 0 === record.value.items.length) {\n            // don't include empty arrays at all\n            return;\n          }\n          if (record.value.valueFormat === PropertyValueFormat.Struct) {\n            // for structs just include all their members\n            for (const nestedField of field.nestedFields)\n              addRecord(nestedField, record.value.members[nestedField.name]);\n            return;\n          }\n        }\n        addRecord(field, record);\n      };\n\n      // create/add records for each field\n      for (const field of fields.fields[category.name]) {\n        const record = this.createRecord(field);\n        if (field.isNestedContentField())\n          handleNestedContentRecord(field, record);\n        else\n          addRecord(field, record);\n      }\n\n      if (records.length === 0) {\n        // don't create the category if it has no records\n        continue;\n      }\n\n      result.categories.push({\n        name: category.name,\n        label: category.label,\n        expand: category.expand,\n      });\n      result.records[category.name] = records;\n    }\n    return result;\n  }\n\n  public async buildPropertyData(): Promise<PropertyData> {\n    const fields = await this.createCategorizedFields();\n    const records = this.createCategorizedRecords(fields);\n    return {\n      ...records,\n      label: this._contentItem.label,\n      description: this._contentItem.classInfo ? this._contentItem.classInfo.label : undefined,\n    } as PropertyData;\n  }\n}\n\n/**\n * Interface for presentation rules-driven property data provider.\n * @public\n */\nexport type IPresentationPropertyDataProvider = IPropertyDataProvider & IContentDataProvider;\n\n/**\n * Presentation Rules-driven property data provider implementation.\n * @public\n */\nexport class PresentationPropertyDataProvider extends ContentDataProvider implements IPresentationPropertyDataProvider {\n  private _includeFieldsWithNoValues: boolean;\n  public onDataChanged = new PropertyDataChangeEvent();\n\n  /** Constructor. */\n  constructor(imodel: IModelConnection, rulesetId: string) {\n    super(imodel, rulesetId, DefaultContentDisplayTypes.PropertyPane);\n    this._includeFieldsWithNoValues = true;\n  }\n\n  protected invalidateCache(props: CacheInvalidationProps): void {\n    super.invalidateCache(props);\n    if (this.getMemoizedData)\n      this.getMemoizedData.cache.clear!();\n    if (this.onDataChanged)\n      this.onDataChanged.raiseEvent();\n  }\n\n  /**\n   * Tells the data provider to _not_ request descriptor and instead configure\n   * content using `getDescriptorOverrides()` call\n   */\n  protected shouldConfigureContentDescriptor(): boolean { return false; }\n\n  /**\n   * Provides content configuration for the property grid\n   */\n  protected getDescriptorOverrides(): DescriptorOverrides {\n    return {\n      ...super.getDescriptorOverrides(),\n      contentFlags: ContentFlags.ShowLabels | ContentFlags.MergeResults,\n    };\n  }\n\n  /**\n   * Hides the computed display label field from the list of properties\n   */\n  protected isFieldHidden(field: Field) {\n    return field.name === \"/DisplayLabel/\";\n  }\n\n  /**\n   * Should fields with no values be included in the property list. No value means:\n   * - For *primitive* fields: null, undefined, \"\" (empty string)\n   * - For *array* fields: [] (empty array)\n   * - For *struct* fields: {} (object with no members)\n   */\n  public get includeFieldsWithNoValues(): boolean { return this._includeFieldsWithNoValues; }\n  public set includeFieldsWithNoValues(value: boolean) {\n    if (this._includeFieldsWithNoValues === value)\n      return;\n    this._includeFieldsWithNoValues = value;\n    this.invalidateCache({ content: true });\n  }\n\n  /** Should the specified field be included in the favorites category. */\n  protected isFieldFavorite(_field: Field): boolean { return false; }\n\n  /**\n   * Sorts the specified list of categories by priority. May be overriden\n   * to supply a different sorting algorithm.\n   */\n  protected sortCategories(categories: CategoryDescription[]): void {\n    categories.sort(prioritySortFunction);\n  }\n\n  /**\n   * Sorts the specified list of fields by priority. May be overriden\n   * to supply a different sorting algorithm.\n   */\n  protected sortFields(_category: CategoryDescription, fields: Field[]): void {\n    fields.sort(prioritySortFunction);\n  }\n\n  /**\n   * Returns property data.\n   */\n  // tslint:disable-next-line:naming-convention\n  protected getMemoizedData = _.memoize(async (): Promise<PropertyData> => {\n    const content = await this.getContent();\n    if (!content || 0 === content.contentSet.length)\n      return createDefaultPropertyData();\n\n    const contentItem = content.contentSet[0];\n    const callbacks: PropertyPaneCallbacks = {\n      isFavorite: this.isFieldFavorite,\n      isHidden: this.isFieldHidden,\n      sortCategories: this.sortCategories,\n      sortFields: this.sortFields,\n    };\n    const builder = new PropertyDataBuilder(content.descriptor, contentItem,\n      this.includeFieldsWithNoValues, callbacks);\n    return builder.buildPropertyData();\n  });\n\n  /**\n   * Returns property data.\n   */\n  public async getData(): Promise<PropertyData> {\n    return this.getMemoizedData();\n  }\n}\n\nconst createDefaultPropertyData = (): PropertyData => ({\n  label: \"\",\n  categories: [],\n  records: {},\n});\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport * as React from \"react\";\nimport { KeySet } from \"@bentley/presentation-common\";\nimport { Presentation, SelectionHandler, SelectionChangeEventArgs } from \"@bentley/presentation-frontend\";\nimport { PropertyGridProps } from \"@bentley/ui-components\";\nimport { getDisplayName, translate } from \"../common/Utils\";\nimport { IUnifiedSelectionComponent } from \"../common/IUnifiedSelectionComponent\";\nimport { IPresentationPropertyDataProvider } from \"./DataProvider\";\nimport \"./WithUnifiedSelection.scss\";\n\nconst DEFAULT_REQUESTED_CONTENT_INSTANCES_LIMIT = 100;\n\n/**\n * Props that are injected to the PropertyGridWithUnifiedSelection HOC component.\n * @public\n */\nexport interface PropertyGridWithUnifiedSelectionProps {\n  /** The data provider used by the property grid. */\n  dataProvider: IPresentationPropertyDataProvider;\n\n  /**\n   * Maximum number of instances to request content for.\n   * Defaults to `100`.\n   */\n  requestedContentInstancesLimit?: number;\n\n  /** @internal */\n  selectionHandler?: SelectionHandler;\n}\n\ninterface State {\n  overLimit?: boolean;\n  localizedStrings?: {\n    tooManyElements: string;\n  };\n}\n\n/**\n * A HOC component that adds unified selection functionality to the supplied\n * property grid component.\n *\n * **Note:** it is required for the property grid to use [[IPresentationPropertyDataProvider]]\n *\n * @public\n */\n// tslint:disable-next-line: variable-name naming-convention\nexport function propertyGridWithUnifiedSelection<P extends PropertyGridProps>(PropertyGridComponent: React.ComponentType<P>): React.ComponentType<P & PropertyGridWithUnifiedSelectionProps> {\n\n  type CombinedProps = P & PropertyGridWithUnifiedSelectionProps;\n\n  return class WithUnifiedSelection extends React.Component<CombinedProps, State> implements IUnifiedSelectionComponent {\n\n    private _selectionHandler?: SelectionHandler;\n    private _isMounted?: boolean;\n\n    public constructor(props: CombinedProps) {\n      super(props);\n      this.state = {};\n      this.initLocalizedStrings(); // tslint:disable-line:no-floating-promises\n    }\n\n    private async initLocalizedStrings() {\n      const localizedStrings = {\n        tooManyElements: await translate(\"property-grid.too-many-elements-selected\"),\n      };\n      if (this._isMounted)\n        this.setState({ localizedStrings });\n    }\n\n    /** Returns the display name of this component */\n    public static get displayName() { return `WithUnifiedSelection(${getDisplayName(PropertyGridComponent)})`; }\n\n    /** Get selection handler used by this property grid */\n    public get selectionHandler(): SelectionHandler | undefined { return this._selectionHandler; }\n\n    /** Get ID of the ruleset used by this unified selection property grid */\n    public get rulesetId() { return this.props.dataProvider.rulesetId; }\n\n    /** Get imodel used by this property grid to query property data */\n    public get imodel() { return this.props.dataProvider.imodel; }\n\n    // tslint:disable-next-line: naming-convention\n    private get requestedContentInstancesLimit() {\n      if (undefined === this.props.requestedContentInstancesLimit)\n        return DEFAULT_REQUESTED_CONTENT_INSTANCES_LIMIT;\n      return this.props.requestedContentInstancesLimit;\n    }\n\n    public componentDidMount() {\n      const name = `PropertyGrid_${counter++}`;\n      const imodel = this.props.dataProvider.imodel;\n      const rulesetId = this.props.dataProvider.rulesetId;\n      this._isMounted = true;\n      this._selectionHandler = this.props.selectionHandler\n        ? this.props.selectionHandler : new SelectionHandler(Presentation.selection, name, imodel, rulesetId);\n      this._selectionHandler!.onSelect = this.onSelectionChanged;\n      this.updateDataProviderSelection();\n    }\n\n    public componentWillUnmount() {\n      if (this._selectionHandler)\n        this._selectionHandler.dispose();\n      this._isMounted = false;\n    }\n\n    public componentDidUpdate() {\n      if (this._selectionHandler) {\n        this._selectionHandler.imodel = this.props.dataProvider.imodel;\n        this._selectionHandler.rulesetId = this.props.dataProvider.rulesetId;\n      }\n    }\n\n    private getSelectedKeys(selectionLevel?: number): KeySet | undefined {\n      if (undefined === selectionLevel) {\n        const availableLevels = this._selectionHandler!.getSelectionLevels();\n        if (0 === availableLevels.length)\n          return undefined;\n        selectionLevel = availableLevels[availableLevels.length - 1];\n      }\n\n      for (let i = selectionLevel; i >= 0; i--) {\n        const selection = this._selectionHandler!.getSelection(i);\n        if (!selection.isEmpty)\n          return new KeySet(selection);\n      }\n      return new KeySet();\n    }\n\n    private setDataProviderSelection(selection: KeySet): void {\n      this.props.dataProvider.keys = selection;\n    }\n\n    private updateDataProviderSelection(selectionLevel?: number) {\n      const selection = this.getSelectedKeys(selectionLevel);\n      if (selection) {\n        if (selection.size > this.requestedContentInstancesLimit) {\n          this.setState({ overLimit: true });\n          this.setDataProviderSelection(new KeySet());\n        } else {\n          this.setState({ overLimit: false });\n          this.setDataProviderSelection(selection);\n        }\n      }\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onSelectionChanged = (evt: SelectionChangeEventArgs): void => {\n      this.updateDataProviderSelection(evt.level);\n    }\n\n    public render() {\n      const {\n        selectionHandler, // do not bleed our props\n        requestedContentInstancesLimit,\n        ...props\n      } = this.props as any;\n\n      let content;\n      if (this.state.overLimit) {\n        content = (<span>{this.state.localizedStrings ? this.state.localizedStrings.tooManyElements : undefined}</span>);\n      } else {\n        content = (<PropertyGridComponent {...props} />);\n      }\n\n      return (\n        <div className=\"pcomponents-property-grid-with-unified-selection\">\n          {content}\n        </div>\n      );\n    }\n  };\n}\n\nlet counter = 1;\n","\nvar content = require(\"!!../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-0-1!../../../../common/temp/node_modules/.registry.npmjs.org/postcss-loader/2.1.6/node_modules/postcss-loader/lib/index.js??postcss!../../../../common/temp/node_modules/.registry.npmjs.org/fast-sass-loader/1.4.7/node-sass@4.12.0+webpack@4.32.2/node_modules/fast-sass-loader/lib/index.js??ref--5!./WithUnifiedSelection.scss\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../../common/temp/node_modules/.registry.npmjs.org/style-loader/0.21.0/node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-0-1!../../../../common/temp/node_modules/.registry.npmjs.org/postcss-loader/2.1.6/node_modules/postcss-loader/lib/index.js??postcss!../../../../common/temp/node_modules/.registry.npmjs.org/fast-sass-loader/1.4.7/node-sass@4.12.0+webpack@4.32.2/node_modules/fast-sass-loader/lib/index.js??ref--5!./WithUnifiedSelection.scss\", function() {\n\t\tvar newContent = require(\"!!../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-0-1!../../../../common/temp/node_modules/.registry.npmjs.org/postcss-loader/2.1.6/node_modules/postcss-loader/lib/index.js??postcss!../../../../common/temp/node_modules/.registry.npmjs.org/fast-sass-loader/1.4.7/node-sass@4.12.0+webpack@4.32.2/node_modules/fast-sass-loader/lib/index.js??ref--5!./WithUnifiedSelection.scss\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Table */\n\nimport * as _ from \"lodash\";\nimport { SortDirection as UiSortDirection } from \"@bentley/ui-core\";\nimport {\n  TableDataProvider as ITableDataProvider, TableDataChangeEvent,\n  ColumnDescription, RowItem, CellItem,\n} from \"@bentley/ui-components\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport {\n  PresentationError, PresentationStatus,\n  DefaultContentDisplayTypes, Descriptor, SortDirection,\n  Content, Field, PropertyValueFormat, Item, Ruleset,\n  InstanceKey,\n} from \"@bentley/presentation-common\";\nimport { ContentDataProvider, CacheInvalidationProps, IContentDataProvider } from \"../common/ContentDataProvider\";\nimport { ContentBuilder } from \"../common/ContentBuilder\";\nimport { PageContainer, Page } from \"../common/PageContainer\";\nimport { prioritySortFunction } from \"../common/Utils\";\n\ninterface PromisedPage<TItem> extends Page<TItem> {\n  promise?: Promise<void>;\n}\n\n/**\n * The default number of rows in a single page requested by [[PresentationTableDataProvider]]\n * @public\n */\nexport const TABLE_DATA_PROVIDER_DEFAULT_PAGE_SIZE = 20;\n\n/**\n * The default number of pages cached by [[PresentationTableDataProvider]]\n * @public\n */\nexport const TABLE_DATA_PROVIDER_DEFAULT_CACHED_PAGES_COUNT = 5;\n\n/**\n * Interface for presentation rules-driven table data provider.\n * @public\n */\nexport type IPresentationTableDataProvider = ITableDataProvider & IContentDataProvider & {\n  /** Get key of ECInstance that's represented by the supplied row */\n  getRowKey: (row: RowItem) => InstanceKey,\n};\n\n/**\n * Initialization properties for [[PresentationTableDataProvider]]\n * @public\n */\nexport interface PresentationTableDataProviderProps {\n  /** IModel to pull data from */\n  imodel: IModelConnection;\n\n  /** Ruleset or it's ID to be used for creating the content */\n  ruleset: string | Ruleset;\n\n  /** Number of rows in a single page requested from the backend. Defaults to [[TABLE_DATA_PROVIDER_DEFAULT_PAGE_SIZE]] */\n  pageSize?: number;\n\n  /** Number of pages cached in the data provider. Defaults to [[TABLE_DATA_PROVIDER_DEFAULT_CACHED_PAGES_COUNT]] */\n  cachedPagesCount?: number;\n\n  /** Display type to use when requesting data from the backend. Defaults to [[DefaultContentDisplayTypes.GRID]] */\n  displayType?: string;\n}\n\n/**\n * Presentation Rules-driven table data provider.\n * @public\n */\nexport class PresentationTableDataProvider extends ContentDataProvider implements IPresentationTableDataProvider {\n  private _sortColumnKey: string | undefined;\n  private _sortDirection = UiSortDirection.NoSort;\n  private _filterExpression: string | undefined;\n  private _pages: PageContainer<RowItem, PromisedPage<RowItem>>;\n  public onColumnsChanged = new TableDataChangeEvent();\n  public onRowsChanged = new TableDataChangeEvent();\n\n  /** Constructor. */\n  constructor(props: PresentationTableDataProviderProps) {\n    super(props.imodel, props.ruleset, props.displayType || DefaultContentDisplayTypes.Grid);\n    this._pages = new PageContainer(props.pageSize || TABLE_DATA_PROVIDER_DEFAULT_PAGE_SIZE,\n      props.cachedPagesCount || TABLE_DATA_PROVIDER_DEFAULT_CACHED_PAGES_COUNT);\n    this.pagingSize = props.pageSize || TABLE_DATA_PROVIDER_DEFAULT_PAGE_SIZE;\n  }\n\n  /** Get key of ECInstance that's represented by the supplied row */\n  public getRowKey(row: RowItem): InstanceKey {\n    return InstanceKey.fromJSON(JSON.parse(row.key));\n  }\n\n  /**\n   * `ECExpression` for filtering data in the table.\n   */\n  public get filterExpression(): string | undefined { return this._filterExpression; }\n  public set filterExpression(value: string | undefined) {\n    if (this._filterExpression === value)\n      return;\n    this._filterExpression = value;\n    this.invalidateCache({ descriptorConfiguration: true, size: true, content: true });\n  }\n\n  /**\n   * Get the column which is used for sorting data in the table.\n   */\n  public get sortColumn(): Promise<ColumnDescription | undefined> {\n    return (async () => {\n      if (!this._sortColumnKey)\n        return undefined;\n      const columns = await this.getColumns();\n      return columns.find((col) => (col.key === this._sortColumnKey));\n    })();\n  }\n\n  /**\n   * Get key of the column which is used for sorting data in the table.\n   */\n  public get sortColumnKey() { return this._sortColumnKey; }\n\n  /**\n   * Get sort direction. Defaults to `SortDirection.NoSort` which means\n   * undefined sorting.\n   */\n  public get sortDirection() { return this._sortDirection; }\n\n  /**\n   * Sorts the data in this data provider.\n   * @param columnIndex Index of the column to sort on.\n   * @param sortDirection Sorting direction.\n   */\n  public async sort(columnIndex: number, sortDirection: UiSortDirection): Promise<void> {\n    const columns = await this.getColumns();\n    const sortingColumn = columns[columnIndex];\n    if (!sortingColumn)\n      throw new PresentationError(PresentationStatus.InvalidArgument, \"Invalid column index\");\n    this._sortColumnKey = sortingColumn.key;\n    this._sortDirection = sortDirection;\n    this.invalidateCache({ descriptorConfiguration: true, content: true });\n  }\n\n  protected invalidateCache(props: CacheInvalidationProps): void {\n    super.invalidateCache(props);\n\n    if (props.descriptor) {\n      this._filterExpression = undefined;\n      this._sortColumnKey = undefined;\n      this._sortDirection = UiSortDirection.NoSort;\n    }\n\n    if (props.descriptor || props.descriptorConfiguration) {\n      if (this.getColumns)\n        this.getColumns.cache.clear!();\n      if (this.onColumnsChanged)\n        this.onColumnsChanged.raiseEvent();\n    }\n\n    if (props.size || props.content) {\n      if (this._pages)\n        this._pages.invalidatePages();\n      if (this.onRowsChanged)\n        this.onRowsChanged.raiseEvent();\n    }\n  }\n\n  /** Handles filtering and sorting. */\n  protected configureContentDescriptor(descriptor: Readonly<Descriptor>): Descriptor {\n    const configured = super.configureContentDescriptor(descriptor);\n    if (this._sortColumnKey) {\n      configured.sortingField = descriptor.getFieldByName(this._sortColumnKey)!;\n      switch (this._sortDirection) {\n        case UiSortDirection.Descending:\n          configured.sortDirection = SortDirection.Descending;\n          break;\n        case UiSortDirection.Ascending:\n          configured.sortDirection = SortDirection.Ascending;\n          break;\n        default:\n          configured.sortDirection = undefined;\n      }\n    }\n    configured.filterExpression = this._filterExpression;\n    return configured;\n  }\n\n  /**\n   * Returns column definitions.\n   */\n  public getColumns = _.memoize(async (): Promise<ColumnDescription[]> => {\n    const descriptor = await this.getContentDescriptor();\n    return createColumns(descriptor);\n  });\n\n  /**\n   * Get the total number of rows.\n   */\n  public async getRowsCount() {\n    return this.getContentSetSize();\n  }\n\n  /**\n   * Get a single row.\n   * @param rowIndex Index of the row to return.\n   */\n  public async getRow(rowIndex: number): Promise<RowItem> {\n    let page = this._pages.getPage(rowIndex);\n    if (!page) {\n      page = this._pages.reservePage(rowIndex);\n      page.promise = this.getContent({\n        start: page.position.start,\n        size: page.position.end - page.position.start + 1,\n      }).then((c: Content | undefined) => {\n        page!.items = createRows(c);\n      }).catch((e) => {\n        throw e;\n      });\n    }\n    await page.promise;\n    return page.items![rowIndex - page.position.start];\n  }\n\n  /**\n   * Try to get a loaded row. Returns undefined if the row is not currently loaded.\n   * @param rowIndex Index of the row to return.\n   */\n  public getLoadedRow(rowIndex: number): Readonly<RowItem> | undefined {\n    return this._pages.getItem(rowIndex);\n  }\n}\n\nconst createColumns = (descriptor: Readonly<Descriptor> | undefined): ColumnDescription[] => {\n  if (!descriptor)\n    return [];\n  const sortedFields = [...descriptor.fields].sort(prioritySortFunction);\n  return sortedFields.map((field) => createColumn(field));\n};\n\nconst createColumn = (field: Readonly<Field>): ColumnDescription => {\n  return {\n    key: field.name,\n    label: field.label,\n    sortable: true,\n    editable: !field.isReadonly,\n    filterable: (field.type.valueFormat === PropertyValueFormat.Primitive),\n  };\n};\n\nconst createRows = (c: Readonly<Content> | undefined): RowItem[] => {\n  if (!c)\n    return [];\n  return c.contentSet.map((item) => createRow(c.descriptor, item));\n};\n\nconst createRow = (descriptor: Readonly<Descriptor>, item: Readonly<Item>): RowItem => {\n  if (item.primaryKeys.length !== 1) {\n    // note: for table view we expect the record to always have only 1 primary key\n    throw new PresentationError(PresentationStatus.InvalidArgument, \"item.primaryKeys\");\n  }\n  return {\n    key: JSON.stringify(item.primaryKeys[0]),\n    cells: descriptor.fields.map((field): CellItem => ({\n      key: field.name,\n      record: ContentBuilder.createPropertyRecord(field, item),\n    })),\n  };\n};\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport * as React from \"react\";\nimport { KeySet, InstanceKey } from \"@bentley/presentation-common\";\nimport { Presentation, SelectionHandler, SelectionChangeEventArgs } from \"@bentley/presentation-frontend\";\nimport { Table as BaseTable, TableProps, RowItem } from \"@bentley/ui-components\";\nimport { getDisplayName } from \"../common/Utils\";\nimport { IUnifiedSelectionComponent } from \"../common/IUnifiedSelectionComponent\";\nimport { IPresentationTableDataProvider } from \"./DataProvider\";\n\n/**\n * Props that are injected to the TableWithUnifiedSelection HOC component.\n * @public\n */\nexport interface TableWithUnifiedSelectionProps {\n  /** The data provider used by the property grid. */\n  dataProvider: IPresentationTableDataProvider;\n\n  /**\n   * Boundary level of selection used by the table. The table requests\n   * data for selection changes whose level is less than `level` and changes\n   * selection at this `level`.\n   *\n   * Examples:\n   * - `selectionLevel = 0`\n   *   - selection change happens at level `0` - selected rows are adjusted based on new selection at level `0`.\n   *   - selection change happens at level `1` or higher - nothing happens.\n   * - `selectionLevel = 1`\n   *   - selection change happens at level `0` - `dataProvider.keys` is set to current selection. This\n   *     reloads the data in the table.\n   *   - selection change happens at level `1` - selected rows are adjusted based on new selection at level `1`.\n   *   - selection change happens at level `2` or higher - nothing happens.\n   *\n   * Defaults to `1`.\n   */\n  selectionLevel?: number;\n\n  /** @internal */\n  selectionHandler?: SelectionHandler;\n}\n\n/**\n * A HOC component that adds unified selection functionality to the supplied\n * table component.\n *\n * **Note:** it is required for the table to use [[PresentationTableDataProvider]]\n *\n * @public\n */\n// tslint:disable-next-line: variable-name naming-convention\nexport function tableWithUnifiedSelection<P extends TableProps>(TableComponent: React.ComponentType<P>): React.ComponentType<P & TableWithUnifiedSelectionProps> {\n\n  type CombinedProps = P & TableWithUnifiedSelectionProps;\n\n  return class WithUnifiedSelection extends React.Component<CombinedProps> implements IUnifiedSelectionComponent {\n\n    private _base: React.RefObject<BaseTable>;\n    private _boundarySelectionLevel: number;\n    private _selectionHandler?: SelectionHandler;\n\n    constructor(props: CombinedProps) {\n      super(props);\n      this._base = React.createRef<BaseTable>();\n      this._boundarySelectionLevel = getBoundarySelectionLevelFromProps(props);\n    }\n\n    /** Returns the display name of this component */\n    public static get displayName() { return `WithUnifiedSelection(${getDisplayName(TableComponent)})`; }\n\n    /** Get selection handler used by this table */\n    public get selectionHandler(): SelectionHandler | undefined { return this._selectionHandler; }\n\n    public get imodel() { return this.props.dataProvider.imodel; }\n\n    public get rulesetId() { return this.props.dataProvider.rulesetId; }\n\n    // tslint:disable-next-line:naming-convention\n    private get baseProps(): TableProps { return this.props; }\n\n    public componentDidMount() {\n      const name = `Table_${counter++}`;\n      const imodel = this.props.dataProvider.imodel;\n      const rulesetId = this.props.dataProvider.rulesetId;\n      this._selectionHandler = this.props.selectionHandler\n        ? this.props.selectionHandler : new SelectionHandler(Presentation.selection, name, imodel, rulesetId);\n      this._selectionHandler!.onSelect = this.onSelectionChanged;\n      this.displaySelection();\n    }\n\n    public componentWillUnmount() {\n      if (this._selectionHandler)\n        this._selectionHandler.dispose();\n    }\n\n    public componentDidUpdate() {\n      this._boundarySelectionLevel = getBoundarySelectionLevelFromProps(this.props);\n      if (this._selectionHandler) {\n        this._selectionHandler.imodel = this.props.dataProvider.imodel;\n        this._selectionHandler.rulesetId = this.props.dataProvider.rulesetId;\n      }\n    }\n\n    private loadDataForSelection(selectionLevel: number) {\n      for (let level = selectionLevel; level >= 0; level--) {\n        const selection = this._selectionHandler!.getSelection(level);\n        if (!selection.isEmpty) {\n          this.props.dataProvider.keys = new KeySet(selection);\n          return;\n        }\n      }\n      this.props.dataProvider.keys = new KeySet();\n    }\n\n    private highlightSelectedRows(_selection: Readonly<KeySet>) {\n      if (this._base.current)\n        this._base.current.updateSelectedRows();\n    }\n\n    private displaySelection(selectionLevel?: number) {\n      if (undefined === selectionLevel) {\n        let availableLevels = this._selectionHandler!.getSelectionLevels();\n        if (this.props.dataProvider.keys.isEmpty) {\n          // if the data provider has no set keys, we have to find the right selection\n          // level and set it's selection to data provider. we take the first highest\n          // available selection level that's smaller than boundary or equal to 0\n          availableLevels = availableLevels.reverse();\n          for (const level of availableLevels) {\n            if (level < this._boundarySelectionLevel || level === 0) {\n              selectionLevel = level;\n              break;\n            }\n          }\n        } else {\n          selectionLevel = (availableLevels.length > 0) ? availableLevels[availableLevels.length - 1] : undefined;\n        }\n      }\n      if (undefined === selectionLevel)\n        return;\n\n      if (selectionLevel < this._boundarySelectionLevel) {\n        // we get here when table should react to selection change by reloading the data\n        // based on the new selection\n        this.loadDataForSelection(selectionLevel);\n      } else if (selectionLevel === this._boundarySelectionLevel) {\n        // we get here when table should react to selection change by\n        // highlighting selected instances\n        const selection = this._selectionHandler!.getSelection(selectionLevel);\n        this.highlightSelectedRows(selection);\n      }\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onSelectionChanged = (evt: SelectionChangeEventArgs): void => {\n      this.displaySelection(evt.level);\n    }\n\n    private async getRowKeys(rows: AsyncIterableIterator<RowItem>): Promise<InstanceKey[]> {\n      const keys = new Array<InstanceKey>();\n      for await (const row of rows)\n        keys.push(this.props.dataProvider.getRowKey(row));\n      return keys;\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private isRowSelected = (row: RowItem): boolean => {\n      // give consumers a chance to tell if row is selected\n      if (this.baseProps.isRowSelected)\n        return this.baseProps.isRowSelected(row);\n\n      if (!this._selectionHandler)\n        return false;\n\n      const selection = this._selectionHandler.getSelection(this._boundarySelectionLevel);\n      return selection.has(this.props.dataProvider.getRowKey(row));\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onRowsSelected = async (rows: AsyncIterableIterator<RowItem>, replace: boolean): Promise<boolean> => {\n      // give consumers a chance to handle selection changes and either\n      // continue default handling (by returning `true`) or abort (by\n      // returning `false`)\n      if (this.baseProps.onRowsSelected && !(await this.baseProps.onRowsSelected(rows, replace)))\n        return true;\n\n      if (this._selectionHandler) {\n        const keys = await this.getRowKeys(rows);\n        if (replace)\n          this._selectionHandler.replaceSelection(keys, this._boundarySelectionLevel);\n        else\n          this._selectionHandler.addToSelection(keys, this._boundarySelectionLevel);\n      }\n      return true;\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onRowsDeselected = async (rows: AsyncIterableIterator<RowItem>): Promise<boolean> => {\n      // give consumers a chance to handle selection changes and either\n      // continue default handling (by returning `true`) or abort (by\n      // returning `false`)\n      if (this.baseProps.onRowsDeselected && !(await this.baseProps.onRowsDeselected(rows)))\n        return true;\n\n      if (this._selectionHandler) {\n        const keys = await this.getRowKeys(rows);\n        this._selectionHandler.removeFromSelection(keys, this._boundarySelectionLevel);\n      }\n      return true;\n    }\n\n    public render() {\n      const {\n        selectionHandler, selectionLevel, // do not bleed our props\n        isRowSelected, onRowsSelected, onRowsDeselected, // take out the props we're overriding\n        ...props /* tslint:disable-line: trailing-comma */ // pass-through props\n      } = this.props as any;\n      return (\n        <TableComponent ref={this._base}\n          isRowSelected={this.isRowSelected} onRowsSelected={this.onRowsSelected} onRowsDeselected={this.onRowsDeselected}\n          {...props}\n        />\n      );\n    }\n  };\n}\n\nlet counter = 1;\n\nfunction getBoundarySelectionLevelFromProps(props: TableWithUnifiedSelectionProps): number {\n  return (undefined !== props.selectionLevel) ? props.selectionLevel : 1;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tree */\n\nimport * as _ from \"lodash\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { Logger } from \"@bentley/bentleyjs-core\";\nimport { NodeKey, NodePathElement, HierarchyRequestOptions } from \"@bentley/presentation-common\";\nimport { Presentation } from \"@bentley/presentation-frontend\";\nimport { DelayLoadedTreeNodeItem, TreeNodeItem, PageOptions } from \"@bentley/ui-components\";\nimport { PRESENTATION_TREE_NODE_KEY, createTreeNodeItems, pageOptionsUiToPresentation } from \"./Utils\";\nimport { IPresentationTreeDataProvider } from \"./IPresentationTreeDataProvider\";\n\n/**\n * Presentation Rules-driven tree data provider.\n * @public\n */\nexport class PresentationTreeDataProvider implements IPresentationTreeDataProvider {\n  private _rulesetId: string;\n  private _imodel: IModelConnection;\n  private _pagingSize?: number;\n\n  /**\n   * Constructor.\n   * @param imodel Connection to an imodel to pull data from.\n   * @param rulesetId Id of the ruleset used by this data provider.\n   */\n  public constructor(imodel: IModelConnection, rulesetId: string) {\n    this._rulesetId = rulesetId;\n    this._imodel = imodel;\n  }\n\n  /** Id of the ruleset used by this data provider */\n  public get rulesetId(): string { return this._rulesetId; }\n\n  /** [[IModelConnection]] used by this data provider */\n  public get imodel(): IModelConnection { return this._imodel; }\n\n  /**\n   * Paging options for obtaining nodes.\n   *\n   * Presentation data providers, when used with paging, have ability to save one backend request for size / count. That\n   * can only be achieved when `pagingSize` property is set on the data provider and it's value matches size which is used when\n   * requesting nodes. To help developers notice this problem, data provider emits a warning similar to this:\n   * ```\n   * PresentationTreeDataProvider.pagingSize doesn't match pageOptions in PresentationTreeDataProvider.getNodes call. Make sure you set PresentationTreeDataProvider.pagingSize to avoid excessive backend requests.\n   * ```\n   * To fix the issue, developers should make sure the page size used for requesting data is also set for the data provider:\n   * ```TS\n   * const pageSize = 10;\n   * const provider = new TreeDataProvider(imodel, rulesetId);\n   * provider.pagingSize = pageSize;\n   * // only one backend request is made for the two following requests:\n   * provider.getNodesCount();\n   * provider.getNodes({ start: 0, size: pageSize });\n   * ```\n   */\n  public get pagingSize(): number | undefined { return this._pagingSize; }\n  public set pagingSize(value: number | undefined) { this._pagingSize = value; }\n\n  /** Called to get extended options for node requests */\n  private createRequestOptions(): HierarchyRequestOptions<IModelConnection> {\n    return {\n      imodel: this._imodel,\n      rulesetId: this._rulesetId,\n    };\n  }\n\n  /**\n   * Returns a [[NodeKey]] from given [[TreeNodeItem]].\n   * **Warning:** the `node` must be created by this data provider.\n   */\n  public getNodeKey(node: TreeNodeItem): NodeKey {\n    return (node as any)[PRESENTATION_TREE_NODE_KEY];\n  }\n\n  /**\n   * Returns nodes\n   * @param parentNode The parent node to return children for.\n   * @param pageOptions Information about the requested page of data.\n   */\n  public async getNodes(parentNode?: TreeNodeItem, pageOptions?: PageOptions): Promise<DelayLoadedTreeNodeItem[]> {\n    if (undefined !== pageOptions && pageOptions.size !== this.pagingSize) {\n      const msg = `PresentationTreeDataProvider.pagingSize doesn't match pageOptions in PresentationTreeDataProvider.getNodes call.\n        Make sure you set PresentationTreeDataProvider.pagingSize to avoid excessive backend requests.`;\n      Logger.logWarning(\"Presentation.Components\", msg);\n    }\n\n    if (parentNode)\n      return (await this._getNodesAndCount(parentNode, pageOptions)).nodes;\n    return (await this._getNodesAndCount(undefined, pageOptions)).nodes;\n  }\n\n  /**\n   * Returns the total number of nodes\n   * @param parentNode The parent node to return children count for.\n   */\n  public async getNodesCount(parentNode?: TreeNodeItem): Promise<number> {\n    const pageOptions = undefined !== this.pagingSize ? { start: 0, size: this.pagingSize } : undefined;\n    return (await this._getNodesAndCount(parentNode, pageOptions)).count!;\n  }\n\n  private _getNodesAndCount = _.memoize(async (parentNode?: TreeNodeItem, pageOptions?: PageOptions) => {\n    const requestCount = undefined !== pageOptions && 0 === pageOptions.start && undefined !== pageOptions.size;\n    const parentKey = parentNode ? this.getNodeKey(parentNode) : undefined;\n\n    if (!requestCount) {\n      const allNodes = await Presentation.presentation.getNodes({ ...this.createRequestOptions(), paging: pageOptionsUiToPresentation(pageOptions) }, parentKey);\n      return { nodes: parentNode ? createTreeNodeItems(allNodes, parentNode.id) : createTreeNodeItems(allNodes), count: allNodes.length };\n    }\n\n    const nodesResponse = await Presentation.presentation.getNodesAndCount({ ...this.createRequestOptions(), paging: pageOptionsUiToPresentation(pageOptions) }, parentKey);\n    return { nodes: parentNode ? createTreeNodeItems(nodesResponse.nodes, parentNode.id) : createTreeNodeItems(nodesResponse.nodes), count: nodesResponse.count };\n  }, MemoizationHelpers.getNodesKeyResolver);\n\n  /**\n   * Returns filtered node paths.\n   * @param filter Filter.\n   */\n  public getFilteredNodePaths = async (filter: string): Promise<NodePathElement[]> => {\n    return Presentation.presentation.getFilteredNodePaths(this.createRequestOptions(), filter);\n  }\n}\n\nclass MemoizationHelpers {\n  public static createKeyForPageOptions(pageOptions?: PageOptions) {\n    if (!pageOptions)\n      return \"0/0\";\n    return `${(pageOptions.start) ? pageOptions.start : 0}/${(pageOptions.size) ? pageOptions.size : 0}`;\n  }\n  public static createKeyForTreeNodeItem(item?: TreeNodeItem) { return item ? item.id : \"\"; }\n  public static getNodesKeyResolver(parent?: TreeNodeItem, pageOptions?: PageOptions) {\n    return `${MemoizationHelpers.createKeyForTreeNodeItem(parent)}/${MemoizationHelpers.createKeyForPageOptions(pageOptions)}`;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tree */\n\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { NodePathElement, NodeKey } from \"@bentley/presentation-common\";\nimport {\n  SimpleTreeDataProvider, SimpleTreeDataProviderHierarchy,\n  DelayLoadedTreeNodeItem, TreeNodeItem,\n  PageOptions, ActiveMatchInfo,\n} from \"@bentley/ui-components\";\nimport { createTreeNodeItem } from \"./Utils\";\nimport { IPresentationTreeDataProvider } from \"./IPresentationTreeDataProvider\";\nimport { memoize } from \"lodash\";\n\n/**\n * Rules-driven presentation tree data provider that returns filtered results.\n * @internal\n */\nexport class FilteredPresentationTreeDataProvider implements IPresentationTreeDataProvider {\n  private _parentDataProvider: IPresentationTreeDataProvider;\n  private _filteredDataProvider: SimpleTreeDataProvider;\n  private _filter: string;\n  private _filteredResultMatches: Array<{ id: string, matchesCount: number }> = [];\n\n  public constructor(parentDataProvider: IPresentationTreeDataProvider, filter: string, paths: ReadonlyArray<Readonly<NodePathElement>>) {\n    this._parentDataProvider = parentDataProvider;\n    this._filter = filter;\n    const hierarchy: SimpleTreeDataProviderHierarchy = new Map<string | undefined, TreeNodeItem[]>();\n    this.createHierarchy(paths, hierarchy);\n    this._filteredDataProvider = new SimpleTreeDataProvider(hierarchy);\n  }\n\n  public get rulesetId(): string { return this._parentDataProvider.rulesetId; }\n\n  public get imodel(): IModelConnection { return this._parentDataProvider.imodel; }\n\n  public get filter(): string { return this._filter; }\n\n  private createHierarchy(paths: ReadonlyArray<Readonly<NodePathElement>>, hierarchy: SimpleTreeDataProviderHierarchy, parentId?: string) {\n    const treeNodes: DelayLoadedTreeNodeItem[] = [];\n    for (let i = 0; i < paths.length; i++) {\n      const node = createTreeNodeItem(paths[i].node, parentId);\n\n      if (paths[i].filteringData && paths[i].filteringData!.matchesCount)\n        this._filteredResultMatches.push({ id: node.id, matchesCount: paths[i].filteringData!.matchesCount });\n\n      if (paths[i].children.length !== 0) {\n        this.createHierarchy(paths[i].children, hierarchy, node.id);\n        node.hasChildren = true;\n        node.autoExpand = true;\n      } else\n        node.hasChildren = false;\n\n      treeNodes[i] = node;\n    }\n    hierarchy.set(parentId, treeNodes);\n  }\n\n  public getActiveMatch: (index: number) => ActiveMatchInfo | undefined = memoize((index: number): ActiveMatchInfo | undefined => {\n    let activeMatch: ActiveMatchInfo | undefined;\n    if (index <= 0)\n      return undefined;\n\n    let i = 1;\n    for (const node of this._filteredResultMatches) {\n      if (index < i + node.matchesCount) {\n        activeMatch = {\n          nodeId: node.id,\n          matchIndex: index - i,\n        };\n        break;\n      }\n\n      i += node.matchesCount;\n    }\n    return activeMatch;\n  });\n\n  /** Count filtering results. Including multiple possible matches within node labels */\n  public countFilteringResults(nodePaths: ReadonlyArray<Readonly<NodePathElement>>): number {\n    let resultCount = 0;\n\n    // Loops through root level only\n    for (const path of nodePaths) {\n      if (path.filteringData)\n        resultCount += path.filteringData.matchesCount + path.filteringData.childMatchesCount;\n    }\n\n    return resultCount;\n  }\n\n  public async getNodes(parent?: TreeNodeItem, pageOptions?: PageOptions): Promise<DelayLoadedTreeNodeItem[]> {\n    return this._filteredDataProvider.getNodes(parent, pageOptions);\n  }\n\n  public async getNodesCount(parent?: TreeNodeItem): Promise<number> {\n    return this._filteredDataProvider.getNodesCount(parent);\n  }\n\n  public async getFilteredNodePaths(filter: string): Promise<NodePathElement[]> {\n    return this._parentDataProvider.getFilteredNodePaths(filter);\n  }\n\n  public getNodeKey(node: TreeNodeItem): NodeKey {\n    return this._parentDataProvider.getNodeKey(node);\n  }\n\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tree */\n\nimport { StyleHelper } from \"../common/StyleHelper\";\nimport { CheckBoxState } from \"@bentley/ui-core\";\nimport { Node, PageOptions as PresentationPageOptions } from \"@bentley/presentation-common\";\nimport { DelayLoadedTreeNodeItem, PageOptions as UiPageOptions, ItemStyle, ItemColorOverrides } from \"@bentley/ui-components\";\n\n/** @internal */\nexport const PRESENTATION_TREE_NODE_KEY = \"__presentation-components/key\";\n\n/** @internal */\nexport const createTreeNodeItems = (nodes: ReadonlyArray<Readonly<Node>>, parentId?: string): DelayLoadedTreeNodeItem[] => {\n  const list = new Array<DelayLoadedTreeNodeItem>();\n  for (const node of nodes)\n    list.push(createTreeNodeItem(node, parentId));\n  return list;\n};\n\n/** @internal */\nexport const createTreeNodeItem = (node: Readonly<Node>, parentId?: string): DelayLoadedTreeNodeItem => {\n  const item: DelayLoadedTreeNodeItem = {\n    id: [...node.key.pathFromRoot].reverse().join(\"/\"),\n    label: node.label,\n  };\n  (item as any)[PRESENTATION_TREE_NODE_KEY] = node.key;\n\n  const style: ItemStyle = {};\n  const colorOverrides: ItemColorOverrides = {};\n  if (parentId)\n    item.parentId = parentId;\n  if (node.description)\n    item.description = node.description;\n  if (node.hasChildren)\n    item.hasChildren = true;\n  if (node.imageId)\n    item.icon = node.imageId;\n  if (StyleHelper.isBold(node))\n    style.isBold = true;\n  if (StyleHelper.isItalic(node))\n    style.isItalic = true;\n  const foreColor = StyleHelper.getForeColor(node);\n  if (foreColor)\n    colorOverrides.color = foreColor;\n  const backColor = StyleHelper.getBackColor(node);\n  if (backColor)\n    colorOverrides.backgroundColor = backColor;\n  if (node.isCheckboxVisible) {\n    item.isCheckboxVisible = true;\n    if (node.isChecked)\n      item.checkBoxState = CheckBoxState.On;\n    if (!node.isCheckboxEnabled)\n      item.isCheckboxDisabled = true;\n  }\n  if (Object.keys(colorOverrides).length > 0)\n    style.colorOverrides = colorOverrides;\n  if (Object.keys(style).length > 0)\n    item.style = style;\n  if (node.extendedData)\n    item.extendedData = node.extendedData;\n  return item;\n};\n\n/** @internal */\nexport const pageOptionsUiToPresentation = (pageOptions?: UiPageOptions): PresentationPageOptions | undefined => {\n  if (pageOptions)\n    return { ...pageOptions };\n  return undefined;\n};\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tree */\n\nimport * as React from \"react\";\nimport { TreeProps, ActiveMatchInfo, HighlightableTreeProps } from \"@bentley/ui-components\";\nimport { getDisplayName } from \"../common/Utils\";\nimport { IPresentationTreeDataProvider } from \"./IPresentationTreeDataProvider\";\nimport { FilteredPresentationTreeDataProvider } from \"./FilteredDataProvider\";\nimport \"./WithFilteringSupport.scss\";\n\n/**\n * Props that are injected to the TreeWithFilteringSupport HOC component.\n * @public\n */\nexport interface TreeWithFilteringSupportProps {\n  /** The text to search for */\n  filter?: string;\n  /** The data provider used by the tree. */\n  dataProvider: IPresentationTreeDataProvider;\n  /** Called when filter is applied. */\n  onFilterApplied?: (filter?: string) => void;\n  /** Called when FilteredDataProvider counts the number of matches */\n  onMatchesCounted?: (count: number) => void;\n  /** Index of the active match */\n  activeMatchIndex?: number;\n}\n\n/**\n * A HOC component that adds filtering functionality to the supplied\n * tree component.\n *\n * **Note:** it is required for the tree to use [[IPresentationTreeDataProvider]]\n *\n * @public\n */\n// tslint:disable-next-line: variable-name naming-convention\nexport function treeWithFilteringSupport<P extends TreeProps>(TreeComponent: React.ComponentType<P>): React.ComponentType<P & TreeWithFilteringSupportProps> {\n\n  type CombinedProps = P & TreeWithFilteringSupportProps;\n\n  interface State {\n    filteredDataProvider?: FilteredPresentationTreeDataProvider;\n  }\n\n  const defaultState: State = {\n    filteredDataProvider: undefined,\n  };\n\n  return class WithFilteringSupport extends React.Component<CombinedProps, State> {\n    public static get displayName() { return `WithFilteringSupport(${getDisplayName(TreeComponent)})`; }\n\n    public constructor(props: CombinedProps, context?: any) {\n      super(props, context);\n      this.state = defaultState;\n    }\n\n    public static getDerivedStateFromProps(nextProps: CombinedProps, state: State): State {\n      if (nextProps.filter === undefined || nextProps.filter === \"\")\n        return defaultState;\n      return state;\n    }\n\n    public async componentDidUpdate(prevProps: CombinedProps, _prevState: State): Promise<void> {\n      const nothingChanged = this.areEqual(prevProps, this.props);\n      const filterIsEmpty = !this.hasFilter;\n\n      if (nothingChanged || filterIsEmpty) {\n        let currentlyLoading = false;\n        if (filterIsEmpty)\n          currentlyLoading = false;\n        else if (!this.state.filteredDataProvider)\n          currentlyLoading = true;\n        else\n          currentlyLoading = !this.areEqual({ dataProvider: this.state.filteredDataProvider, filter: this.state.filteredDataProvider.filter }, this.props);\n\n        if (!currentlyLoading && this.props.onFilterApplied)\n          this.props.onFilterApplied(this.props.filter);\n        return;\n      }\n\n      await this.loadDataProvider(this.props.filter as string);\n    }\n\n    public async componentDidMount(): Promise<void> {\n      if (!this.hasFilter) {\n        if (this.props.onFilterApplied)\n          this.props.onFilterApplied(this.props.filter);\n        return;\n      }\n      await this.loadDataProvider(this.props.filter as string);\n    }\n\n    private async loadDataProvider(filter: string): Promise<void> {\n      const nodePaths = await this.props.dataProvider.getFilteredNodePaths(filter);\n      if (this.props.filter !== filter)\n        return;\n\n      const filteredDataProvider = new FilteredPresentationTreeDataProvider(this.props.dataProvider, filter, nodePaths);\n\n      if (this.props.onMatchesCounted)\n        this.props.onMatchesCounted(filteredDataProvider.countFilteringResults(nodePaths));\n\n      this.setState({ filteredDataProvider });\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private get hasFilter() {\n      return (this.props.filter !== \"\" && this.props.filter !== undefined);\n    }\n\n    private areEqual(prop1: TreeWithFilteringSupportProps, prop2: TreeWithFilteringSupportProps): boolean {\n      if (prop1.filter !== prop2.filter)\n        return false;\n\n      if (prop1.dataProvider.rulesetId !== prop2.dataProvider.rulesetId || prop1.dataProvider.imodel !== prop2.dataProvider.imodel)\n        return false;\n\n      return true;\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private get shouldDisplayOverlay() {\n      if (this.hasFilter) {\n        if (!this.state.filteredDataProvider)\n          return true;\n        return !this.areEqual({ dataProvider: this.state.filteredDataProvider, filter: this.state.filteredDataProvider.filter }, this.props);\n      }\n      return false;\n    }\n\n    public render() {\n      const {\n        filter, dataProvider, onFilterApplied, onMatchesCounted, activeMatchIndex,\n        ...props /* tslint:disable-line: trailing-comma */\n      } = this.props as any;\n\n      const overlay = this.shouldDisplayOverlay ? <div className=\"filteredTreeOverlay\" /> : undefined;\n\n      let nodeHighlightingProps: HighlightableTreeProps | undefined;\n      if (filter) {\n        let activeMatch: ActiveMatchInfo | undefined;\n        if (this.state.filteredDataProvider && undefined !== activeMatchIndex)\n          activeMatch = this.state.filteredDataProvider.getActiveMatch(activeMatchIndex);\n        nodeHighlightingProps = {\n          searchText: filter,\n          activeMatch,\n        };\n      }\n\n      return (\n        <div className=\"filteredTree\">\n          <TreeComponent\n            dataProvider={this.state.filteredDataProvider ? this.state.filteredDataProvider : this.props.dataProvider}\n            nodeHighlightingProps={nodeHighlightingProps}\n            {...props}\n          />\n          {overlay}\n        </div>\n      );\n    }\n\n  };\n}\n","\nvar content = require(\"!!../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-0-1!../../../../common/temp/node_modules/.registry.npmjs.org/postcss-loader/2.1.6/node_modules/postcss-loader/lib/index.js??postcss!../../../../common/temp/node_modules/.registry.npmjs.org/fast-sass-loader/1.4.7/node-sass@4.12.0+webpack@4.32.2/node_modules/fast-sass-loader/lib/index.js??ref--5!./WithFilteringSupport.scss\");\n\nif(typeof content === 'string') content = [[module.id, content, '']];\n\nvar transform;\nvar insertInto;\n\n\n\nvar options = {\"hmr\":true}\n\noptions.transform = transform\noptions.insertInto = undefined;\n\nvar update = require(\"!../../../../common/temp/node_modules/.registry.npmjs.org/style-loader/0.21.0/node_modules/style-loader/lib/addStyles.js\")(content, options);\n\nif(content.locals) module.exports = content.locals;\n\nif(module.hot) {\n\tmodule.hot.accept(\"!!../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-0-1!../../../../common/temp/node_modules/.registry.npmjs.org/postcss-loader/2.1.6/node_modules/postcss-loader/lib/index.js??postcss!../../../../common/temp/node_modules/.registry.npmjs.org/fast-sass-loader/1.4.7/node-sass@4.12.0+webpack@4.32.2/node_modules/fast-sass-loader/lib/index.js??ref--5!./WithFilteringSupport.scss\", function() {\n\t\tvar newContent = require(\"!!../../../../common/temp/node_modules/.registry.npmjs.org/css-loader/2.1.1/webpack@4.32.2/node_modules/css-loader/dist/cjs.js??ref--6-oneOf-0-1!../../../../common/temp/node_modules/.registry.npmjs.org/postcss-loader/2.1.6/node_modules/postcss-loader/lib/index.js??postcss!../../../../common/temp/node_modules/.registry.npmjs.org/fast-sass-loader/1.4.7/node-sass@4.12.0+webpack@4.32.2/node_modules/fast-sass-loader/lib/index.js??ref--5!./WithFilteringSupport.scss\");\n\n\t\tif(typeof newContent === 'string') newContent = [[module.id, newContent, '']];\n\n\t\tvar locals = (function(a, b) {\n\t\t\tvar key, idx = 0;\n\n\t\t\tfor(key in a) {\n\t\t\t\tif(!b || a[key] !== b[key]) return false;\n\t\t\t\tidx++;\n\t\t\t}\n\n\t\t\tfor(key in b) idx--;\n\n\t\t\treturn idx === 0;\n\t\t}(content.locals, newContent.locals));\n\n\t\tif(!locals) throw new Error('Aborting CSS HMR due to changed css-modules locals.');\n\n\t\tupdate(newContent);\n\t});\n\n\tmodule.hot.dispose(function() { update(); });\n}","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport * as React from \"react\";\nimport { Keys, StandardNodeTypes, ECInstanceNodeKey } from \"@bentley/presentation-common\";\nimport { Presentation, SelectionHandler, SelectionChangeEventArgs, ISelectionProvider } from \"@bentley/presentation-frontend\";\nimport { TreeProps, TreeNodeItem } from \"@bentley/ui-components\";\nimport { getDisplayName } from \"../common/Utils\";\nimport { IUnifiedSelectionComponent } from \"../common/IUnifiedSelectionComponent\";\nimport { IPresentationTreeDataProvider } from \"./IPresentationTreeDataProvider\";\n\n/**\n * Props that are injected to the TreeWithUnifiedSelection HOC component.\n * @public\n */\nexport interface TreeWithUnifiedSelectionProps {\n  /** The data provider used by the tree. */\n  dataProvider: IPresentationTreeDataProvider;\n\n  /**\n   * Called when nodes are selected. The callback should return `true`\n   * to continue default handling or `false` otherwise.\n   */\n  onNodesSelected?: (items: TreeNodeItem[], replace: boolean) => boolean;\n\n  /**\n   * Called when nodes are deselected. The callback should return `true`\n   * to continue default handling or `false` otherwise.\n   */\n  onNodesDeselected?: (items: TreeNodeItem[]) => boolean;\n\n  /** @internal */\n  selectionHandler?: SelectionHandler;\n}\n\n/**\n * A HOC component that adds unified selection functionality to the supplied\n * tree component.\n *\n * **Note:** it is required for the tree to use [[PresentationTreeDataProvider]]\n *\n * @public\n */\n// tslint:disable-next-line: variable-name naming-convention\nexport function treeWithUnifiedSelection<P extends TreeProps>(TreeComponent: React.ComponentClass<P>) {\n\n  type TreeComponentInstance = InstanceType<typeof TreeComponent>;\n  type CombinedProps = P & TreeWithUnifiedSelectionProps;\n  type CombinedPropsWithForwardedRef = CombinedProps & {\n    forwardedRef: React.Ref<TreeComponentInstance>;\n  };\n\n  interface State {\n    isNodeSelected: (node: TreeNodeItem) => boolean;\n  }\n\n  class WithUnifiedSelection extends React.Component<CombinedPropsWithForwardedRef, State> implements IUnifiedSelectionComponent {\n\n    private _selectionHandler?: SelectionHandler;\n\n    public constructor(props: CombinedPropsWithForwardedRef, context: any) {\n      super(props, context);\n      this.state = {\n        isNodeSelected: this.createIsNodeSelectedCallback(),\n      };\n    }\n\n    /** Returns the display name of this component */\n    public static get displayName() { return `WithUnifiedSelection(${getDisplayName(TreeComponent)})`; }\n\n    /** Get selection handler used by this property grid */\n    public get selectionHandler(): SelectionHandler | undefined { return this._selectionHandler; }\n\n    public get imodel() { return this.props.dataProvider.imodel; }\n\n    public get rulesetId() { return this.props.dataProvider.rulesetId; }\n\n    public componentDidMount() {\n      const name = `Tree_${counter++}`;\n      const imodel = this.props.dataProvider.imodel;\n      const rulesetId = this.props.dataProvider.rulesetId;\n      this._selectionHandler = this.props.selectionHandler\n        ? this.props.selectionHandler : new SelectionHandler(Presentation.selection, name, imodel, rulesetId);\n      this._selectionHandler!.onSelect = this.onSelectionChanged;\n    }\n\n    public componentWillUnmount() {\n      if (this._selectionHandler)\n        this._selectionHandler.dispose();\n    }\n\n    public componentDidUpdate() {\n      if (this._selectionHandler) {\n        this._selectionHandler.imodel = this.props.dataProvider.imodel;\n        this._selectionHandler.rulesetId = this.props.dataProvider.rulesetId;\n      }\n    }\n\n    private createIsNodeSelectedCallback() {\n      return (node: TreeNodeItem) => this.isNodeSelected(node);\n    }\n\n    private isNodeSelected(node: TreeNodeItem): boolean {\n      if (!this._selectionHandler)\n        return false;\n\n      const selection = this._selectionHandler.getSelection();\n\n      // consider node selected if it's key is in selection\n      const nodeKey = this.props.dataProvider.getNodeKey(node);\n      if (selection.has(nodeKey))\n        return true;\n\n      // ... or if it's an ECInstance node and instance key is in selection\n      if (nodeKey.type === StandardNodeTypes.ECInstanceNode) {\n        const instanceKey = (nodeKey as ECInstanceNodeKey).instanceKey;\n        return selection.has(instanceKey);\n      }\n\n      return false;\n    }\n\n    private getKeys(nodes: TreeNodeItem[]): Keys {\n      const nodeKeys = nodes.map((node) => this.props.dataProvider.getNodeKey(node));\n      return nodeKeys.map((key) => {\n        if (key.type === StandardNodeTypes.ECInstanceNode)\n          return (key as ECInstanceNodeKey).instanceKey;\n        return key;\n      });\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onNodesSelected = (nodes: TreeNodeItem[], replace: boolean) => {\n      const props: Readonly<CombinedProps> = this.props;\n\n      // give consumers a chance to handle selection changes and either\n      // continue default handling (by returning `true`) or abort (by\n      // returning `false`)\n      if (props.onNodesSelected && !props.onNodesSelected(nodes, replace))\n        return;\n\n      if (!this._selectionHandler)\n        return;\n\n      if (replace)\n        this._selectionHandler.replaceSelection(this.getKeys(nodes));\n      else\n        this._selectionHandler.addToSelection(this.getKeys(nodes));\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onNodesDeselected = (nodes: TreeNodeItem[]) => {\n      const props: Readonly<CombinedProps> = this.props;\n\n      // give consumers a chance to handle selection changes and either\n      // continue default handling (by returning `true`) or abort (by\n      // returning `false`)\n      if (props.onNodesDeselected && !props.onNodesDeselected(nodes))\n        return;\n\n      if (!this._selectionHandler)\n        return;\n\n      this._selectionHandler.removeFromSelection(this.getKeys(nodes));\n    }\n\n    // tslint:disable-next-line:naming-convention\n    private onSelectionChanged = (args: SelectionChangeEventArgs, _provider: ISelectionProvider) => {\n      if (args.level === 0) {\n        // note: we set the `isNodeSelected` callback to a new function which basically\n        // does the same thing, but makes sure that nested component gets re-rendered\n        this.setState({\n          isNodeSelected: this.createIsNodeSelectedCallback(),\n        });\n      }\n    }\n\n    public render() {\n      const {\n        forwardedRef, selectionHandler, // do not bleed our props\n        ...props /* tslint:disable-line: trailing-comma */ // pass-through props\n      } = this.props;\n      return (\n        <TreeComponent\n          {...props as CombinedProps}\n          ref={forwardedRef}\n          selectedNodes={this.state.isNodeSelected}\n          onNodesSelected={this.onNodesSelected}\n          onNodesDeselected={this.onNodesDeselected}\n        />\n      );\n    }\n  }\n  return React.forwardRef<TreeComponentInstance, CombinedProps>((props, ref) => <WithUnifiedSelection {...props} forwardedRef={ref} />);\n}\n\nlet counter = 1;\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module UnifiedSelection */\n\nimport * as React from \"react\";\nimport { Id64String, IDisposable, GuidString, Guid } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"@bentley/imodeljs-frontend\";\nimport { SelectionInfo, DefaultContentDisplayTypes, KeySet, Ruleset, RegisteredRuleset, ContentFlags, Key } from \"@bentley/presentation-common\";\nimport { SelectionHandler, Presentation, SelectionChangeEventArgs, ISelectionProvider } from \"@bentley/presentation-frontend\";\nimport { ViewportProps } from \"@bentley/ui-components\";\nimport { getDisplayName } from \"../common/Utils\";\nimport { IUnifiedSelectionComponent } from \"../common/IUnifiedSelectionComponent\";\nimport { ContentDataProvider } from \"../common/ContentDataProvider\";\nimport { TRANSIENT_ELEMENT_CLASSNAME } from \"@bentley/presentation-frontend/lib/selection/SelectionManager\"; /* tslint:disable-line:no-direct-imports */\n\n// tslint:disable-next-line: no-var-requires\nconst DEFAULT_RULESET: Ruleset = require(\"./HiliteRules.json\");\n\n/**\n * Props that are injected to the ViewWithUnifiedSelection HOC component.\n * @public\n */\nexport interface ViewWithUnifiedSelectionProps {\n  /**\n   * Ruleset or its ID to use when determining viewport selection.\n   * @alpha\n   */\n  ruleset?: Ruleset | string;\n\n  /** @internal */\n  selectionHandler?: ViewportSelectionHandler;\n}\n\n/**\n * A HOC component that adds unified selection functionality to the supplied\n * viewport component.\n *\n * @public\n */\n// tslint:disable-next-line: variable-name naming-convention\nexport function viewWithUnifiedSelection<P extends ViewportProps>(ViewportComponent: React.ComponentType<P>): React.ComponentType<P & ViewWithUnifiedSelectionProps> {\n\n  type CombinedProps = P & ViewWithUnifiedSelectionProps;\n\n  return class WithUnifiedSelection extends React.PureComponent<CombinedProps> implements IUnifiedSelectionComponent {\n\n    /** @internal */\n    public viewportSelectionHandler?: ViewportSelectionHandler;\n\n    /** Returns the display name of this component */\n    public static get displayName() { return `WithUnifiedSelection(${getDisplayName(ViewportComponent)})`; }\n\n    /** Get selection handler used by this viewport */\n    public get selectionHandler(): SelectionHandler | undefined {\n      return this.viewportSelectionHandler ? this.viewportSelectionHandler.selectionHandler : undefined;\n    }\n\n    public get imodel() { return this.props.imodel; }\n\n    public get rulesetId() { return getRulesetId(this.props.ruleset); }\n\n    public componentDidMount() {\n      this.viewportSelectionHandler = this.props.selectionHandler\n        ? this.props.selectionHandler : new ViewportSelectionHandler(this.props.imodel, getRuleset(this.props.ruleset));\n    }\n\n    public componentWillUnmount() {\n      if (this.viewportSelectionHandler) {\n        this.viewportSelectionHandler.dispose();\n        this.viewportSelectionHandler = undefined;\n      }\n    }\n\n    public componentDidUpdate() {\n      if (this.viewportSelectionHandler) {\n        this.viewportSelectionHandler.imodel = this.props.imodel;\n        this.viewportSelectionHandler.ruleset = getRuleset(this.props.ruleset);\n      }\n    }\n\n    public render() {\n      const {\n        ruleset, selectionHandler, // do not bleed our props\n        ...props /* tslint:disable-line: trailing-comma */ // pass-through props\n      } = this.props as any;\n      return (\n        <ViewportComponent {...props} />\n      );\n    }\n\n  };\n}\n\n/**\n * A handler that syncs selection between unified selection\n * manager (`Presentation.selection`) and a viewport (`imodel.hilited`).\n * It has nothing to do with the viewport component itself - the\n * viewport updates its highlighted elements when `imodel.hilited`\n * changes.\n *\n * @internal\n */\nexport class ViewportSelectionHandler implements IDisposable {\n\n  private _imodel: IModelConnection;\n  private _ruleset: Ruleset | string;\n  private _rulesetRegistration?: RegisteredRuleset;\n  private _selectionHandler: SelectionHandler;\n  private _selectedElementsProvider: SelectedElementsProvider;\n  private _lastPendingSelectionChange?: { info: SelectionInfo, selection: Readonly<KeySet> };\n  private _isInSelectedElementsRequest = false;\n  private _asyncsInProgress = new Set<GuidString>();\n\n  public constructor(imodel: IModelConnection, ruleset: Ruleset | string) {\n    this._imodel = imodel;\n    this._ruleset = ruleset;\n    const rulesetId = getRulesetId(ruleset);\n\n    // tslint:disable-next-line: no-floating-promises\n    this.registerRuleset(ruleset);\n\n    // handles changing and listening to unified selection\n    this._selectionHandler = new SelectionHandler(Presentation.selection,\n      `Viewport_${counter++}`, imodel, rulesetId, this.onUnifiedSelectionChanged);\n    this._selectionHandler.manager.setSyncWithIModelToolSelection(imodel, true);\n\n    // stop imodel from syncing tool selection with hilited list - we want\n    // to override that behavior\n    imodel.hilited.wantSyncWithSelectionSet = false;\n\n    // handles querying for elements which should be hilited in the viewport\n    this._selectedElementsProvider = new SelectedElementsProvider(imodel, rulesetId);\n  }\n\n  public dispose() {\n    this._selectionHandler.dispose();\n    this._selectionHandler.manager.setSyncWithIModelToolSelection(this._imodel, false);\n    if (this._rulesetRegistration)\n      this._rulesetRegistration.dispose();\n    this._ruleset = \"\";\n  }\n\n  private async registerRuleset(ruleset: Ruleset | string) {\n    if (typeof ruleset !== \"object\")\n      return;\n\n    const reg = await Presentation.presentation.rulesets().add(ruleset);\n    if (this._ruleset !== ruleset)\n      reg.dispose();\n    else\n      this._rulesetRegistration = reg;\n  }\n\n  public get selectionHandler() { return this._selectionHandler; }\n\n  public get imodel() { return this._imodel; }\n  public set imodel(value: IModelConnection) {\n    if (this._imodel === value)\n      return;\n\n    this._selectionHandler.manager.setSyncWithIModelToolSelection(this._imodel, false);\n    this._selectionHandler.manager.setSyncWithIModelToolSelection(value, true);\n    this._imodel = value;\n    this._imodel.hilited.wantSyncWithSelectionSet = false;\n    this._selectionHandler.imodel = value;\n    this._selectedElementsProvider.imodel = value;\n  }\n\n  public get rulesetId() { return getRulesetId(this._ruleset); }\n  public set ruleset(value: Ruleset | string) {\n    if (this._rulesetRegistration)\n      this._rulesetRegistration.dispose();\n    this.registerRuleset(value); // tslint:disable-line: no-floating-promises\n\n    const rulesetId = getRulesetId(value);\n    this._ruleset = value;\n    this._selectionHandler.rulesetId = rulesetId;\n    this._selectedElementsProvider.rulesetId = rulesetId;\n  }\n\n  /** note: used only it tests */\n  public get pendingAsyncs() { return this._asyncsInProgress; }\n\n  private async applyUnifiedSelection(imodel: IModelConnection, selectionInfo: SelectionInfo, selection: Readonly<KeySet>) {\n    if (this._isInSelectedElementsRequest) {\n      this._lastPendingSelectionChange = { info: selectionInfo, selection };\n      return;\n    }\n\n    const asyncId = Guid.createValue();\n    this._asyncsInProgress.add(asyncId);\n    this._isInSelectedElementsRequest = true;\n    const ids = await this._selectedElementsProvider.getElementIds(new KeySet(selection), selectionInfo);\n    try {\n      imodel.hilited.clear();\n      imodel.hilited.setHilite(ids, true);\n    } finally {\n      this._isInSelectedElementsRequest = false;\n      this._asyncsInProgress.delete(asyncId);\n    }\n\n    if (this._lastPendingSelectionChange) {\n      const change = this._lastPendingSelectionChange;\n      this._lastPendingSelectionChange = undefined;\n      await this.applyUnifiedSelection(imodel, change.info, change.selection);\n    }\n  }\n\n  // tslint:disable-next-line:naming-convention\n  private onUnifiedSelectionChanged = async (args: SelectionChangeEventArgs, provider: ISelectionProvider): Promise<void> => {\n    // this component only cares about its own imodel\n    if (args.imodel !== this._imodel)\n      return;\n\n    // viewports are only interested in top-level selection changes\n    // wip: may want to handle different selection levels?\n    if (0 !== args.level)\n      return;\n\n    const selection = provider.getSelection(args.imodel, 0);\n    const info: SelectionInfo = {\n      providerName: args.source,\n      level: args.level,\n    };\n    await this.applyUnifiedSelection(args.imodel, info, selection);\n  }\n}\n\nclass SelectedElementsProvider extends ContentDataProvider {\n  public constructor(imodel: IModelConnection, rulesetId: string) {\n    super(imodel, rulesetId, DefaultContentDisplayTypes.Viewport);\n  }\n  protected shouldConfigureContentDescriptor() { return false; }\n  protected getDescriptorOverrides() {\n    return {\n      ...super.getDescriptorOverrides(),\n      contentFlags: ContentFlags.KeysOnly,\n    };\n  }\n  public async getElementIds(selectionKeys: KeySet, info: SelectionInfo): Promise<Id64String[]> {\n    // need to create a new set without transients\n    const transientIds = new Array<Id64String>();\n    const keys = new KeySet();\n    keys.add(selectionKeys, (key: Key) => {\n      if (Key.isInstanceKey(key) && key.className === TRANSIENT_ELEMENT_CLASSNAME) {\n        transientIds.push(key.id);\n        return false;\n      }\n      return true;\n    });\n\n    this.keys = keys;\n    this.selectionInfo = info;\n\n    const content = await this.getContent();\n    if (!content)\n      return transientIds;\n\n    // note: not making a copy here since we're throwing away `transientIds` anyway\n    const ids = transientIds;\n    content.contentSet.forEach((r) => r.primaryKeys.forEach((pk) => ids.push(pk.id)));\n    return ids;\n  }\n}\n\nconst getRuleset = (ruleset: Ruleset | string | undefined): Ruleset | string => {\n  if (!ruleset)\n    return DEFAULT_RULESET;\n  return ruleset;\n};\n\nconst getRulesetId = (ruleset: Ruleset | string | undefined): string => {\n  ruleset = getRuleset(ruleset);\n  if (typeof ruleset === \"string\")\n    return ruleset;\n  return ruleset.id;\n};\n\nlet counter = 1;\n","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_frontend__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_presentation_common__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_presentation_frontend__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_ui_components__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_ui_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE_lodash__;","module.exports = __WEBPACK_EXTERNAL_MODULE_react__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;;;;;;;;;;;;ACHA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACpFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxFA;;;AAGA;AACA;;AAEA;AAWA;;;AAGA;AACA;AAAA;AAAA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;ACvCA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAYA;;;AAGA;AACA;AAUA;;AAEA;AACA;AAZA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AA/NA;AAiOA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AASA;AAPA;AAKA;AAgBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA3EA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAiEA;AAtFA;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACncA;;;AAGA;AACA;;;;;;;;;;;AAEA;AAGA;AAcA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAlCA;AAoCA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACzEA;;;AAGA;AACA;;AAEA;AACA;AAOA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzCA;;;;;;;;;;;;;;ACtLA;;;AAGA;AACA;;AAEA;AACA;AAEA;AAKA;AAuCA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AA+BA;;;AAGA;AACA;AAWA;;;;;;AAMA;AACA;AA+KA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AA6BA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AArPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAsBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA2BA;AAzQA;AA2QA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC7WA;;;AAGA;AACA;;AAqBA;;;;AAIA;AACA;AAKA;AACA;AAHA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AApHA;;;;;;;;;;;;;;AC9BA;;;AAGA;AACA;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzCA;;;;;;;;;;;;;;AC9JA;;;AAGA;AACA;;AAIA;AAUA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5DA;;;AAGA;AACA;;AAEA;AAGA;AAmBA;;;AAGA;AACA;AAIA;AACA;AAQA;AACA;AAeA;AACA;AAxBA;AACA;AAEA;AACA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AAxCA;;;;;;;;;;;;;;AChCA;;;AAGA;AACA;;AAIA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AAEA;AACA;AAAA;AAIA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvCA;;;AAGA;AACA;;AAEA;AACA;AAGA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAQA;;;AAGA;AACA;AAIA;AACA;AACA;AAJA;AAwEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAtFA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AAIA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAuBA;;AAEA;AACA;AACA;AACA;AACA;AArGA;AAuGA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AChUA;;;AAGA;AACA;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AA2BA;;;;;;;AAOA;AACA;AACA;AAIA;AAKA;AACA;AAyFA;AACA;AACA;AACA;AA3FA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAKA;AACA;AACA;AA7HA;AA+HA;;;;;;;;;;;;AClLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;;AAEA;AACA;AACA;AAKA;AAMA;AACA;AACA;AACA;AAMA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AAgCA;;;AAGA;AACA;AAQA;AACA;AACA;AARA;AAGA;AACA;AA4GA;;AAEA;AACA;AACA;AACA;AACA;AA7GA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AA7JA;AA+JA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5QA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AAmCA;;;;;;;AAOA;AACA;AACA;AAIA;AAMA;AACA;AA0FA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAjJA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;AACA;;AACA;AAAA;AACA;AAAA;;;;;;;;;AACA;AACA;AAgDA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AA7KA;AA+KA;AAEA;AACA;AACA;;;;;;;;;;;;;;ACzOA;;;AAGA;AACA;;AAEA;AAEA;AAEA;AAEA;AAGA;;;AAGA;AACA;AAKA;;;;AAIA;AACA;AA2EA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AA7FA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAsBA;AAzGA;AA2GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACxIA;;;AAGA;AACA;;AAIA;AAKA;AAEA;AAEA;;;AAGA;AACA;AAMA;AAFA;AAoCA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAnDA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAsBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAzFA;;;;;;;;;;;;;;ACrBA;;;AAGA;AACA;;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACvEA;;;AAGA;AACA;;;;;;;;;;;AAEA;AAEA;AAEA;AACA;AAmBA;;;;;;;AAOA;AACA;AACA;AAQA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AAGA;AAEA;AACA;AA9HA;;;;;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;;;;;;;;;;;AAEA;AACA;AACA;AAEA;AA4BA;;;;;;;AAOA;AACA;AACA;AAYA;AAIA;AACA;AAsEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjHA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgDA;AACA;AAEA;AACA;AACA;AASA;AACA;AACA;AACA;AAtJA;AAwJA;;;;;;;;;;;;;;;;;;;;;;;;;ACvMA;;;AAGA;AACA;;;;;;;;;;;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAiBA;;;;;AAKA;AACA;AACA;AAIA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AAnDA;AAqDA;;;;;;;;AAQA;AACA;AAWA;AAHA;AACA;AAiGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA/GA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAoBA;AA5HA;AA8HA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;ACxRA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;A","sourceRoot":""}